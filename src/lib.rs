/* automatically generated by rust-bindgen */

# [ repr ( C ) ] # [ derive ( Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd ) ] pub struct __BindgenBitfieldUnit < Storage , Align > where Storage : AsRef < [ u8 ] > + AsMut < [ u8 ] >, { storage : Storage , align : [ Align ; 0 ] , } impl < Storage , Align > __BindgenBitfieldUnit < Storage , Align > where Storage : AsRef < [ u8 ] > + AsMut < [ u8 ] >, { # [ inline ] pub fn new ( storage : Storage ) -> Self { Self { storage , align : [ ] , } } # [ inline ] pub fn get_bit ( & self , index : usize ) -> bool { debug_assert ! ( index / 8 < self . storage . as_ref ( ) . len ( ) ) ; let byte_index = index / 8 ; let byte = self . storage . as_ref ( ) [ byte_index ] ; let bit_index = if cfg ! ( target_endian = "big" ) { 7 - ( index % 8 ) } else { index % 8 } ; let mask = 1 << bit_index ; byte & mask == mask } # [ inline ] pub fn set_bit ( & mut self , index : usize , val : bool ) { debug_assert ! ( index / 8 < self . storage . as_ref ( ) . len ( ) ) ; let byte_index = index / 8 ; let byte = & mut self . storage . as_mut ( ) [ byte_index ] ; let bit_index = if cfg ! ( target_endian = "big" ) { 7 - ( index % 8 ) } else { index % 8 } ; let mask = 1 << bit_index ; if val { * byte |= mask ; } else { * byte &= ! mask ; } } # [ inline ] pub fn get ( & self , bit_offset : usize , bit_width : u8 ) -> u64 { debug_assert ! ( bit_width <= 64 ) ; debug_assert ! ( bit_offset / 8 < self . storage . as_ref ( ) . len ( ) ) ; debug_assert ! ( ( bit_offset + ( bit_width as usize ) ) / 8 <= self . storage . as_ref ( ) . len ( ) ) ; let mut val = 0 ; for i in 0 .. ( bit_width as usize ) { if self . get_bit ( i + bit_offset ) { let index = if cfg ! ( target_endian = "big" ) { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [ inline ] pub fn set ( & mut self , bit_offset : usize , bit_width : u8 , val : u64 ) { debug_assert ! ( bit_width <= 64 ) ; debug_assert ! ( bit_offset / 8 < self . storage . as_ref ( ) . len ( ) ) ; debug_assert ! ( ( bit_offset + ( bit_width as usize ) ) / 8 <= self . storage . as_ref ( ) . len ( ) ) ; for i in 0 .. ( bit_width as usize ) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! ( target_endian = "big" ) { bit_width as usize - 1 - i } else { i } ; self . set_bit ( index + bit_offset , val_bit_is_set ) ; } } } # [ repr ( C ) ] pub struct __BindgenUnionField < T > ( :: core :: marker :: PhantomData < T > ) ; impl < T > __BindgenUnionField < T > { # [ inline ] pub fn new ( ) -> Self { __BindgenUnionField ( :: core :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ref ( & self ) -> & T { :: core :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut ( & mut self ) -> & mut T { :: core :: mem :: transmute ( self ) } } impl < T > :: core :: default :: Default for __BindgenUnionField < T > { # [ inline ] fn default ( ) -> Self { Self :: new ( ) } } impl < T > :: core :: clone :: Clone for __BindgenUnionField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: core :: marker :: Copy for __BindgenUnionField < T > { } impl < T > :: core :: fmt :: Debug for __BindgenUnionField < T > { fn fmt ( & self , fmt : & mut :: core :: fmt :: Formatter < '_ > ) -> :: core :: fmt :: Result { fmt . write_str ( "__BindgenUnionField" ) } } impl < T > :: core :: hash :: Hash for __BindgenUnionField < T > { fn hash < H : :: core :: hash :: Hasher > ( & self , _state : & mut H ) { } } impl < T > :: core :: cmp :: PartialEq for __BindgenUnionField < T > { fn eq ( & self , _other : & __BindgenUnionField < T > ) -> bool { true } } impl < T > :: core :: cmp :: Eq for __BindgenUnionField < T > { } pub type std_integral_constant_value_type < _Tp > = _Tp ; pub type std_integral_constant_type = u8 ; pub type std_true_type = u8 ; pub type std_false_type = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_is_empty { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_atomic { pub _address : u8 , } pub type std_atomic___base = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_iterator_traits { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_iterator { pub _address : u8 , } pub type std_iterator_value_type < _Tp > = _Tp ; pub type std_iterator_difference_type < _Distance > = _Distance ; pub type std_iterator_pointer < _Pointer > = _Pointer ; pub type std_iterator_reference < _Reference > = _Reference ; pub type std_iterator_iterator_category < _Category > = _Category ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_reverse_iterator < _Iter > { pub __t : _Iter , pub current : _Iter , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Iter > > , } pub type std_reverse_iterator_iterator_type < _Iter > = _Iter ; pub type std_reverse_iterator_difference_type = std_iterator_traits ; pub type std_reverse_iterator_reference = std_iterator_traits ; pub type std_reverse_iterator_pointer = std_iterator_traits ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___wrap_iter < _Iter > { pub __i : std___wrap_iter_iterator_type < _Iter > , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Iter > > , } pub type std___wrap_iter_iterator_type < _Iter > = _Iter ; pub type std___wrap_iter_iterator_category = std_iterator_traits ; pub type std___wrap_iter_value_type = std_iterator_traits ; pub type std___wrap_iter_difference_type = std_iterator_traits ; pub type std___wrap_iter_pointer = std_iterator_traits ; pub type std___wrap_iter_reference = std_iterator_traits ; pub type std___pointer_type_imp___pointer_type_type = [ u8 ; 0usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___pointer_type { pub _address : u8 , } pub type std___pointer_type_type = u8 ; pub type std___propagate_on_container_copy_assignment_type = std_false_type ; pub type std___propagate_on_container_move_assignment_type = std_false_type ; pub type std___propagate_on_container_swap_type = std_false_type ; pub type std___is_always_equal_type = std_is_empty ; pub type std___allocator_traits_rebind_type = [ u8 ; 0usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator_traits { pub _address : u8 , } pub type std_allocator_traits_allocator_type < _Alloc > = _Alloc ; pub type std_allocator_traits_value_type = [ u8 ; 0usize ] ; pub type std_allocator_traits_pointer = [ u8 ; 0usize ] ; pub type std_allocator_traits_const_pointer = [ u8 ; 0usize ] ; pub type std_allocator_traits_void_pointer = [ u8 ; 0usize ] ; pub type std_allocator_traits_const_void_pointer = [ u8 ; 0usize ] ; pub type std_allocator_traits_difference_type = [ u8 ; 0usize ] ; pub type std_allocator_traits_size_type = [ u8 ; 0usize ] ; pub type std_allocator_traits_propagate_on_container_copy_assignment = u8 ; pub type std_allocator_traits_propagate_on_container_move_assignment = u8 ; pub type std_allocator_traits_propagate_on_container_swap = u8 ; pub type std_allocator_traits_is_always_equal = u8 ; pub type std_allocator_traits_rebind_alloc = u8 ; pub type std_allocator_traits_rebind_traits = std_allocator_traits ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator { pub _address : u8 , } pub type std_allocator_size_type = usize ; pub type std_allocator_difference_type = isize ; pub type std_allocator_pointer < _Tp > = * mut _Tp ; pub type std_allocator_const_pointer < _Tp > = * const _Tp ; pub type std_allocator_reference < _Tp > = * mut _Tp ; pub type std_allocator_const_reference < _Tp > = * const _Tp ; pub type std_allocator_value_type < _Tp > = _Tp ; pub type std_allocator_propagate_on_container_move_assignment = std_true_type ; pub type std_allocator_is_always_equal = std_true_type ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_allocator_rebind { pub _address : u8 , } pub type std_allocator_rebind_other = std_allocator ; pub type std___compressed_pair_elem__ParamT < _Tp > = _Tp ; pub type std___compressed_pair_elem_reference < _Tp > = * mut _Tp ; pub type std___compressed_pair_elem_const_reference < _Tp > = * const _Tp ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___compressed_pair { pub _address : u8 , } pub type std___compressed_pair__Base1 = u8 ; pub type std___compressed_pair__Base2 = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_default_delete { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std___unique_ptr_deleter_sfinae { pub _address : u8 , } pub type std___unique_ptr_deleter_sfinae___lval_ref_type < _Deleter > = * const _Deleter ; pub type std___unique_ptr_deleter_sfinae___good_rval_ref_type < _Deleter > = * mut _Deleter ; pub type std___unique_ptr_deleter_sfinae___enable_rval_overload = std_true_type ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_unique_ptr { pub __ptr_ : std___compressed_pair , } pub type std_unique_ptr_element_type < _Tp > = _Tp ; pub type std_unique_ptr_deleter_type < _Dp > = _Dp ; pub type std_unique_ptr_pointer = std___pointer_type ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_unique_ptr___nat { pub __for_bool_ : :: std :: os :: raw :: c_int , } pub type std_unique_ptr__DeleterSFINAE = std___unique_ptr_deleter_sfinae ; pub type std_unique_ptr__LValRefType = u8 ; pub type std_unique_ptr__GoodRValRefType = u8 ; pub type std_unique_ptr__BadRValRefType = u8 ; pub type std_unique_ptr__EnableIfDeleterDefaultConstructible = u8 ; pub type std_unique_ptr__EnableIfDeleterConstructible = u8 ; pub type std_unique_ptr__EnableIfMoveConvertible = u8 ; pub type std_unique_ptr__EnableIfDeleterConvertible = u8 ; pub type std_unique_ptr__EnableIfDeleterAssignable = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_function { pub _address : u8 , } extern "C" { # [ link_name = "\u{1}__na" ] pub static std_ratio___na : intmax_t ; } extern "C" { # [ link_name = "\u{1}__da" ] pub static std_ratio___da : intmax_t ; } extern "C" { # [ link_name = "\u{1}__s" ] pub static std_ratio___s : intmax_t ; } extern "C" { # [ link_name = "\u{1}__gcd" ] pub static std_ratio___gcd : intmax_t ; } extern "C" { # [ link_name = "\u{1}num" ] pub static std_ratio_num : intmax_t ; } extern "C" { # [ link_name = "\u{1}den" ] pub static std_ratio_den : intmax_t ; } pub type std_ratio_type = u8 ; pub type std_nano = u8 ; pub type std_milli = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_chrono_duration < _Rep > { pub __rep_ : std_chrono_duration_rep < _Rep > , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Rep > > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_chrono_duration___no_overflow { pub _address : u8 , } pub type std_chrono_duration___no_overflow_type = u8 ; pub type std_chrono_duration_rep < _Rep > = _Rep ; pub type std_chrono_duration_period = [ u8 ; 0usize ] ; pub type std_chrono_nanoseconds = std_chrono_duration < :: std :: os :: raw :: c_longlong > ; pub type std_chrono_milliseconds = std_chrono_duration < :: std :: os :: raw :: c_longlong > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_chrono_time_point < _Duration > { pub __d_ : std_chrono_time_point_duration < _Duration > , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Duration > > , } pub type std_chrono_time_point_clock < _Clock > = _Clock ; pub type std_chrono_time_point_duration < _Duration > = _Duration ; pub type std_chrono_time_point_rep = [ u8 ; 0usize ] ; pub type std_chrono_time_point_period = [ u8 ; 0usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_chrono_steady_clock { pub _address : u8 , } pub type std_chrono_steady_clock_duration = std_chrono_nanoseconds ; pub type std_chrono_steady_clock_rep = rep ; pub type std_chrono_steady_clock_period = u8 ; pub type std_chrono_steady_clock_time_point = std_chrono_time_point < std_chrono_steady_clock_duration > ; pub const std_chrono_steady_clock_is_steady : bool = true ; # [ test ] fn bindgen_test_layout_std_chrono_steady_clock ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_chrono_steady_clock > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( std_chrono_steady_clock ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_chrono_steady_clock > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( std_chrono_steady_clock ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNSt3__16chrono12steady_clock3nowEv" ] pub fn std_chrono_steady_clock_now ( ) -> std_chrono_steady_clock_time_point ; } impl std_chrono_steady_clock { # [ inline ] pub unsafe fn now ( ) -> std_chrono_steady_clock_time_point { std_chrono_steady_clock_now ( ) } } extern "C" { # [ link_name = "\u{1}__throw_length_error" ] pub fn std___vector_base_common___throw_length_error ( this : * const u8 ) ; } extern "C" { # [ link_name = "\u{1}__throw_out_of_range" ] pub fn std___vector_base_common___throw_out_of_range ( this : * const u8 ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std___vector_base { pub _base : u8 , pub __begin_ : std___vector_base_pointer , pub __end_ : std___vector_base_pointer , pub __end_cap_ : std___compressed_pair , } pub type std___vector_base_allocator_type < _Allocator > = _Allocator ; pub type std___vector_base___alloc_traits = std_allocator_traits ; pub type std___vector_base_size_type = std___vector_base___alloc_traits ; pub type std___vector_base_value_type < _Tp > = _Tp ; pub type std___vector_base_reference < _Tp > = * mut std___vector_base_value_type < _Tp > ; pub type std___vector_base_const_reference < _Tp > = * const std___vector_base_value_type < _Tp > ; pub type std___vector_base_difference_type = std___vector_base___alloc_traits ; pub type std___vector_base_pointer = std___vector_base___alloc_traits ; pub type std___vector_base_const_pointer = std___vector_base___alloc_traits ; pub type std___vector_base_iterator = std___vector_base_pointer ; pub type std___vector_base_const_iterator = std___vector_base_const_pointer ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct std_vector { pub _base : std___vector_base , } pub type std_vector___base = std___vector_base ; pub type std_vector___default_allocator_type = std_allocator ; pub type std_vector___self = std_vector ; pub type std_vector_value_type < _Tp > = _Tp ; pub type std_vector_allocator_type < _Allocator > = _Allocator ; pub type std_vector___alloc_traits = std_vector___base ; pub type std_vector_reference = std_vector___base ; pub type std_vector_const_reference = std_vector___base ; pub type std_vector_size_type = std_vector___base ; pub type std_vector_difference_type = std_vector___base ; pub type std_vector_pointer = std_vector___base ; pub type std_vector_const_pointer = std_vector___base ; pub type std_vector_iterator = std___wrap_iter < std_vector_pointer > ; pub type std_vector_const_iterator = std___wrap_iter < std_vector_const_pointer > ; pub type std_vector_reverse_iterator = std_reverse_iterator < std_vector_iterator > ; pub type std_vector_const_reverse_iterator = std_reverse_iterator < std_vector_const_iterator > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_vector___RAII_IncreaseAnnotator { pub _address : u8 , } pub type std_nullptr_t = * const :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct std_initializer_list < _Ep > { pub __begin_ : * const _Ep , pub __size_ : usize , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Ep > > , } pub type std_initializer_list_value_type < _Ep > = _Ep ; pub type std_initializer_list_reference < _Ep > = * const _Ep ; pub type std_initializer_list_const_reference < _Ep > = * const _Ep ; pub type std_initializer_list_size_type = usize ; pub type std_initializer_list_iterator < _Ep > = * const _Ep ; pub type std_initializer_list_const_iterator < _Ep > = * const _Ep ; pub type __int64_t = :: std :: os :: raw :: c_longlong ; pub type __darwin_intptr_t = :: std :: os :: raw :: c_long ; pub type __darwin_off_t = __int64_t ; pub type intmax_t = :: std :: os :: raw :: c_long ; # [ doc = " Fast type for unsigned 8 bits. Use for parameter passing and local" ] # [ doc = "variables, not for storage" ] pub type U8CPU = :: std :: os :: raw :: c_uint ; # [ doc = " Fast type for unsigned 16 bits. Use for parameter passing and local" ] # [ doc = "variables, not for storage" ] pub type U16CPU = :: std :: os :: raw :: c_uint ; pub type SkFourByteTag = u32 ; # [ doc = " 32 bit integer to hold a unicode value" ] pub type SkUnichar = i32 ; # [ doc = " 16 bit unsigned integer to hold a glyph index" ] pub type SkGlyphID = u16 ; pub const SkBudgeted_kNo : SkBudgeted = 0 ; pub const SkBudgeted_kYes : SkBudgeted = 1 ; # [ doc = " Indicates whether an allocation should count against a cache budget." ] pub type SkBudgeted = u8 ; pub const SkBackingFit_kApprox : SkBackingFit = 0 ; pub const SkBackingFit_kExact : SkBackingFit = 1 ; # [ doc = " Indicates whether a backing store needs to be an exact match or can be" ] # [ doc = "larger than is strictly necessary" ] pub type SkBackingFit = i32 ; # [ doc = "!< replaces destination with zero: fully transparent" ] pub const SkBlendMode_kClear : SkBlendMode = 0 ; # [ doc = "!< replaces destination" ] pub const SkBlendMode_kSrc : SkBlendMode = 1 ; # [ doc = "!< preserves destination" ] pub const SkBlendMode_kDst : SkBlendMode = 2 ; # [ doc = "!< source over destination" ] pub const SkBlendMode_kSrcOver : SkBlendMode = 3 ; # [ doc = "!< destination over source" ] pub const SkBlendMode_kDstOver : SkBlendMode = 4 ; # [ doc = "!< source trimmed inside destination" ] pub const SkBlendMode_kSrcIn : SkBlendMode = 5 ; # [ doc = "!< destination trimmed by source" ] pub const SkBlendMode_kDstIn : SkBlendMode = 6 ; # [ doc = "!< source trimmed outside destination" ] pub const SkBlendMode_kSrcOut : SkBlendMode = 7 ; # [ doc = "!< destination trimmed outside source" ] pub const SkBlendMode_kDstOut : SkBlendMode = 8 ; # [ doc = "!< source inside destination blended with destination" ] pub const SkBlendMode_kSrcATop : SkBlendMode = 9 ; # [ doc = "!< destination inside source blended with source" ] pub const SkBlendMode_kDstATop : SkBlendMode = 10 ; # [ doc = "!< each of source and destination trimmed outside the other" ] pub const SkBlendMode_kXor : SkBlendMode = 11 ; # [ doc = "!< sum of colors" ] pub const SkBlendMode_kPlus : SkBlendMode = 12 ; # [ doc = "!< product of premultiplied colors; darkens destination" ] pub const SkBlendMode_kModulate : SkBlendMode = 13 ; # [ doc = "!< multiply inverse of pixels, inverting result; brightens destination" ] pub const SkBlendMode_kScreen : SkBlendMode = 14 ; # [ doc = "!< last porter duff blend mode" ] pub const SkBlendMode_kLastCoeffMode : SkBlendMode = 14 ; # [ doc = "!< multiply or screen, depending on destination" ] pub const SkBlendMode_kOverlay : SkBlendMode = 15 ; # [ doc = "!< darker of source and destination" ] pub const SkBlendMode_kDarken : SkBlendMode = 16 ; # [ doc = "!< lighter of source and destination" ] pub const SkBlendMode_kLighten : SkBlendMode = 17 ; # [ doc = "!< brighten destination to reflect source" ] pub const SkBlendMode_kColorDodge : SkBlendMode = 18 ; # [ doc = "!< darken destination to reflect source" ] pub const SkBlendMode_kColorBurn : SkBlendMode = 19 ; # [ doc = "!< multiply or screen, depending on source" ] pub const SkBlendMode_kHardLight : SkBlendMode = 20 ; # [ doc = "!< lighten or darken, depending on source" ] pub const SkBlendMode_kSoftLight : SkBlendMode = 21 ; # [ doc = "!< subtract darker from lighter with higher contrast" ] pub const SkBlendMode_kDifference : SkBlendMode = 22 ; # [ doc = "!< subtract darker from lighter with lower contrast" ] pub const SkBlendMode_kExclusion : SkBlendMode = 23 ; # [ doc = "!< multiply source with destination, darkening image" ] pub const SkBlendMode_kMultiply : SkBlendMode = 24 ; # [ doc = "!< last blend mode operating separately on components" ] pub const SkBlendMode_kLastSeparableMode : SkBlendMode = 24 ; # [ doc = "!< hue of source with saturation and luminosity of destination" ] pub const SkBlendMode_kHue : SkBlendMode = 25 ; # [ doc = "!< saturation of source with hue and luminosity of destination" ] pub const SkBlendMode_kSaturation : SkBlendMode = 26 ; # [ doc = "!< hue and saturation of source with luminosity of destination" ] pub const SkBlendMode_kColor : SkBlendMode = 27 ; # [ doc = "!< luminosity of source with hue and saturation of destination" ] pub const SkBlendMode_kLuminosity : SkBlendMode = 28 ; # [ doc = "!< last valid value" ] pub const SkBlendMode_kLastMode : SkBlendMode = 28 ; pub type SkBlendMode = i32 ; pub const SkClipOp_kDifference : SkClipOp = 0 ; pub const SkClipOp_kIntersect : SkClipOp = 1 ; pub const SkClipOp_kExtraEnumNeedInternallyPleaseIgnoreWillGoAway2 : SkClipOp = 2 ; pub const SkClipOp_kExtraEnumNeedInternallyPleaseIgnoreWillGoAway3 : SkClipOp = 3 ; pub const SkClipOp_kExtraEnumNeedInternallyPleaseIgnoreWillGoAway4 : SkClipOp = 4 ; pub const SkClipOp_kExtraEnumNeedInternallyPleaseIgnoreWillGoAway5 : SkClipOp = 5 ; pub const SkClipOp_kMax_EnumValue : SkClipOp = 5 ; pub type SkClipOp = i32 ; # [ doc = " \\class SkNoncopyable" ] # [ doc = "" ] # [ doc = "SkNoncopyable is the base class for objects that do not want to" ] # [ doc = "be copied. It hides its copy-constructor and its assignment-operator." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkNoncopyable { pub _address : u8 , } # [ test ] fn bindgen_test_layout_SkNoncopyable ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkNoncopyable > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( SkNoncopyable ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkNoncopyable > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SkNoncopyable ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13SkNoncopyableC1Ev" ] pub fn SkNoncopyable_SkNoncopyable ( this : * mut SkNoncopyable ) ; } extern "C" { # [ link_name = "\u{1}__ZN13SkNoncopyableC1EOS_" ] pub fn SkNoncopyable_SkNoncopyable1 ( this : * mut SkNoncopyable , arg1 : * mut SkNoncopyable ) ; } impl SkNoncopyable { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkNoncopyable_SkNoncopyable ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : * mut SkNoncopyable ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkNoncopyable_SkNoncopyable1 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkDeque { pub fFront : * mut :: std :: os :: raw :: c_void , pub fBack : * mut :: std :: os :: raw :: c_void , pub fFrontBlock : * mut SkDeque_Block , pub fBackBlock : * mut SkDeque_Block , pub fElemSize : usize , pub fInitialStorage : * mut :: std :: os :: raw :: c_void , pub fCount : :: std :: os :: raw :: c_int , pub fAllocCount : :: std :: os :: raw :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDeque_Block { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDeque_Iter { pub fCurBlock : * mut SkDeque_Block , pub fPos : * mut :: std :: os :: raw :: c_char , pub fElemSize : usize , } pub const SkDeque_Iter_IterStart_kFront_IterStart : SkDeque_Iter_IterStart = 0 ; pub const SkDeque_Iter_IterStart_kBack_IterStart : SkDeque_Iter_IterStart = 1 ; pub type SkDeque_Iter_IterStart = u32 ; # [ test ] fn bindgen_test_layout_SkDeque_Iter ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkDeque_Iter > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkDeque_Iter ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkDeque_Iter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkDeque_Iter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque_Iter > ( ) ) ) . fCurBlock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque_Iter ) , "::" , stringify ! ( fCurBlock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque_Iter > ( ) ) ) . fPos as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque_Iter ) , "::" , stringify ! ( fPos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque_Iter > ( ) ) ) . fElemSize as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque_Iter ) , "::" , stringify ! ( fElemSize ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque4Iter4nextEv" ] pub fn SkDeque_Iter_next ( this : * mut SkDeque_Iter ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque4Iter4prevEv" ] pub fn SkDeque_Iter_prev ( this : * mut SkDeque_Iter ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque4Iter5resetERKS_NS0_9IterStartE" ] pub fn SkDeque_Iter_reset ( this : * mut SkDeque_Iter , d : * const SkDeque , startLoc : SkDeque_Iter_IterStart ) ; } extern "C" { # [ doc = " Creates an uninitialized iterator. Must be reset()" ] # [ link_name = "\u{1}__ZN7SkDeque4IterC1Ev" ] pub fn SkDeque_Iter_Iter ( this : * mut SkDeque_Iter ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque4IterC1ERKS_NS0_9IterStartE" ] pub fn SkDeque_Iter_Iter1 ( this : * mut SkDeque_Iter , d : * const SkDeque , startLoc : SkDeque_Iter_IterStart ) ; } impl SkDeque_Iter { # [ inline ] pub unsafe fn next ( & mut self ) -> * mut :: std :: os :: raw :: c_void { SkDeque_Iter_next ( self ) } # [ inline ] pub unsafe fn prev ( & mut self ) -> * mut :: std :: os :: raw :: c_void { SkDeque_Iter_prev ( self ) } # [ inline ] pub unsafe fn reset ( & mut self , d : * const SkDeque , startLoc : SkDeque_Iter_IterStart ) { SkDeque_Iter_reset ( self , d , startLoc ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkDeque_Iter_Iter ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( d : * const SkDeque , startLoc : SkDeque_Iter_IterStart ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkDeque_Iter_Iter1 ( & mut __bindgen_tmp , d , startLoc ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDeque_F2BIter { pub _base : SkDeque_Iter , } pub type SkDeque_F2BIter_INHERITED = SkDeque_Iter ; # [ test ] fn bindgen_test_layout_SkDeque_F2BIter ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkDeque_F2BIter > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkDeque_F2BIter ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkDeque_F2BIter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkDeque_F2BIter ) ) ) ; } extern "C" { # [ doc = " Wrap Iter::reset to force initialization to the beginning of the" ] # [ doc = " deque" ] # [ link_name = "\u{1}__ZN7SkDeque7F2BIter5resetERKS_" ] pub fn SkDeque_F2BIter_reset ( this : * mut SkDeque_F2BIter , d : * const SkDeque ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque7F2BIterC1Ev" ] pub fn SkDeque_F2BIter_F2BIter ( this : * mut SkDeque_F2BIter ) ; } extern "C" { # [ doc = " Wrap Iter\'s 2 parameter ctor to force initialization to the" ] # [ doc = " beginning of the deque" ] # [ link_name = "\u{1}__ZN7SkDeque7F2BIterC1ERKS_" ] pub fn SkDeque_F2BIter_F2BIter1 ( this : * mut SkDeque_F2BIter , d : * const SkDeque ) ; } impl SkDeque_F2BIter { # [ inline ] pub unsafe fn reset ( & mut self , d : * const SkDeque ) { SkDeque_F2BIter_reset ( self , d ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkDeque_F2BIter_F2BIter ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( d : * const SkDeque ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkDeque_F2BIter_F2BIter1 ( & mut __bindgen_tmp , d ) ; __bindgen_tmp } } # [ test ] fn bindgen_test_layout_SkDeque ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkDeque > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( SkDeque ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkDeque > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkDeque ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque > ( ) ) ) . fFront as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque ) , "::" , stringify ! ( fFront ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque > ( ) ) ) . fBack as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque ) , "::" , stringify ! ( fBack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque > ( ) ) ) . fFrontBlock as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque ) , "::" , stringify ! ( fFrontBlock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque > ( ) ) ) . fBackBlock as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque ) , "::" , stringify ! ( fBackBlock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque > ( ) ) ) . fElemSize as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque ) , "::" , stringify ! ( fElemSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque > ( ) ) ) . fInitialStorage as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque ) , "::" , stringify ! ( fInitialStorage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque > ( ) ) ) . fCount as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque ) , "::" , stringify ! ( fCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkDeque > ( ) ) ) . fAllocCount as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( SkDeque ) , "::" , stringify ! ( fAllocCount ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkDeque5emptyEv" ] pub fn SkDeque_empty ( this : * const SkDeque ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkDeque5countEv" ] pub fn SkDeque_count ( this : * const SkDeque ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkDeque8elemSizeEv" ] pub fn SkDeque_elemSize ( this : * const SkDeque ) -> usize ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkDeque5frontEv" ] pub fn SkDeque_front ( this : * const SkDeque ) -> * const :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkDeque4backEv" ] pub fn SkDeque_back ( this : * const SkDeque ) -> * const :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque5frontEv" ] pub fn SkDeque_front1 ( this : * mut SkDeque ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque4backEv" ] pub fn SkDeque_back1 ( this : * mut SkDeque ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " push_front and push_back return a pointer to the memory space" ] # [ doc = " for the new element" ] # [ link_name = "\u{1}__ZN7SkDeque10push_frontEv" ] pub fn SkDeque_push_front ( this : * mut SkDeque ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque9push_backEv" ] pub fn SkDeque_push_back ( this : * mut SkDeque ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque9pop_frontEv" ] pub fn SkDeque_pop_front ( this : * mut SkDeque ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDeque8pop_backEv" ] pub fn SkDeque_pop_back ( this : * mut SkDeque ) ; } extern "C" { # [ doc = " elemSize specifies the size of each individual element in the deque" ] # [ doc = " allocCount specifies how many elements are to be allocated as a block" ] # [ link_name = "\u{1}__ZN7SkDequeC1Emi" ] pub fn SkDeque_SkDeque ( this : * mut SkDeque , elemSize : usize , allocCount : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDequeC1EmPvmi" ] pub fn SkDeque_SkDeque1 ( this : * mut SkDeque , elemSize : usize , storage : * mut :: std :: os :: raw :: c_void , storageSize : usize , allocCount : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkDequeD1Ev" ] pub fn SkDeque_SkDeque_destructor ( this : * mut SkDeque ) ; } impl SkDeque { # [ inline ] pub unsafe fn empty ( & self ) -> bool { SkDeque_empty ( self ) } # [ inline ] pub unsafe fn count ( & self ) -> :: std :: os :: raw :: c_int { SkDeque_count ( self ) } # [ inline ] pub unsafe fn elemSize ( & self ) -> usize { SkDeque_elemSize ( self ) } # [ inline ] pub unsafe fn front ( & self ) -> * const :: std :: os :: raw :: c_void { SkDeque_front ( self ) } # [ inline ] pub unsafe fn back ( & self ) -> * const :: std :: os :: raw :: c_void { SkDeque_back ( self ) } # [ inline ] pub unsafe fn front1 ( & mut self ) -> * mut :: std :: os :: raw :: c_void { SkDeque_front1 ( self ) } # [ inline ] pub unsafe fn back1 ( & mut self ) -> * mut :: std :: os :: raw :: c_void { SkDeque_back1 ( self ) } # [ inline ] pub unsafe fn push_front ( & mut self ) -> * mut :: std :: os :: raw :: c_void { SkDeque_push_front ( self ) } # [ inline ] pub unsafe fn push_back ( & mut self ) -> * mut :: std :: os :: raw :: c_void { SkDeque_push_back ( self ) } # [ inline ] pub unsafe fn pop_front ( & mut self ) { SkDeque_pop_front ( self ) } # [ inline ] pub unsafe fn pop_back ( & mut self ) { SkDeque_pop_back ( self ) } # [ inline ] pub unsafe fn new ( elemSize : usize , allocCount : :: std :: os :: raw :: c_int ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkDeque_SkDeque ( & mut __bindgen_tmp , elemSize , allocCount ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( elemSize : usize , storage : * mut :: std :: os :: raw :: c_void , storageSize : usize , allocCount : :: std :: os :: raw :: c_int ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkDeque_SkDeque1 ( & mut __bindgen_tmp , elemSize , storage , storageSize , allocCount ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkDeque_SkDeque_destructor ( self ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkOnce { pub fState : std_atomic , } pub const SkOnce_State_NotStarted : SkOnce_State = 0 ; pub const SkOnce_State_Claimed : SkOnce_State = 1 ; pub const SkOnce_State_Done : SkOnce_State = 2 ; pub type SkOnce_State = u8 ; # [ test ] fn bindgen_test_layout_SkOnce ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkOnce > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( SkOnce ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkOnce > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SkOnce ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkOnce > ( ) ) ) . fState as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkOnce ) , "::" , stringify ! ( fState ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN6SkOnceC1Ev" ] pub fn SkOnce_SkOnce ( this : * mut SkOnce ) ; } impl SkOnce { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkOnce_SkOnce ( & mut __bindgen_tmp ) ; __bindgen_tmp } } pub type va_list = __builtin_va_list ; pub type fpos_t = __darwin_off_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sbuf { pub _base : * mut :: std :: os :: raw :: c_uchar , pub _size : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___sbuf ( ) { assert_eq ! ( :: core :: mem :: size_of :: < __sbuf > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __sbuf ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < __sbuf > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sbuf > ( ) ) ) . _base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __sbuf ) , "::" , stringify ! ( _base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sbuf > ( ) ) ) . _size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __sbuf ) , "::" , stringify ! ( _size ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sFILEX { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sFILE { pub _p : * mut :: std :: os :: raw :: c_uchar , pub _r : :: std :: os :: raw :: c_int , pub _w : :: std :: os :: raw :: c_int , pub _flags : :: std :: os :: raw :: c_short , pub _file : :: std :: os :: raw :: c_short , pub _bf : __sbuf , pub _lbfsize : :: std :: os :: raw :: c_int , pub _cookie : * mut :: std :: os :: raw :: c_void , pub _close : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , pub _read : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub _seek : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : fpos_t , arg3 : :: std :: os :: raw :: c_int ) -> fpos_t > , pub _write : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub _ub : __sbuf , pub _extra : * mut __sFILEX , pub _ur : :: std :: os :: raw :: c_int , pub _ubuf : [ :: std :: os :: raw :: c_uchar ; 3usize ] , pub _nbuf : [ :: std :: os :: raw :: c_uchar ; 1usize ] , pub _lb : __sbuf , pub _blksize : :: std :: os :: raw :: c_int , pub _offset : fpos_t , } # [ test ] fn bindgen_test_layout___sFILE ( ) { assert_eq ! ( :: core :: mem :: size_of :: < __sFILE > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( __sFILE ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < __sFILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sFILE ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _p as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _p ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _r as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _r ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _w as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _w ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _flags as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _file as * const _ as usize } , 18usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _file ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _bf as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _bf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _lbfsize as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _lbfsize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _cookie as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _cookie ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _close as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _close ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _read as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _read ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _seek as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _seek ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _write as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _write ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _ub as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ub ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _extra as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _extra ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _ur as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ur ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _ubuf as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ubuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _nbuf as * const _ as usize } , 119usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _nbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _lb as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _lb ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _blksize as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _blksize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _offset as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _offset ) ) ) ; } pub type FILE = __sFILE ; # [ repr ( C ) ] pub struct SkRefCntBase__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ doc = " \\class SkRefCntBase" ] # [ doc = "" ] # [ doc = "SkRefCntBase is the base class for objects that may be shared by multiple" ] # [ doc = "objects. When an existing owner wants to share a reference, it calls ref()." ] # [ doc = "When an owner wants to release its reference, it calls unref(). When the" ] # [ doc = "shared object\'s reference count goes to zero as the result of an unref()" ] # [ doc = "call, its (virtual) destructor is called. It is an error for the" ] # [ doc = "destructor to be called explicitly (or via the object going out of scope on" ] # [ doc = "the stack or calling delete) if getRefCnt() > 1." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkRefCntBase { pub vtable_ : * const SkRefCntBase__bindgen_vtable , pub fRefCnt : std_atomic , } # [ test ] fn bindgen_test_layout_SkRefCntBase ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRefCntBase > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkRefCntBase ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRefCntBase > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkRefCntBase ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRefCntBase > ( ) ) ) . fRefCnt as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkRefCntBase ) , "::" , stringify ! ( fRefCnt ) ) ) ; } extern "C" { # [ doc = " May return true if the caller is the only owner." ] # [ doc = "  Ensures that all previous owner\'s actions are complete." ] # [ link_name = "\u{1}__ZNK12SkRefCntBase6uniqueEv" ] pub fn SkRefCntBase_unique ( this : * const SkRefCntBase ) -> bool ; } extern "C" { # [ doc = " Increment the reference count. Must be balanced by a call to unref()." ] # [ link_name = "\u{1}__ZNK12SkRefCntBase3refEv" ] pub fn SkRefCntBase_ref ( this : * const SkRefCntBase ) ; } extern "C" { # [ doc = " Decrement the reference count. If the reference count is 1 before the" ] # [ doc = "decrement, then delete the object. Note that if this is the case, then" ] # [ doc = "the object needs to have been allocated via new, and not on the stack." ] # [ link_name = "\u{1}__ZNK12SkRefCntBase5unrefEv" ] pub fn SkRefCntBase_unref ( this : * const SkRefCntBase ) ; } extern "C" { # [ doc = " Default construct, initializing the reference count to 1." ] # [ link_name = "\u{1}__ZN12SkRefCntBaseC1Ev" ] pub fn SkRefCntBase_SkRefCntBase ( this : * mut SkRefCntBase ) ; } impl SkRefCntBase { # [ inline ] pub unsafe fn unique ( & self ) -> bool { SkRefCntBase_unique ( self ) } # [ inline ] pub unsafe fn ref_ ( & self ) { SkRefCntBase_ref ( self ) } # [ inline ] pub unsafe fn unref ( & self ) { SkRefCntBase_unref ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRefCntBase_SkRefCntBase ( & mut __bindgen_tmp ) ; __bindgen_tmp } } extern "C" { # [ doc = " Destruct, asserting that the reference count is 1." ] # [ link_name = "\u{1}__ZN12SkRefCntBaseD1Ev" ] pub fn SkRefCntBase_SkRefCntBase_destructor ( this : * mut SkRefCntBase ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkRefCnt { pub _base : SkRefCntBase , } # [ test ] fn bindgen_test_layout_SkRefCnt ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRefCnt > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkRefCnt ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRefCnt > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkRefCnt ) ) ) ; } # [ doc = "" ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkNVRefCnt { pub fRefCnt : std_atomic , } # [ doc = "  Shared pointer class to wrap classes that support a ref()/unref() interface." ] # [ doc = "" ] # [ doc = "  This can be used for classes inheriting from SkRefCnt, but it also works for other" ] # [ doc = "  classes that match the interface, but have different internal choices: e.g. the hosted class" ] # [ doc = "  may have its ref/unref be thread-safe, but that is not assumed/imposed by sk_sp." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct sk_sp < T > { pub fPtr : * mut T , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } pub type sk_sp_element_type < T > = T ; # [ doc = " \\class SkWeakRefCnt" ] # [ doc = "" ] # [ doc = "SkWeakRefCnt is the base class for objects that may be shared by multiple" ] # [ doc = "objects. When an existing strong owner wants to share a reference, it calls" ] # [ doc = "ref(). When a strong owner wants to release its reference, it calls" ] # [ doc = "unref(). When the shared object\'s strong reference count goes to zero as" ] # [ doc = "the result of an unref() call, its (virtual) weak_dispose method is called." ] # [ doc = "It is an error for the destructor to be called explicitly (or via the" ] # [ doc = "object going out of scope on the stack or calling delete) if" ] # [ doc = "getRefCnt() > 1." ] # [ doc = "" ] # [ doc = "In addition to strong ownership, an owner may instead obtain a weak" ] # [ doc = "reference by calling weak_ref(). A call to weak_ref() must be balanced by a" ] # [ doc = "call to weak_unref(). To obtain a strong reference from a weak reference," ] # [ doc = "call try_ref(). If try_ref() returns true, the owner\'s pointer is now also" ] # [ doc = "a strong reference on which unref() must be called. Note that this does not" ] # [ doc = "affect the original weak reference, weak_unref() must still be called. When" ] # [ doc = "the weak reference count goes to zero, the object is deleted. While the" ] # [ doc = "weak reference count is positive and the strong reference count is zero the" ] # [ doc = "object still exists, but will be in the disposed state. It is up to the" ] # [ doc = "object to define what this means." ] # [ doc = "" ] # [ doc = "Note that a strong reference implicitly implies a weak reference. As a" ] # [ doc = "result, it is allowable for the owner of a strong ref to call try_ref()." ] # [ doc = "This will have the same effect as calling ref(), but may be more expensive." ] # [ doc = "" ] # [ doc = "Example:" ] # [ doc = "" ] # [ doc = "SkWeakRefCnt myRef = strongRef.weak_ref();" ] # [ doc = "... // strongRef.unref() may or may not be called" ] # [ doc = "if (myRef.try_ref()) {" ] # [ doc = "... // use myRef" ] # [ doc = "myRef.unref();" ] # [ doc = "} else {" ] # [ doc = "}" ] # [ doc = "myRef.weak_unref();" ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkWeakRefCnt { pub _base : SkRefCnt , pub fWeakCnt : std_atomic , } pub type SkWeakRefCnt_INHERITED = SkRefCnt ; # [ test ] fn bindgen_test_layout_SkWeakRefCnt ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkWeakRefCnt > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkWeakRefCnt ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkWeakRefCnt > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkWeakRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkWeakRefCnt > ( ) ) ) . fWeakCnt as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkWeakRefCnt ) , "::" , stringify ! ( fWeakCnt ) ) ) ; } extern "C" { # [ doc = " Return the weak reference count." ] # [ link_name = "\u{1}__ZNK12SkWeakRefCnt10getWeakCntEv" ] pub fn SkWeakRefCnt_getWeakCnt ( this : * const SkWeakRefCnt ) -> i32 ; } extern "C" { # [ doc = " Creates a strong reference from a weak reference, if possible. The" ] # [ doc = "caller must already be an owner. If try_ref() returns true the owner" ] # [ doc = "is in posession of an additional strong reference. Both the original" ] # [ doc = "reference and new reference must be properly unreferenced. If try_ref()" ] # [ doc = "returns false, no strong reference could be created and the owner\'s" ] # [ doc = "reference is in the same state as before the call." ] # [ link_name = "\u{1}__ZNK12SkWeakRefCnt7try_refEv" ] pub fn SkWeakRefCnt_try_ref ( this : * const SkWeakRefCnt ) -> bool ; } extern "C" { # [ doc = " Increment the weak reference count. Must be balanced by a call to" ] # [ doc = "weak_unref()." ] # [ link_name = "\u{1}__ZNK12SkWeakRefCnt8weak_refEv" ] pub fn SkWeakRefCnt_weak_ref ( this : * const SkWeakRefCnt ) ; } extern "C" { # [ doc = " Decrement the weak reference count. If the weak reference count is 1" ] # [ doc = "before the decrement, then call delete on the object. Note that if this" ] # [ doc = "is the case, then the object needs to have been allocated via new, and" ] # [ doc = "not on the stack." ] # [ link_name = "\u{1}__ZNK12SkWeakRefCnt10weak_unrefEv" ] pub fn SkWeakRefCnt_weak_unref ( this : * const SkWeakRefCnt ) ; } extern "C" { # [ doc = " Returns true if there are no strong references to the object. When this" ] # [ doc = "is the case all future calls to try_ref() will return false." ] # [ link_name = "\u{1}__ZNK12SkWeakRefCnt12weak_expiredEv" ] pub fn SkWeakRefCnt_weak_expired ( this : * const SkWeakRefCnt ) -> bool ; } extern "C" { # [ doc = " Default construct, initializing the reference counts to 1." ] # [ doc = "The strong references collectively hold one weak reference. When the" ] # [ doc = "strong reference count goes to zero, the collectively held weak" ] # [ doc = "reference is released." ] # [ link_name = "\u{1}__ZN12SkWeakRefCntC1Ev" ] pub fn SkWeakRefCnt_SkWeakRefCnt ( this : * mut SkWeakRefCnt ) ; } impl SkWeakRefCnt { # [ inline ] pub unsafe fn getWeakCnt ( & self ) -> i32 { SkWeakRefCnt_getWeakCnt ( self ) } # [ inline ] pub unsafe fn try_ref ( & self ) -> bool { SkWeakRefCnt_try_ref ( self ) } # [ inline ] pub unsafe fn weak_ref ( & self ) { SkWeakRefCnt_weak_ref ( self ) } # [ inline ] pub unsafe fn weak_unref ( & self ) { SkWeakRefCnt_weak_unref ( self ) } # [ inline ] pub unsafe fn weak_expired ( & self ) -> bool { SkWeakRefCnt_weak_expired ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkWeakRefCnt_SkWeakRefCnt ( & mut __bindgen_tmp ) ; __bindgen_tmp } } extern "C" { # [ doc = " Destruct, asserting that the weak reference count is 1." ] # [ link_name = "\u{1}__ZN12SkWeakRefCntD1Ev" ] pub fn SkWeakRefCnt_SkWeakRefCnt_destructor ( this : * mut SkWeakRefCnt ) ; } extern "C" { # [ doc = " Called when the strong reference count goes to zero. This allows the" ] # [ doc = "object to free any resources it may be holding. Weak references may" ] # [ doc = "still exist and their level of allowed access to the object is defined" ] # [ doc = "by the object\'s class." ] # [ link_name = "\u{1}__ZNK12SkWeakRefCnt12weak_disposeEv" ] pub fn SkWeakRefCnt_weak_dispose ( this : * mut :: std :: os :: raw :: c_void ) ; } pub type SkScalar = f32 ; # [ doc = " Represents a set of actual arguments for a font." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontArguments { pub fCollectionIndex : :: std :: os :: raw :: c_int , pub fVariationDesignPosition : SkFontArguments_VariationPosition , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontArguments_VariationPosition { pub coordinates : * const SkFontArguments_VariationPosition_Coordinate , pub coordinateCount : :: std :: os :: raw :: c_int , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontArguments_VariationPosition_Coordinate { pub axis : SkFourByteTag , pub value : f32 , } # [ test ] fn bindgen_test_layout_SkFontArguments_VariationPosition_Coordinate ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFontArguments_VariationPosition_Coordinate > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkFontArguments_VariationPosition_Coordinate ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFontArguments_VariationPosition_Coordinate > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkFontArguments_VariationPosition_Coordinate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontArguments_VariationPosition_Coordinate > ( ) ) ) . axis as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkFontArguments_VariationPosition_Coordinate ) , "::" , stringify ! ( axis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontArguments_VariationPosition_Coordinate > ( ) ) ) . value as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkFontArguments_VariationPosition_Coordinate ) , "::" , stringify ! ( value ) ) ) ; } # [ test ] fn bindgen_test_layout_SkFontArguments_VariationPosition ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFontArguments_VariationPosition > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkFontArguments_VariationPosition ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFontArguments_VariationPosition > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkFontArguments_VariationPosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontArguments_VariationPosition > ( ) ) ) . coordinates as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkFontArguments_VariationPosition ) , "::" , stringify ! ( coordinates ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontArguments_VariationPosition > ( ) ) ) . coordinateCount as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkFontArguments_VariationPosition ) , "::" , stringify ! ( coordinateCount ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontArguments_Axis { pub fTag : SkFourByteTag , pub fStyleValue : f32 , } # [ test ] fn bindgen_test_layout_SkFontArguments_Axis ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFontArguments_Axis > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkFontArguments_Axis ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFontArguments_Axis > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkFontArguments_Axis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontArguments_Axis > ( ) ) ) . fTag as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkFontArguments_Axis ) , "::" , stringify ! ( fTag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontArguments_Axis > ( ) ) ) . fStyleValue as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkFontArguments_Axis ) , "::" , stringify ! ( fStyleValue ) ) ) ; } # [ test ] fn bindgen_test_layout_SkFontArguments ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFontArguments > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkFontArguments ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFontArguments > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkFontArguments ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontArguments > ( ) ) ) . fCollectionIndex as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkFontArguments ) , "::" , stringify ! ( fCollectionIndex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontArguments > ( ) ) ) . fVariationDesignPosition as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkFontArguments ) , "::" , stringify ! ( fVariationDesignPosition ) ) ) ; } extern "C" { # [ doc = " Specify the index of the desired font." ] # [ doc = "" ] # [ doc = "  Font formats like ttc, dfont, cff, cid, pfr, t42, t1, and fon may actually be indexed" ] # [ doc = "  collections of fonts." ] # [ link_name = "\u{1}__ZN15SkFontArguments18setCollectionIndexEi" ] pub fn SkFontArguments_setCollectionIndex ( this : * mut SkFontArguments , collectionIndex : :: std :: os :: raw :: c_int ) -> * mut SkFontArguments ; } extern "C" { # [ link_name = "\u{1}__ZN15SkFontArguments7setAxesEPKNS_4AxisEi" ] pub fn SkFontArguments_setAxes ( this : * mut SkFontArguments , axes : * const SkFontArguments_Axis , axisCount : :: std :: os :: raw :: c_int ) -> * mut SkFontArguments ; } extern "C" { # [ doc = " Specify a position in the variation design space." ] # [ doc = "" ] # [ doc = "  Any axis not specified will use the default value." ] # [ doc = "  Any specified axis not actually present in the font will be ignored." ] # [ doc = "" ] # [ doc = "  @param position not copied. The value must remain valid for life of SkFontArguments." ] # [ link_name = "\u{1}__ZN15SkFontArguments26setVariationDesignPositionENS_17VariationPositionE" ] pub fn SkFontArguments_setVariationDesignPosition ( this : * mut SkFontArguments , position : SkFontArguments_VariationPosition ) -> * mut SkFontArguments ; } extern "C" { # [ link_name = "\u{1}__ZNK15SkFontArguments18getCollectionIndexEv" ] pub fn SkFontArguments_getCollectionIndex ( this : * const SkFontArguments ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK15SkFontArguments7getAxesEPi" ] pub fn SkFontArguments_getAxes ( this : * const SkFontArguments , axisCount : * mut :: std :: os :: raw :: c_int ) -> * const SkFontArguments_Axis ; } extern "C" { # [ link_name = "\u{1}__ZNK15SkFontArguments26getVariationDesignPositionEv" ] pub fn SkFontArguments_getVariationDesignPosition ( this : * const SkFontArguments ) -> SkFontArguments_VariationPosition ; } extern "C" { # [ link_name = "\u{1}__ZN15SkFontArgumentsC1Ev" ] pub fn SkFontArguments_SkFontArguments ( this : * mut SkFontArguments ) ; } impl SkFontArguments { # [ inline ] pub unsafe fn setCollectionIndex ( & mut self , collectionIndex : :: std :: os :: raw :: c_int ) -> * mut SkFontArguments { SkFontArguments_setCollectionIndex ( self , collectionIndex ) } # [ inline ] pub unsafe fn setAxes ( & mut self , axes : * const SkFontArguments_Axis , axisCount : :: std :: os :: raw :: c_int ) -> * mut SkFontArguments { SkFontArguments_setAxes ( self , axes , axisCount ) } # [ inline ] pub unsafe fn setVariationDesignPosition ( & mut self , position : SkFontArguments_VariationPosition ) -> * mut SkFontArguments { SkFontArguments_setVariationDesignPosition ( self , position ) } # [ inline ] pub unsafe fn getCollectionIndex ( & self ) -> :: std :: os :: raw :: c_int { SkFontArguments_getCollectionIndex ( self ) } # [ inline ] pub unsafe fn getAxes ( & self , axisCount : * mut :: std :: os :: raw :: c_int ) -> * const SkFontArguments_Axis { SkFontArguments_getAxes ( self , axisCount ) } # [ inline ] pub unsafe fn getVariationDesignPosition ( & self ) -> SkFontArguments_VariationPosition { SkFontArguments_getVariationDesignPosition ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkFontArguments_SkFontArguments ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontParameters_Variation_Axis { pub tag : SkFourByteTag , pub min : f32 , pub def : f32 , pub max : f32 , pub flags : u16 , } pub const SkFontParameters_Variation_Axis_HIDDEN : u16 = 1 ; # [ test ] fn bindgen_test_layout_SkFontParameters_Variation_Axis ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFontParameters_Variation_Axis > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( SkFontParameters_Variation_Axis ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFontParameters_Variation_Axis > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkFontParameters_Variation_Axis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontParameters_Variation_Axis > ( ) ) ) . tag as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkFontParameters_Variation_Axis ) , "::" , stringify ! ( tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontParameters_Variation_Axis > ( ) ) ) . min as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkFontParameters_Variation_Axis ) , "::" , stringify ! ( min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontParameters_Variation_Axis > ( ) ) ) . def as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkFontParameters_Variation_Axis ) , "::" , stringify ! ( def ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontParameters_Variation_Axis > ( ) ) ) . max as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkFontParameters_Variation_Axis ) , "::" , stringify ! ( max ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontParameters_Variation_Axis > ( ) ) ) . flags as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkFontParameters_Variation_Axis ) , "::" , stringify ! ( flags ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK16SkFontParameters9Variation4Axis8isHiddenEv" ] pub fn SkFontParameters_Variation_Axis_isHidden ( this : * const SkFontParameters_Variation_Axis ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN16SkFontParameters9Variation4Axis9setHiddenEb" ] pub fn SkFontParameters_Variation_Axis_setHidden ( this : * mut SkFontParameters_Variation_Axis , hidden : bool ) ; } impl SkFontParameters_Variation_Axis { # [ inline ] pub unsafe fn isHidden ( & self ) -> bool { SkFontParameters_Variation_Axis_isHidden ( self ) } # [ inline ] pub unsafe fn setHidden ( & mut self , hidden : bool ) { SkFontParameters_Variation_Axis_setHidden ( self , hidden ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontStyle { pub fValue : u32 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkFontStyle_Weight { kInvisible_Weight = 0 , kThin_Weight = 100 , kExtraLight_Weight = 200 , kLight_Weight = 300 , kNormal_Weight = 400 , kMedium_Weight = 500 , kSemiBold_Weight = 600 , kBold_Weight = 700 , kExtraBold_Weight = 800 , kBlack_Weight = 900 , kExtraBlack_Weight = 1000 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkFontStyle_Width { kUltraCondensed_Width = 1 , kExtraCondensed_Width = 2 , kCondensed_Width = 3 , kSemiCondensed_Width = 4 , kNormal_Width = 5 , kSemiExpanded_Width = 6 , kExpanded_Width = 7 , kExtraExpanded_Width = 8 , kUltraExpanded_Width = 9 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkFontStyle_Slant { kUpright_Slant = 0 , kItalic_Slant = 1 , kOblique_Slant = 2 , } # [ test ] fn bindgen_test_layout_SkFontStyle ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFontStyle > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( SkFontStyle ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFontStyle > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkFontStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontStyle > ( ) ) ) . fValue as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkFontStyle ) , "::" , stringify ! ( fValue ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK11SkFontStyle6weightEv" ] pub fn SkFontStyle_weight ( this : * const SkFontStyle ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK11SkFontStyle5widthEv" ] pub fn SkFontStyle_width ( this : * const SkFontStyle ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK11SkFontStyle5slantEv" ] pub fn SkFontStyle_slant ( this : * const SkFontStyle ) -> SkFontStyle_Slant ; } extern "C" { # [ link_name = "\u{1}__ZN11SkFontStyle6NormalEv" ] pub fn SkFontStyle_Normal ( ) -> SkFontStyle ; } extern "C" { # [ link_name = "\u{1}__ZN11SkFontStyle4BoldEv" ] pub fn SkFontStyle_Bold ( ) -> SkFontStyle ; } extern "C" { # [ link_name = "\u{1}__ZN11SkFontStyle6ItalicEv" ] pub fn SkFontStyle_Italic ( ) -> SkFontStyle ; } extern "C" { # [ link_name = "\u{1}__ZN11SkFontStyle10BoldItalicEv" ] pub fn SkFontStyle_BoldItalic ( ) -> SkFontStyle ; } extern "C" { # [ link_name = "\u{1}__ZN11SkFontStyleC1EiiNS_5SlantE" ] pub fn SkFontStyle_SkFontStyle ( this : * mut SkFontStyle , weight : :: std :: os :: raw :: c_int , width : :: std :: os :: raw :: c_int , slant : SkFontStyle_Slant ) ; } extern "C" { # [ link_name = "\u{1}__ZN11SkFontStyleC1Ev" ] pub fn SkFontStyle_SkFontStyle1 ( this : * mut SkFontStyle ) ; } impl SkFontStyle { # [ inline ] pub unsafe fn weight ( & self ) -> :: std :: os :: raw :: c_int { SkFontStyle_weight ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { SkFontStyle_width ( self ) } # [ inline ] pub unsafe fn slant ( & self ) -> SkFontStyle_Slant { SkFontStyle_slant ( self ) } # [ inline ] pub unsafe fn Normal ( ) -> SkFontStyle { SkFontStyle_Normal ( ) } # [ inline ] pub unsafe fn Bold ( ) -> SkFontStyle { SkFontStyle_Bold ( ) } # [ inline ] pub unsafe fn Italic ( ) -> SkFontStyle { SkFontStyle_Italic ( ) } # [ inline ] pub unsafe fn BoldItalic ( ) -> SkFontStyle { SkFontStyle_BoldItalic ( ) } # [ inline ] pub unsafe fn new ( weight : :: std :: os :: raw :: c_int , width : :: std :: os :: raw :: c_int , slant : SkFontStyle_Slant ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkFontStyle_SkFontStyle ( & mut __bindgen_tmp , weight , width , slant ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkFontStyle_SkFontStyle1 ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ doc = " \\struct SkIPoint" ] # [ doc = "SkIPoint holds two 32-bit integer coordinates." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkIPoint { # [ doc = "!< x-axis value" ] pub fX : i32 , # [ doc = "!< y-axis value" ] pub fY : i32 , } # [ test ] fn bindgen_test_layout_SkIPoint ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkIPoint > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkIPoint ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkIPoint > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkIPoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkIPoint > ( ) ) ) . fX as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkIPoint ) , "::" , stringify ! ( fX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkIPoint > ( ) ) ) . fY as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkIPoint ) , "::" , stringify ! ( fY ) ) ) ; } extern "C" { # [ doc = " Sets fX to x, fY to y." ] # [ doc = "" ] # [ doc = "@param x  integer x-axis value of constructed SkIPoint" ] # [ doc = "@param y  integer y-axis value of constructed SkIPoint" ] # [ doc = "@return   SkIPoint (x, y)" ] # [ link_name = "\u{1}__ZN8SkIPoint4MakeEii" ] pub fn SkIPoint_Make ( x : i32 , y : i32 ) -> SkIPoint ; } extern "C" { # [ doc = " Returns x-axis value of SkIPoint." ] # [ doc = "" ] # [ doc = "@return  fX" ] # [ link_name = "\u{1}__ZNK8SkIPoint1xEv" ] pub fn SkIPoint_x ( this : * const SkIPoint ) -> i32 ; } extern "C" { # [ doc = " Returns y-axis value of SkIPoint." ] # [ doc = "" ] # [ doc = "@return  fY" ] # [ link_name = "\u{1}__ZNK8SkIPoint1yEv" ] pub fn SkIPoint_y ( this : * const SkIPoint ) -> i32 ; } extern "C" { # [ doc = " Returns true if fX and fY are both zero." ] # [ doc = "" ] # [ doc = "@return  true if fX is zero and fY is zero" ] # [ link_name = "\u{1}__ZNK8SkIPoint6isZeroEv" ] pub fn SkIPoint_isZero ( this : * const SkIPoint ) -> bool ; } extern "C" { # [ doc = " Sets fX to x and fY to y." ] # [ doc = "" ] # [ doc = "@param x  new value for fX" ] # [ doc = "@param y  new value for fY" ] # [ link_name = "\u{1}__ZN8SkIPoint3setEii" ] pub fn SkIPoint_set ( this : * mut SkIPoint , x : i32 , y : i32 ) ; } extern "C" { # [ doc = " Returns true if SkIPoint is equivalent to SkIPoint constructed from (x, y)." ] # [ doc = "" ] # [ doc = "@param x  value compared with fX" ] # [ doc = "@param y  value compared with fY" ] # [ doc = "@return   true if SkIPoint equals (x, y)" ] # [ link_name = "\u{1}__ZNK8SkIPoint6equalsEii" ] pub fn SkIPoint_equals ( this : * const SkIPoint , x : i32 , y : i32 ) -> bool ; } impl SkIPoint { # [ inline ] pub unsafe fn Make ( x : i32 , y : i32 ) -> SkIPoint { SkIPoint_Make ( x , y ) } # [ inline ] pub unsafe fn x ( & self ) -> i32 { SkIPoint_x ( self ) } # [ inline ] pub unsafe fn y ( & self ) -> i32 { SkIPoint_y ( self ) } # [ inline ] pub unsafe fn isZero ( & self ) -> bool { SkIPoint_isZero ( self ) } # [ inline ] pub unsafe fn set ( & mut self , x : i32 , y : i32 ) { SkIPoint_set ( self , x , y ) } # [ inline ] pub unsafe fn equals ( & self , x : i32 , y : i32 ) -> bool { SkIPoint_equals ( self , x , y ) } } # [ doc = " SkVector provides an alternative name for SkPoint. SkVector and SkPoint can" ] # [ doc = "be used interchangeably for all purposes." ] pub type SkVector = SkPoint ; # [ doc = " \\struct SkPoint" ] # [ doc = "SkPoint holds two 32-bit floating point coordinates." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkPoint { # [ doc = "!< x-axis value" ] pub fX : SkScalar , # [ doc = "!< y-axis value" ] pub fY : SkScalar , } # [ test ] fn bindgen_test_layout_SkPoint ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPoint > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkPoint ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPoint > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkPoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPoint > ( ) ) ) . fX as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPoint ) , "::" , stringify ! ( fX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPoint > ( ) ) ) . fY as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkPoint ) , "::" , stringify ! ( fY ) ) ) ; } extern "C" { # [ doc = " Sets fX to x, fY to y. Used both to set SkPoint and vector." ] # [ doc = "" ] # [ doc = "@param x  SkScalar x-axis value of constructed SkPoint or vector" ] # [ doc = "@param y  SkScalar y-axis value of constructed SkPoint or vector" ] # [ doc = "@return   SkPoint (x, y)" ] # [ link_name = "\u{1}__ZN7SkPoint4MakeEff" ] pub fn SkPoint_Make ( x : SkScalar , y : SkScalar ) -> SkPoint ; } extern "C" { # [ doc = " Returns x-axis value of SkPoint or vector." ] # [ doc = "" ] # [ doc = "@return  fX" ] # [ link_name = "\u{1}__ZNK7SkPoint1xEv" ] pub fn SkPoint_x ( this : * const SkPoint ) -> SkScalar ; } extern "C" { # [ doc = " Returns y-axis value of SkPoint or vector." ] # [ doc = "" ] # [ doc = "@return  fY" ] # [ link_name = "\u{1}__ZNK7SkPoint1yEv" ] pub fn SkPoint_y ( this : * const SkPoint ) -> SkScalar ; } extern "C" { # [ doc = " Returns true if fX and fY are both zero." ] # [ doc = "" ] # [ doc = "@return  true if fX is zero and fY is zero" ] # [ link_name = "\u{1}__ZNK7SkPoint6isZeroEv" ] pub fn SkPoint_isZero ( this : * const SkPoint ) -> bool ; } extern "C" { # [ doc = " Sets fX to x and fY to y." ] # [ doc = "" ] # [ doc = "@param x  new value for fX" ] # [ doc = "@param y  new value for fY" ] # [ link_name = "\u{1}__ZN7SkPoint3setEff" ] pub fn SkPoint_set ( this : * mut SkPoint , x : SkScalar , y : SkScalar ) ; } extern "C" { # [ doc = " Sets fX to x and fY to y, promoting integers to SkScalar values." ] # [ doc = "" ] # [ doc = "Assigning a large integer value directly to fX or fY may cause a compiler" ] # [ doc = "error, triggered by narrowing conversion of int to SkScalar. This safely" ] # [ doc = "casts x and y to avoid the error." ] # [ doc = "" ] # [ doc = "@param x  new value for fX" ] # [ doc = "@param y  new value for fY" ] # [ link_name = "\u{1}__ZN7SkPoint4isetEii" ] pub fn SkPoint_iset ( this : * mut SkPoint , x : i32 , y : i32 ) ; } extern "C" { # [ doc = " Sets fX to p.fX and fY to p.fY, promoting integers to SkScalar values." ] # [ doc = "" ] # [ doc = "Assigning an SkIPoint containing a large integer value directly to fX or fY may" ] # [ doc = "cause a compiler error, triggered by narrowing conversion of int to SkScalar." ] # [ doc = "This safely casts p.fX and p.fY to avoid the error." ] # [ doc = "" ] # [ doc = "@param p  SkIPoint members promoted to SkScalar" ] # [ link_name = "\u{1}__ZN7SkPoint4isetERK8SkIPoint" ] pub fn SkPoint_iset1 ( this : * mut SkPoint , p : * const SkIPoint ) ; } extern "C" { # [ doc = " Sets fX to absolute value of pt.fX; and fY to absolute value of pt.fY." ] # [ doc = "" ] # [ doc = "@param pt  members providing magnitude for fX and fY" ] # [ link_name = "\u{1}__ZN7SkPoint6setAbsERKS_" ] pub fn SkPoint_setAbs ( this : * mut SkPoint , pt : * const SkPoint ) ; } extern "C" { # [ doc = " Adds offset to each SkPoint in points array with count entries." ] # [ doc = "" ] # [ doc = "@param points  SkPoint array" ] # [ doc = "@param count   entries in array" ] # [ doc = "@param offset  vector added to points" ] # [ link_name = "\u{1}__ZN7SkPoint6OffsetEPS_iRKS_" ] pub fn SkPoint_Offset ( points : * mut SkPoint , count : :: std :: os :: raw :: c_int , offset : * const SkVector ) ; } extern "C" { # [ doc = " Adds offset (dx, dy) to each SkPoint in points array of length count." ] # [ doc = "" ] # [ doc = "@param points  SkPoint array" ] # [ doc = "@param count   entries in array" ] # [ doc = "@param dx      added to fX in points" ] # [ doc = "@param dy      added to fY in points" ] # [ link_name = "\u{1}__ZN7SkPoint6OffsetEPS_iff" ] pub fn SkPoint_Offset1 ( points : * mut SkPoint , count : :: std :: os :: raw :: c_int , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Adds offset (dx, dy) to SkPoint." ] # [ doc = "" ] # [ doc = "@param dx  added to fX" ] # [ doc = "@param dy  added to fY" ] # [ link_name = "\u{1}__ZN7SkPoint6offsetEff" ] pub fn SkPoint_offset ( this : * mut SkPoint , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Returns the Euclidean distance from origin, computed as:" ] # [ doc = "" ] # [ doc = "sqrt(fX * fX + fY * fY)" ] # [ doc = "" ] # [ doc = "." ] # [ doc = "" ] # [ doc = "@return  straight-line distance to origin" ] # [ link_name = "\u{1}__ZNK7SkPoint6lengthEv" ] pub fn SkPoint_length ( this : * const SkPoint ) -> SkScalar ; } extern "C" { # [ doc = " Returns the Euclidean distance from origin, computed as:" ] # [ doc = "" ] # [ doc = "sqrt(fX * fX + fY * fY)" ] # [ doc = "" ] # [ doc = "." ] # [ doc = "" ] # [ doc = "@return  straight-line distance to origin" ] # [ link_name = "\u{1}__ZNK7SkPoint16distanceToOriginEv" ] pub fn SkPoint_distanceToOrigin ( this : * const SkPoint ) -> SkScalar ; } extern "C" { # [ doc = " Scales (fX, fY) so that length() returns one, while preserving ratio of fX to fY," ] # [ doc = "if possible. If prior length is nearly zero, sets vector to (0, 0) and returns" ] # [ doc = "false; otherwise returns true." ] # [ doc = "" ] # [ doc = "@return  true if former length is not zero or nearly zero" ] # [ link_name = "\u{1}__ZN7SkPoint9normalizeEv" ] pub fn SkPoint_normalize ( this : * mut SkPoint ) -> bool ; } extern "C" { # [ doc = " Sets vector to (x, y) scaled so length() returns one, and so that" ] # [ doc = "(fX, fY) is proportional to (x, y).  If (x, y) length is nearly zero," ] # [ doc = "sets vector to (0, 0) and returns false; otherwise returns true." ] # [ doc = "" ] # [ doc = "@param x  proportional value for fX" ] # [ doc = "@param y  proportional value for fY" ] # [ doc = "@return   true if (x, y) length is not zero or nearly zero" ] # [ link_name = "\u{1}__ZN7SkPoint12setNormalizeEff" ] pub fn SkPoint_setNormalize ( this : * mut SkPoint , x : SkScalar , y : SkScalar ) -> bool ; } extern "C" { # [ doc = " Scales vector so that distanceToOrigin() returns length, if possible. If former" ] # [ doc = "length is nearly zero, sets vector to (0, 0) and return false; otherwise returns" ] # [ doc = "true." ] # [ doc = "" ] # [ doc = "@param length  straight-line distance to origin" ] # [ doc = "@return        true if former length is not zero or nearly zero" ] # [ link_name = "\u{1}__ZN7SkPoint9setLengthEf" ] pub fn SkPoint_setLength ( this : * mut SkPoint , length : SkScalar ) -> bool ; } extern "C" { # [ doc = " Sets vector to (x, y) scaled to length, if possible. If former" ] # [ doc = "length is nearly zero, sets vector to (0, 0) and return false; otherwise returns" ] # [ doc = "true." ] # [ doc = "" ] # [ doc = "@param x       proportional value for fX" ] # [ doc = "@param y       proportional value for fY" ] # [ doc = "@param length  straight-line distance to origin" ] # [ doc = "@return        true if (x, y) length is not zero or nearly zero" ] # [ link_name = "\u{1}__ZN7SkPoint9setLengthEfff" ] pub fn SkPoint_setLength1 ( this : * mut SkPoint , x : SkScalar , y : SkScalar , length : SkScalar ) -> bool ; } extern "C" { # [ doc = " Sets dst to SkPoint times scale. dst may be SkPoint to modify SkPoint in place." ] # [ doc = "" ] # [ doc = "@param scale  factor to multiply SkPoint by" ] # [ doc = "@param dst    storage for scaled SkPoint" ] # [ link_name = "\u{1}__ZNK7SkPoint5scaleEfPS_" ] pub fn SkPoint_scale ( this : * const SkPoint , scale : SkScalar , dst : * mut SkPoint ) ; } extern "C" { # [ doc = " Scales SkPoint in place by scale." ] # [ doc = "" ] # [ doc = "@param value  factor to multiply SkPoint by" ] # [ link_name = "\u{1}__ZN7SkPoint5scaleEf" ] pub fn SkPoint_scale1 ( this : * mut SkPoint , value : SkScalar ) ; } extern "C" { # [ doc = " Changes the sign of fX and fY." ] # [ link_name = "\u{1}__ZN7SkPoint6negateEv" ] pub fn SkPoint_negate ( this : * mut SkPoint ) ; } extern "C" { # [ doc = " Returns true if both fX and fY are measurable values." ] # [ doc = "" ] # [ doc = "@return  true for values other than infinities and NaN" ] # [ link_name = "\u{1}__ZNK7SkPoint8isFiniteEv" ] pub fn SkPoint_isFinite ( this : * const SkPoint ) -> bool ; } extern "C" { # [ doc = " Returns true if SkPoint is equivalent to SkPoint constructed from (x, y)." ] # [ doc = "" ] # [ doc = "@param x  value compared with fX" ] # [ doc = "@param y  value compared with fY" ] # [ doc = "@return   true if SkPoint equals (x, y)" ] # [ link_name = "\u{1}__ZNK7SkPoint6equalsEff" ] pub fn SkPoint_equals ( this : * const SkPoint , x : SkScalar , y : SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns the Euclidean distance from origin, computed as:" ] # [ doc = "" ] # [ doc = "sqrt(x * x + y * y)" ] # [ doc = "" ] # [ doc = "." ] # [ doc = "" ] # [ doc = "@param x  component of length" ] # [ doc = "@param y  component of length" ] # [ doc = "@return   straight-line distance to origin" ] # [ link_name = "\u{1}__ZN7SkPoint6LengthEff" ] pub fn SkPoint_Length ( x : SkScalar , y : SkScalar ) -> SkScalar ; } extern "C" { # [ doc = " Scales (vec->fX, vec->fY) so that length() returns one, while preserving ratio of vec->fX" ] # [ doc = "to vec->fY, if possible. If original length is nearly zero, sets vec to (0, 0) and returns" ] # [ doc = "zero; otherwise, returns length of vec before vec is scaled." ] # [ doc = "" ] # [ doc = "Returned prior length may be SK_ScalarInfinity if it can not be represented by SkScalar." ] # [ doc = "" ] # [ doc = "Note that normalize() is faster if prior length is not required." ] # [ doc = "" ] # [ doc = "@param vec  normalized to unit length" ] # [ doc = "@return     original vec length" ] # [ link_name = "\u{1}__ZN7SkPoint9NormalizeEPS_" ] pub fn SkPoint_Normalize ( vec : * mut SkVector ) -> SkScalar ; } extern "C" { # [ doc = " Returns the Euclidean distance between a and b." ] # [ doc = "" ] # [ doc = "@param a  line end point" ] # [ doc = "@param b  line end point" ] # [ doc = "@return   straight-line distance from a to b" ] # [ link_name = "\u{1}__ZN7SkPoint8DistanceERKS_S1_" ] pub fn SkPoint_Distance ( a : * const SkPoint , b : * const SkPoint ) -> SkScalar ; } extern "C" { # [ doc = " Returns the dot product of vector a and vector b." ] # [ doc = "" ] # [ doc = "@param a  left side of dot product" ] # [ doc = "@param b  right side of dot product" ] # [ doc = "@return   product of input magnitudes and cosine of the angle between them" ] # [ link_name = "\u{1}__ZN7SkPoint10DotProductERKS_S1_" ] pub fn SkPoint_DotProduct ( a : * const SkVector , b : * const SkVector ) -> SkScalar ; } extern "C" { # [ doc = " Returns the cross product of vector a and vector b." ] # [ doc = "" ] # [ doc = "a and b form three-dimensional vectors with z-axis value equal to zero. The" ] # [ doc = "cross product is a three-dimensional vector with x-axis and y-axis values equal" ] # [ doc = "to zero. The cross product z-axis component is returned." ] # [ doc = "" ] # [ doc = "@param a  left side of cross product" ] # [ doc = "@param b  right side of cross product" ] # [ doc = "@return   area spanned by vectors signed by angle direction" ] # [ link_name = "\u{1}__ZN7SkPoint12CrossProductERKS_S1_" ] pub fn SkPoint_CrossProduct ( a : * const SkVector , b : * const SkVector ) -> SkScalar ; } extern "C" { # [ doc = " Returns the cross product of vector and vec." ] # [ doc = "" ] # [ doc = "Vector and vec form three-dimensional vectors with z-axis value equal to zero." ] # [ doc = "The cross product is a three-dimensional vector with x-axis and y-axis values" ] # [ doc = "equal to zero. The cross product z-axis component is returned." ] # [ doc = "" ] # [ doc = "@param vec  right side of cross product" ] # [ doc = "@return     area spanned by vectors signed by angle direction" ] # [ link_name = "\u{1}__ZNK7SkPoint5crossERKS_" ] pub fn SkPoint_cross ( this : * const SkPoint , vec : * const SkVector ) -> SkScalar ; } extern "C" { # [ doc = " Returns the dot product of vector and vector vec." ] # [ doc = "" ] # [ doc = "@param vec  right side of dot product" ] # [ doc = "@return     product of input magnitudes and cosine of the angle between them" ] # [ link_name = "\u{1}__ZNK7SkPoint3dotERKS_" ] pub fn SkPoint_dot ( this : * const SkPoint , vec : * const SkVector ) -> SkScalar ; } impl SkPoint { # [ inline ] pub unsafe fn Make ( x : SkScalar , y : SkScalar ) -> SkPoint { SkPoint_Make ( x , y ) } # [ inline ] pub unsafe fn x ( & self ) -> SkScalar { SkPoint_x ( self ) } # [ inline ] pub unsafe fn y ( & self ) -> SkScalar { SkPoint_y ( self ) } # [ inline ] pub unsafe fn isZero ( & self ) -> bool { SkPoint_isZero ( self ) } # [ inline ] pub unsafe fn set ( & mut self , x : SkScalar , y : SkScalar ) { SkPoint_set ( self , x , y ) } # [ inline ] pub unsafe fn iset ( & mut self , x : i32 , y : i32 ) { SkPoint_iset ( self , x , y ) } # [ inline ] pub unsafe fn iset1 ( & mut self , p : * const SkIPoint ) { SkPoint_iset1 ( self , p ) } # [ inline ] pub unsafe fn setAbs ( & mut self , pt : * const SkPoint ) { SkPoint_setAbs ( self , pt ) } # [ inline ] pub unsafe fn Offset ( points : * mut SkPoint , count : :: std :: os :: raw :: c_int , offset : * const SkVector ) { SkPoint_Offset ( points , count , offset ) } # [ inline ] pub unsafe fn Offset1 ( points : * mut SkPoint , count : :: std :: os :: raw :: c_int , dx : SkScalar , dy : SkScalar ) { SkPoint_Offset1 ( points , count , dx , dy ) } # [ inline ] pub unsafe fn offset ( & mut self , dx : SkScalar , dy : SkScalar ) { SkPoint_offset ( self , dx , dy ) } # [ inline ] pub unsafe fn length ( & self ) -> SkScalar { SkPoint_length ( self ) } # [ inline ] pub unsafe fn distanceToOrigin ( & self ) -> SkScalar { SkPoint_distanceToOrigin ( self ) } # [ inline ] pub unsafe fn normalize ( & mut self ) -> bool { SkPoint_normalize ( self ) } # [ inline ] pub unsafe fn setNormalize ( & mut self , x : SkScalar , y : SkScalar ) -> bool { SkPoint_setNormalize ( self , x , y ) } # [ inline ] pub unsafe fn setLength ( & mut self , length : SkScalar ) -> bool { SkPoint_setLength ( self , length ) } # [ inline ] pub unsafe fn setLength1 ( & mut self , x : SkScalar , y : SkScalar , length : SkScalar ) -> bool { SkPoint_setLength1 ( self , x , y , length ) } # [ inline ] pub unsafe fn scale ( & self , scale : SkScalar , dst : * mut SkPoint ) { SkPoint_scale ( self , scale , dst ) } # [ inline ] pub unsafe fn scale1 ( & mut self , value : SkScalar ) { SkPoint_scale1 ( self , value ) } # [ inline ] pub unsafe fn negate ( & mut self ) { SkPoint_negate ( self ) } # [ inline ] pub unsafe fn isFinite ( & self ) -> bool { SkPoint_isFinite ( self ) } # [ inline ] pub unsafe fn equals ( & self , x : SkScalar , y : SkScalar ) -> bool { SkPoint_equals ( self , x , y ) } # [ inline ] pub unsafe fn Length ( x : SkScalar , y : SkScalar ) -> SkScalar { SkPoint_Length ( x , y ) } # [ inline ] pub unsafe fn Normalize ( vec : * mut SkVector ) -> SkScalar { SkPoint_Normalize ( vec ) } # [ inline ] pub unsafe fn Distance ( a : * const SkPoint , b : * const SkPoint ) -> SkScalar { SkPoint_Distance ( a , b ) } # [ inline ] pub unsafe fn DotProduct ( a : * const SkVector , b : * const SkVector ) -> SkScalar { SkPoint_DotProduct ( a , b ) } # [ inline ] pub unsafe fn CrossProduct ( a : * const SkVector , b : * const SkVector ) -> SkScalar { SkPoint_CrossProduct ( a , b ) } # [ inline ] pub unsafe fn cross ( & self , vec : * const SkVector ) -> SkScalar { SkPoint_cross ( self , vec ) } # [ inline ] pub unsafe fn dot ( & self , vec : * const SkVector ) -> SkScalar { SkPoint_dot ( self , vec ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkISize { pub fWidth : i32 , pub fHeight : i32 , } # [ test ] fn bindgen_test_layout_SkISize ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkISize > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkISize ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkISize > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkISize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkISize > ( ) ) ) . fWidth as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkISize ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkISize > ( ) ) ) . fHeight as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkISize ) , "::" , stringify ! ( fHeight ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkISize4MakeEii" ] pub fn SkISize_Make ( w : i32 , h : i32 ) -> SkISize ; } extern "C" { # [ link_name = "\u{1}__ZN7SkISize9MakeEmptyEv" ] pub fn SkISize_MakeEmpty ( ) -> SkISize ; } extern "C" { # [ link_name = "\u{1}__ZN7SkISize3setEii" ] pub fn SkISize_set ( this : * mut SkISize , w : i32 , h : i32 ) ; } extern "C" { # [ doc = " Returns true iff fWidth == 0 && fHeight == 0" ] # [ link_name = "\u{1}__ZNK7SkISize6isZeroEv" ] pub fn SkISize_isZero ( this : * const SkISize ) -> bool ; } extern "C" { # [ doc = " Returns true if either width or height are <= 0" ] # [ link_name = "\u{1}__ZNK7SkISize7isEmptyEv" ] pub fn SkISize_isEmpty ( this : * const SkISize ) -> bool ; } extern "C" { # [ doc = " Set the width and height to 0" ] # [ link_name = "\u{1}__ZN7SkISize8setEmptyEv" ] pub fn SkISize_setEmpty ( this : * mut SkISize ) ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkISize5widthEv" ] pub fn SkISize_width ( this : * const SkISize ) -> i32 ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkISize6heightEv" ] pub fn SkISize_height ( this : * const SkISize ) -> i32 ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkISize6equalsEii" ] pub fn SkISize_equals ( this : * const SkISize , w : i32 , h : i32 ) -> bool ; } impl SkISize { # [ inline ] pub unsafe fn Make ( w : i32 , h : i32 ) -> SkISize { SkISize_Make ( w , h ) } # [ inline ] pub unsafe fn MakeEmpty ( ) -> SkISize { SkISize_MakeEmpty ( ) } # [ inline ] pub unsafe fn set ( & mut self , w : i32 , h : i32 ) { SkISize_set ( self , w , h ) } # [ inline ] pub unsafe fn isZero ( & self ) -> bool { SkISize_isZero ( self ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkISize_isEmpty ( self ) } # [ inline ] pub unsafe fn setEmpty ( & mut self ) { SkISize_setEmpty ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> i32 { SkISize_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> i32 { SkISize_height ( self ) } # [ inline ] pub unsafe fn equals ( & self , w : i32 , h : i32 ) -> bool { SkISize_equals ( self , w , h ) } } # [ doc = "" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkSize { pub fWidth : SkScalar , pub fHeight : SkScalar , } # [ test ] fn bindgen_test_layout_SkSize ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkSize > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkSize ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkSize > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkSize > ( ) ) ) . fWidth as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkSize ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkSize > ( ) ) ) . fHeight as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkSize ) , "::" , stringify ! ( fHeight ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN6SkSize4MakeEff" ] pub fn SkSize_Make ( w : SkScalar , h : SkScalar ) -> SkSize ; } extern "C" { # [ link_name = "\u{1}__ZN6SkSize4MakeERK7SkISize" ] pub fn SkSize_Make1 ( src : * const SkISize ) -> SkSize ; } extern "C" { # [ link_name = "\u{1}__ZN6SkSize9MakeEmptyEv" ] pub fn SkSize_MakeEmpty ( ) -> SkSize ; } extern "C" { # [ link_name = "\u{1}__ZN6SkSize3setEff" ] pub fn SkSize_set ( this : * mut SkSize , w : SkScalar , h : SkScalar ) ; } extern "C" { # [ doc = " Returns true iff fWidth == 0 && fHeight == 0" ] # [ link_name = "\u{1}__ZNK6SkSize6isZeroEv" ] pub fn SkSize_isZero ( this : * const SkSize ) -> bool ; } extern "C" { # [ doc = " Returns true if either width or height are <= 0" ] # [ link_name = "\u{1}__ZNK6SkSize7isEmptyEv" ] pub fn SkSize_isEmpty ( this : * const SkSize ) -> bool ; } extern "C" { # [ doc = " Set the width and height to 0" ] # [ link_name = "\u{1}__ZN6SkSize8setEmptyEv" ] pub fn SkSize_setEmpty ( this : * mut SkSize ) ; } extern "C" { # [ link_name = "\u{1}__ZNK6SkSize5widthEv" ] pub fn SkSize_width ( this : * const SkSize ) -> SkScalar ; } extern "C" { # [ link_name = "\u{1}__ZNK6SkSize6heightEv" ] pub fn SkSize_height ( this : * const SkSize ) -> SkScalar ; } extern "C" { # [ link_name = "\u{1}__ZNK6SkSize6equalsEff" ] pub fn SkSize_equals ( this : * const SkSize , w : SkScalar , h : SkScalar ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK6SkSize7toRoundEv" ] pub fn SkSize_toRound ( this : * const SkSize ) -> SkISize ; } extern "C" { # [ link_name = "\u{1}__ZNK6SkSize6toCeilEv" ] pub fn SkSize_toCeil ( this : * const SkSize ) -> SkISize ; } extern "C" { # [ link_name = "\u{1}__ZNK6SkSize7toFloorEv" ] pub fn SkSize_toFloor ( this : * const SkSize ) -> SkISize ; } impl SkSize { # [ inline ] pub unsafe fn Make ( w : SkScalar , h : SkScalar ) -> SkSize { SkSize_Make ( w , h ) } # [ inline ] pub unsafe fn Make1 ( src : * const SkISize ) -> SkSize { SkSize_Make1 ( src ) } # [ inline ] pub unsafe fn MakeEmpty ( ) -> SkSize { SkSize_MakeEmpty ( ) } # [ inline ] pub unsafe fn set ( & mut self , w : SkScalar , h : SkScalar ) { SkSize_set ( self , w , h ) } # [ inline ] pub unsafe fn isZero ( & self ) -> bool { SkSize_isZero ( self ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkSize_isEmpty ( self ) } # [ inline ] pub unsafe fn setEmpty ( & mut self ) { SkSize_setEmpty ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> SkScalar { SkSize_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> SkScalar { SkSize_height ( self ) } # [ inline ] pub unsafe fn equals ( & self , w : SkScalar , h : SkScalar ) -> bool { SkSize_equals ( self , w , h ) } # [ inline ] pub unsafe fn toRound ( & self ) -> SkISize { SkSize_toRound ( self ) } # [ inline ] pub unsafe fn toCeil ( & self ) -> SkISize { SkSize_toCeil ( self ) } # [ inline ] pub unsafe fn toFloor ( & self ) -> SkISize { SkSize_toFloor ( self ) } } # [ doc = " \\struct SkIRect" ] # [ doc = "SkIRect holds four 32-bit integer coordinates describing the upper and" ] # [ doc = "lower bounds of a rectangle. SkIRect may be created from outer bounds or" ] # [ doc = "from position, width, and height. SkIRect describes an area; if its right" ] # [ doc = "is less than or equal to its left, or if its bottom is less than or equal to" ] # [ doc = "its top, it is considered empty." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkIRect { # [ doc = "!< smaller x-axis bounds" ] pub fLeft : i32 , # [ doc = "!< smaller y-axis bounds" ] pub fTop : i32 , # [ doc = "!< larger x-axis bounds" ] pub fRight : i32 , # [ doc = "!< larger y-axis bounds" ] pub fBottom : i32 , } # [ test ] fn bindgen_test_layout_SkIRect ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkIRect > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkIRect ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkIRect > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkIRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkIRect > ( ) ) ) . fLeft as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkIRect ) , "::" , stringify ! ( fLeft ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkIRect > ( ) ) ) . fTop as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkIRect ) , "::" , stringify ! ( fTop ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkIRect > ( ) ) ) . fRight as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkIRect ) , "::" , stringify ! ( fRight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkIRect > ( ) ) ) . fBottom as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkIRect ) , "::" , stringify ! ( fBottom ) ) ) ; } extern "C" { # [ doc = " Returns constructed SkIRect set to (0, 0, 0, 0)." ] # [ doc = "Many other rectangles are empty; if left is equal to or greater than right," ] # [ doc = "or if top is equal to or greater than bottom. Setting all members to zero" ] # [ doc = "is a convenience, but does not designate a special empty rectangle." ] # [ doc = "" ] # [ doc = "@return  bounds (0, 0, 0, 0)" ] # [ link_name = "\u{1}__ZN7SkIRect9MakeEmptyEv" ] pub fn SkIRect_MakeEmpty ( ) -> SkIRect ; } extern "C" { # [ doc = " Returns constructed SkIRect set to (0, 0, w, h). Does not validate input; w or h" ] # [ doc = "may be negative." ] # [ doc = "" ] # [ doc = "@param w  width of constructed SkIRect" ] # [ doc = "@param h  height of constructed SkIRect" ] # [ doc = "@return   bounds (0, 0, w, h)" ] # [ link_name = "\u{1}__ZN7SkIRect6MakeWHEii" ] pub fn SkIRect_MakeWH ( w : i32 , h : i32 ) -> SkIRect ; } extern "C" { # [ doc = " Returns constructed SkIRect set to (0, 0, size.width(), size.height())." ] # [ doc = "Does not validate input; size.width() or size.height() may be negative." ] # [ doc = "" ] # [ doc = "@param size  values for SkIRect width and height" ] # [ doc = "@return      bounds (0, 0, size.width(), size.height())" ] # [ link_name = "\u{1}__ZN7SkIRect8MakeSizeERK7SkISize" ] pub fn SkIRect_MakeSize ( size : * const SkISize ) -> SkIRect ; } extern "C" { # [ doc = " Returns constructed SkIRect set to (l, t, r, b). Does not sort input; SkIRect may" ] # [ doc = "result in fLeft greater than fRight, or fTop greater than fBottom." ] # [ doc = "" ] # [ doc = "@param l  integer stored in fLeft" ] # [ doc = "@param t  integer stored in fTop" ] # [ doc = "@param r  integer stored in fRight" ] # [ doc = "@param b  integer stored in fBottom" ] # [ doc = "@return   bounds (l, t, r, b)" ] # [ link_name = "\u{1}__ZN7SkIRect8MakeLTRBEiiii" ] pub fn SkIRect_MakeLTRB ( l : i32 , t : i32 , r : i32 , b : i32 ) -> SkIRect ; } extern "C" { # [ doc = " Returns constructed SkIRect set to: (x, y, x + w, y + h)." ] # [ doc = "Does not validate input; w or h may be negative." ] # [ doc = "" ] # [ doc = "@param x  stored in fLeft" ] # [ doc = "@param y  stored in fTop" ] # [ doc = "@param w  added to x and stored in fRight" ] # [ doc = "@param h  added to y and stored in fBottom" ] # [ doc = "@return   bounds at (x, y) with width w and height h" ] # [ link_name = "\u{1}__ZN7SkIRect8MakeXYWHEiiii" ] pub fn SkIRect_MakeXYWH ( x : i32 , y : i32 , w : i32 , h : i32 ) -> SkIRect ; } extern "C" { # [ doc = " Returns left edge of SkIRect, if sorted." ] # [ doc = "Call sort() to reverse fLeft and fRight if needed." ] # [ doc = "" ] # [ doc = "@return  fLeft" ] # [ link_name = "\u{1}__ZNK7SkIRect4leftEv" ] pub fn SkIRect_left ( this : * const SkIRect ) -> i32 ; } extern "C" { # [ doc = " Returns top edge of SkIRect, if sorted. Call isEmpty() to see if SkIRect may be invalid," ] # [ doc = "and sort() to reverse fTop and fBottom if needed." ] # [ doc = "" ] # [ doc = "@return  fTop" ] # [ link_name = "\u{1}__ZNK7SkIRect3topEv" ] pub fn SkIRect_top ( this : * const SkIRect ) -> i32 ; } extern "C" { # [ doc = " Returns right edge of SkIRect, if sorted." ] # [ doc = "Call sort() to reverse fLeft and fRight if needed." ] # [ doc = "" ] # [ doc = "@return  fRight" ] # [ link_name = "\u{1}__ZNK7SkIRect5rightEv" ] pub fn SkIRect_right ( this : * const SkIRect ) -> i32 ; } extern "C" { # [ doc = " Returns bottom edge of SkIRect, if sorted. Call isEmpty() to see if SkIRect may be invalid," ] # [ doc = "and sort() to reverse fTop and fBottom if needed." ] # [ doc = "" ] # [ doc = "@return  fBottom" ] # [ link_name = "\u{1}__ZNK7SkIRect6bottomEv" ] pub fn SkIRect_bottom ( this : * const SkIRect ) -> i32 ; } extern "C" { # [ doc = " Returns left edge of SkIRect, if sorted. Call isEmpty() to see if SkIRect may be invalid," ] # [ doc = "and sort() to reverse fLeft and fRight if needed." ] # [ doc = "" ] # [ doc = "@return  fLeft" ] # [ link_name = "\u{1}__ZNK7SkIRect1xEv" ] pub fn SkIRect_x ( this : * const SkIRect ) -> i32 ; } extern "C" { # [ doc = " Returns top edge of SkIRect, if sorted. Call isEmpty() to see if SkIRect may be invalid," ] # [ doc = "and sort() to reverse fTop and fBottom if needed." ] # [ doc = "" ] # [ doc = "@return  fTop" ] # [ link_name = "\u{1}__ZNK7SkIRect1yEv" ] pub fn SkIRect_y ( this : * const SkIRect ) -> i32 ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkIRect7topLeftEv" ] pub fn SkIRect_topLeft ( this : * const SkIRect ) -> SkIPoint ; } extern "C" { # [ doc = " Returns span on the x-axis. This does not check if SkIRect is sorted, or if" ] # [ doc = "result fits in 32-bit signed integer; result may be negative." ] # [ doc = "" ] # [ doc = "@return  fRight minus fLeft" ] # [ link_name = "\u{1}__ZNK7SkIRect5widthEv" ] pub fn SkIRect_width ( this : * const SkIRect ) -> i32 ; } extern "C" { # [ doc = " Returns span on the y-axis. This does not check if SkIRect is sorted, or if" ] # [ doc = "result fits in 32-bit signed integer; result may be negative." ] # [ doc = "" ] # [ doc = "@return  fBottom minus fTop" ] # [ link_name = "\u{1}__ZNK7SkIRect6heightEv" ] pub fn SkIRect_height ( this : * const SkIRect ) -> i32 ; } extern "C" { # [ doc = " Returns spans on the x-axis and y-axis. This does not check if SkIRect is sorted," ] # [ doc = "or if result fits in 32-bit signed integer; result may be negative." ] # [ doc = "" ] # [ doc = "@return  SkISize (width, height)" ] # [ link_name = "\u{1}__ZNK7SkIRect4sizeEv" ] pub fn SkIRect_size ( this : * const SkIRect ) -> SkISize ; } extern "C" { # [ doc = " Returns span on the x-axis. This does not check if SkIRect is sorted, so the" ] # [ doc = "result may be negative. This is safer than calling width() since width() might" ] # [ doc = "overflow in its calculation." ] # [ doc = "" ] # [ doc = "@return  fRight minus fLeft cast to int64_t" ] # [ link_name = "\u{1}__ZNK7SkIRect7width64Ev" ] pub fn SkIRect_width64 ( this : * const SkIRect ) -> i64 ; } extern "C" { # [ doc = " Returns span on the y-axis. This does not check if SkIRect is sorted, so the" ] # [ doc = "result may be negative. This is safer than calling height() since height() might" ] # [ doc = "overflow in its calculation." ] # [ doc = "" ] # [ doc = "@return  fBottom minus fTop cast to int64_t" ] # [ link_name = "\u{1}__ZNK7SkIRect8height64Ev" ] pub fn SkIRect_height64 ( this : * const SkIRect ) -> i64 ; } extern "C" { # [ doc = " Returns true if fLeft is equal to or greater than fRight, or if fTop is equal" ] # [ doc = "to or greater than fBottom. Call sort() to reverse rectangles with negative" ] # [ doc = "width64() or height64()." ] # [ doc = "" ] # [ doc = "@return  true if width64() or height64() are zero or negative" ] # [ link_name = "\u{1}__ZNK7SkIRect9isEmpty64Ev" ] pub fn SkIRect_isEmpty64 ( this : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if width() or height() are zero or negative." ] # [ doc = "" ] # [ doc = "@return  true if width() or height() are zero or negative" ] # [ link_name = "\u{1}__ZNK7SkIRect7isEmptyEv" ] pub fn SkIRect_isEmpty ( this : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Sets SkIRect to (0, 0, 0, 0)." ] # [ doc = "" ] # [ doc = "Many other rectangles are empty; if left is equal to or greater than right," ] # [ doc = "or if top is equal to or greater than bottom. Setting all members to zero" ] # [ doc = "is a convenience, but does not designate a special empty rectangle." ] # [ link_name = "\u{1}__ZN7SkIRect8setEmptyEv" ] pub fn SkIRect_setEmpty ( this : * mut SkIRect ) ; } extern "C" { # [ doc = " Sets SkIRect to (left, top, right, bottom)." ] # [ doc = "left and right are not sorted; left is not necessarily less than right." ] # [ doc = "top and bottom are not sorted; top is not necessarily less than bottom." ] # [ doc = "" ] # [ doc = "@param left    assigned to fLeft" ] # [ doc = "@param top     assigned to fTop" ] # [ doc = "@param right   assigned to fRight" ] # [ doc = "@param bottom  assigned to fBottom" ] # [ link_name = "\u{1}__ZN7SkIRect3setEiiii" ] pub fn SkIRect_set ( this : * mut SkIRect , left : i32 , top : i32 , right : i32 , bottom : i32 ) ; } extern "C" { # [ doc = " Sets SkIRect to (left, top, right, bottom)." ] # [ doc = "left and right are not sorted; left is not necessarily less than right." ] # [ doc = "top and bottom are not sorted; top is not necessarily less than bottom." ] # [ doc = "" ] # [ doc = "@param left    stored in fLeft" ] # [ doc = "@param top     stored in fTop" ] # [ doc = "@param right   stored in fRight" ] # [ doc = "@param bottom  stored in fBottom" ] # [ link_name = "\u{1}__ZN7SkIRect7setLTRBEiiii" ] pub fn SkIRect_setLTRB ( this : * mut SkIRect , left : i32 , top : i32 , right : i32 , bottom : i32 ) ; } extern "C" { # [ doc = " Sets SkIRect to: (x, y, x + width, y + height)." ] # [ doc = "Does not validate input; width or height may be negative." ] # [ doc = "" ] # [ doc = "@param x       stored in fLeft" ] # [ doc = "@param y       stored in fTop" ] # [ doc = "@param width   added to x and stored in fRight" ] # [ doc = "@param height  added to y and stored in fBottom" ] # [ link_name = "\u{1}__ZN7SkIRect7setXYWHEiiii" ] pub fn SkIRect_setXYWH ( this : * mut SkIRect , x : i32 , y : i32 , width : i32 , height : i32 ) ; } extern "C" { # [ doc = " Returns SkIRect offset by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is negative, SkIRect returned is moved to the left." ] # [ doc = "If dx is positive, SkIRect returned is moved to the right." ] # [ doc = "If dy is negative, SkIRect returned is moved upward." ] # [ doc = "If dy is positive, SkIRect returned is moved downward." ] # [ doc = "" ] # [ doc = "@param dx  offset added to fLeft and fRight" ] # [ doc = "@param dy  offset added to fTop and fBottom" ] # [ doc = "@return    SkIRect offset by dx and dy, with original width and height" ] # [ link_name = "\u{1}__ZNK7SkIRect10makeOffsetEii" ] pub fn SkIRect_makeOffset ( this : * const SkIRect , dx : i32 , dy : i32 ) -> SkIRect ; } extern "C" { # [ doc = " Returns SkIRect, inset by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is negative, SkIRect returned is wider." ] # [ doc = "If dx is positive, SkIRect returned is narrower." ] # [ doc = "If dy is negative, SkIRect returned is taller." ] # [ doc = "If dy is positive, SkIRect returned is shorter." ] # [ doc = "" ] # [ doc = "@param dx  offset added to fLeft and subtracted from fRight" ] # [ doc = "@param dy  offset added to fTop and subtracted from fBottom" ] # [ doc = "@return    SkIRect inset symmetrically left and right, top and bottom" ] # [ link_name = "\u{1}__ZNK7SkIRect9makeInsetEii" ] pub fn SkIRect_makeInset ( this : * const SkIRect , dx : i32 , dy : i32 ) -> SkIRect ; } extern "C" { # [ doc = " Returns SkIRect, outset by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is negative, SkIRect returned is narrower." ] # [ doc = "If dx is positive, SkIRect returned is wider." ] # [ doc = "If dy is negative, SkIRect returned is shorter." ] # [ doc = "If dy is positive, SkIRect returned is taller." ] # [ doc = "" ] # [ doc = "@param dx  offset subtracted to fLeft and added from fRight" ] # [ doc = "@param dy  offset subtracted to fTop and added from fBottom" ] # [ doc = "@return    SkIRect outset symmetrically left and right, top and bottom" ] # [ link_name = "\u{1}__ZNK7SkIRect10makeOutsetEii" ] pub fn SkIRect_makeOutset ( this : * const SkIRect , dx : i32 , dy : i32 ) -> SkIRect ; } extern "C" { # [ doc = " Offsets SkIRect by adding dx to fLeft, fRight; and by adding dy to fTop, fBottom." ] # [ doc = "" ] # [ doc = "If dx is negative, moves SkIRect returned to the left." ] # [ doc = "If dx is positive, moves SkIRect returned to the right." ] # [ doc = "If dy is negative, moves SkIRect returned upward." ] # [ doc = "If dy is positive, moves SkIRect returned downward." ] # [ doc = "" ] # [ doc = "@param dx  offset added to fLeft and fRight" ] # [ doc = "@param dy  offset added to fTop and fBottom" ] # [ link_name = "\u{1}__ZN7SkIRect6offsetEii" ] pub fn SkIRect_offset ( this : * mut SkIRect , dx : i32 , dy : i32 ) ; } extern "C" { # [ doc = " Offsets SkIRect by adding delta.fX to fLeft, fRight; and by adding delta.fY to" ] # [ doc = "fTop, fBottom." ] # [ doc = "" ] # [ doc = "If delta.fX is negative, moves SkIRect returned to the left." ] # [ doc = "If delta.fX is positive, moves SkIRect returned to the right." ] # [ doc = "If delta.fY is negative, moves SkIRect returned upward." ] # [ doc = "If delta.fY is positive, moves SkIRect returned downward." ] # [ doc = "" ] # [ doc = "@param delta  offset added to SkIRect" ] # [ link_name = "\u{1}__ZN7SkIRect6offsetERK8SkIPoint" ] pub fn SkIRect_offset1 ( this : * mut SkIRect , delta : * const SkIPoint ) ; } extern "C" { # [ doc = " Offsets SkIRect so that fLeft equals newX, and fTop equals newY. width and height" ] # [ doc = "are unchanged." ] # [ doc = "" ] # [ doc = "@param newX  stored in fLeft, preserving width()" ] # [ doc = "@param newY  stored in fTop, preserving height()" ] # [ link_name = "\u{1}__ZN7SkIRect8offsetToEii" ] pub fn SkIRect_offsetTo ( this : * mut SkIRect , newX : i32 , newY : i32 ) ; } extern "C" { # [ doc = " Insets SkIRect by (dx,dy)." ] # [ doc = "" ] # [ doc = "If dx is positive, makes SkIRect narrower." ] # [ doc = "If dx is negative, makes SkIRect wider." ] # [ doc = "If dy is positive, makes SkIRect shorter." ] # [ doc = "If dy is negative, makes SkIRect taller." ] # [ doc = "" ] # [ doc = "@param dx  offset added to fLeft and subtracted from fRight" ] # [ doc = "@param dy  offset added to fTop and subtracted from fBottom" ] # [ link_name = "\u{1}__ZN7SkIRect5insetEii" ] pub fn SkIRect_inset ( this : * mut SkIRect , dx : i32 , dy : i32 ) ; } extern "C" { # [ doc = " Outsets SkIRect by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is positive, makes SkIRect wider." ] # [ doc = "If dx is negative, makes SkIRect narrower." ] # [ doc = "If dy is positive, makes SkIRect taller." ] # [ doc = "If dy is negative, makes SkIRect shorter." ] # [ doc = "" ] # [ doc = "@param dx  subtracted to fLeft and added from fRight" ] # [ doc = "@param dy  subtracted to fTop and added from fBottom" ] # [ link_name = "\u{1}__ZN7SkIRect6outsetEii" ] pub fn SkIRect_outset ( this : * mut SkIRect , dx : i32 , dy : i32 ) ; } extern "C" { # [ doc = " Adjusts SkIRect by adding dL to fLeft, dT to fTop, dR to fRight, and dB to fBottom." ] # [ doc = "" ] # [ doc = "If dL is positive, narrows SkIRect on the left. If negative, widens it on the left." ] # [ doc = "If dT is positive, shrinks SkIRect on the top. If negative, lengthens it on the top." ] # [ doc = "If dR is positive, narrows SkIRect on the right. If negative, widens it on the right." ] # [ doc = "If dB is positive, shrinks SkIRect on the bottom. If negative, lengthens it on the bottom." ] # [ doc = "" ] # [ doc = "The resulting SkIRect is not checked for validity. Thus, if the resulting SkIRect left is" ] # [ doc = "greater than right, the SkIRect will be considered empty. Call sort() after this call" ] # [ doc = "if that is not the desired behavior." ] # [ doc = "" ] # [ doc = "@param dL  offset added to fLeft" ] # [ doc = "@param dT  offset added to fTop" ] # [ doc = "@param dR  offset added to fRight" ] # [ doc = "@param dB  offset added to fBottom" ] # [ link_name = "\u{1}__ZN7SkIRect6adjustEiiii" ] pub fn SkIRect_adjust ( this : * mut SkIRect , dL : i32 , dT : i32 , dR : i32 , dB : i32 ) ; } extern "C" { # [ doc = " Returns true if: fLeft <= x < fRight && fTop <= y < fBottom." ] # [ doc = "Returns false if SkIRect is empty." ] # [ doc = "" ] # [ doc = "Considers input to describe constructed SkIRect: (x, y, x + 1, y + 1) and" ] # [ doc = "returns true if constructed area is completely enclosed by SkIRect area." ] # [ doc = "" ] # [ doc = "@param x  test SkIPoint x-coordinate" ] # [ doc = "@param y  test SkIPoint y-coordinate" ] # [ doc = "@return   true if (x, y) is inside SkIRect" ] # [ link_name = "\u{1}__ZNK7SkIRect8containsEii" ] pub fn SkIRect_contains ( this : * const SkIRect , x : i32 , y : i32 ) -> bool ; } extern "C" { # [ doc = " Constructs SkIRect to intersect from (left, top, right, bottom). Does not sort" ] # [ doc = "construction." ] # [ doc = "" ] # [ doc = "Returns true if SkIRect contains construction." ] # [ doc = "Returns false if SkIRect is empty or construction is empty." ] # [ doc = "" ] # [ doc = "@param left    x-axis minimum of constructed SkIRect" ] # [ doc = "@param top     y-axis minimum of constructed SkIRect" ] # [ doc = "@param right   x-axis maximum of constructed SkIRect" ] # [ doc = "@param bottom  y-axis maximum of constructed SkIRect" ] # [ doc = "@return        true if all sides of SkIRect are outside construction" ] # [ link_name = "\u{1}__ZNK7SkIRect8containsEiiii" ] pub fn SkIRect_contains1 ( this : * const SkIRect , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool ; } extern "C" { # [ doc = " Returns true if SkIRect contains r." ] # [ doc = "Returns false if SkIRect is empty or r is empty." ] # [ doc = "" ] # [ doc = "SkIRect contains r when SkIRect area completely includes r area." ] # [ doc = "" ] # [ doc = "@param r  SkIRect contained" ] # [ doc = "@return   true if all sides of SkIRect are outside r" ] # [ link_name = "\u{1}__ZNK7SkIRect8containsERKS_" ] pub fn SkIRect_contains2 ( this : * const SkIRect , r : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if SkIRect contains r." ] # [ doc = "Returns false if SkIRect is empty or r is empty." ] # [ doc = "" ] # [ doc = "SkIRect contains r when SkIRect area completely includes r area." ] # [ doc = "" ] # [ doc = "@param r  SkRect contained" ] # [ doc = "@return   true if all sides of SkIRect are outside r" ] # [ link_name = "\u{1}__ZNK7SkIRect8containsERK6SkRect" ] pub fn SkIRect_contains3 ( this : * const SkIRect , r : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Constructs SkIRect from (left, top, right, bottom). Does not sort" ] # [ doc = "construction." ] # [ doc = "" ] # [ doc = "Returns true if SkIRect contains construction." ] # [ doc = "Asserts if SkIRect is empty or construction is empty, and if SK_DEBUG is defined." ] # [ doc = "" ] # [ doc = "Return is undefined if SkIRect is empty or construction is empty." ] # [ doc = "" ] # [ doc = "@param left    x-axis minimum of constructed SkIRect" ] # [ doc = "@param top     y-axis minimum of constructed SkIRect" ] # [ doc = "@param right   x-axis maximum of constructed SkIRect" ] # [ doc = "@param bottom  y-axis maximum of constructed SkIRect" ] # [ doc = "@return        true if all sides of SkIRect are outside construction" ] # [ link_name = "\u{1}__ZNK7SkIRect20containsNoEmptyCheckEiiii" ] pub fn SkIRect_containsNoEmptyCheck ( this : * const SkIRect , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool ; } extern "C" { # [ doc = " Returns true if SkIRect contains construction." ] # [ doc = "Asserts if SkIRect is empty or construction is empty, and if SK_DEBUG is defined." ] # [ doc = "" ] # [ doc = "Return is undefined if SkIRect is empty or construction is empty." ] # [ doc = "" ] # [ doc = "@param r  SkIRect contained" ] # [ doc = "@return   true if all sides of SkIRect are outside r" ] # [ link_name = "\u{1}__ZNK7SkIRect20containsNoEmptyCheckERKS_" ] pub fn SkIRect_containsNoEmptyCheck1 ( this : * const SkIRect , r : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if SkIRect intersects r, and sets SkIRect to intersection." ] # [ doc = "Returns false if SkIRect does not intersect r, and leaves SkIRect unchanged." ] # [ doc = "" ] # [ doc = "Returns false if either r or SkIRect is empty, leaving SkIRect unchanged." ] # [ doc = "" ] # [ doc = "@param r  limit of result" ] # [ doc = "@return   true if r and SkIRect have area in common" ] # [ link_name = "\u{1}__ZN7SkIRect9intersectERKS_" ] pub fn SkIRect_intersect ( this : * mut SkIRect , r : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if a intersects b, and sets SkIRect to intersection." ] # [ doc = "Returns false if a does not intersect b, and leaves SkIRect unchanged." ] # [ doc = "" ] # [ doc = "Asserts if either a or b is empty, and if SK_DEBUG is defined." ] # [ doc = "" ] # [ doc = "@param a  SkIRect to intersect" ] # [ doc = "@param b  SkIRect to intersect" ] # [ doc = "@return   true if a and b have area in common" ] # [ link_name = "\u{1}__ZN7SkIRect21intersectNoEmptyCheckERKS_S1_" ] pub fn SkIRect_intersectNoEmptyCheck ( this : * mut SkIRect , a : * const SkIRect , b : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if a intersects b, and sets SkIRect to intersection." ] # [ doc = "Returns false if a does not intersect b, and leaves SkIRect unchanged." ] # [ doc = "" ] # [ doc = "Returns false if either a or b is empty, leaving SkIRect unchanged." ] # [ doc = "" ] # [ doc = "@param a  SkIRect to intersect" ] # [ doc = "@param b  SkIRect to intersect" ] # [ doc = "@return   true if a and b have area in common" ] # [ link_name = "\u{1}__ZN7SkIRect9intersectERKS_S1_" ] pub fn SkIRect_intersect1 ( this : * mut SkIRect , a : * const SkIRect , b : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Constructs SkIRect to intersect from (left, top, right, bottom). Does not sort" ] # [ doc = "construction." ] # [ doc = "" ] # [ doc = "Returns true if SkIRect intersects construction, and sets SkIRect to intersection." ] # [ doc = "Returns false if SkIRect does not intersect construction, and leaves SkIRect unchanged." ] # [ doc = "" ] # [ doc = "Returns false if either construction or SkIRect is empty, leaving SkIRect unchanged." ] # [ doc = "" ] # [ doc = "@param left    x-axis minimum of constructed SkIRect" ] # [ doc = "@param top     y-axis minimum of constructed SkIRect" ] # [ doc = "@param right   x-axis maximum of constructed SkIRect" ] # [ doc = "@param bottom  y-axis maximum of constructed SkIRect" ] # [ doc = "@return        true if construction and SkIRect have area in common" ] # [ link_name = "\u{1}__ZN7SkIRect9intersectEiiii" ] pub fn SkIRect_intersect2 ( this : * mut SkIRect , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool ; } extern "C" { # [ doc = " Returns true if a intersects b." ] # [ doc = "Returns false if either a or b is empty, or do not intersect." ] # [ doc = "" ] # [ doc = "@param a  SkIRect to intersect" ] # [ doc = "@param b  SkIRect to intersect" ] # [ doc = "@return   true if a and b have area in common" ] # [ link_name = "\u{1}__ZN7SkIRect10IntersectsERKS_S1_" ] pub fn SkIRect_Intersects ( a : * const SkIRect , b : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if a intersects b." ] # [ doc = "Asserts if either a or b is empty, and if SK_DEBUG is defined." ] # [ doc = "" ] # [ doc = "@param a  SkIRect to intersect" ] # [ doc = "@param b  SkIRect to intersect" ] # [ doc = "@return   true if a and b have area in common" ] # [ link_name = "\u{1}__ZN7SkIRect22IntersectsNoEmptyCheckERKS_S1_" ] pub fn SkIRect_IntersectsNoEmptyCheck ( a : * const SkIRect , b : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Constructs SkIRect to intersect from (left, top, right, bottom). Does not sort" ] # [ doc = "construction." ] # [ doc = "" ] # [ doc = "Sets SkIRect to the union of itself and the construction." ] # [ doc = "" ] # [ doc = "Has no effect if construction is empty. Otherwise, if SkIRect is empty, sets" ] # [ doc = "SkIRect to construction." ] # [ doc = "" ] # [ doc = "@param left    x-axis minimum of constructed SkIRect" ] # [ doc = "@param top     y-axis minimum of constructed SkIRect" ] # [ doc = "@param right   x-axis maximum of constructed SkIRect" ] # [ doc = "@param bottom  y-axis maximum of constructed SkIRect" ] # [ link_name = "\u{1}__ZN7SkIRect4joinEiiii" ] pub fn SkIRect_join ( this : * mut SkIRect , left : i32 , top : i32 , right : i32 , bottom : i32 ) ; } extern "C" { # [ doc = " Sets SkIRect to the union of itself and r." ] # [ doc = "" ] # [ doc = "Has no effect if r is empty. Otherwise, if SkIRect is empty, sets SkIRect to r." ] # [ doc = "" ] # [ doc = "@param r  expansion SkIRect" ] # [ link_name = "\u{1}__ZN7SkIRect4joinERKS_" ] pub fn SkIRect_join1 ( this : * mut SkIRect , r : * const SkIRect ) ; } extern "C" { # [ doc = " Swaps fLeft and fRight if fLeft is greater than fRight; and swaps" ] # [ doc = "fTop and fBottom if fTop is greater than fBottom. Result may be empty," ] # [ doc = "and width() and height() will be zero or positive." ] # [ link_name = "\u{1}__ZN7SkIRect4sortEv" ] pub fn SkIRect_sort ( this : * mut SkIRect ) ; } extern "C" { # [ doc = " Returns SkIRect with fLeft and fRight swapped if fLeft is greater than fRight; and" ] # [ doc = "with fTop and fBottom swapped if fTop is greater than fBottom. Result may be empty;" ] # [ doc = "and width() and height() will be zero or positive." ] # [ doc = "" ] # [ doc = "@return  sorted SkIRect" ] # [ link_name = "\u{1}__ZNK7SkIRect10makeSortedEv" ] pub fn SkIRect_makeSorted ( this : * const SkIRect ) -> SkIRect ; } extern "C" { # [ doc = " Returns a reference to immutable empty SkIRect, set to (0, 0, 0, 0)." ] # [ doc = "" ] # [ doc = "@return  global SkIRect set to all zeroes" ] # [ link_name = "\u{1}__ZN7SkIRect10EmptyIRectEv" ] pub fn SkIRect_EmptyIRect ( ) -> * const SkIRect ; } impl SkIRect { # [ inline ] pub unsafe fn MakeEmpty ( ) -> SkIRect { SkIRect_MakeEmpty ( ) } # [ inline ] pub unsafe fn MakeWH ( w : i32 , h : i32 ) -> SkIRect { SkIRect_MakeWH ( w , h ) } # [ inline ] pub unsafe fn MakeSize ( size : * const SkISize ) -> SkIRect { SkIRect_MakeSize ( size ) } # [ inline ] pub unsafe fn MakeLTRB ( l : i32 , t : i32 , r : i32 , b : i32 ) -> SkIRect { SkIRect_MakeLTRB ( l , t , r , b ) } # [ inline ] pub unsafe fn MakeXYWH ( x : i32 , y : i32 , w : i32 , h : i32 ) -> SkIRect { SkIRect_MakeXYWH ( x , y , w , h ) } # [ inline ] pub unsafe fn left ( & self ) -> i32 { SkIRect_left ( self ) } # [ inline ] pub unsafe fn top ( & self ) -> i32 { SkIRect_top ( self ) } # [ inline ] pub unsafe fn right ( & self ) -> i32 { SkIRect_right ( self ) } # [ inline ] pub unsafe fn bottom ( & self ) -> i32 { SkIRect_bottom ( self ) } # [ inline ] pub unsafe fn x ( & self ) -> i32 { SkIRect_x ( self ) } # [ inline ] pub unsafe fn y ( & self ) -> i32 { SkIRect_y ( self ) } # [ inline ] pub unsafe fn topLeft ( & self ) -> SkIPoint { SkIRect_topLeft ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> i32 { SkIRect_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> i32 { SkIRect_height ( self ) } # [ inline ] pub unsafe fn size ( & self ) -> SkISize { SkIRect_size ( self ) } # [ inline ] pub unsafe fn width64 ( & self ) -> i64 { SkIRect_width64 ( self ) } # [ inline ] pub unsafe fn height64 ( & self ) -> i64 { SkIRect_height64 ( self ) } # [ inline ] pub unsafe fn isEmpty64 ( & self ) -> bool { SkIRect_isEmpty64 ( self ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkIRect_isEmpty ( self ) } # [ inline ] pub unsafe fn setEmpty ( & mut self ) { SkIRect_setEmpty ( self ) } # [ inline ] pub unsafe fn set ( & mut self , left : i32 , top : i32 , right : i32 , bottom : i32 ) { SkIRect_set ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn setLTRB ( & mut self , left : i32 , top : i32 , right : i32 , bottom : i32 ) { SkIRect_setLTRB ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn setXYWH ( & mut self , x : i32 , y : i32 , width : i32 , height : i32 ) { SkIRect_setXYWH ( self , x , y , width , height ) } # [ inline ] pub unsafe fn makeOffset ( & self , dx : i32 , dy : i32 ) -> SkIRect { SkIRect_makeOffset ( self , dx , dy ) } # [ inline ] pub unsafe fn makeInset ( & self , dx : i32 , dy : i32 ) -> SkIRect { SkIRect_makeInset ( self , dx , dy ) } # [ inline ] pub unsafe fn makeOutset ( & self , dx : i32 , dy : i32 ) -> SkIRect { SkIRect_makeOutset ( self , dx , dy ) } # [ inline ] pub unsafe fn offset ( & mut self , dx : i32 , dy : i32 ) { SkIRect_offset ( self , dx , dy ) } # [ inline ] pub unsafe fn offset1 ( & mut self , delta : * const SkIPoint ) { SkIRect_offset1 ( self , delta ) } # [ inline ] pub unsafe fn offsetTo ( & mut self , newX : i32 , newY : i32 ) { SkIRect_offsetTo ( self , newX , newY ) } # [ inline ] pub unsafe fn inset ( & mut self , dx : i32 , dy : i32 ) { SkIRect_inset ( self , dx , dy ) } # [ inline ] pub unsafe fn outset ( & mut self , dx : i32 , dy : i32 ) { SkIRect_outset ( self , dx , dy ) } # [ inline ] pub unsafe fn adjust ( & mut self , dL : i32 , dT : i32 , dR : i32 , dB : i32 ) { SkIRect_adjust ( self , dL , dT , dR , dB ) } # [ inline ] pub unsafe fn contains ( & self , x : i32 , y : i32 ) -> bool { SkIRect_contains ( self , x , y ) } # [ inline ] pub unsafe fn contains1 ( & self , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool { SkIRect_contains1 ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn contains2 ( & self , r : * const SkIRect ) -> bool { SkIRect_contains2 ( self , r ) } # [ inline ] pub unsafe fn contains3 ( & self , r : * const SkRect ) -> bool { SkIRect_contains3 ( self , r ) } # [ inline ] pub unsafe fn containsNoEmptyCheck ( & self , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool { SkIRect_containsNoEmptyCheck ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn containsNoEmptyCheck1 ( & self , r : * const SkIRect ) -> bool { SkIRect_containsNoEmptyCheck1 ( self , r ) } # [ inline ] pub unsafe fn intersect ( & mut self , r : * const SkIRect ) -> bool { SkIRect_intersect ( self , r ) } # [ inline ] pub unsafe fn intersectNoEmptyCheck ( & mut self , a : * const SkIRect , b : * const SkIRect ) -> bool { SkIRect_intersectNoEmptyCheck ( self , a , b ) } # [ inline ] pub unsafe fn intersect1 ( & mut self , a : * const SkIRect , b : * const SkIRect ) -> bool { SkIRect_intersect1 ( self , a , b ) } # [ inline ] pub unsafe fn intersect2 ( & mut self , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool { SkIRect_intersect2 ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn Intersects ( a : * const SkIRect , b : * const SkIRect ) -> bool { SkIRect_Intersects ( a , b ) } # [ inline ] pub unsafe fn IntersectsNoEmptyCheck ( a : * const SkIRect , b : * const SkIRect ) -> bool { SkIRect_IntersectsNoEmptyCheck ( a , b ) } # [ inline ] pub unsafe fn join ( & mut self , left : i32 , top : i32 , right : i32 , bottom : i32 ) { SkIRect_join ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn join1 ( & mut self , r : * const SkIRect ) { SkIRect_join1 ( self , r ) } # [ inline ] pub unsafe fn sort ( & mut self ) { SkIRect_sort ( self ) } # [ inline ] pub unsafe fn makeSorted ( & self ) -> SkIRect { SkIRect_makeSorted ( self ) } # [ inline ] pub unsafe fn EmptyIRect ( ) -> * const SkIRect { SkIRect_EmptyIRect ( ) } } # [ doc = " \\struct SkRect" ] # [ doc = "SkRect holds four SkScalar coordinates describing the upper and" ] # [ doc = "lower bounds of a rectangle. SkRect may be created from outer bounds or" ] # [ doc = "from position, width, and height. SkRect describes an area; if its right" ] # [ doc = "is less than or equal to its left, or if its bottom is less than or equal to" ] # [ doc = "its top, it is considered empty." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRect { # [ doc = "!< smaller x-axis bounds" ] pub fLeft : SkScalar , # [ doc = "!< smaller y-axis bounds" ] pub fTop : SkScalar , # [ doc = "!< larger x-axis bounds" ] pub fRight : SkScalar , # [ doc = "!< larger y-axis bounds" ] pub fBottom : SkScalar , } # [ test ] fn bindgen_test_layout_SkRect ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRect > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkRect ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRect > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRect > ( ) ) ) . fLeft as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkRect ) , "::" , stringify ! ( fLeft ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRect > ( ) ) ) . fTop as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkRect ) , "::" , stringify ! ( fTop ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRect > ( ) ) ) . fRight as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkRect ) , "::" , stringify ! ( fRight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRect > ( ) ) ) . fBottom as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkRect ) , "::" , stringify ! ( fBottom ) ) ) ; } extern "C" { # [ doc = " Returns constructed SkRect set to (0, 0, 0, 0)." ] # [ doc = "Many other rectangles are empty; if left is equal to or greater than right," ] # [ doc = "or if top is equal to or greater than bottom. Setting all members to zero" ] # [ doc = "is a convenience, but does not designate a special empty rectangle." ] # [ doc = "" ] # [ doc = "@return  bounds (0, 0, 0, 0)" ] # [ link_name = "\u{1}__ZN6SkRect9MakeEmptyEv" ] pub fn SkRect_MakeEmpty ( ) -> SkRect ; } extern "C" { # [ doc = " Returns constructed SkRect set to SkScalar values (0, 0, w, h). Does not" ] # [ doc = "validate input; w or h may be negative." ] # [ doc = "" ] # [ doc = "Passing integer values may generate a compiler warning since SkRect cannot" ] # [ doc = "represent 32-bit integers exactly. Use SkIRect for an exact integer rectangle." ] # [ doc = "" ] # [ doc = "@param w  SkScalar width of constructed SkRect" ] # [ doc = "@param h  SkScalar height of constructed SkRect" ] # [ doc = "@return   bounds (0, 0, w, h)" ] # [ link_name = "\u{1}__ZN6SkRect6MakeWHEff" ] pub fn SkRect_MakeWH ( w : SkScalar , h : SkScalar ) -> SkRect ; } extern "C" { # [ doc = " Returns constructed SkRect set to integer values (0, 0, w, h). Does not validate" ] # [ doc = "input; w or h may be negative." ] # [ doc = "" ] # [ doc = "Use to avoid a compiler warning that input may lose precision when stored." ] # [ doc = "Use SkIRect for an exact integer rectangle." ] # [ doc = "" ] # [ doc = "@param w  integer width of constructed SkRect" ] # [ doc = "@param h  integer height of constructed SkRect" ] # [ doc = "@return   bounds (0, 0, w, h)" ] # [ link_name = "\u{1}__ZN6SkRect7MakeIWHEii" ] pub fn SkRect_MakeIWH ( w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int ) -> SkRect ; } extern "C" { # [ doc = " Returns constructed SkRect set to (0, 0, size.width(), size.height()). Does not" ] # [ doc = "validate input; size.width() or size.height() may be negative." ] # [ doc = "" ] # [ doc = "@param size  SkScalar values for SkRect width and height" ] # [ doc = "@return      bounds (0, 0, size.width(), size.height())" ] # [ link_name = "\u{1}__ZN6SkRect8MakeSizeERK6SkSize" ] pub fn SkRect_MakeSize ( size : * const SkSize ) -> SkRect ; } extern "C" { # [ doc = " Returns constructed SkRect set to (l, t, r, b). Does not sort input; SkRect may" ] # [ doc = "result in fLeft greater than fRight, or fTop greater than fBottom." ] # [ doc = "" ] # [ doc = "@param l  SkScalar stored in fLeft" ] # [ doc = "@param t  SkScalar stored in fTop" ] # [ doc = "@param r  SkScalar stored in fRight" ] # [ doc = "@param b  SkScalar stored in fBottom" ] # [ doc = "@return   bounds (l, t, r, b)" ] # [ link_name = "\u{1}__ZN6SkRect8MakeLTRBEffff" ] pub fn SkRect_MakeLTRB ( l : SkScalar , t : SkScalar , r : SkScalar , b : SkScalar ) -> SkRect ; } extern "C" { # [ doc = " Returns constructed SkRect set to (x, y, x + w, y + h)." ] # [ doc = "Does not validate input; w or h may be negative." ] # [ doc = "" ] # [ doc = "@param x  stored in fLeft" ] # [ doc = "@param y  stored in fTop" ] # [ doc = "@param w  added to x and stored in fRight" ] # [ doc = "@param h  added to y and stored in fBottom" ] # [ doc = "@return   bounds at (x, y) with width w and height h" ] # [ link_name = "\u{1}__ZN6SkRect8MakeXYWHEffff" ] pub fn SkRect_MakeXYWH ( x : SkScalar , y : SkScalar , w : SkScalar , h : SkScalar ) -> SkRect ; } extern "C" { # [ doc = " Returns constructed SkIRect set to (0, 0, size.width(), size.height())." ] # [ doc = "Does not validate input; size.width() or size.height() may be negative." ] # [ doc = "" ] # [ doc = "@param size  integer values for SkRect width and height" ] # [ doc = "@return      bounds (0, 0, size.width(), size.height())" ] # [ link_name = "\u{1}__ZN6SkRect4MakeERK7SkISize" ] pub fn SkRect_Make ( size : * const SkISize ) -> SkRect ; } extern "C" { # [ doc = " Returns constructed SkIRect set to irect, promoting integers to scalar." ] # [ doc = "Does not validate input; fLeft may be greater than fRight, fTop may be greater" ] # [ doc = "than fBottom." ] # [ doc = "" ] # [ doc = "@param irect  integer unsorted bounds" ] # [ doc = "@return       irect members converted to SkScalar" ] # [ link_name = "\u{1}__ZN6SkRect4MakeERK7SkIRect" ] pub fn SkRect_Make1 ( irect : * const SkIRect ) -> SkRect ; } extern "C" { # [ doc = " Returns true if fLeft is equal to or greater than fRight, or if fTop is equal" ] # [ doc = "to or greater than fBottom. Call sort() to reverse rectangles with negative" ] # [ doc = "width() or height()." ] # [ doc = "" ] # [ doc = "@return  true if width() or height() are zero or negative" ] # [ link_name = "\u{1}__ZNK6SkRect7isEmptyEv" ] pub fn SkRect_isEmpty ( this : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Returns true if fLeft is equal to or less than fRight, or if fTop is equal" ] # [ doc = "to or less than fBottom. Call sort() to reverse rectangles with negative" ] # [ doc = "width() or height()." ] # [ doc = "" ] # [ doc = "@return  true if width() or height() are zero or positive" ] # [ link_name = "\u{1}__ZNK6SkRect8isSortedEv" ] pub fn SkRect_isSorted ( this : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Returns true if all values in the rectangle are finite: SK_ScalarMin or larger," ] # [ doc = "and SK_ScalarMax or smaller." ] # [ doc = "" ] # [ doc = "@return  true if no member is infinite or NaN" ] # [ link_name = "\u{1}__ZNK6SkRect8isFiniteEv" ] pub fn SkRect_isFinite ( this : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Returns left edge of SkRect, if sorted. Call isSorted() to see if SkRect is valid." ] # [ doc = "Call sort() to reverse fLeft and fRight if needed." ] # [ doc = "" ] # [ doc = "@return  fLeft" ] # [ link_name = "\u{1}__ZNK6SkRect1xEv" ] pub fn SkRect_x ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns top edge of SkRect, if sorted. Call isEmpty() to see if SkRect may be invalid," ] # [ doc = "and sort() to reverse fTop and fBottom if needed." ] # [ doc = "" ] # [ doc = "@return  fTop" ] # [ link_name = "\u{1}__ZNK6SkRect1yEv" ] pub fn SkRect_y ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns left edge of SkRect, if sorted. Call isSorted() to see if SkRect is valid." ] # [ doc = "Call sort() to reverse fLeft and fRight if needed." ] # [ doc = "" ] # [ doc = "@return  fLeft" ] # [ link_name = "\u{1}__ZNK6SkRect4leftEv" ] pub fn SkRect_left ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns top edge of SkRect, if sorted. Call isEmpty() to see if SkRect may be invalid," ] # [ doc = "and sort() to reverse fTop and fBottom if needed." ] # [ doc = "" ] # [ doc = "@return  fTop" ] # [ link_name = "\u{1}__ZNK6SkRect3topEv" ] pub fn SkRect_top ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns right edge of SkRect, if sorted. Call isSorted() to see if SkRect is valid." ] # [ doc = "Call sort() to reverse fLeft and fRight if needed." ] # [ doc = "" ] # [ doc = "@return  fRight" ] # [ link_name = "\u{1}__ZNK6SkRect5rightEv" ] pub fn SkRect_right ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns bottom edge of SkRect, if sorted. Call isEmpty() to see if SkRect may be invalid," ] # [ doc = "and sort() to reverse fTop and fBottom if needed." ] # [ doc = "" ] # [ doc = "@return  fBottom" ] # [ link_name = "\u{1}__ZNK6SkRect6bottomEv" ] pub fn SkRect_bottom ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns span on the x-axis. This does not check if SkRect is sorted, or if" ] # [ doc = "result fits in 32-bit float; result may be negative or infinity." ] # [ doc = "" ] # [ doc = "@return  fRight minus fLeft" ] # [ link_name = "\u{1}__ZNK6SkRect5widthEv" ] pub fn SkRect_width ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns span on the y-axis. This does not check if SkRect is sorted, or if" ] # [ doc = "result fits in 32-bit float; result may be negative or infinity." ] # [ doc = "" ] # [ doc = "@return  fBottom minus fTop" ] # [ link_name = "\u{1}__ZNK6SkRect6heightEv" ] pub fn SkRect_height ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns average of left edge and right edge. Result does not change if SkRect" ] # [ doc = "is sorted. Result may overflow to infinity if SkRect is far from the origin." ] # [ doc = "" ] # [ doc = "@return  midpoint on x-axis" ] # [ link_name = "\u{1}__ZNK6SkRect7centerXEv" ] pub fn SkRect_centerX ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns average of top edge and bottom edge. Result does not change if SkRect" ] # [ doc = "is sorted." ] # [ doc = "" ] # [ doc = "@return  midpoint on y-axis" ] # [ link_name = "\u{1}__ZNK6SkRect7centerYEv" ] pub fn SkRect_centerY ( this : * const SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns four points in quad that enclose SkRect ordered as: top-left, top-right," ] # [ doc = "bottom-right, bottom-left." ] # [ doc = "" ] # [ doc = "TODO: Consider adding parameter to control whether quad is clockwise or counterclockwise." ] # [ doc = "" ] # [ doc = "@param quad  storage for corners of SkRect" ] # [ link_name = "\u{1}__ZNK6SkRect6toQuadEP7SkPoint" ] pub fn SkRect_toQuad ( this : * const SkRect , quad : * mut SkPoint ) ; } extern "C" { # [ doc = " Sets SkRect to (0, 0, 0, 0)." ] # [ doc = "" ] # [ doc = "Many other rectangles are empty; if left is equal to or greater than right," ] # [ doc = "or if top is equal to or greater than bottom. Setting all members to zero" ] # [ doc = "is a convenience, but does not designate a special empty rectangle." ] # [ link_name = "\u{1}__ZN6SkRect8setEmptyEv" ] pub fn SkRect_setEmpty ( this : * mut SkRect ) ; } extern "C" { # [ doc = " Sets SkRect to src, promoting src members from integer to scalar." ] # [ doc = "Very large values in src may lose precision." ] # [ doc = "" ] # [ doc = "@param src  integer SkRect" ] # [ link_name = "\u{1}__ZN6SkRect3setERK7SkIRect" ] pub fn SkRect_set ( this : * mut SkRect , src : * const SkIRect ) ; } extern "C" { # [ doc = " Sets SkRect to (left, top, right, bottom)." ] # [ doc = "left and right are not sorted; left is not necessarily less than right." ] # [ doc = "top and bottom are not sorted; top is not necessarily less than bottom." ] # [ doc = "" ] # [ doc = "@param left    stored in fLeft" ] # [ doc = "@param top     stored in fTop" ] # [ doc = "@param right   stored in fRight" ] # [ doc = "@param bottom  stored in fBottom" ] # [ link_name = "\u{1}__ZN6SkRect3setEffff" ] pub fn SkRect_set1 ( this : * mut SkRect , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) ; } extern "C" { # [ doc = " Sets SkRect to (left, top, right, bottom)." ] # [ doc = "left and right are not sorted; left is not necessarily less than right." ] # [ doc = "top and bottom are not sorted; top is not necessarily less than bottom." ] # [ doc = "" ] # [ doc = "@param left    stored in fLeft" ] # [ doc = "@param top     stored in fTop" ] # [ doc = "@param right   stored in fRight" ] # [ doc = "@param bottom  stored in fBottom" ] # [ link_name = "\u{1}__ZN6SkRect7setLTRBEffff" ] pub fn SkRect_setLTRB ( this : * mut SkRect , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) ; } extern "C" { # [ doc = " Sets SkRect to (left, top, right, bottom)." ] # [ doc = "All parameters are promoted from integer to scalar." ] # [ doc = "left and right are not sorted; left is not necessarily less than right." ] # [ doc = "top and bottom are not sorted; top is not necessarily less than bottom." ] # [ doc = "" ] # [ doc = "@param left    promoted to SkScalar and stored in fLeft" ] # [ doc = "@param top     promoted to SkScalar and stored in fTop" ] # [ doc = "@param right   promoted to SkScalar and stored in fRight" ] # [ doc = "@param bottom  promoted to SkScalar and stored in fBottom" ] # [ link_name = "\u{1}__ZN6SkRect4isetEiiii" ] pub fn SkRect_iset ( this : * mut SkRect , left : :: std :: os :: raw :: c_int , top : :: std :: os :: raw :: c_int , right : :: std :: os :: raw :: c_int , bottom : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Sets SkRect to (0, 0, width, height)." ] # [ doc = "width and height may be zero or negative. width and height are promoted from" ] # [ doc = "integer to SkScalar, large values may lose precision." ] # [ doc = "" ] # [ doc = "@param width   promoted to SkScalar and stored in fRight" ] # [ doc = "@param height  promoted to SkScalar and stored in fBottom" ] # [ link_name = "\u{1}__ZN6SkRect6isetWHEii" ] pub fn SkRect_isetWH ( this : * mut SkRect , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Sets to bounds of SkPoint array with count entries. If count is zero or smaller," ] # [ doc = "or if SkPoint array contains an infinity or NaN, sets SkRect to (0, 0, 0, 0)." ] # [ doc = "" ] # [ doc = "Result is either empty or sorted: fLeft is less than or equal to fRight, and" ] # [ doc = "fTop is less than or equal to fBottom." ] # [ doc = "" ] # [ doc = "@param pts    SkPoint array" ] # [ doc = "@param count  entries in array" ] # [ link_name = "\u{1}__ZN6SkRect3setEPK7SkPointi" ] pub fn SkRect_set2 ( this : * mut SkRect , pts : * const SkPoint , count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Sets to bounds of SkPoint array with count entries. If count is zero or smaller," ] # [ doc = "or if SkPoint array contains an infinity or NaN, sets to (0, 0, 0, 0)." ] # [ doc = "" ] # [ doc = "Result is either empty or sorted: fLeft is less than or equal to fRight, and" ] # [ doc = "fTop is less than or equal to fBottom." ] # [ doc = "" ] # [ doc = "@param pts    SkPoint array" ] # [ doc = "@param count  entries in array" ] # [ link_name = "\u{1}__ZN6SkRect9setBoundsEPK7SkPointi" ] pub fn SkRect_setBounds ( this : * mut SkRect , pts : * const SkPoint , count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Sets to bounds of SkPoint array with count entries. Returns false if count is" ] # [ doc = "zero or smaller, or if SkPoint array contains an infinity or NaN; in these cases" ] # [ doc = "sets SkRect to (0, 0, 0, 0)." ] # [ doc = "" ] # [ doc = "Result is either empty or sorted: fLeft is less than or equal to fRight, and" ] # [ doc = "fTop is less than or equal to fBottom." ] # [ doc = "" ] # [ doc = "@param pts    SkPoint array" ] # [ doc = "@param count  entries in array" ] # [ doc = "@return       true if all SkPoint values are finite" ] # [ link_name = "\u{1}__ZN6SkRect14setBoundsCheckEPK7SkPointi" ] pub fn SkRect_setBoundsCheck ( this : * mut SkRect , pts : * const SkPoint , count : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Sets to bounds of SkPoint pts array with count entries. If any SkPoint in pts" ] # [ doc = "contains infinity or NaN, all SkRect dimensions are set to NaN." ] # [ doc = "" ] # [ doc = "@param pts    SkPoint array" ] # [ doc = "@param count  entries in array" ] # [ link_name = "\u{1}__ZN6SkRect16setBoundsNoCheckEPK7SkPointi" ] pub fn SkRect_setBoundsNoCheck ( this : * mut SkRect , pts : * const SkPoint , count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Sets bounds to the smallest SkRect enclosing SkPoint p0 and p1. The result is" ] # [ doc = "sorted and may be empty. Does not check to see if values are finite." ] # [ doc = "" ] # [ doc = "@param p0  corner to include" ] # [ doc = "@param p1  corner to include" ] # [ link_name = "\u{1}__ZN6SkRect3setERK7SkPointS2_" ] pub fn SkRect_set3 ( this : * mut SkRect , p0 : * const SkPoint , p1 : * const SkPoint ) ; } extern "C" { # [ doc = " Sets SkRect to (x, y, x + width, y + height)." ] # [ doc = "Does not validate input; width or height may be negative." ] # [ doc = "" ] # [ doc = "@param x       stored in fLeft" ] # [ doc = "@param y       stored in fTop" ] # [ doc = "@param width   added to x and stored in fRight" ] # [ doc = "@param height  added to y and stored in fBottom" ] # [ link_name = "\u{1}__ZN6SkRect7setXYWHEffff" ] pub fn SkRect_setXYWH ( this : * mut SkRect , x : SkScalar , y : SkScalar , width : SkScalar , height : SkScalar ) ; } extern "C" { # [ doc = " Sets SkRect to (0, 0, width, height). Does not validate input;" ] # [ doc = "width or height may be negative." ] # [ doc = "" ] # [ doc = "@param width   stored in fRight" ] # [ doc = "@param height  stored in fBottom" ] # [ link_name = "\u{1}__ZN6SkRect5setWHEff" ] pub fn SkRect_setWH ( this : * mut SkRect , width : SkScalar , height : SkScalar ) ; } extern "C" { # [ doc = " Returns SkRect offset by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is negative, SkRect returned is moved to the left." ] # [ doc = "If dx is positive, SkRect returned is moved to the right." ] # [ doc = "If dy is negative, SkRect returned is moved upward." ] # [ doc = "If dy is positive, SkRect returned is moved downward." ] # [ doc = "" ] # [ doc = "@param dx  added to fLeft and fRight" ] # [ doc = "@param dy  added to fTop and fBottom" ] # [ doc = "@return    SkRect offset on axes, with original width and height" ] # [ link_name = "\u{1}__ZNK6SkRect10makeOffsetEff" ] pub fn SkRect_makeOffset ( this : * const SkRect , dx : SkScalar , dy : SkScalar ) -> SkRect ; } extern "C" { # [ doc = " Returns SkRect, inset by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is negative, SkRect returned is wider." ] # [ doc = "If dx is positive, SkRect returned is narrower." ] # [ doc = "If dy is negative, SkRect returned is taller." ] # [ doc = "If dy is positive, SkRect returned is shorter." ] # [ doc = "" ] # [ doc = "@param dx  added to fLeft and subtracted from fRight" ] # [ doc = "@param dy  added to fTop and subtracted from fBottom" ] # [ doc = "@return    SkRect inset symmetrically left and right, top and bottom" ] # [ link_name = "\u{1}__ZNK6SkRect9makeInsetEff" ] pub fn SkRect_makeInset ( this : * const SkRect , dx : SkScalar , dy : SkScalar ) -> SkRect ; } extern "C" { # [ doc = " Returns SkRect, outset by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is negative, SkRect returned is narrower." ] # [ doc = "If dx is positive, SkRect returned is wider." ] # [ doc = "If dy is negative, SkRect returned is shorter." ] # [ doc = "If dy is positive, SkRect returned is taller." ] # [ doc = "" ] # [ doc = "@param dx  subtracted to fLeft and added from fRight" ] # [ doc = "@param dy  subtracted to fTop and added from fBottom" ] # [ doc = "@return    SkRect outset symmetrically left and right, top and bottom" ] # [ link_name = "\u{1}__ZNK6SkRect10makeOutsetEff" ] pub fn SkRect_makeOutset ( this : * const SkRect , dx : SkScalar , dy : SkScalar ) -> SkRect ; } extern "C" { # [ doc = " Offsets SkRect by adding dx to fLeft, fRight; and by adding dy to fTop, fBottom." ] # [ doc = "" ] # [ doc = "If dx is negative, moves SkRect to the left." ] # [ doc = "If dx is positive, moves SkRect to the right." ] # [ doc = "If dy is negative, moves SkRect upward." ] # [ doc = "If dy is positive, moves SkRect downward." ] # [ doc = "" ] # [ doc = "@param dx  offset added to fLeft and fRight" ] # [ doc = "@param dy  offset added to fTop and fBottom" ] # [ link_name = "\u{1}__ZN6SkRect6offsetEff" ] pub fn SkRect_offset ( this : * mut SkRect , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Offsets SkRect by adding delta.fX to fLeft, fRight; and by adding delta.fY to" ] # [ doc = "fTop, fBottom." ] # [ doc = "" ] # [ doc = "If delta.fX is negative, moves SkRect to the left." ] # [ doc = "If delta.fX is positive, moves SkRect to the right." ] # [ doc = "If delta.fY is negative, moves SkRect upward." ] # [ doc = "If delta.fY is positive, moves SkRect downward." ] # [ doc = "" ] # [ doc = "@param delta  added to SkRect" ] # [ link_name = "\u{1}__ZN6SkRect6offsetERK7SkPoint" ] pub fn SkRect_offset1 ( this : * mut SkRect , delta : * const SkPoint ) ; } extern "C" { # [ doc = " Offsets SkRect so that fLeft equals newX, and fTop equals newY. width and height" ] # [ doc = "are unchanged." ] # [ doc = "" ] # [ doc = "@param newX  stored in fLeft, preserving width()" ] # [ doc = "@param newY  stored in fTop, preserving height()" ] # [ link_name = "\u{1}__ZN6SkRect8offsetToEff" ] pub fn SkRect_offsetTo ( this : * mut SkRect , newX : SkScalar , newY : SkScalar ) ; } extern "C" { # [ doc = " Insets SkRect by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is positive, makes SkRect narrower." ] # [ doc = "If dx is negative, makes SkRect wider." ] # [ doc = "If dy is positive, makes SkRect shorter." ] # [ doc = "If dy is negative, makes SkRect taller." ] # [ doc = "" ] # [ doc = "@param dx  added to fLeft and subtracted from fRight" ] # [ doc = "@param dy  added to fTop and subtracted from fBottom" ] # [ link_name = "\u{1}__ZN6SkRect5insetEff" ] pub fn SkRect_inset ( this : * mut SkRect , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Outsets SkRect by (dx, dy)." ] # [ doc = "" ] # [ doc = "If dx is positive, makes SkRect wider." ] # [ doc = "If dx is negative, makes SkRect narrower." ] # [ doc = "If dy is positive, makes SkRect taller." ] # [ doc = "If dy is negative, makes SkRect shorter." ] # [ doc = "" ] # [ doc = "@param dx  subtracted to fLeft and added from fRight" ] # [ doc = "@param dy  subtracted to fTop and added from fBottom" ] # [ link_name = "\u{1}__ZN6SkRect6outsetEff" ] pub fn SkRect_outset ( this : * mut SkRect , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Returns true if SkRect intersects r, and sets SkRect to intersection." ] # [ doc = "Returns false if SkRect does not intersect r, and leaves SkRect unchanged." ] # [ doc = "" ] # [ doc = "Returns false if either r or SkRect is empty, leaving SkRect unchanged." ] # [ doc = "" ] # [ doc = "@param r  limit of result" ] # [ doc = "@return   true if r and SkRect have area in common" ] # [ link_name = "\u{1}__ZN6SkRect9intersectERKS_" ] pub fn SkRect_intersect ( this : * mut SkRect , r : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Constructs SkRect to intersect from (left, top, right, bottom). Does not sort" ] # [ doc = "construction." ] # [ doc = "" ] # [ doc = "Returns true if SkRect intersects construction, and sets SkRect to intersection." ] # [ doc = "Returns false if SkRect does not intersect construction, and leaves SkRect unchanged." ] # [ doc = "" ] # [ doc = "Returns false if either construction or SkRect is empty, leaving SkRect unchanged." ] # [ doc = "" ] # [ doc = "@param left    x-axis minimum of constructed SkRect" ] # [ doc = "@param top     y-axis minimum of constructed SkRect" ] # [ doc = "@param right   x-axis maximum of constructed SkRect" ] # [ doc = "@param bottom  y-axis maximum of constructed SkRect" ] # [ doc = "@return        true if construction and SkRect have area in common" ] # [ link_name = "\u{1}__ZN6SkRect9intersectEffff" ] pub fn SkRect_intersect1 ( this : * mut SkRect , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns true if a intersects b, and sets SkRect to intersection." ] # [ doc = "Returns false if a does not intersect b, and leaves SkRect unchanged." ] # [ doc = "" ] # [ doc = "Returns false if either a or b is empty, leaving SkRect unchanged." ] # [ doc = "" ] # [ doc = "@param a  SkRect to intersect" ] # [ doc = "@param b  SkRect to intersect" ] # [ doc = "@return   true if a and b have area in common" ] # [ link_name = "\u{1}__ZN6SkRect9intersectERKS_S1_" ] pub fn SkRect_intersect2 ( this : * mut SkRect , a : * const SkRect , b : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Constructs SkRect to intersect from (left, top, right, bottom). Does not sort" ] # [ doc = "construction." ] # [ doc = "" ] # [ doc = "Returns true if SkRect intersects construction." ] # [ doc = "Returns false if either construction or SkRect is empty, or do not intersect." ] # [ doc = "" ] # [ doc = "@param left    x-axis minimum of constructed SkRect" ] # [ doc = "@param top     y-axis minimum of constructed SkRect" ] # [ doc = "@param right   x-axis maximum of constructed SkRect" ] # [ doc = "@param bottom  y-axis maximum of constructed SkRect" ] # [ doc = "@return        true if construction and SkRect have area in common" ] # [ link_name = "\u{1}__ZNK6SkRect10intersectsEffff" ] pub fn SkRect_intersects ( this : * const SkRect , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRect intersects r." ] # [ doc = "Returns false if either r or SkRect is empty, or do not intersect." ] # [ doc = "" ] # [ doc = "@param r  SkRect to intersect" ] # [ doc = "@return   true if r and SkRect have area in common" ] # [ link_name = "\u{1}__ZNK6SkRect10intersectsERKS_" ] pub fn SkRect_intersects1 ( this : * const SkRect , r : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Returns true if a intersects b." ] # [ doc = "Returns false if either a or b is empty, or do not intersect." ] # [ doc = "" ] # [ doc = "@param a  SkRect to intersect" ] # [ doc = "@param b  SkRect to intersect" ] # [ doc = "@return   true if a and b have area in common" ] # [ link_name = "\u{1}__ZN6SkRect10IntersectsERKS_S1_" ] pub fn SkRect_Intersects ( a : * const SkRect , b : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Constructs SkRect to intersect from (left, top, right, bottom). Does not sort" ] # [ doc = "construction." ] # [ doc = "" ] # [ doc = "Sets SkRect to the union of itself and the construction." ] # [ doc = "" ] # [ doc = "Has no effect if construction is empty. Otherwise, if SkRect is empty, sets" ] # [ doc = "SkRect to construction." ] # [ doc = "" ] # [ doc = "@param left    x-axis minimum of constructed SkRect" ] # [ doc = "@param top     y-axis minimum of constructed SkRect" ] # [ doc = "@param right   x-axis maximum of constructed SkRect" ] # [ doc = "@param bottom  y-axis maximum of constructed SkRect" ] # [ link_name = "\u{1}__ZN6SkRect4joinEffff" ] pub fn SkRect_join ( this : * mut SkRect , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) ; } extern "C" { # [ doc = " Sets SkRect to the union of itself and r." ] # [ doc = "" ] # [ doc = "Has no effect if r is empty. Otherwise, if SkRect is empty, sets" ] # [ doc = "SkRect to r." ] # [ doc = "" ] # [ doc = "@param r  expansion SkRect" ] # [ link_name = "\u{1}__ZN6SkRect4joinERKS_" ] pub fn SkRect_join1 ( this : * mut SkRect , r : * const SkRect ) ; } extern "C" { # [ doc = " Sets SkRect to the union of itself and r." ] # [ doc = "" ] # [ doc = "Asserts if r is empty and SK_DEBUG is defined." ] # [ doc = "If SkRect is empty, sets SkRect to r." ] # [ doc = "" ] # [ doc = "May produce incorrect results if r is empty." ] # [ doc = "" ] # [ doc = "@param r  expansion SkRect" ] # [ link_name = "\u{1}__ZN6SkRect15joinNonEmptyArgERKS_" ] pub fn SkRect_joinNonEmptyArg ( this : * mut SkRect , r : * const SkRect ) ; } extern "C" { # [ doc = " Sets SkRect to the union of itself and the construction." ] # [ doc = "" ] # [ doc = "May produce incorrect results if SkRect or r is empty." ] # [ doc = "" ] # [ doc = "@param r  expansion SkRect" ] # [ link_name = "\u{1}__ZN6SkRect21joinPossiblyEmptyRectERKS_" ] pub fn SkRect_joinPossiblyEmptyRect ( this : * mut SkRect , r : * const SkRect ) ; } extern "C" { # [ doc = " Returns true if: fLeft <= x < fRight && fTop <= y < fBottom." ] # [ doc = "Returns false if SkRect is empty." ] # [ doc = "" ] # [ doc = "@param x  test SkPoint x-coordinate" ] # [ doc = "@param y  test SkPoint y-coordinate" ] # [ doc = "@return   true if (x, y) is inside SkRect" ] # [ link_name = "\u{1}__ZNK6SkRect8containsEff" ] pub fn SkRect_contains ( this : * const SkRect , x : SkScalar , y : SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRect contains r." ] # [ doc = "Returns false if SkRect is empty or r is empty." ] # [ doc = "" ] # [ doc = "SkRect contains r when SkRect area completely includes r area." ] # [ doc = "" ] # [ doc = "@param r  SkRect contained" ] # [ doc = "@return   true if all sides of SkRect are outside r" ] # [ link_name = "\u{1}__ZNK6SkRect8containsERKS_" ] pub fn SkRect_contains1 ( this : * const SkRect , r : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRect contains r." ] # [ doc = "Returns false if SkRect is empty or r is empty." ] # [ doc = "" ] # [ doc = "SkRect contains r when SkRect area completely includes r area." ] # [ doc = "" ] # [ doc = "@param r  SkIRect contained" ] # [ doc = "@return   true if all sides of SkRect are outside r" ] # [ link_name = "\u{1}__ZNK6SkRect8containsERK7SkIRect" ] pub fn SkRect_contains2 ( this : * const SkRect , r : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Sets SkIRect by adding 0.5 and discarding the fractional portion of SkRect" ] # [ doc = "members, using (SkScalarRoundToInt(fLeft), SkScalarRoundToInt(fTop)," ] # [ doc = "SkScalarRoundToInt(fRight), SkScalarRoundToInt(fBottom))." ] # [ doc = "" ] # [ doc = "@param dst  storage for SkIRect" ] # [ link_name = "\u{1}__ZNK6SkRect5roundEP7SkIRect" ] pub fn SkRect_round ( this : * const SkRect , dst : * mut SkIRect ) ; } extern "C" { # [ doc = " Sets SkIRect by discarding the fractional portion of fLeft and fTop; and rounding" ] # [ doc = "up fRight and fBottom, using" ] # [ doc = "(SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop)," ] # [ doc = "SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom))." ] # [ doc = "" ] # [ doc = "@param dst  storage for SkIRect" ] # [ link_name = "\u{1}__ZNK6SkRect8roundOutEP7SkIRect" ] pub fn SkRect_roundOut ( this : * const SkRect , dst : * mut SkIRect ) ; } extern "C" { # [ doc = " Sets SkRect by discarding the fractional portion of fLeft and fTop; and rounding" ] # [ doc = "up fRight and fBottom, using" ] # [ doc = "(SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop)," ] # [ doc = "SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom))." ] # [ doc = "" ] # [ doc = "@param dst  storage for SkRect" ] # [ link_name = "\u{1}__ZNK6SkRect8roundOutEPS_" ] pub fn SkRect_roundOut1 ( this : * const SkRect , dst : * mut SkRect ) ; } extern "C" { # [ doc = " Sets SkRect by rounding up fLeft and fTop; and discarding the fractional portion" ] # [ doc = "of fRight and fBottom, using" ] # [ doc = "(SkScalarCeilToInt(fLeft), SkScalarCeilToInt(fTop)," ] # [ doc = "SkScalarFloorToInt(fRight), SkScalarFloorToInt(fBottom))." ] # [ doc = "" ] # [ doc = "@param dst  storage for SkIRect" ] # [ link_name = "\u{1}__ZNK6SkRect7roundInEP7SkIRect" ] pub fn SkRect_roundIn ( this : * const SkRect , dst : * mut SkIRect ) ; } extern "C" { # [ doc = " Returns SkIRect by adding 0.5 and discarding the fractional portion of SkRect" ] # [ doc = "members, using (SkScalarRoundToInt(fLeft), SkScalarRoundToInt(fTop)," ] # [ doc = "SkScalarRoundToInt(fRight), SkScalarRoundToInt(fBottom))." ] # [ doc = "" ] # [ doc = "@return  rounded SkIRect" ] # [ link_name = "\u{1}__ZNK6SkRect5roundEv" ] pub fn SkRect_round1 ( this : * const SkRect ) -> SkIRect ; } extern "C" { # [ doc = " Sets SkIRect by discarding the fractional portion of fLeft and fTop; and rounding" ] # [ doc = "up fRight and fBottom, using" ] # [ doc = "(SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop)," ] # [ doc = "SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom))." ] # [ doc = "" ] # [ doc = "@return  rounded SkIRect" ] # [ link_name = "\u{1}__ZNK6SkRect8roundOutEv" ] pub fn SkRect_roundOut2 ( this : * const SkRect ) -> SkIRect ; } extern "C" { # [ doc = " Swaps fLeft and fRight if fLeft is greater than fRight; and swaps" ] # [ doc = "fTop and fBottom if fTop is greater than fBottom. Result may be empty;" ] # [ doc = "and width() and height() will be zero or positive." ] # [ link_name = "\u{1}__ZN6SkRect4sortEv" ] pub fn SkRect_sort ( this : * mut SkRect ) ; } extern "C" { # [ doc = " Returns SkRect with fLeft and fRight swapped if fLeft is greater than fRight; and" ] # [ doc = "with fTop and fBottom swapped if fTop is greater than fBottom. Result may be empty;" ] # [ doc = "and width() and height() will be zero or positive." ] # [ doc = "" ] # [ doc = "@return  sorted SkRect" ] # [ link_name = "\u{1}__ZNK6SkRect10makeSortedEv" ] pub fn SkRect_makeSorted ( this : * const SkRect ) -> SkRect ; } extern "C" { # [ doc = " Returns pointer to first scalar in SkRect, to treat it as an array with four" ] # [ doc = "entries." ] # [ doc = "" ] # [ doc = "@return  pointer to fLeft" ] # [ link_name = "\u{1}__ZNK6SkRect9asScalarsEv" ] pub fn SkRect_asScalars ( this : * const SkRect ) -> * const SkScalar ; } extern "C" { # [ doc = " Writes text representation of SkRect to standard output. Set asHex to true to" ] # [ doc = "generate exact binary representations of floating point numbers." ] # [ doc = "" ] # [ doc = "@param asHex  true if SkScalar values are written as hexadecimal" ] # [ link_name = "\u{1}__ZNK6SkRect4dumpEb" ] pub fn SkRect_dump ( this : * const SkRect , asHex : bool ) ; } extern "C" { # [ doc = " Writes text representation of SkRect to standard output. The representation may be" ] # [ doc = "directly compiled as C++ code. Floating point values are written" ] # [ doc = "with limited precision; it may not be possible to reconstruct original SkRect" ] # [ doc = "from output." ] # [ link_name = "\u{1}__ZNK6SkRect4dumpEv" ] pub fn SkRect_dump1 ( this : * const SkRect ) ; } extern "C" { # [ doc = " Writes text representation of SkRect to standard output. The representation may be" ] # [ doc = "directly compiled as C++ code. Floating point values are written" ] # [ doc = "in hexadecimal to preserve their exact bit pattern. The output reconstructs the" ] # [ doc = "original SkRect." ] # [ doc = "" ] # [ doc = "Use instead of dump() when submitting" ] # [ link_name = "\u{1}__ZNK6SkRect7dumpHexEv" ] pub fn SkRect_dumpHex ( this : * const SkRect ) ; } impl SkRect { # [ inline ] pub unsafe fn MakeEmpty ( ) -> SkRect { SkRect_MakeEmpty ( ) } # [ inline ] pub unsafe fn MakeWH ( w : SkScalar , h : SkScalar ) -> SkRect { SkRect_MakeWH ( w , h ) } # [ inline ] pub unsafe fn MakeIWH ( w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int ) -> SkRect { SkRect_MakeIWH ( w , h ) } # [ inline ] pub unsafe fn MakeSize ( size : * const SkSize ) -> SkRect { SkRect_MakeSize ( size ) } # [ inline ] pub unsafe fn MakeLTRB ( l : SkScalar , t : SkScalar , r : SkScalar , b : SkScalar ) -> SkRect { SkRect_MakeLTRB ( l , t , r , b ) } # [ inline ] pub unsafe fn MakeXYWH ( x : SkScalar , y : SkScalar , w : SkScalar , h : SkScalar ) -> SkRect { SkRect_MakeXYWH ( x , y , w , h ) } # [ inline ] pub unsafe fn Make ( size : * const SkISize ) -> SkRect { SkRect_Make ( size ) } # [ inline ] pub unsafe fn Make1 ( irect : * const SkIRect ) -> SkRect { SkRect_Make1 ( irect ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkRect_isEmpty ( self ) } # [ inline ] pub unsafe fn isSorted ( & self ) -> bool { SkRect_isSorted ( self ) } # [ inline ] pub unsafe fn isFinite ( & self ) -> bool { SkRect_isFinite ( self ) } # [ inline ] pub unsafe fn x ( & self ) -> SkScalar { SkRect_x ( self ) } # [ inline ] pub unsafe fn y ( & self ) -> SkScalar { SkRect_y ( self ) } # [ inline ] pub unsafe fn left ( & self ) -> SkScalar { SkRect_left ( self ) } # [ inline ] pub unsafe fn top ( & self ) -> SkScalar { SkRect_top ( self ) } # [ inline ] pub unsafe fn right ( & self ) -> SkScalar { SkRect_right ( self ) } # [ inline ] pub unsafe fn bottom ( & self ) -> SkScalar { SkRect_bottom ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> SkScalar { SkRect_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> SkScalar { SkRect_height ( self ) } # [ inline ] pub unsafe fn centerX ( & self ) -> SkScalar { SkRect_centerX ( self ) } # [ inline ] pub unsafe fn centerY ( & self ) -> SkScalar { SkRect_centerY ( self ) } # [ inline ] pub unsafe fn toQuad ( & self , quad : * mut SkPoint ) { SkRect_toQuad ( self , quad ) } # [ inline ] pub unsafe fn setEmpty ( & mut self ) { SkRect_setEmpty ( self ) } # [ inline ] pub unsafe fn set ( & mut self , src : * const SkIRect ) { SkRect_set ( self , src ) } # [ inline ] pub unsafe fn set1 ( & mut self , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) { SkRect_set1 ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn setLTRB ( & mut self , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) { SkRect_setLTRB ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn iset ( & mut self , left : :: std :: os :: raw :: c_int , top : :: std :: os :: raw :: c_int , right : :: std :: os :: raw :: c_int , bottom : :: std :: os :: raw :: c_int ) { SkRect_iset ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn isetWH ( & mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) { SkRect_isetWH ( self , width , height ) } # [ inline ] pub unsafe fn set2 ( & mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int ) { SkRect_set2 ( self , pts , count ) } # [ inline ] pub unsafe fn setBounds ( & mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int ) { SkRect_setBounds ( self , pts , count ) } # [ inline ] pub unsafe fn setBoundsCheck ( & mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int ) -> bool { SkRect_setBoundsCheck ( self , pts , count ) } # [ inline ] pub unsafe fn setBoundsNoCheck ( & mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int ) { SkRect_setBoundsNoCheck ( self , pts , count ) } # [ inline ] pub unsafe fn set3 ( & mut self , p0 : * const SkPoint , p1 : * const SkPoint ) { SkRect_set3 ( self , p0 , p1 ) } # [ inline ] pub unsafe fn setXYWH ( & mut self , x : SkScalar , y : SkScalar , width : SkScalar , height : SkScalar ) { SkRect_setXYWH ( self , x , y , width , height ) } # [ inline ] pub unsafe fn setWH ( & mut self , width : SkScalar , height : SkScalar ) { SkRect_setWH ( self , width , height ) } # [ inline ] pub unsafe fn makeOffset ( & self , dx : SkScalar , dy : SkScalar ) -> SkRect { SkRect_makeOffset ( self , dx , dy ) } # [ inline ] pub unsafe fn makeInset ( & self , dx : SkScalar , dy : SkScalar ) -> SkRect { SkRect_makeInset ( self , dx , dy ) } # [ inline ] pub unsafe fn makeOutset ( & self , dx : SkScalar , dy : SkScalar ) -> SkRect { SkRect_makeOutset ( self , dx , dy ) } # [ inline ] pub unsafe fn offset ( & mut self , dx : SkScalar , dy : SkScalar ) { SkRect_offset ( self , dx , dy ) } # [ inline ] pub unsafe fn offset1 ( & mut self , delta : * const SkPoint ) { SkRect_offset1 ( self , delta ) } # [ inline ] pub unsafe fn offsetTo ( & mut self , newX : SkScalar , newY : SkScalar ) { SkRect_offsetTo ( self , newX , newY ) } # [ inline ] pub unsafe fn inset ( & mut self , dx : SkScalar , dy : SkScalar ) { SkRect_inset ( self , dx , dy ) } # [ inline ] pub unsafe fn outset ( & mut self , dx : SkScalar , dy : SkScalar ) { SkRect_outset ( self , dx , dy ) } # [ inline ] pub unsafe fn intersect ( & mut self , r : * const SkRect ) -> bool { SkRect_intersect ( self , r ) } # [ inline ] pub unsafe fn intersect1 ( & mut self , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) -> bool { SkRect_intersect1 ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn intersect2 ( & mut self , a : * const SkRect , b : * const SkRect ) -> bool { SkRect_intersect2 ( self , a , b ) } # [ inline ] pub unsafe fn intersects ( & self , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) -> bool { SkRect_intersects ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn intersects1 ( & self , r : * const SkRect ) -> bool { SkRect_intersects1 ( self , r ) } # [ inline ] pub unsafe fn Intersects ( a : * const SkRect , b : * const SkRect ) -> bool { SkRect_Intersects ( a , b ) } # [ inline ] pub unsafe fn join ( & mut self , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar ) { SkRect_join ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn join1 ( & mut self , r : * const SkRect ) { SkRect_join1 ( self , r ) } # [ inline ] pub unsafe fn joinNonEmptyArg ( & mut self , r : * const SkRect ) { SkRect_joinNonEmptyArg ( self , r ) } # [ inline ] pub unsafe fn joinPossiblyEmptyRect ( & mut self , r : * const SkRect ) { SkRect_joinPossiblyEmptyRect ( self , r ) } # [ inline ] pub unsafe fn contains ( & self , x : SkScalar , y : SkScalar ) -> bool { SkRect_contains ( self , x , y ) } # [ inline ] pub unsafe fn contains1 ( & self , r : * const SkRect ) -> bool { SkRect_contains1 ( self , r ) } # [ inline ] pub unsafe fn contains2 ( & self , r : * const SkIRect ) -> bool { SkRect_contains2 ( self , r ) } # [ inline ] pub unsafe fn round ( & self , dst : * mut SkIRect ) { SkRect_round ( self , dst ) } # [ inline ] pub unsafe fn roundOut ( & self , dst : * mut SkIRect ) { SkRect_roundOut ( self , dst ) } # [ inline ] pub unsafe fn roundOut1 ( & self , dst : * mut SkRect ) { SkRect_roundOut1 ( self , dst ) } # [ inline ] pub unsafe fn roundIn ( & self , dst : * mut SkIRect ) { SkRect_roundIn ( self , dst ) } # [ inline ] pub unsafe fn round1 ( & self ) -> SkIRect { SkRect_round1 ( self ) } # [ inline ] pub unsafe fn roundOut2 ( & self ) -> SkIRect { SkRect_roundOut2 ( self ) } # [ inline ] pub unsafe fn sort ( & mut self ) { SkRect_sort ( self ) } # [ inline ] pub unsafe fn makeSorted ( & self ) -> SkRect { SkRect_makeSorted ( self ) } # [ inline ] pub unsafe fn asScalars ( & self ) -> * const SkScalar { SkRect_asScalars ( self ) } # [ inline ] pub unsafe fn dump ( & self , asHex : bool ) { SkRect_dump ( self , asHex ) } # [ inline ] pub unsafe fn dump1 ( & self ) { SkRect_dump1 ( self ) } # [ inline ] pub unsafe fn dumpHex ( & self ) { SkRect_dumpHex ( self ) } } # [ doc = " Allocate an array of T elements, and free the array in the destructor" ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkAutoTArray { pub fArray : std_unique_ptr , pub fCount : :: std :: os :: raw :: c_int , } # [ repr ( C ) ] pub struct SkAutoSTMalloc__bindgen_ty_1 < T > { pub fStorage32 : __BindgenUnionField < * mut u32 > , pub fTStorage : __BindgenUnionField < [ T ; 1usize ] > , pub bindgen_union_field : u64 , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [ repr ( C ) ] pub union SkTArray__bindgen_ty_1 < T > { pub fItemArray : * mut T , pub fMemArray : * mut :: std :: os :: raw :: c_void , _bindgen_union_align : u64 , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [ doc = " \\class SkString" ] # [ doc = "" ] # [ doc = "Light weight class for managing strings. Uses reference" ] # [ doc = "counting to make string assignments and copies very fast" ] # [ doc = "with no extra RAM cost. Assumes UTF8 encoding." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkString { pub fRec : sk_sp < SkString_Rec > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkString_Rec { pub fLength : u32 , pub fRefCnt : std_atomic , pub fBeginningOfData : :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_SkString_Rec ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkString_Rec > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( SkString_Rec ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkString_Rec > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkString_Rec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkString_Rec > ( ) ) ) . fLength as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkString_Rec ) , "::" , stringify ! ( fLength ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkString_Rec > ( ) ) ) . fRefCnt as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkString_Rec ) , "::" , stringify ! ( fRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkString_Rec > ( ) ) ) . fBeginningOfData as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkString_Rec ) , "::" , stringify ! ( fBeginningOfData ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString3Rec4MakeEPKcm" ] pub fn SkString_Rec_Make ( text : * const :: std :: os :: raw :: c_char , len : usize ) -> sk_sp < SkString_Rec > ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString3Rec4dataEv" ] pub fn SkString_Rec_data ( this : * mut SkString_Rec ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString3Rec4dataEv" ] pub fn SkString_Rec_data1 ( this : * const SkString_Rec ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString3Rec3refEv" ] pub fn SkString_Rec_ref ( this : * const SkString_Rec ) ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString3Rec5unrefEv" ] pub fn SkString_Rec_unref ( this : * const SkString_Rec ) ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString3Rec6uniqueEv" ] pub fn SkString_Rec_unique ( this : * const SkString_Rec ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString3RecC1Eji" ] pub fn SkString_Rec_Rec ( this : * mut SkString_Rec , len : u32 , refCnt : i32 ) ; } impl SkString_Rec { # [ inline ] pub unsafe fn Make ( text : * const :: std :: os :: raw :: c_char , len : usize ) -> sk_sp < SkString_Rec > { SkString_Rec_Make ( text , len ) } # [ inline ] pub unsafe fn data ( & mut self ) -> * mut :: std :: os :: raw :: c_char { SkString_Rec_data ( self ) } # [ inline ] pub unsafe fn data1 ( & self ) -> * const :: std :: os :: raw :: c_char { SkString_Rec_data1 ( self ) } # [ inline ] pub unsafe fn ref_ ( & self ) { SkString_Rec_ref ( self ) } # [ inline ] pub unsafe fn unref ( & self ) { SkString_Rec_unref ( self ) } # [ inline ] pub unsafe fn unique ( & self ) -> bool { SkString_Rec_unique ( self ) } # [ inline ] pub unsafe fn new ( len : u32 , refCnt : i32 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkString_Rec_Rec ( & mut __bindgen_tmp , len , refCnt ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN8SkString9gEmptyRecE" ] pub static SkString_gEmptyRec : SkString_Rec ; } # [ test ] fn bindgen_test_layout_SkString ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkString > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkString ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkString > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkString ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkString > ( ) ) ) . fRec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkString ) , "::" , stringify ! ( fRec ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString7isEmptyEv" ] pub fn SkString_isEmpty ( this : * const SkString ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString4sizeEv" ] pub fn SkString_size ( this : * const SkString ) -> usize ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString5c_strEv" ] pub fn SkString_c_str ( this : * const SkString ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString6equalsERKS_" ] pub fn SkString_equals ( this : * const SkString , arg1 : * const SkString ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString6equalsEPKc" ] pub fn SkString_equals1 ( this : * const SkString , text : * const :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString6equalsEPKcm" ] pub fn SkString_equals2 ( this : * const SkString , text : * const :: std :: os :: raw :: c_char , len : usize ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString10startsWithEPKc" ] pub fn SkString_startsWith ( this : * const SkString , prefixStr : * const :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString10startsWithEc" ] pub fn SkString_startsWith1 ( this : * const SkString , prefixChar : :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString8endsWithEPKc" ] pub fn SkString_endsWith ( this : * const SkString , suffixStr : * const :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString8endsWithEc" ] pub fn SkString_endsWith1 ( this : * const SkString , suffixChar : :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString8containsEPKc" ] pub fn SkString_contains ( this : * const SkString , substring : * const :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString8containsEc" ] pub fn SkString_contains1 ( this : * const SkString , subchar : :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString4findEPKc" ] pub fn SkString_find ( this : * const SkString , substring : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkString10findLastOfEc" ] pub fn SkString_findLastOf ( this : * const SkString , subchar : :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString12writable_strEv" ] pub fn SkString_writable_str ( this : * mut SkString ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString5resetEv" ] pub fn SkString_reset ( this : * mut SkString ) ; } extern "C" { # [ doc = " Destructive resize, does not preserve contents." ] # [ link_name = "\u{1}__ZN8SkString6resizeEm" ] pub fn SkString_resize ( this : * mut SkString , len : usize ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString3setERKS_" ] pub fn SkString_set ( this : * mut SkString , src : * const SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString3setEPKc" ] pub fn SkString_set1 ( this : * mut SkString , text : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString3setEPKcm" ] pub fn SkString_set2 ( this : * mut SkString , text : * const :: std :: os :: raw :: c_char , len : usize ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString6insertEmRKS_" ] pub fn SkString_insert ( this : * mut SkString , offset : usize , src : * const SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString6insertEmPKc" ] pub fn SkString_insert1 ( this : * mut SkString , offset : usize , text : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString6insertEmPKcm" ] pub fn SkString_insert2 ( this : * mut SkString , offset : usize , text : * const :: std :: os :: raw :: c_char , len : usize ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString13insertUnicharEmi" ] pub fn SkString_insertUnichar ( this : * mut SkString , offset : usize , arg1 : SkUnichar ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9insertS32Emi" ] pub fn SkString_insertS32 ( this : * mut SkString , offset : usize , value : i32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9insertS64Emxi" ] pub fn SkString_insertS64 ( this : * mut SkString , offset : usize , value : i64 , minDigits : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9insertU32Emj" ] pub fn SkString_insertU32 ( this : * mut SkString , offset : usize , value : u32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9insertU64Emyi" ] pub fn SkString_insertU64 ( this : * mut SkString , offset : usize , value : u64 , minDigits : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9insertHexEmji" ] pub fn SkString_insertHex ( this : * mut SkString , offset : usize , value : u32 , minDigits : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString12insertScalarEmf" ] pub fn SkString_insertScalar ( this : * mut SkString , offset : usize , arg1 : SkScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString6appendERKS_" ] pub fn SkString_append ( this : * mut SkString , str : * const SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString6appendEPKc" ] pub fn SkString_append1 ( this : * mut SkString , text : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString6appendEPKcm" ] pub fn SkString_append2 ( this : * mut SkString , text : * const :: std :: os :: raw :: c_char , len : usize ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString13appendUnicharEi" ] pub fn SkString_appendUnichar ( this : * mut SkString , uni : SkUnichar ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9appendS32Ei" ] pub fn SkString_appendS32 ( this : * mut SkString , value : i32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9appendS64Exi" ] pub fn SkString_appendS64 ( this : * mut SkString , value : i64 , minDigits : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9appendU32Ej" ] pub fn SkString_appendU32 ( this : * mut SkString , value : u32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9appendU64Eyi" ] pub fn SkString_appendU64 ( this : * mut SkString , value : u64 , minDigits : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString9appendHexEji" ] pub fn SkString_appendHex ( this : * mut SkString , value : u32 , minDigits : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString12appendScalarEf" ] pub fn SkString_appendScalar ( this : * mut SkString , value : SkScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString7prependERKS_" ] pub fn SkString_prepend ( this : * mut SkString , str : * const SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString7prependEPKc" ] pub fn SkString_prepend1 ( this : * mut SkString , text : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString7prependEPKcm" ] pub fn SkString_prepend2 ( this : * mut SkString , text : * const :: std :: os :: raw :: c_char , len : usize ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString14prependUnicharEi" ] pub fn SkString_prependUnichar ( this : * mut SkString , uni : SkUnichar ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString10prependS32Ei" ] pub fn SkString_prependS32 ( this : * mut SkString , value : i32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString10prependS64Eii" ] pub fn SkString_prependS64 ( this : * mut SkString , value : i32 , minDigits : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString10prependHexEji" ] pub fn SkString_prependHex ( this : * mut SkString , value : u32 , minDigits : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString13prependScalarEf" ] pub fn SkString_prependScalar ( this : * mut SkString , value : SkScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString6printfEPKcz" ] pub fn SkString_printf ( this : * mut SkString , format : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString7appendfEPKcz" ] pub fn SkString_appendf ( this : * mut SkString , format : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString12appendVAListEPKcP13__va_list_tag" ] pub fn SkString_appendVAList ( this : * mut SkString , format : * const :: std :: os :: raw :: c_char , arg1 : * mut __va_list_tag ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString8prependfEPKcz" ] pub fn SkString_prependf ( this : * mut SkString , format : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString13prependVAListEPKcP13__va_list_tag" ] pub fn SkString_prependVAList ( this : * mut SkString , format : * const :: std :: os :: raw :: c_char , arg1 : * mut __va_list_tag ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkString6removeEmm" ] pub fn SkString_remove ( this : * mut SkString , offset : usize , length : usize ) ; } extern "C" { # [ doc = "  Swap contents between this and other. This function is guaranteed" ] # [ doc = "  to never fail or throw." ] # [ link_name = "\u{1}__ZN8SkString4swapERS_" ] pub fn SkString_swap ( this : * mut SkString , other : * mut SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStringC1Ev" ] pub fn SkString_SkString ( this : * mut SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStringC1Em" ] pub fn SkString_SkString1 ( this : * mut SkString , len : usize ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStringC1EPKc" ] pub fn SkString_SkString2 ( this : * mut SkString , text : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStringC1EPKcm" ] pub fn SkString_SkString3 ( this : * mut SkString , text : * const :: std :: os :: raw :: c_char , len : usize ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStringC1ERKS_" ] pub fn SkString_SkString4 ( this : * mut SkString , arg1 : * const SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStringC1EOS_" ] pub fn SkString_SkString5 ( this : * mut SkString , arg1 : * mut SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStringD1Ev" ] pub fn SkString_SkString_destructor ( this : * mut SkString ) ; } impl SkString { # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkString_isEmpty ( self ) } # [ inline ] pub unsafe fn size ( & self ) -> usize { SkString_size ( self ) } # [ inline ] pub unsafe fn c_str ( & self ) -> * const :: std :: os :: raw :: c_char { SkString_c_str ( self ) } # [ inline ] pub unsafe fn equals ( & self , arg1 : * const SkString ) -> bool { SkString_equals ( self , arg1 ) } # [ inline ] pub unsafe fn equals1 ( & self , text : * const :: std :: os :: raw :: c_char ) -> bool { SkString_equals1 ( self , text ) } # [ inline ] pub unsafe fn equals2 ( & self , text : * const :: std :: os :: raw :: c_char , len : usize ) -> bool { SkString_equals2 ( self , text , len ) } # [ inline ] pub unsafe fn startsWith ( & self , prefixStr : * const :: std :: os :: raw :: c_char ) -> bool { SkString_startsWith ( self , prefixStr ) } # [ inline ] pub unsafe fn startsWith1 ( & self , prefixChar : :: std :: os :: raw :: c_char ) -> bool { SkString_startsWith1 ( self , prefixChar ) } # [ inline ] pub unsafe fn endsWith ( & self , suffixStr : * const :: std :: os :: raw :: c_char ) -> bool { SkString_endsWith ( self , suffixStr ) } # [ inline ] pub unsafe fn endsWith1 ( & self , suffixChar : :: std :: os :: raw :: c_char ) -> bool { SkString_endsWith1 ( self , suffixChar ) } # [ inline ] pub unsafe fn contains ( & self , substring : * const :: std :: os :: raw :: c_char ) -> bool { SkString_contains ( self , substring ) } # [ inline ] pub unsafe fn contains1 ( & self , subchar : :: std :: os :: raw :: c_char ) -> bool { SkString_contains1 ( self , subchar ) } # [ inline ] pub unsafe fn find ( & self , substring : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int { SkString_find ( self , substring ) } # [ inline ] pub unsafe fn findLastOf ( & self , subchar : :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int { SkString_findLastOf ( self , subchar ) } # [ inline ] pub unsafe fn writable_str ( & mut self ) -> * mut :: std :: os :: raw :: c_char { SkString_writable_str ( self ) } # [ inline ] pub unsafe fn reset ( & mut self ) { SkString_reset ( self ) } # [ inline ] pub unsafe fn resize ( & mut self , len : usize ) { SkString_resize ( self , len ) } # [ inline ] pub unsafe fn set ( & mut self , src : * const SkString ) { SkString_set ( self , src ) } # [ inline ] pub unsafe fn set1 ( & mut self , text : * const :: std :: os :: raw :: c_char ) { SkString_set1 ( self , text ) } # [ inline ] pub unsafe fn set2 ( & mut self , text : * const :: std :: os :: raw :: c_char , len : usize ) { SkString_set2 ( self , text , len ) } # [ inline ] pub unsafe fn insert ( & mut self , offset : usize , src : * const SkString ) { SkString_insert ( self , offset , src ) } # [ inline ] pub unsafe fn insert1 ( & mut self , offset : usize , text : * const :: std :: os :: raw :: c_char ) { SkString_insert1 ( self , offset , text ) } # [ inline ] pub unsafe fn insert2 ( & mut self , offset : usize , text : * const :: std :: os :: raw :: c_char , len : usize ) { SkString_insert2 ( self , offset , text , len ) } # [ inline ] pub unsafe fn insertUnichar ( & mut self , offset : usize , arg1 : SkUnichar ) { SkString_insertUnichar ( self , offset , arg1 ) } # [ inline ] pub unsafe fn insertS32 ( & mut self , offset : usize , value : i32 ) { SkString_insertS32 ( self , offset , value ) } # [ inline ] pub unsafe fn insertS64 ( & mut self , offset : usize , value : i64 , minDigits : :: std :: os :: raw :: c_int ) { SkString_insertS64 ( self , offset , value , minDigits ) } # [ inline ] pub unsafe fn insertU32 ( & mut self , offset : usize , value : u32 ) { SkString_insertU32 ( self , offset , value ) } # [ inline ] pub unsafe fn insertU64 ( & mut self , offset : usize , value : u64 , minDigits : :: std :: os :: raw :: c_int ) { SkString_insertU64 ( self , offset , value , minDigits ) } # [ inline ] pub unsafe fn insertHex ( & mut self , offset : usize , value : u32 , minDigits : :: std :: os :: raw :: c_int ) { SkString_insertHex ( self , offset , value , minDigits ) } # [ inline ] pub unsafe fn insertScalar ( & mut self , offset : usize , arg1 : SkScalar ) { SkString_insertScalar ( self , offset , arg1 ) } # [ inline ] pub unsafe fn append ( & mut self , str : * const SkString ) { SkString_append ( self , str ) } # [ inline ] pub unsafe fn append1 ( & mut self , text : * const :: std :: os :: raw :: c_char ) { SkString_append1 ( self , text ) } # [ inline ] pub unsafe fn append2 ( & mut self , text : * const :: std :: os :: raw :: c_char , len : usize ) { SkString_append2 ( self , text , len ) } # [ inline ] pub unsafe fn appendUnichar ( & mut self , uni : SkUnichar ) { SkString_appendUnichar ( self , uni ) } # [ inline ] pub unsafe fn appendS32 ( & mut self , value : i32 ) { SkString_appendS32 ( self , value ) } # [ inline ] pub unsafe fn appendS64 ( & mut self , value : i64 , minDigits : :: std :: os :: raw :: c_int ) { SkString_appendS64 ( self , value , minDigits ) } # [ inline ] pub unsafe fn appendU32 ( & mut self , value : u32 ) { SkString_appendU32 ( self , value ) } # [ inline ] pub unsafe fn appendU64 ( & mut self , value : u64 , minDigits : :: std :: os :: raw :: c_int ) { SkString_appendU64 ( self , value , minDigits ) } # [ inline ] pub unsafe fn appendHex ( & mut self , value : u32 , minDigits : :: std :: os :: raw :: c_int ) { SkString_appendHex ( self , value , minDigits ) } # [ inline ] pub unsafe fn appendScalar ( & mut self , value : SkScalar ) { SkString_appendScalar ( self , value ) } # [ inline ] pub unsafe fn prepend ( & mut self , str : * const SkString ) { SkString_prepend ( self , str ) } # [ inline ] pub unsafe fn prepend1 ( & mut self , text : * const :: std :: os :: raw :: c_char ) { SkString_prepend1 ( self , text ) } # [ inline ] pub unsafe fn prepend2 ( & mut self , text : * const :: std :: os :: raw :: c_char , len : usize ) { SkString_prepend2 ( self , text , len ) } # [ inline ] pub unsafe fn prependUnichar ( & mut self , uni : SkUnichar ) { SkString_prependUnichar ( self , uni ) } # [ inline ] pub unsafe fn prependS32 ( & mut self , value : i32 ) { SkString_prependS32 ( self , value ) } # [ inline ] pub unsafe fn prependS64 ( & mut self , value : i32 , minDigits : :: std :: os :: raw :: c_int ) { SkString_prependS64 ( self , value , minDigits ) } # [ inline ] pub unsafe fn prependHex ( & mut self , value : u32 , minDigits : :: std :: os :: raw :: c_int ) { SkString_prependHex ( self , value , minDigits ) } # [ inline ] pub unsafe fn prependScalar ( & mut self , value : SkScalar ) { SkString_prependScalar ( self , value ) } # [ inline ] pub unsafe fn appendVAList ( & mut self , format : * const :: std :: os :: raw :: c_char , arg1 : * mut __va_list_tag ) { SkString_appendVAList ( self , format , arg1 ) } # [ inline ] pub unsafe fn prependVAList ( & mut self , format : * const :: std :: os :: raw :: c_char , arg1 : * mut __va_list_tag ) { SkString_prependVAList ( self , format , arg1 ) } # [ inline ] pub unsafe fn remove ( & mut self , offset : usize , length : usize ) { SkString_remove ( self , offset , length ) } # [ inline ] pub unsafe fn swap ( & mut self , other : * mut SkString ) { SkString_swap ( self , other ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkString_SkString ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( len : usize ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkString_SkString1 ( & mut __bindgen_tmp , len ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( text : * const :: std :: os :: raw :: c_char ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkString_SkString2 ( & mut __bindgen_tmp , text ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( text : * const :: std :: os :: raw :: c_char , len : usize ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkString_SkString3 ( & mut __bindgen_tmp , text , len ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new4 ( arg1 : * const SkString ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkString_SkString4 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new5 ( arg1 : * mut SkString ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkString_SkString5 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkString_SkString_destructor ( self ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDescriptor { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontData { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontDescriptor { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkScalerContext { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkAdvancedTypefaceMetrics { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkScalerContextEffects { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkScalerContextRec { _unused : [ u8 ; 0 ] , } pub type SkFontID = u32 ; # [ doc = " Machine endian." ] pub type SkFontTableTag = u32 ; # [ doc = " \\class SkTypeface" ] # [ doc = "" ] # [ doc = "The SkTypeface class specifies the typeface and intrinsic style of a font." ] # [ doc = "This is used in the paint, along with optionally algorithmic settings like" ] # [ doc = "textSize, textSkewX, textScaleX, kFakeBoldText_Mask, to specify" ] # [ doc = "how text appears when drawn (and measured)." ] # [ doc = "" ] # [ doc = "Typeface objects are immutable, and so they can be shared between threads." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkTypeface { pub _base : SkWeakRefCnt , pub fUniqueID : SkFontID , pub fStyle : SkFontStyle , pub fBounds : SkRect , pub fBoundsOnce : SkOnce , pub fIsFixedPitch : bool , } # [ repr ( i32 ) ] # [ doc = "  A typeface can serialize just a descriptor (names, etc.), or it can also include the" ] # [ doc = "  actual font data (which can be large). This enum controls how serialize() decides what" ] # [ doc = "  to serialize." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkTypeface_SerializeBehavior { kDoIncludeData = 0 , kDontIncludeData = 1 , kIncludeDataIfLocal = 2 , } # [ repr ( u8 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkTypeface_Encoding { kUTF8_Encoding = 0 , kUTF16_Encoding = 1 , kUTF32_Encoding = 2 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkTypeface_LocalizedString { pub fString : SkString , pub fLanguage : SkString , } # [ test ] fn bindgen_test_layout_SkTypeface_LocalizedString ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkTypeface_LocalizedString > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkTypeface_LocalizedString ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkTypeface_LocalizedString > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkTypeface_LocalizedString ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkTypeface_LocalizedString > ( ) ) ) . fString as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkTypeface_LocalizedString ) , "::" , stringify ! ( fString ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkTypeface_LocalizedString > ( ) ) ) . fLanguage as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkTypeface_LocalizedString ) , "::" , stringify ! ( fLanguage ) ) ) ; } # [ repr ( C ) ] pub struct SkTypeface_LocalizedStrings__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkTypeface_LocalizedStrings { pub vtable_ : * const SkTypeface_LocalizedStrings__bindgen_vtable , } # [ test ] fn bindgen_test_layout_SkTypeface_LocalizedStrings ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkTypeface_LocalizedStrings > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkTypeface_LocalizedStrings ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkTypeface_LocalizedStrings > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkTypeface_LocalizedStrings ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkTypeface16LocalizedStrings5unrefEv" ] pub fn SkTypeface_LocalizedStrings_unref ( this : * mut SkTypeface_LocalizedStrings ) ; } impl SkTypeface_LocalizedStrings { # [ inline ] pub unsafe fn unref ( & mut self ) { SkTypeface_LocalizedStrings_unref ( self ) } } pub const SkTypeface_Style_kNormal : SkTypeface_Style = 0 ; pub const SkTypeface_Style_kBold : SkTypeface_Style = 1 ; pub const SkTypeface_Style_kItalic : SkTypeface_Style = 2 ; pub const SkTypeface_Style_kBoldItalic : SkTypeface_Style = 3 ; # [ doc = " Style specifies the intrinsic style attributes of a given typeface" ] pub type SkTypeface_Style = u32 ; pub type SkTypeface_INHERITED = SkWeakRefCnt ; # [ test ] fn bindgen_test_layout_SkTypeface ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkTypeface > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SkTypeface ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkTypeface > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkTypeface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkTypeface > ( ) ) ) . fUniqueID as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkTypeface ) , "::" , stringify ! ( fUniqueID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkTypeface > ( ) ) ) . fStyle as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SkTypeface ) , "::" , stringify ! ( fStyle ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkTypeface > ( ) ) ) . fBounds as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkTypeface ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkTypeface > ( ) ) ) . fBoundsOnce as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkTypeface ) , "::" , stringify ! ( fBoundsOnce ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkTypeface > ( ) ) ) . fIsFixedPitch as * const _ as usize } , 41usize , concat ! ( "Offset of field: " , stringify ! ( SkTypeface ) , "::" , stringify ! ( fIsFixedPitch ) ) ) ; } extern "C" { # [ doc = " Returns the typeface\'s intrinsic style attributes." ] # [ link_name = "\u{1}__ZNK10SkTypeface9fontStyleEv" ] pub fn SkTypeface_fontStyle ( this : * const SkTypeface ) -> SkFontStyle ; } extern "C" { # [ doc = " Returns true if style() has the kBold bit set." ] # [ link_name = "\u{1}__ZNK10SkTypeface6isBoldEv" ] pub fn SkTypeface_isBold ( this : * const SkTypeface ) -> bool ; } extern "C" { # [ doc = " Returns true if style() has the kItalic bit set." ] # [ link_name = "\u{1}__ZNK10SkTypeface8isItalicEv" ] pub fn SkTypeface_isItalic ( this : * const SkTypeface ) -> bool ; } extern "C" { # [ doc = " Returns true if the typeface claims to be fixed-pitch." ] # [ doc = "  This is a style bit, advance widths may vary even if this returns true." ] # [ link_name = "\u{1}__ZNK10SkTypeface12isFixedPitchEv" ] pub fn SkTypeface_isFixedPitch ( this : * const SkTypeface ) -> bool ; } extern "C" { # [ doc = " Copy into \'coordinates\' (allocated by the caller) the design variation coordinates." ] # [ doc = "" ] # [ doc = "  @param coordinates the buffer into which to write the design variation coordinates." ] # [ doc = "  @param coordinateCount the number of entries available through \'coordinates\'." ] # [ doc = "" ] # [ doc = "  @return The number of axes, or -1 if there is an error." ] # [ doc = "  If \'coordinates != nullptr\' and \'coordinateCount >= numAxes\' then \'coordinates\' will be" ] # [ doc = "  filled with the variation coordinates describing the position of this typeface in design" ] # [ doc = "  variation space. It is possible the number of axes can be retrieved but actual position" ] # [ doc = "  cannot." ] # [ link_name = "\u{1}__ZNK10SkTypeface26getVariationDesignPositionEPN15SkFontArguments17VariationPosition10CoordinateEi" ] pub fn SkTypeface_getVariationDesignPosition ( this : * const SkTypeface , coordinates : * mut SkFontArguments_VariationPosition_Coordinate , coordinateCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Copy into \'parameters\' (allocated by the caller) the design variation parameters." ] # [ doc = "" ] # [ doc = "  @param parameters the buffer into which to write the design variation parameters." ] # [ doc = "  @param coordinateCount the number of entries available through \'parameters\'." ] # [ doc = "" ] # [ doc = "  @return The number of axes, or -1 if there is an error." ] # [ doc = "  If \'parameters != nullptr\' and \'parameterCount >= numAxes\' then \'parameters\' will be" ] # [ doc = "  filled with the variation parameters describing the position of this typeface in design" ] # [ doc = "  variation space. It is possible the number of axes can be retrieved but actual parameters" ] # [ doc = "  cannot." ] # [ link_name = "\u{1}__ZNK10SkTypeface28getVariationDesignParametersEPN16SkFontParameters9Variation4AxisEi" ] pub fn SkTypeface_getVariationDesignParameters ( this : * const SkTypeface , parameters : * mut SkFontParameters_Variation_Axis , parameterCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Return a 32bit value for this typeface, unique for the underlying font" ] # [ doc = "data. Will never return 0." ] # [ link_name = "\u{1}__ZNK10SkTypeface8uniqueIDEv" ] pub fn SkTypeface_uniqueID ( this : * const SkTypeface ) -> SkFontID ; } extern "C" { # [ doc = " Return the uniqueID for the specified typeface. If the face is null," ] # [ doc = "resolve it to the default font and return its uniqueID. Will never" ] # [ doc = "return 0." ] # [ link_name = "\u{1}__ZN10SkTypeface8UniqueIDEPKS_" ] pub fn SkTypeface_UniqueID ( face : * const SkTypeface ) -> SkFontID ; } extern "C" { # [ doc = " Returns true if the two typefaces reference the same underlying font," ] # [ doc = "handling either being null (treating null as the default font)" ] # [ link_name = "\u{1}__ZN10SkTypeface5EqualEPKS_S1_" ] pub fn SkTypeface_Equal ( facea : * const SkTypeface , faceb : * const SkTypeface ) -> bool ; } extern "C" { # [ doc = " Returns the default normal typeface, which is never nullptr." ] # [ link_name = "\u{1}__ZN10SkTypeface11MakeDefaultEv" ] pub fn SkTypeface_MakeDefault ( ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Creates a new reference to the typeface that most closely matches the" ] # [ doc = "requested familyName and fontStyle. This method allows extended font" ] # [ doc = "face specifiers as in the SkFontStyle type. Will never return null." ] # [ doc = "" ] # [ doc = "@param familyName  May be NULL. The name of the font family." ] # [ doc = "@param fontStyle   The style of the typeface." ] # [ doc = "@return reference to the closest-matching typeface. Call must call" ] # [ doc = "unref() when they are done." ] # [ link_name = "\u{1}__ZN10SkTypeface12MakeFromNameEPKc11SkFontStyle" ] pub fn SkTypeface_MakeFromName ( familyName : * const :: std :: os :: raw :: c_char , fontStyle : SkFontStyle ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Return a new typeface given a file. If the file does not exist, or is" ] # [ doc = "not a valid font file, returns nullptr." ] # [ link_name = "\u{1}__ZN10SkTypeface12MakeFromFileEPKci" ] pub fn SkTypeface_MakeFromFile ( path : * const :: std :: os :: raw :: c_char , index : :: std :: os :: raw :: c_int ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Return a new typeface given a stream. If the stream is" ] # [ doc = "not a valid font file, returns nullptr. Ownership of the stream is" ] # [ doc = "transferred, so the caller must not reference it again." ] # [ link_name = "\u{1}__ZN10SkTypeface14MakeFromStreamENSt3__110unique_ptrI13SkStreamAssetNS0_14default_deleteIS2_EEEEi" ] pub fn SkTypeface_MakeFromStream ( stream : std_unique_ptr , index : :: std :: os :: raw :: c_int ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Return a new typeface given a SkData. If the data is null, or is not a valid font file," ] # [ doc = "  returns nullptr." ] # [ link_name = "\u{1}__ZN10SkTypeface12MakeFromDataE5sk_spI6SkDataEi" ] pub fn SkTypeface_MakeFromData ( arg1 : sk_sp < SkData > , index : :: std :: os :: raw :: c_int ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Return a new typeface given font data and configuration. If the data" ] # [ doc = "is not valid font data, returns nullptr." ] # [ link_name = "\u{1}__ZN10SkTypeface16MakeFromFontDataENSt3__110unique_ptrI10SkFontDataNS0_14default_deleteIS2_EEEE" ] pub fn SkTypeface_MakeFromFontData ( arg1 : std_unique_ptr ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Return a new typeface based on this typeface but parameterized as specified in the" ] # [ doc = "SkFontArguments. If the SkFontArguments does not supply an argument for a parameter" ] # [ doc = "in the font then the value from this typeface will be used as the value for that" ] # [ doc = "argument. If the cloned typeface would be exaclty the same as this typeface then" ] # [ doc = "this typeface may be ref\'ed and returned. May return nullptr on failure." ] # [ link_name = "\u{1}__ZNK10SkTypeface9makeCloneERK15SkFontArguments" ] pub fn SkTypeface_makeClone ( this : * const SkTypeface , arg1 : * const SkFontArguments ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Write a unique signature to a stream, sufficient to reconstruct a" ] # [ doc = "typeface referencing the same font when Deserialize is called." ] # [ link_name = "\u{1}__ZNK10SkTypeface9serializeEP9SkWStreamNS_17SerializeBehaviorE" ] pub fn SkTypeface_serialize ( this : * const SkTypeface , arg1 : * mut SkWStream , arg2 : SkTypeface_SerializeBehavior ) ; } extern "C" { # [ doc = "  Same as serialize(SkWStream*, ...) but returns the serialized data in SkData, instead of" ] # [ doc = "  writing it to a stream." ] # [ link_name = "\u{1}__ZNK10SkTypeface9serializeENS_17SerializeBehaviorE" ] pub fn SkTypeface_serialize1 ( this : * const SkTypeface , arg1 : SkTypeface_SerializeBehavior ) -> sk_sp < SkData > ; } extern "C" { # [ doc = " Given the data previously written by serialize(), return a new instance" ] # [ doc = "of a typeface referring to the same font. If that font is not available," ] # [ doc = "return nullptr." ] # [ doc = "Does not affect ownership of SkStream." ] # [ link_name = "\u{1}__ZN10SkTypeface15MakeDeserializeEP8SkStream" ] pub fn SkTypeface_MakeDeserialize ( arg1 : * mut SkStream ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = "  Given an array of character codes, of the specified encoding," ] # [ doc = "  optionally return their corresponding glyph IDs (if glyphs is not NULL)." ] # [ doc = "" ] # [ doc = "  @param chars pointer to the array of character codes" ] # [ doc = "  @param encoding how the characters are encoded" ] # [ doc = "  @param glyphs (optional) returns the corresponding glyph IDs for each" ] # [ doc = "          character code, up to glyphCount values. If a character code is" ] # [ doc = "          not found in the typeface, the corresponding glyph ID will be 0." ] # [ doc = "  @param glyphCount number of code points in \'chars\' to process. If glyphs" ] # [ doc = "          is not NULL, then it must point sufficient memory to write" ] # [ doc = "          glyphCount values into it." ] # [ doc = "  @return the number of number of continuous non-zero glyph IDs computed" ] # [ doc = "          from the beginning of chars. This value is valid, even if the" ] # [ doc = "          glyphs parameter is NULL." ] # [ link_name = "\u{1}__ZNK10SkTypeface13charsToGlyphsEPKvNS_8EncodingEPti" ] pub fn SkTypeface_charsToGlyphs ( this : * const SkTypeface , chars : * const :: std :: os :: raw :: c_void , encoding : SkTypeface_Encoding , glyphs : * mut SkGlyphID , glyphCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = "  Return the glyphID that corresponds to the specified unicode code-point" ] # [ doc = "  (in UTF32 encoding). If the unichar is not supported, returns 0." ] # [ doc = "" ] # [ doc = "  This is a short-cut for calling charsToGlyphs() with kUTF32_Encoding for one code-point." ] # [ link_name = "\u{1}__ZNK10SkTypeface14unicharToGlyphEi" ] pub fn SkTypeface_unicharToGlyph ( this : * const SkTypeface , unichar : SkUnichar ) -> SkGlyphID ; } extern "C" { # [ doc = "  Return the number of glyphs in the typeface." ] # [ link_name = "\u{1}__ZNK10SkTypeface11countGlyphsEv" ] pub fn SkTypeface_countGlyphs ( this : * const SkTypeface ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Return the number of tables in the font." ] # [ link_name = "\u{1}__ZNK10SkTypeface11countTablesEv" ] pub fn SkTypeface_countTables ( this : * const SkTypeface ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Copy into tags[] (allocated by the caller) the list of table tags in" ] # [ doc = "  the font, and return the number. This will be the same as CountTables()" ] # [ doc = "  or 0 if an error occured. If tags == NULL, this only returns the count" ] # [ doc = "  (the same as calling countTables())." ] # [ link_name = "\u{1}__ZNK10SkTypeface12getTableTagsEPj" ] pub fn SkTypeface_getTableTags ( this : * const SkTypeface , tags : * mut SkFontTableTag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Given a table tag, return the size of its contents, or 0 if not present" ] # [ link_name = "\u{1}__ZNK10SkTypeface12getTableSizeEj" ] pub fn SkTypeface_getTableSize ( this : * const SkTypeface , arg1 : SkFontTableTag ) -> usize ; } extern "C" { # [ doc = " Copy the contents of a table into data (allocated by the caller). Note" ] # [ doc = "  that the contents of the table will be in their native endian order" ] # [ doc = "  (which for most truetype tables is big endian). If the table tag is" ] # [ doc = "  not found, or there is an error copying the data, then 0 is returned." ] # [ doc = "  If this happens, it is possible that some or all of the memory pointed" ] # [ doc = "  to by data may have been written to, even though an error has occured." ] # [ doc = "" ] # [ doc = "  @param fontID the font to copy the table from" ] # [ doc = "  @param tag  The table tag whose contents are to be copied" ] # [ doc = "  @param offset The offset in bytes into the table\'s contents where the" ] # [ doc = "  copy should start from." ] # [ doc = "  @param length The number of bytes, starting at offset, of table data" ] # [ doc = "  to copy." ] # [ doc = "  @param data storage address where the table contents are copied to" ] # [ doc = "  @return the number of bytes actually copied into data. If offset+length" ] # [ doc = "  exceeds the table\'s size, then only the bytes up to the table\'s" ] # [ doc = "  size are actually copied, and this is the value returned. If" ] # [ doc = "  offset > the table\'s size, or tag is not a valid table," ] # [ doc = "  then 0 is returned." ] # [ link_name = "\u{1}__ZNK10SkTypeface12getTableDataEjmmPv" ] pub fn SkTypeface_getTableData ( this : * const SkTypeface , tag : SkFontTableTag , offset : usize , length : usize , data : * mut :: std :: os :: raw :: c_void ) -> usize ; } extern "C" { # [ doc = "  Return the units-per-em value for this typeface, or zero if there is an" ] # [ doc = "  error." ] # [ link_name = "\u{1}__ZNK10SkTypeface13getUnitsPerEmEv" ] pub fn SkTypeface_getUnitsPerEm ( this : * const SkTypeface ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = "  Given a run of glyphs, return the associated horizontal adjustments." ] # [ doc = "  Adjustments are in \"design units\", which are integers relative to the" ] # [ doc = "  typeface\'s units per em (see getUnitsPerEm)." ] # [ doc = "" ] # [ doc = "  Some typefaces are known to never support kerning. Calling this method" ] # [ doc = "  with all zeros (e.g. getKerningPairAdustments(NULL, 0, NULL)) returns" ] # [ doc = "  a boolean indicating if the typeface might support kerning. If it" ] # [ doc = "  returns false, then it will always return false (no kerning) for all" ] # [ doc = "  possible glyph runs. If it returns true, then it *may* return true for" ] # [ doc = "  somne glyph runs." ] # [ doc = "" ] # [ doc = "  If count is non-zero, then the glyphs parameter must point to at least" ] # [ doc = "  [count] valid glyph IDs, and the adjustments parameter must be" ] # [ doc = "  sized to at least [count - 1] entries. If the method returns true, then" ] # [ doc = "  [count-1] entries in the adjustments array will be set. If the method" ] # [ doc = "  returns false, then no kerning should be applied, and the adjustments" ] # [ doc = "  array will be in an undefined state (possibly some values may have been" ] # [ doc = "  written, but none of them should be interpreted as valid values)." ] # [ link_name = "\u{1}__ZNK10SkTypeface25getKerningPairAdjustmentsEPKtiPi" ] pub fn SkTypeface_getKerningPairAdjustments ( this : * const SkTypeface , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , adjustments : * mut i32 ) -> bool ; } extern "C" { # [ doc = "  Returns an iterator which will attempt to enumerate all of the" ] # [ doc = "  family names specified by the font." ] # [ doc = "  It is the caller\'s responsibility to unref() the returned pointer." ] # [ link_name = "\u{1}__ZNK10SkTypeface24createFamilyNameIteratorEv" ] pub fn SkTypeface_createFamilyNameIterator ( this : * const SkTypeface ) -> * mut SkTypeface_LocalizedStrings ; } extern "C" { # [ doc = "  Return the family name for this typeface. It will always be returned" ] # [ doc = "  encoded as UTF8, but the language of the name is whatever the host" ] # [ doc = "  platform chooses." ] # [ link_name = "\u{1}__ZNK10SkTypeface13getFamilyNameEP8SkString" ] pub fn SkTypeface_getFamilyName ( this : * const SkTypeface , name : * mut SkString ) ; } extern "C" { # [ doc = "  Return a stream for the contents of the font data, or NULL on failure." ] # [ doc = "  If ttcIndex is not null, it is set to the TrueTypeCollection index" ] # [ doc = "  of this typeface within the stream, or 0 if the stream is not a" ] # [ doc = "  collection." ] # [ doc = "  The caller is responsible for deleting the stream." ] # [ link_name = "\u{1}__ZNK10SkTypeface10openStreamEPi" ] pub fn SkTypeface_openStream ( this : * const SkTypeface , ttcIndex : * mut :: std :: os :: raw :: c_int ) -> std_unique_ptr ; } extern "C" { # [ doc = "  Return the font data, or nullptr on failure." ] # [ link_name = "\u{1}__ZNK10SkTypeface12makeFontDataEv" ] pub fn SkTypeface_makeFontData ( this : * const SkTypeface ) -> std_unique_ptr ; } extern "C" { # [ doc = "  Return a scalercontext for the given descriptor. If this fails, then" ] # [ doc = "  if allowFailure is true, this returns NULL, else it returns a" ] # [ doc = "  dummy scalercontext that will not crash, but will draw nothing." ] # [ link_name = "\u{1}__ZNK10SkTypeface19createScalerContextERK22SkScalerContextEffectsPK12SkDescriptorb" ] pub fn SkTypeface_createScalerContext ( this : * const SkTypeface , arg1 : * const SkScalerContextEffects , arg2 : * const SkDescriptor , allowFailure : bool ) -> std_unique_ptr ; } extern "C" { # [ doc = "  Return a rectangle (scaled to 1-pt) that represents the union of the bounds of all" ] # [ doc = "  of the glyphs, but each one positioned at (0,). This may be conservatively large, and" ] # [ doc = "  will not take into account any hinting or other size-specific adjustments." ] # [ link_name = "\u{1}__ZNK10SkTypeface9getBoundsEv" ] pub fn SkTypeface_getBounds ( this : * const SkTypeface ) -> SkRect ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface9filterRecEP18SkScalerContextRec" ] pub fn SkTypeface_filterRec ( this : * const SkTypeface , rec : * mut SkScalerContextRec ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface17getFontDescriptorEP16SkFontDescriptorPb" ] pub fn SkTypeface_getFontDescriptor ( this : * const SkTypeface , desc : * mut SkFontDescriptor , isLocal : * mut bool ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface29internal_private_getCTFontRefEv" ] pub fn SkTypeface_internal_private_getCTFontRef ( this : * const SkTypeface ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " Sets the fixedPitch bit. If used, must be called in the constructor." ] # [ link_name = "\u{1}__ZN10SkTypeface15setIsFixedPitchEb" ] pub fn SkTypeface_setIsFixedPitch ( this : * mut SkTypeface , isFixedPitch : bool ) ; } extern "C" { # [ doc = " Sets the font style. If used, must be called in the constructor." ] # [ link_name = "\u{1}__ZN10SkTypeface12setFontStyleE11SkFontStyle" ] pub fn SkTypeface_setFontStyle ( this : * mut SkTypeface , style : SkFontStyle ) ; } extern "C" { # [ doc = " uniqueID must be unique and non-zero" ] # [ link_name = "\u{1}__ZN10SkTypefaceC2ERK11SkFontStyleb" ] pub fn SkTypeface_SkTypeface ( this : * mut SkTypeface , style : * const SkFontStyle , isFixedPitch : bool ) ; } impl SkTypeface { # [ inline ] pub unsafe fn fontStyle ( & self ) -> SkFontStyle { SkTypeface_fontStyle ( self ) } # [ inline ] pub unsafe fn isBold ( & self ) -> bool { SkTypeface_isBold ( self ) } # [ inline ] pub unsafe fn isItalic ( & self ) -> bool { SkTypeface_isItalic ( self ) } # [ inline ] pub unsafe fn isFixedPitch ( & self ) -> bool { SkTypeface_isFixedPitch ( self ) } # [ inline ] pub unsafe fn getVariationDesignPosition ( & self , coordinates : * mut SkFontArguments_VariationPosition_Coordinate , coordinateCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int { SkTypeface_getVariationDesignPosition ( self , coordinates , coordinateCount ) } # [ inline ] pub unsafe fn getVariationDesignParameters ( & self , parameters : * mut SkFontParameters_Variation_Axis , parameterCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int { SkTypeface_getVariationDesignParameters ( self , parameters , parameterCount ) } # [ inline ] pub unsafe fn uniqueID ( & self ) -> SkFontID { SkTypeface_uniqueID ( self ) } # [ inline ] pub unsafe fn UniqueID ( face : * const SkTypeface ) -> SkFontID { SkTypeface_UniqueID ( face ) } # [ inline ] pub unsafe fn Equal ( facea : * const SkTypeface , faceb : * const SkTypeface ) -> bool { SkTypeface_Equal ( facea , faceb ) } # [ inline ] pub unsafe fn MakeDefault ( ) -> sk_sp < SkTypeface > { SkTypeface_MakeDefault ( ) } # [ inline ] pub unsafe fn MakeFromName ( familyName : * const :: std :: os :: raw :: c_char , fontStyle : SkFontStyle ) -> sk_sp < SkTypeface > { SkTypeface_MakeFromName ( familyName , fontStyle ) } # [ inline ] pub unsafe fn MakeFromFile ( path : * const :: std :: os :: raw :: c_char , index : :: std :: os :: raw :: c_int ) -> sk_sp < SkTypeface > { SkTypeface_MakeFromFile ( path , index ) } # [ inline ] pub unsafe fn MakeFromStream ( stream : std_unique_ptr , index : :: std :: os :: raw :: c_int ) -> sk_sp < SkTypeface > { SkTypeface_MakeFromStream ( stream , index ) } # [ inline ] pub unsafe fn MakeFromData ( arg1 : sk_sp < SkData > , index : :: std :: os :: raw :: c_int ) -> sk_sp < SkTypeface > { SkTypeface_MakeFromData ( arg1 , index ) } # [ inline ] pub unsafe fn MakeFromFontData ( arg1 : std_unique_ptr ) -> sk_sp < SkTypeface > { SkTypeface_MakeFromFontData ( arg1 ) } # [ inline ] pub unsafe fn makeClone ( & self , arg1 : * const SkFontArguments ) -> sk_sp < SkTypeface > { SkTypeface_makeClone ( self , arg1 ) } # [ inline ] pub unsafe fn serialize ( & self , arg1 : * mut SkWStream , arg2 : SkTypeface_SerializeBehavior ) { SkTypeface_serialize ( self , arg1 , arg2 ) } # [ inline ] pub unsafe fn serialize1 ( & self , arg1 : SkTypeface_SerializeBehavior ) -> sk_sp < SkData > { SkTypeface_serialize1 ( self , arg1 ) } # [ inline ] pub unsafe fn MakeDeserialize ( arg1 : * mut SkStream ) -> sk_sp < SkTypeface > { SkTypeface_MakeDeserialize ( arg1 ) } # [ inline ] pub unsafe fn charsToGlyphs ( & self , chars : * const :: std :: os :: raw :: c_void , encoding : SkTypeface_Encoding , glyphs : * mut SkGlyphID , glyphCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int { SkTypeface_charsToGlyphs ( self , chars , encoding , glyphs , glyphCount ) } # [ inline ] pub unsafe fn unicharToGlyph ( & self , unichar : SkUnichar ) -> SkGlyphID { SkTypeface_unicharToGlyph ( self , unichar ) } # [ inline ] pub unsafe fn countGlyphs ( & self ) -> :: std :: os :: raw :: c_int { SkTypeface_countGlyphs ( self ) } # [ inline ] pub unsafe fn countTables ( & self ) -> :: std :: os :: raw :: c_int { SkTypeface_countTables ( self ) } # [ inline ] pub unsafe fn getTableTags ( & self , tags : * mut SkFontTableTag ) -> :: std :: os :: raw :: c_int { SkTypeface_getTableTags ( self , tags ) } # [ inline ] pub unsafe fn getTableSize ( & self , arg1 : SkFontTableTag ) -> usize { SkTypeface_getTableSize ( self , arg1 ) } # [ inline ] pub unsafe fn getTableData ( & self , tag : SkFontTableTag , offset : usize , length : usize , data : * mut :: std :: os :: raw :: c_void ) -> usize { SkTypeface_getTableData ( self , tag , offset , length , data ) } # [ inline ] pub unsafe fn getUnitsPerEm ( & self ) -> :: std :: os :: raw :: c_int { SkTypeface_getUnitsPerEm ( self ) } # [ inline ] pub unsafe fn getKerningPairAdjustments ( & self , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , adjustments : * mut i32 ) -> bool { SkTypeface_getKerningPairAdjustments ( self , glyphs , count , adjustments ) } # [ inline ] pub unsafe fn createFamilyNameIterator ( & self ) -> * mut SkTypeface_LocalizedStrings { SkTypeface_createFamilyNameIterator ( self ) } # [ inline ] pub unsafe fn getFamilyName ( & self , name : * mut SkString ) { SkTypeface_getFamilyName ( self , name ) } # [ inline ] pub unsafe fn openStream ( & self , ttcIndex : * mut :: std :: os :: raw :: c_int ) -> std_unique_ptr { SkTypeface_openStream ( self , ttcIndex ) } # [ inline ] pub unsafe fn makeFontData ( & self ) -> std_unique_ptr { SkTypeface_makeFontData ( self ) } # [ inline ] pub unsafe fn createScalerContext ( & self , arg1 : * const SkScalerContextEffects , arg2 : * const SkDescriptor , allowFailure : bool ) -> std_unique_ptr { SkTypeface_createScalerContext ( self , arg1 , arg2 , allowFailure ) } # [ inline ] pub unsafe fn getBounds ( & self ) -> SkRect { SkTypeface_getBounds ( self ) } # [ inline ] pub unsafe fn filterRec ( & self , rec : * mut SkScalerContextRec ) { SkTypeface_filterRec ( self , rec ) } # [ inline ] pub unsafe fn getFontDescriptor ( & self , desc : * mut SkFontDescriptor , isLocal : * mut bool ) { SkTypeface_getFontDescriptor ( self , desc , isLocal ) } # [ inline ] pub unsafe fn internal_private_getCTFontRef ( & self ) -> * mut :: std :: os :: raw :: c_void { SkTypeface_internal_private_getCTFontRef ( self ) } # [ inline ] pub unsafe fn setIsFixedPitch ( & mut self , isFixedPitch : bool ) { SkTypeface_setIsFixedPitch ( self , isFixedPitch ) } # [ inline ] pub unsafe fn setFontStyle ( & mut self , style : SkFontStyle ) { SkTypeface_setFontStyle ( self , style ) } # [ inline ] pub unsafe fn new ( style : * const SkFontStyle , isFixedPitch : bool ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkTypeface_SkTypeface ( & mut __bindgen_tmp , style , isFixedPitch ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN10SkTypeface16LocalizedStringsD1Ev" ] pub fn SkTypeface_LocalizedStrings_LocalizedStrings_destructor ( this : * mut SkTypeface_LocalizedStrings ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkTypefaceD1Ev" ] pub fn SkTypeface_SkTypeface_destructor ( this : * mut SkTypeface ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface11onMakeCloneERK15SkFontArguments" ] pub fn SkTypeface_onMakeClone ( this : * mut :: std :: os :: raw :: c_void , arg1 : * const SkFontArguments ) -> sk_sp < SkTypeface > ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface20onGetAdvancedMetricsEv" ] pub fn SkTypeface_onGetAdvancedMetrics ( this : * mut :: std :: os :: raw :: c_void ) -> std_unique_ptr ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface23getPostScriptGlyphNamesEP8SkString" ] pub fn SkTypeface_getPostScriptGlyphNames ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut SkString ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface20getGlyphToUnicodeMapEPi" ] pub fn SkTypeface_getGlyphToUnicodeMap ( this : * mut :: std :: os :: raw :: c_void , dstArray : * mut SkUnichar ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface14onMakeFontDataEv" ] pub fn SkTypeface_onMakeFontData ( this : * mut :: std :: os :: raw :: c_void ) -> std_unique_ptr ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface30onGetVariationDesignParametersEPN16SkFontParameters9Variation4AxisEi" ] pub fn SkTypeface_onGetVariationDesignParameters ( this : * mut :: std :: os :: raw :: c_void , parameters : * mut SkFontParameters_Variation_Axis , parameterCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface27onGetKerningPairAdjustmentsEPKtiPi" ] pub fn SkTypeface_onGetKerningPairAdjustments ( this : * mut :: std :: os :: raw :: c_void , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , adjustments : * mut i32 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface15onComputeBoundsEP6SkRect" ] pub fn SkTypeface_onComputeBounds ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut SkRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkTypeface14onGetCTFontRefEv" ] pub fn SkTypeface_onGetCTFontRef ( this : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void ; } # [ doc = "!< uses bytes to represent UTF-8 or ASCII" ] pub const SkTextEncoding_kUTF8 : SkTextEncoding = 0 ; # [ doc = "!< uses two byte words to represent most of Unicode" ] pub const SkTextEncoding_kUTF16 : SkTextEncoding = 1 ; # [ doc = "!< uses four byte words to represent all of Unicode" ] pub const SkTextEncoding_kUTF32 : SkTextEncoding = 2 ; # [ doc = "!< uses two byte words to represent glyph indices" ] pub const SkTextEncoding_kGlyphID : SkTextEncoding = 3 ; pub type SkTextEncoding = i32 ; # [ doc = "!< glyph outlines unchanged" ] pub const SkFontHinting_kNone : SkFontHinting = 0 ; # [ doc = "!< minimal modification to improve constrast" ] pub const SkFontHinting_kSlight : SkFontHinting = 1 ; # [ doc = "!< glyph outlines modified to improve constrast" ] pub const SkFontHinting_kNormal : SkFontHinting = 2 ; # [ doc = "!< modifies glyph outlines for maximum constrast" ] pub const SkFontHinting_kFull : SkFontHinting = 3 ; pub type SkFontHinting = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct skcms_Matrix3x3 { pub vals : [ [ f32 ; 3usize ] ; 3usize ] , } # [ test ] fn bindgen_test_layout_skcms_Matrix3x3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < skcms_Matrix3x3 > ( ) , 36usize , concat ! ( "Size of: " , stringify ! ( skcms_Matrix3x3 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < skcms_Matrix3x3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( skcms_Matrix3x3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_Matrix3x3 > ( ) ) ) . vals as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( skcms_Matrix3x3 ) , "::" , stringify ! ( vals ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct skcms_Matrix3x4 { pub vals : [ [ f32 ; 4usize ] ; 3usize ] , } # [ test ] fn bindgen_test_layout_skcms_Matrix3x4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < skcms_Matrix3x4 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( skcms_Matrix3x4 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < skcms_Matrix3x4 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( skcms_Matrix3x4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_Matrix3x4 > ( ) ) ) . vals as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( skcms_Matrix3x4 ) , "::" , stringify ! ( vals ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct skcms_TransferFunction { pub g : f32 , pub a : f32 , pub b : f32 , pub c : f32 , pub d : f32 , pub e : f32 , pub f : f32 , } # [ test ] fn bindgen_test_layout_skcms_TransferFunction ( ) { assert_eq ! ( :: core :: mem :: size_of :: < skcms_TransferFunction > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( skcms_TransferFunction ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < skcms_TransferFunction > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( skcms_TransferFunction ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_TransferFunction > ( ) ) ) . g as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( skcms_TransferFunction ) , "::" , stringify ! ( g ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_TransferFunction > ( ) ) ) . a as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( skcms_TransferFunction ) , "::" , stringify ! ( a ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_TransferFunction > ( ) ) ) . b as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( skcms_TransferFunction ) , "::" , stringify ! ( b ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_TransferFunction > ( ) ) ) . c as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( skcms_TransferFunction ) , "::" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_TransferFunction > ( ) ) ) . d as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( skcms_TransferFunction ) , "::" , stringify ! ( d ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_TransferFunction > ( ) ) ) . e as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( skcms_TransferFunction ) , "::" , stringify ! ( e ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_TransferFunction > ( ) ) ) . f as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( skcms_TransferFunction ) , "::" , stringify ! ( f ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union skcms_Curve { pub __bindgen_anon_1 : skcms_Curve__bindgen_ty_1 , pub __bindgen_anon_2 : skcms_Curve__bindgen_ty_2 , _bindgen_union_align : [ u64 ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct skcms_Curve__bindgen_ty_1 { pub alias_of_table_entries : u32 , pub parametric : skcms_TransferFunction , } # [ test ] fn bindgen_test_layout_skcms_Curve__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < skcms_Curve__bindgen_ty_1 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( skcms_Curve__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < skcms_Curve__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( skcms_Curve__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_Curve__bindgen_ty_1 > ( ) ) ) . alias_of_table_entries as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( skcms_Curve__bindgen_ty_1 ) , "::" , stringify ! ( alias_of_table_entries ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_Curve__bindgen_ty_1 > ( ) ) ) . parametric as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( skcms_Curve__bindgen_ty_1 ) , "::" , stringify ! ( parametric ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct skcms_Curve__bindgen_ty_2 { pub table_entries : u32 , pub table_8 : * const u8 , pub table_16 : * const u8 , } # [ test ] fn bindgen_test_layout_skcms_Curve__bindgen_ty_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < skcms_Curve__bindgen_ty_2 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( skcms_Curve__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < skcms_Curve__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( skcms_Curve__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_Curve__bindgen_ty_2 > ( ) ) ) . table_entries as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( skcms_Curve__bindgen_ty_2 ) , "::" , stringify ! ( table_entries ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_Curve__bindgen_ty_2 > ( ) ) ) . table_8 as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( skcms_Curve__bindgen_ty_2 ) , "::" , stringify ! ( table_8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_Curve__bindgen_ty_2 > ( ) ) ) . table_16 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( skcms_Curve__bindgen_ty_2 ) , "::" , stringify ! ( table_16 ) ) ) ; } # [ test ] fn bindgen_test_layout_skcms_Curve ( ) { assert_eq ! ( :: core :: mem :: size_of :: < skcms_Curve > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( skcms_Curve ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < skcms_Curve > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( skcms_Curve ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct skcms_A2B { pub input_channels : u32 , pub input_curves : [ skcms_Curve ; 4usize ] , pub grid_points : [ u8 ; 4usize ] , pub grid_8 : * const u8 , pub grid_16 : * const u8 , pub matrix_channels : u32 , pub matrix_curves : [ skcms_Curve ; 3usize ] , pub matrix : skcms_Matrix3x4 , pub output_channels : u32 , pub output_curves : [ skcms_Curve ; 3usize ] , } # [ test ] fn bindgen_test_layout_skcms_A2B ( ) { assert_eq ! ( :: core :: mem :: size_of :: < skcms_A2B > ( ) , 416usize , concat ! ( "Size of: " , stringify ! ( skcms_A2B ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < skcms_A2B > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( skcms_A2B ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . input_channels as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( input_channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . input_curves as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( input_curves ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . grid_points as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( grid_points ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . grid_8 as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( grid_8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . grid_16 as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( grid_16 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . matrix_channels as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( matrix_channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . matrix_curves as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( matrix_curves ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . matrix as * const _ as usize } , 264usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( matrix ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . output_channels as * const _ as usize } , 312usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( output_channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_A2B > ( ) ) ) . output_curves as * const _ as usize } , 320usize , concat ! ( "Offset of field: " , stringify ! ( skcms_A2B ) , "::" , stringify ! ( output_curves ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct skcms_ICCProfile { pub buffer : * const u8 , pub size : u32 , pub data_color_space : u32 , pub pcs : u32 , pub tag_count : u32 , pub has_trc : bool , pub trc : [ skcms_Curve ; 3usize ] , pub has_toXYZD50 : bool , pub toXYZD50 : skcms_Matrix3x3 , pub has_A2B : bool , pub A2B : skcms_A2B , } # [ test ] fn bindgen_test_layout_skcms_ICCProfile ( ) { assert_eq ! ( :: core :: mem :: size_of :: < skcms_ICCProfile > ( ) , 592usize , concat ! ( "Size of: " , stringify ! ( skcms_ICCProfile ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < skcms_ICCProfile > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( skcms_ICCProfile ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . buffer as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . data_color_space as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( data_color_space ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . pcs as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( pcs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . tag_count as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( tag_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . has_trc as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( has_trc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . trc as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( trc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . has_toXYZD50 as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( has_toXYZD50 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . toXYZD50 as * const _ as usize } , 132usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( toXYZD50 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . has_A2B as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( has_A2B ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < skcms_ICCProfile > ( ) ) ) . A2B as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( skcms_ICCProfile ) , "::" , stringify ! ( A2B ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRSXform { _unused : [ u8 ; 0 ] , } # [ doc = " \\class SkMatrix" ] # [ doc = "SkMatrix holds a 3x3 matrix for transforming coordinates. This allows mapping" ] # [ doc = "SkPoint and vectors with translation, scaling, skewing, rotation, and" ] # [ doc = "perspective." ] # [ doc = "" ] # [ doc = "SkMatrix elements are in row major order. SkMatrix does not have a constructor," ] # [ doc = "so it must be explicitly initialized. setIdentity() initializes SkMatrix" ] # [ doc = "so it has no effect. setTranslate(), setScale(), setSkew(), setRotate(), set9 and setAll()" ] # [ doc = "initializes all SkMatrix elements with the corresponding mapping." ] # [ doc = "" ] # [ doc = "SkMatrix includes a hidden variable that classifies the type of matrix to" ] # [ doc = "improve performance. SkMatrix is not thread safe unless getType() is called first." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkMatrix { pub fMat : [ SkScalar ; 9usize ] , pub fTypeMask : u32 , } # [ repr ( u32 ) ] # [ doc = " \\enum SkMatrix::TypeMask" ] # [ doc = "Enum of bit fields for mask returned by getType()." ] # [ doc = "Used to identify the complexity of SkMatrix, to optimize performance." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkMatrix_TypeMask { # [ doc = "!< identity SkMatrix; all bits clear" ] kIdentity_Mask = 0 , # [ doc = "!< translation SkMatrix" ] kTranslate_Mask = 1 , # [ doc = "!< scale SkMatrix" ] kScale_Mask = 2 , # [ doc = "!< skew or rotate SkMatrix" ] kAffine_Mask = 4 , # [ doc = "!< perspective SkMatrix" ] kPerspective_Mask = 8 , } # [ repr ( u32 ) ] # [ doc = " \\enum SkMatrix::ScaleToFit" ] # [ doc = "ScaleToFit describes how SkMatrix is constructed to map one SkRect to another." ] # [ doc = "ScaleToFit may allow SkMatrix to have unequal horizontal and vertical scaling," ] # [ doc = "or may restrict SkMatrix to square scaling. If restricted, ScaleToFit specifies" ] # [ doc = "how SkMatrix maps to the side or center of the destination SkRect." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkMatrix_ScaleToFit { # [ doc = "!< scales in x and y to fill destination SkRect" ] kFill_ScaleToFit = 0 , # [ doc = "!< scales and aligns to left and top" ] kStart_ScaleToFit = 1 , # [ doc = "!< scales and aligns to center" ] kCenter_ScaleToFit = 2 , # [ doc = "!< scales and aligns to right and bottom" ] kEnd_ScaleToFit = 3 , } pub type SkMatrix_MapXYProc = :: core :: option :: Option < unsafe extern "C" fn ( mat : * const SkMatrix , x : SkScalar , y : SkScalar , result : * mut SkPoint ) > ; pub type SkMatrix_MapPtsProc = :: core :: option :: Option < unsafe extern "C" fn ( mat : * const SkMatrix , dst : * mut SkPoint , src : * const SkPoint , count : :: std :: os :: raw :: c_int ) > ; pub const SkMatrix_kMScaleX : :: std :: os :: raw :: c_int = 0 ; pub const SkMatrix_kMSkewX : :: std :: os :: raw :: c_int = 1 ; pub const SkMatrix_kMTransX : :: std :: os :: raw :: c_int = 2 ; pub const SkMatrix_kMSkewY : :: std :: os :: raw :: c_int = 3 ; pub const SkMatrix_kMScaleY : :: std :: os :: raw :: c_int = 4 ; pub const SkMatrix_kMTransY : :: std :: os :: raw :: c_int = 5 ; pub const SkMatrix_kMPersp0 : :: std :: os :: raw :: c_int = 6 ; pub const SkMatrix_kMPersp1 : :: std :: os :: raw :: c_int = 7 ; pub const SkMatrix_kMPersp2 : :: std :: os :: raw :: c_int = 8 ; pub const SkMatrix_kAScaleX : :: std :: os :: raw :: c_int = 0 ; pub const SkMatrix_kASkewY : :: std :: os :: raw :: c_int = 1 ; pub const SkMatrix_kASkewX : :: std :: os :: raw :: c_int = 2 ; pub const SkMatrix_kAScaleY : :: std :: os :: raw :: c_int = 3 ; pub const SkMatrix_kATransX : :: std :: os :: raw :: c_int = 4 ; pub const SkMatrix_kATransY : :: std :: os :: raw :: c_int = 5 ; pub const SkMatrix_kRectStaysRect_Mask : :: std :: os :: raw :: c_int = 16 ; pub const SkMatrix_kOnlyPerspectiveValid_Mask : :: std :: os :: raw :: c_int = 64 ; pub const SkMatrix_kUnknown_Mask : :: std :: os :: raw :: c_int = 128 ; pub const SkMatrix_kORableMasks : :: std :: os :: raw :: c_int = 15 ; pub const SkMatrix_kAllMasks : :: std :: os :: raw :: c_int = 31 ; extern "C" { # [ link_name = "\u{1}__ZN8SkMatrix11gMapXYProcsE" ] pub static mut SkMatrix_gMapXYProcs : [ SkMatrix_MapXYProc ; 0usize ] ; } extern "C" { # [ link_name = "\u{1}__ZN8SkMatrix12gMapPtsProcsE" ] pub static mut SkMatrix_gMapPtsProcs : [ SkMatrix_MapPtsProc ; 0usize ] ; } # [ test ] fn bindgen_test_layout_SkMatrix ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkMatrix > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( SkMatrix ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkMatrix > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkMatrix ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkMatrix > ( ) ) ) . fMat as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkMatrix ) , "::" , stringify ! ( fMat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkMatrix > ( ) ) ) . fTypeMask as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SkMatrix ) , "::" , stringify ! ( fTypeMask ) ) ) ; } extern "C" { # [ doc = " Sets SkMatrix to scale by (sx, sy). Returned matrix is:" ] # [ doc = "" ] # [ doc = "| sx  0  0 |" ] # [ doc = "|  0 sy  0 |" ] # [ doc = "|  0  0  1 |" ] # [ doc = "" ] # [ doc = "@param sx  horizontal scale factor" ] # [ doc = "@param sy  vertical scale factor" ] # [ doc = "@return    SkMatrix with scale" ] # [ link_name = "\u{1}__ZN8SkMatrix9MakeScaleEff" ] pub fn SkMatrix_MakeScale ( sx : SkScalar , sy : SkScalar ) -> SkMatrix ; } extern "C" { # [ doc = " Sets SkMatrix to scale by (scale, scale). Returned matrix is:" ] # [ doc = "" ] # [ doc = "| scale   0   0 |" ] # [ doc = "|   0   scale 0 |" ] # [ doc = "|   0     0   1 |" ] # [ doc = "" ] # [ doc = "@param scale  horizontal and vertical scale factor" ] # [ doc = "@return       SkMatrix with scale" ] # [ link_name = "\u{1}__ZN8SkMatrix9MakeScaleEf" ] pub fn SkMatrix_MakeScale1 ( scale : SkScalar ) -> SkMatrix ; } extern "C" { # [ doc = " Sets SkMatrix to translate by (dx, dy). Returned matrix is:" ] # [ doc = "" ] # [ doc = "| 1 0 dx |" ] # [ doc = "| 0 1 dy |" ] # [ doc = "| 0 0  1 |" ] # [ doc = "" ] # [ doc = "@param dx  horizontal translation" ] # [ doc = "@param dy  vertical translation" ] # [ doc = "@return    SkMatrix with translation" ] # [ link_name = "\u{1}__ZN8SkMatrix9MakeTransEff" ] pub fn SkMatrix_MakeTrans ( dx : SkScalar , dy : SkScalar ) -> SkMatrix ; } extern "C" { # [ doc = " Sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| scaleX  skewX transX |" ] # [ doc = "|  skewY scaleY transY |" ] # [ doc = "|  pers0  pers1  pers2 |" ] # [ doc = "" ] # [ doc = "@param scaleX  horizontal scale factor" ] # [ doc = "@param skewX   horizontal skew factor" ] # [ doc = "@param transX  horizontal translation" ] # [ doc = "@param skewY   vertical skew factor" ] # [ doc = "@param scaleY  vertical scale factor" ] # [ doc = "@param transY  vertical translation" ] # [ doc = "@param pers0   input x-axis perspective factor" ] # [ doc = "@param pers1   input y-axis perspective factor" ] # [ doc = "@param pers2   perspective scale factor" ] # [ doc = "@return        SkMatrix constructed from parameters" ] # [ link_name = "\u{1}__ZN8SkMatrix7MakeAllEfffffffff" ] pub fn SkMatrix_MakeAll ( scaleX : SkScalar , skewX : SkScalar , transX : SkScalar , skewY : SkScalar , scaleY : SkScalar , transY : SkScalar , pers0 : SkScalar , pers1 : SkScalar , pers2 : SkScalar ) -> SkMatrix ; } extern "C" { # [ doc = " Returns a bit field describing the transformations the matrix may" ] # [ doc = "perform. The bit field is computed conservatively, so it may include" ] # [ doc = "false positives. For example, when kPerspective_Mask is set, all" ] # [ doc = "other bits are set." ] # [ doc = "" ] # [ doc = "@return  kIdentity_Mask, or combinations of: kTranslate_Mask, kScale_Mask," ] # [ doc = "kAffine_Mask, kPerspective_Mask" ] # [ link_name = "\u{1}__ZNK8SkMatrix7getTypeEv" ] pub fn SkMatrix_getType ( this : * const SkMatrix ) -> SkMatrix_TypeMask ; } extern "C" { # [ doc = " Returns true if SkMatrix is identity.  Identity matrix is:" ] # [ doc = "" ] # [ doc = "| 1 0 0 |" ] # [ doc = "| 0 1 0 |" ] # [ doc = "| 0 0 1 |" ] # [ doc = "" ] # [ doc = "@return  true if SkMatrix has no effect" ] # [ link_name = "\u{1}__ZNK8SkMatrix10isIdentityEv" ] pub fn SkMatrix_isIdentity ( this : * const SkMatrix ) -> bool ; } extern "C" { # [ doc = " Returns true if SkMatrix at most scales and translates. SkMatrix may be identity," ] # [ doc = "contain only scale elements, only translate elements, or both. SkMatrix form is:" ] # [ doc = "" ] # [ doc = "| scale-x    0    translate-x |" ] # [ doc = "|    0    scale-y translate-y |" ] # [ doc = "|    0       0         1      |" ] # [ doc = "" ] # [ doc = "@return  true if SkMatrix is identity; or scales, translates, or both" ] # [ link_name = "\u{1}__ZNK8SkMatrix16isScaleTranslateEv" ] pub fn SkMatrix_isScaleTranslate ( this : * const SkMatrix ) -> bool ; } extern "C" { # [ doc = " Returns true if SkMatrix is identity, or translates. SkMatrix form is:" ] # [ doc = "" ] # [ doc = "| 1 0 translate-x |" ] # [ doc = "| 0 1 translate-y |" ] # [ doc = "| 0 0      1      |" ] # [ doc = "" ] # [ doc = "@return  true if SkMatrix is identity, or translates" ] # [ link_name = "\u{1}__ZNK8SkMatrix11isTranslateEv" ] pub fn SkMatrix_isTranslate ( this : * const SkMatrix ) -> bool ; } extern "C" { # [ doc = " Returns true SkMatrix maps SkRect to another SkRect. If true, SkMatrix is identity," ] # [ doc = "or scales, or rotates a multiple of 90 degrees, or mirrors on axes. In all" ] # [ doc = "cases, SkMatrix may also have translation. SkMatrix form is either:" ] # [ doc = "" ] # [ doc = "| scale-x    0    translate-x |" ] # [ doc = "|    0    scale-y translate-y |" ] # [ doc = "|    0       0         1      |" ] # [ doc = "" ] # [ doc = "or" ] # [ doc = "" ] # [ doc = "|    0     rotate-x translate-x |" ] # [ doc = "| rotate-y    0     translate-y |" ] # [ doc = "|    0        0          1      |" ] # [ doc = "" ] # [ doc = "for non-zero values of scale-x, scale-y, rotate-x, and rotate-y." ] # [ doc = "" ] # [ doc = "Also called preservesAxisAlignment(); use the one that provides better inline" ] # [ doc = "documentation." ] # [ doc = "" ] # [ doc = "@return  true if SkMatrix maps one SkRect into another" ] # [ link_name = "\u{1}__ZNK8SkMatrix13rectStaysRectEv" ] pub fn SkMatrix_rectStaysRect ( this : * const SkMatrix ) -> bool ; } extern "C" { # [ doc = " Returns true SkMatrix maps SkRect to another SkRect. If true, SkMatrix is identity," ] # [ doc = "or scales, or rotates a multiple of 90 degrees, or mirrors on axes. In all" ] # [ doc = "cases, SkMatrix may also have translation. SkMatrix form is either:" ] # [ doc = "" ] # [ doc = "| scale-x    0    translate-x |" ] # [ doc = "|    0    scale-y translate-y |" ] # [ doc = "|    0       0         1      |" ] # [ doc = "" ] # [ doc = "or" ] # [ doc = "" ] # [ doc = "|    0     rotate-x translate-x |" ] # [ doc = "| rotate-y    0     translate-y |" ] # [ doc = "|    0        0          1      |" ] # [ doc = "" ] # [ doc = "for non-zero values of scale-x, scale-y, rotate-x, and rotate-y." ] # [ doc = "" ] # [ doc = "Also called rectStaysRect(); use the one that provides better inline" ] # [ doc = "documentation." ] # [ doc = "" ] # [ doc = "@return  true if SkMatrix maps one SkRect into another" ] # [ link_name = "\u{1}__ZNK8SkMatrix22preservesAxisAlignmentEv" ] pub fn SkMatrix_preservesAxisAlignment ( this : * const SkMatrix ) -> bool ; } extern "C" { # [ doc = " Returns true if the matrix contains perspective elements. SkMatrix form is:" ] # [ doc = "" ] # [ doc = "|       --            --              --          |" ] # [ doc = "|       --            --              --          |" ] # [ doc = "| perspective-x  perspective-y  perspective-scale |" ] # [ doc = "" ] # [ doc = "where perspective-x or perspective-y is non-zero, or perspective-scale is" ] # [ doc = "not one. All other elements may have any value." ] # [ doc = "" ] # [ doc = "@return  true if SkMatrix is in most general form" ] # [ link_name = "\u{1}__ZNK8SkMatrix14hasPerspectiveEv" ] pub fn SkMatrix_hasPerspective ( this : * const SkMatrix ) -> bool ; } extern "C" { # [ doc = " Returns true if SkMatrix contains only translation, rotation, reflection, and" ] # [ doc = "uniform scale." ] # [ doc = "Returns false if SkMatrix contains different scales, skewing, perspective, or" ] # [ doc = "degenerate forms that collapse to a line or point." ] # [ doc = "" ] # [ doc = "Describes that the SkMatrix makes rendering with and without the matrix are" ] # [ doc = "visually alike; a transformed circle remains a circle. Mathematically, this is" ] # [ doc = "referred to as similarity of a Euclidean space, or a similarity transformation." ] # [ doc = "" ] # [ doc = "Preserves right angles, keeping the arms of the angle equal lengths." ] # [ doc = "" ] # [ doc = "@param tol  to be deprecated" ] # [ doc = "@return     true if SkMatrix only rotates, uniformly scales, translates" ] # [ link_name = "\u{1}__ZNK8SkMatrix12isSimilarityEf" ] pub fn SkMatrix_isSimilarity ( this : * const SkMatrix , tol : SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns true if SkMatrix contains only translation, rotation, reflection, and" ] # [ doc = "scale. Scale may differ along rotated axes." ] # [ doc = "Returns false if SkMatrix skewing, perspective, or degenerate forms that collapse" ] # [ doc = "to a line or point." ] # [ doc = "" ] # [ doc = "Preserves right angles, but not requiring that the arms of the angle" ] # [ doc = "retain equal lengths." ] # [ doc = "" ] # [ doc = "@param tol  to be deprecated" ] # [ doc = "@return     true if SkMatrix only rotates, scales, translates" ] # [ link_name = "\u{1}__ZNK8SkMatrix20preservesRightAnglesEf" ] pub fn SkMatrix_preservesRightAngles ( this : * const SkMatrix , tol : SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns one matrix value. Asserts if index is out of range and SK_DEBUG is" ] # [ doc = "defined." ] # [ doc = "" ] # [ doc = "@param index  one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY," ] # [ doc = "kMPersp0, kMPersp1, kMPersp2" ] # [ doc = "@return       value corresponding to index" ] # [ link_name = "\u{1}__ZNK8SkMatrix3getEi" ] pub fn SkMatrix_get ( this : * const SkMatrix , index : :: std :: os :: raw :: c_int ) -> SkScalar ; } extern "C" { # [ doc = " Returns scale factor multiplied by x-axis input, contributing to x-axis output." ] # [ doc = "With mapPoints(), scales SkPoint along the x-axis." ] # [ doc = "" ] # [ doc = "@return  horizontal scale factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix9getScaleXEv" ] pub fn SkMatrix_getScaleX ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Returns scale factor multiplied by y-axis input, contributing to y-axis output." ] # [ doc = "With mapPoints(), scales SkPoint along the y-axis." ] # [ doc = "" ] # [ doc = "@return  vertical scale factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix9getScaleYEv" ] pub fn SkMatrix_getScaleY ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Returns scale factor multiplied by x-axis input, contributing to y-axis output." ] # [ doc = "With mapPoints(), skews SkPoint along the y-axis." ] # [ doc = "Skewing both axes can rotate SkPoint." ] # [ doc = "" ] # [ doc = "@return  vertical skew factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix8getSkewYEv" ] pub fn SkMatrix_getSkewY ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Returns scale factor multiplied by y-axis input, contributing to x-axis output." ] # [ doc = "With mapPoints(), skews SkPoint along the x-axis." ] # [ doc = "Skewing both axes can rotate SkPoint." ] # [ doc = "" ] # [ doc = "@return  horizontal scale factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix8getSkewXEv" ] pub fn SkMatrix_getSkewX ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Returns translation contributing to x-axis output." ] # [ doc = "With mapPoints(), moves SkPoint along the x-axis." ] # [ doc = "" ] # [ doc = "@return  horizontal translation factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix13getTranslateXEv" ] pub fn SkMatrix_getTranslateX ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Returns translation contributing to y-axis output." ] # [ doc = "With mapPoints(), moves SkPoint along the y-axis." ] # [ doc = "" ] # [ doc = "@return  vertical translation factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix13getTranslateYEv" ] pub fn SkMatrix_getTranslateY ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Returns factor scaling input x-axis relative to input y-axis." ] # [ doc = "" ] # [ doc = "@return  input x-axis perspective factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix9getPerspXEv" ] pub fn SkMatrix_getPerspX ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Returns factor scaling input y-axis relative to input x-axis." ] # [ doc = "" ] # [ doc = "@return  input y-axis perspective factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix9getPerspYEv" ] pub fn SkMatrix_getPerspY ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Sets SkMatrix value. Asserts if index is out of range and SK_DEBUG is" ] # [ doc = "defined. Safer than operator[]; internal cache is always maintained." ] # [ doc = "" ] # [ doc = "@param index  one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY," ] # [ doc = "kMPersp0, kMPersp1, kMPersp2" ] # [ doc = "@param value  scalar to store in SkMatrix" ] # [ link_name = "\u{1}__ZN8SkMatrix3setEif" ] pub fn SkMatrix_set ( this : * mut SkMatrix , index : :: std :: os :: raw :: c_int , value : SkScalar ) ; } extern "C" { # [ doc = " Sets horizontal scale factor." ] # [ doc = "" ] # [ doc = "@param v  horizontal scale factor to store" ] # [ link_name = "\u{1}__ZN8SkMatrix9setScaleXEf" ] pub fn SkMatrix_setScaleX ( this : * mut SkMatrix , v : SkScalar ) ; } extern "C" { # [ doc = " Sets vertical scale factor." ] # [ doc = "" ] # [ doc = "@param v  vertical scale factor to store" ] # [ link_name = "\u{1}__ZN8SkMatrix9setScaleYEf" ] pub fn SkMatrix_setScaleY ( this : * mut SkMatrix , v : SkScalar ) ; } extern "C" { # [ doc = " Sets vertical skew factor." ] # [ doc = "" ] # [ doc = "@param v  vertical skew factor to store" ] # [ link_name = "\u{1}__ZN8SkMatrix8setSkewYEf" ] pub fn SkMatrix_setSkewY ( this : * mut SkMatrix , v : SkScalar ) ; } extern "C" { # [ doc = " Sets horizontal skew factor." ] # [ doc = "" ] # [ doc = "@param v  horizontal skew factor to store" ] # [ link_name = "\u{1}__ZN8SkMatrix8setSkewXEf" ] pub fn SkMatrix_setSkewX ( this : * mut SkMatrix , v : SkScalar ) ; } extern "C" { # [ doc = " Sets horizontal translation." ] # [ doc = "" ] # [ doc = "@param v  horizontal translation to store" ] # [ link_name = "\u{1}__ZN8SkMatrix13setTranslateXEf" ] pub fn SkMatrix_setTranslateX ( this : * mut SkMatrix , v : SkScalar ) ; } extern "C" { # [ doc = " Sets vertical translation." ] # [ doc = "" ] # [ doc = "@param v  vertical translation to store" ] # [ link_name = "\u{1}__ZN8SkMatrix13setTranslateYEf" ] pub fn SkMatrix_setTranslateY ( this : * mut SkMatrix , v : SkScalar ) ; } extern "C" { # [ doc = " Sets input x-axis perspective factor, which causes mapXY() to vary input x-axis values" ] # [ doc = "inversely proportional to input y-axis values." ] # [ doc = "" ] # [ doc = "@param v  perspective factor" ] # [ link_name = "\u{1}__ZN8SkMatrix9setPerspXEf" ] pub fn SkMatrix_setPerspX ( this : * mut SkMatrix , v : SkScalar ) ; } extern "C" { # [ doc = " Sets input y-axis perspective factor, which causes mapXY() to vary input y-axis values" ] # [ doc = "inversely proportional to input x-axis values." ] # [ doc = "" ] # [ doc = "@param v  perspective factor" ] # [ link_name = "\u{1}__ZN8SkMatrix9setPerspYEf" ] pub fn SkMatrix_setPerspY ( this : * mut SkMatrix , v : SkScalar ) ; } extern "C" { # [ doc = " Sets all values from parameters. Sets matrix to:" ] # [ doc = "" ] # [ doc = "| scaleX  skewX transX |" ] # [ doc = "|  skewY scaleY transY |" ] # [ doc = "| persp0 persp1 persp2 |" ] # [ doc = "" ] # [ doc = "@param scaleX  horizontal scale factor to store" ] # [ doc = "@param skewX   horizontal skew factor to store" ] # [ doc = "@param transX  horizontal translation to store" ] # [ doc = "@param skewY   vertical skew factor to store" ] # [ doc = "@param scaleY  vertical scale factor to store" ] # [ doc = "@param transY  vertical translation to store" ] # [ doc = "@param persp0  input x-axis values perspective factor to store" ] # [ doc = "@param persp1  input y-axis values perspective factor to store" ] # [ doc = "@param persp2  perspective scale factor to store" ] # [ link_name = "\u{1}__ZN8SkMatrix6setAllEfffffffff" ] pub fn SkMatrix_setAll ( this : * mut SkMatrix , scaleX : SkScalar , skewX : SkScalar , transX : SkScalar , skewY : SkScalar , scaleY : SkScalar , transY : SkScalar , persp0 : SkScalar , persp1 : SkScalar , persp2 : SkScalar ) ; } extern "C" { # [ doc = " Copies nine scalar values contained by SkMatrix into buffer, in member value" ] # [ doc = "ascending order: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY," ] # [ doc = "kMPersp0, kMPersp1, kMPersp2." ] # [ doc = "" ] # [ doc = "@param buffer  storage for nine scalar values" ] # [ link_name = "\u{1}__ZNK8SkMatrix4get9EPf" ] pub fn SkMatrix_get9 ( this : * const SkMatrix , buffer : * mut SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to nine scalar values in buffer, in member value ascending order:" ] # [ doc = "kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1," ] # [ doc = "kMPersp2." ] # [ doc = "" ] # [ doc = "Sets matrix to:" ] # [ doc = "" ] # [ doc = "| buffer[0] buffer[1] buffer[2] |" ] # [ doc = "| buffer[3] buffer[4] buffer[5] |" ] # [ doc = "| buffer[6] buffer[7] buffer[8] |" ] # [ doc = "" ] # [ doc = "In the future, set9 followed by get9 may not return the same values. Since SkMatrix" ] # [ doc = "maps non-homogeneous coordinates, scaling all nine values produces an equivalent" ] # [ doc = "transformation, possibly improving precision." ] # [ doc = "" ] # [ doc = "@param buffer  nine scalar values" ] # [ link_name = "\u{1}__ZN8SkMatrix4set9EPKf" ] pub fn SkMatrix_set9 ( this : * mut SkMatrix , buffer : * const SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to identity; which has no effect on mapped SkPoint. Sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| 1 0 0 |" ] # [ doc = "| 0 1 0 |" ] # [ doc = "| 0 0 1 |" ] # [ doc = "" ] # [ doc = "Also called setIdentity(); use the one that provides better inline" ] # [ doc = "documentation." ] # [ link_name = "\u{1}__ZN8SkMatrix5resetEv" ] pub fn SkMatrix_reset ( this : * mut SkMatrix ) ; } extern "C" { # [ doc = " Sets SkMatrix to identity; which has no effect on mapped SkPoint. Sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| 1 0 0 |" ] # [ doc = "| 0 1 0 |" ] # [ doc = "| 0 0 1 |" ] # [ doc = "" ] # [ doc = "Also called reset(); use the one that provides better inline" ] # [ doc = "documentation." ] # [ link_name = "\u{1}__ZN8SkMatrix11setIdentityEv" ] pub fn SkMatrix_setIdentity ( this : * mut SkMatrix ) ; } extern "C" { # [ doc = " Sets SkMatrix to translate by (dx, dy)." ] # [ doc = "" ] # [ doc = "@param dx  horizontal translation" ] # [ doc = "@param dy  vertical translation" ] # [ link_name = "\u{1}__ZN8SkMatrix12setTranslateEff" ] pub fn SkMatrix_setTranslate ( this : * mut SkMatrix , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to translate by (v.fX, v.fY)." ] # [ doc = "" ] # [ doc = "@param v  vector containing horizontal and vertical translation" ] # [ link_name = "\u{1}__ZN8SkMatrix12setTranslateERK7SkPoint" ] pub fn SkMatrix_setTranslate1 ( this : * mut SkMatrix , v : * const SkVector ) ; } extern "C" { # [ doc = " Sets SkMatrix to scale by sx and sy, about a pivot point at (px, py)." ] # [ doc = "The pivot point is unchanged when mapped with SkMatrix." ] # [ doc = "" ] # [ doc = "@param sx  horizontal scale factor" ] # [ doc = "@param sy  vertical scale factor" ] # [ doc = "@param px  pivot on x-axis" ] # [ doc = "@param py  pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix8setScaleEffff" ] pub fn SkMatrix_setScale ( this : * mut SkMatrix , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to scale by sx and sy about at pivot point at (0, 0)." ] # [ doc = "" ] # [ doc = "@param sx  horizontal scale factor" ] # [ doc = "@param sy  vertical scale factor" ] # [ link_name = "\u{1}__ZN8SkMatrix8setScaleEff" ] pub fn SkMatrix_setScale1 ( this : * mut SkMatrix , sx : SkScalar , sy : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to rotate by degrees about a pivot point at (px, py)." ] # [ doc = "The pivot point is unchanged when mapped with SkMatrix." ] # [ doc = "" ] # [ doc = "Positive degrees rotates clockwise." ] # [ doc = "" ] # [ doc = "@param degrees  angle of axes relative to upright axes" ] # [ doc = "@param px       pivot on x-axis" ] # [ doc = "@param py       pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix9setRotateEfff" ] pub fn SkMatrix_setRotate ( this : * mut SkMatrix , degrees : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to rotate by degrees about a pivot point at (0, 0)." ] # [ doc = "Positive degrees rotates clockwise." ] # [ doc = "" ] # [ doc = "@param degrees  angle of axes relative to upright axes" ] # [ link_name = "\u{1}__ZN8SkMatrix9setRotateEf" ] pub fn SkMatrix_setRotate1 ( this : * mut SkMatrix , degrees : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to rotate by sinValue and cosValue, about a pivot point at (px, py)." ] # [ doc = "The pivot point is unchanged when mapped with SkMatrix." ] # [ doc = "" ] # [ doc = "Vector (sinValue, cosValue) describes the angle of rotation relative to (0, 1)." ] # [ doc = "Vector length specifies scale." ] # [ doc = "" ] # [ doc = "@param sinValue  rotation vector x-axis component" ] # [ doc = "@param cosValue  rotation vector y-axis component" ] # [ doc = "@param px        pivot on x-axis" ] # [ doc = "@param py        pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix9setSinCosEffff" ] pub fn SkMatrix_setSinCos ( this : * mut SkMatrix , sinValue : SkScalar , cosValue : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to rotate by sinValue and cosValue, about a pivot point at (0, 0)." ] # [ doc = "" ] # [ doc = "Vector (sinValue, cosValue) describes the angle of rotation relative to (0, 1)." ] # [ doc = "Vector length specifies scale." ] # [ doc = "" ] # [ doc = "@param sinValue  rotation vector x-axis component" ] # [ doc = "@param cosValue  rotation vector y-axis component" ] # [ link_name = "\u{1}__ZN8SkMatrix9setSinCosEff" ] pub fn SkMatrix_setSinCos1 ( this : * mut SkMatrix , sinValue : SkScalar , cosValue : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to rotate, scale, and translate using a compressed matrix form." ] # [ doc = "" ] # [ doc = "Vector (rsxForm.fSSin, rsxForm.fSCos) describes the angle of rotation relative" ] # [ doc = "to (0, 1). Vector length specifies scale. Mapped point is rotated and scaled" ] # [ doc = "by vector, then translated by (rsxForm.fTx, rsxForm.fTy)." ] # [ doc = "" ] # [ doc = "@param rsxForm  compressed SkRSXform matrix" ] # [ doc = "@return         reference to SkMatrix" ] # [ link_name = "\u{1}__ZN8SkMatrix10setRSXformERK9SkRSXform" ] pub fn SkMatrix_setRSXform ( this : * mut SkMatrix , rsxForm : * const SkRSXform ) -> * mut SkMatrix ; } extern "C" { # [ doc = " Sets SkMatrix to skew by kx and ky, about a pivot point at (px, py)." ] # [ doc = "The pivot point is unchanged when mapped with SkMatrix." ] # [ doc = "" ] # [ doc = "@param kx  horizontal skew factor" ] # [ doc = "@param ky  vertical skew factor" ] # [ doc = "@param px  pivot on x-axis" ] # [ doc = "@param py  pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix7setSkewEffff" ] pub fn SkMatrix_setSkew ( this : * mut SkMatrix , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to skew by kx and ky, about a pivot point at (0, 0)." ] # [ doc = "" ] # [ doc = "@param kx  horizontal skew factor" ] # [ doc = "@param ky  vertical skew factor" ] # [ link_name = "\u{1}__ZN8SkMatrix7setSkewEff" ] pub fn SkMatrix_setSkew1 ( this : * mut SkMatrix , kx : SkScalar , ky : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix a multiplied by SkMatrix b. Either a or b may be this." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |      | J K L |" ] # [ doc = "a = | D E F |, b = | M N O |" ] # [ doc = "| G H I |      | P Q R |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |" ] # [ doc = "a * b = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |" ] # [ doc = "| G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |" ] # [ doc = "" ] # [ doc = "@param a  SkMatrix on left side of multiply expression" ] # [ doc = "@param b  SkMatrix on right side of multiply expression" ] # [ link_name = "\u{1}__ZN8SkMatrix9setConcatERKS_S1_" ] pub fn SkMatrix_setConcat ( this : * mut SkMatrix , a : * const SkMatrix , b : * const SkMatrix ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix multiplied by SkMatrix constructed from translation (dx, dy)." ] # [ doc = "This can be thought of as moving the point to be mapped before applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |               | 1 0 dx |" ] # [ doc = "Matrix = | D E F |,  T(dx, dy) = | 0 1 dy |" ] # [ doc = "| G H I |               | 0 0  1 |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C | | 1 0 dx |   | A B A*dx+B*dy+C |" ] # [ doc = "Matrix * T(dx, dy) = | D E F | | 0 1 dy | = | D E D*dx+E*dy+F |" ] # [ doc = "| G H I | | 0 0  1 |   | G H G*dx+H*dy+I |" ] # [ doc = "" ] # [ doc = "@param dx  x-axis translation before applying SkMatrix" ] # [ doc = "@param dy  y-axis translation before applying SkMatrix" ] # [ link_name = "\u{1}__ZN8SkMatrix12preTranslateEff" ] pub fn SkMatrix_preTranslate ( this : * mut SkMatrix , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix multiplied by SkMatrix constructed from scaling by (sx, sy)" ] # [ doc = "about pivot point (px, py)." ] # [ doc = "This can be thought of as scaling about a pivot point before applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |                       | sx  0 dx |" ] # [ doc = "Matrix = | D E F |,  S(sx, sy, px, py) = |  0 sy dy |" ] # [ doc = "| G H I |                       |  0  0  1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "dx = px - sx * px" ] # [ doc = "dy = py - sy * py" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C | | sx  0 dx |   | A*sx B*sy A*dx+B*dy+C |" ] # [ doc = "Matrix * S(sx, sy, px, py) = | D E F | |  0 sy dy | = | D*sx E*sy D*dx+E*dy+F |" ] # [ doc = "| G H I | |  0  0  1 |   | G*sx H*sy G*dx+H*dy+I |" ] # [ doc = "" ] # [ doc = "@param sx  horizontal scale factor" ] # [ doc = "@param sy  vertical scale factor" ] # [ doc = "@param px  pivot on x-axis" ] # [ doc = "@param py  pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix8preScaleEffff" ] pub fn SkMatrix_preScale ( this : * mut SkMatrix , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix multiplied by SkMatrix constructed from scaling by (sx, sy)" ] # [ doc = "about pivot point (0, 0)." ] # [ doc = "This can be thought of as scaling about the origin before applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |               | sx  0  0 |" ] # [ doc = "Matrix = | D E F |,  S(sx, sy) = |  0 sy  0 |" ] # [ doc = "| G H I |               |  0  0  1 |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C | | sx  0  0 |   | A*sx B*sy C |" ] # [ doc = "Matrix * S(sx, sy) = | D E F | |  0 sy  0 | = | D*sx E*sy F |" ] # [ doc = "| G H I | |  0  0  1 |   | G*sx H*sy I |" ] # [ doc = "" ] # [ doc = "@param sx  horizontal scale factor" ] # [ doc = "@param sy  vertical scale factor" ] # [ link_name = "\u{1}__ZN8SkMatrix8preScaleEff" ] pub fn SkMatrix_preScale1 ( this : * mut SkMatrix , sx : SkScalar , sy : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix multiplied by SkMatrix constructed from rotating by degrees" ] # [ doc = "about pivot point (px, py)." ] # [ doc = "This can be thought of as rotating about a pivot point before applying SkMatrix." ] # [ doc = "" ] # [ doc = "Positive degrees rotates clockwise." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |                        | c -s dx |" ] # [ doc = "Matrix = | D E F |,  R(degrees, px, py) = | s  c dy |" ] # [ doc = "| G H I |                        | 0  0  1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "c  = cos(degrees)" ] # [ doc = "s  = sin(degrees)" ] # [ doc = "dx =  s * py + (1 - c) * px" ] # [ doc = "dy = -s * px + (1 - c) * py" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C | | c -s dx |   | Ac+Bs -As+Bc A*dx+B*dy+C |" ] # [ doc = "Matrix * R(degrees, px, py) = | D E F | | s  c dy | = | Dc+Es -Ds+Ec D*dx+E*dy+F |" ] # [ doc = "| G H I | | 0  0  1 |   | Gc+Hs -Gs+Hc G*dx+H*dy+I |" ] # [ doc = "" ] # [ doc = "@param degrees  angle of axes relative to upright axes" ] # [ doc = "@param px       pivot on x-axis" ] # [ doc = "@param py       pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix9preRotateEfff" ] pub fn SkMatrix_preRotate ( this : * mut SkMatrix , degrees : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix multiplied by SkMatrix constructed from rotating by degrees" ] # [ doc = "about pivot point (0, 0)." ] # [ doc = "This can be thought of as rotating about the origin before applying SkMatrix." ] # [ doc = "" ] # [ doc = "Positive degrees rotates clockwise." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |                        | c -s 0 |" ] # [ doc = "Matrix = | D E F |,  R(degrees, px, py) = | s  c 0 |" ] # [ doc = "| G H I |                        | 0  0 1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "c  = cos(degrees)" ] # [ doc = "s  = sin(degrees)" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C | | c -s 0 |   | Ac+Bs -As+Bc C |" ] # [ doc = "Matrix * R(degrees, px, py) = | D E F | | s  c 0 | = | Dc+Es -Ds+Ec F |" ] # [ doc = "| G H I | | 0  0 1 |   | Gc+Hs -Gs+Hc I |" ] # [ doc = "" ] # [ doc = "@param degrees  angle of axes relative to upright axes" ] # [ link_name = "\u{1}__ZN8SkMatrix9preRotateEf" ] pub fn SkMatrix_preRotate1 ( this : * mut SkMatrix , degrees : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix multiplied by SkMatrix constructed from skewing by (kx, ky)" ] # [ doc = "about pivot point (px, py)." ] # [ doc = "This can be thought of as skewing about a pivot point before applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |                       |  1 kx dx |" ] # [ doc = "Matrix = | D E F |,  K(kx, ky, px, py) = | ky  1 dy |" ] # [ doc = "| G H I |                       |  0  0  1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "dx = -kx * py" ] # [ doc = "dy = -ky * px" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C | |  1 kx dx |   | A+B*ky A*kx+B A*dx+B*dy+C |" ] # [ doc = "Matrix * K(kx, ky, px, py) = | D E F | | ky  1 dy | = | D+E*ky D*kx+E D*dx+E*dy+F |" ] # [ doc = "| G H I | |  0  0  1 |   | G+H*ky G*kx+H G*dx+H*dy+I |" ] # [ doc = "" ] # [ doc = "@param kx  horizontal skew factor" ] # [ doc = "@param ky  vertical skew factor" ] # [ doc = "@param px  pivot on x-axis" ] # [ doc = "@param py  pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix7preSkewEffff" ] pub fn SkMatrix_preSkew ( this : * mut SkMatrix , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix multiplied by SkMatrix constructed from skewing by (kx, ky)" ] # [ doc = "about pivot point (0, 0)." ] # [ doc = "This can be thought of as skewing about the origin before applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |               |  1 kx 0 |" ] # [ doc = "Matrix = | D E F |,  K(kx, ky) = | ky  1 0 |" ] # [ doc = "| G H I |               |  0  0 1 |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C | |  1 kx 0 |   | A+B*ky A*kx+B C |" ] # [ doc = "Matrix * K(kx, ky) = | D E F | | ky  1 0 | = | D+E*ky D*kx+E F |" ] # [ doc = "| G H I | |  0  0 1 |   | G+H*ky G*kx+H I |" ] # [ doc = "" ] # [ doc = "@param kx  horizontal skew factor" ] # [ doc = "@param ky  vertical skew factor" ] # [ link_name = "\u{1}__ZN8SkMatrix7preSkewEff" ] pub fn SkMatrix_preSkew1 ( this : * mut SkMatrix , kx : SkScalar , ky : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix multiplied by SkMatrix other." ] # [ doc = "This can be thought of mapping by other before applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |          | J K L |" ] # [ doc = "Matrix = | D E F |, other = | M N O |" ] # [ doc = "| G H I |          | P Q R |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |" ] # [ doc = "Matrix * other = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |" ] # [ doc = "| G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |" ] # [ doc = "" ] # [ doc = "@param other  SkMatrix on right side of multiply expression" ] # [ link_name = "\u{1}__ZN8SkMatrix9preConcatERKS_" ] pub fn SkMatrix_preConcat ( this : * mut SkMatrix , other : * const SkMatrix ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix constructed from translation (dx, dy) multiplied by SkMatrix." ] # [ doc = "This can be thought of as moving the point to be mapped after applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |               | 1 0 dx |" ] # [ doc = "Matrix = | M N O |,  T(dx, dy) = | 0 1 dy |" ] # [ doc = "| P Q R |               | 0 0  1 |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| 1 0 dx | | J K L |   | J+dx*P K+dx*Q L+dx*R |" ] # [ doc = "T(dx, dy) * Matrix = | 0 1 dy | | M N O | = | M+dy*P N+dy*Q O+dy*R |" ] # [ doc = "| 0 0  1 | | P Q R |   |      P      Q      R |" ] # [ doc = "" ] # [ doc = "@param dx  x-axis translation after applying SkMatrix" ] # [ doc = "@param dy  y-axis translation after applying SkMatrix" ] # [ link_name = "\u{1}__ZN8SkMatrix13postTranslateEff" ] pub fn SkMatrix_postTranslate ( this : * mut SkMatrix , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix constructed from scaling by (sx, sy) about pivot point" ] # [ doc = "(px, py), multiplied by SkMatrix." ] # [ doc = "This can be thought of as scaling about a pivot point after applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |                       | sx  0 dx |" ] # [ doc = "Matrix = | M N O |,  S(sx, sy, px, py) = |  0 sy dy |" ] # [ doc = "| P Q R |                       |  0  0  1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "dx = px - sx * px" ] # [ doc = "dy = py - sy * py" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| sx  0 dx | | J K L |   | sx*J+dx*P sx*K+dx*Q sx*L+dx+R |" ] # [ doc = "S(sx, sy, px, py) * Matrix = |  0 sy dy | | M N O | = | sy*M+dy*P sy*N+dy*Q sy*O+dy*R |" ] # [ doc = "|  0  0  1 | | P Q R |   |         P         Q         R |" ] # [ doc = "" ] # [ doc = "@param sx  horizontal scale factor" ] # [ doc = "@param sy  vertical scale factor" ] # [ doc = "@param px  pivot on x-axis" ] # [ doc = "@param py  pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix9postScaleEffff" ] pub fn SkMatrix_postScale ( this : * mut SkMatrix , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix constructed from scaling by (sx, sy) about pivot point" ] # [ doc = "(0, 0), multiplied by SkMatrix." ] # [ doc = "This can be thought of as scaling about the origin after applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |               | sx  0  0 |" ] # [ doc = "Matrix = | M N O |,  S(sx, sy) = |  0 sy  0 |" ] # [ doc = "| P Q R |               |  0  0  1 |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| sx  0  0 | | J K L |   | sx*J sx*K sx*L |" ] # [ doc = "S(sx, sy) * Matrix = |  0 sy  0 | | M N O | = | sy*M sy*N sy*O |" ] # [ doc = "|  0  0  1 | | P Q R |   |    P    Q    R |" ] # [ doc = "" ] # [ doc = "@param sx  horizontal scale factor" ] # [ doc = "@param sy  vertical scale factor" ] # [ link_name = "\u{1}__ZN8SkMatrix9postScaleEff" ] pub fn SkMatrix_postScale1 ( this : * mut SkMatrix , sx : SkScalar , sy : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix constructed from scaling by (1/divx, 1/divy)," ] # [ doc = "about pivot point (px, py), multiplied by SkMatrix." ] # [ doc = "" ] # [ doc = "Returns false if either divx or divy is zero." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |                   | sx  0  0 |" ] # [ doc = "Matrix = | M N O |,  I(divx, divy) = |  0 sy  0 |" ] # [ doc = "| P Q R |                   |  0  0  1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "sx = 1 / divx" ] # [ doc = "sy = 1 / divy" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| sx  0  0 | | J K L |   | sx*J sx*K sx*L |" ] # [ doc = "I(divx, divy) * Matrix = |  0 sy  0 | | M N O | = | sy*M sy*N sy*O |" ] # [ doc = "|  0  0  1 | | P Q R |   |    P    Q    R |" ] # [ doc = "" ] # [ doc = "@param divx  integer divisor for inverse scale in x" ] # [ doc = "@param divy  integer divisor for inverse scale in y" ] # [ doc = "@return      true on successful scale" ] # [ link_name = "\u{1}__ZN8SkMatrix8postIDivEii" ] pub fn SkMatrix_postIDiv ( this : * mut SkMatrix , divx : :: std :: os :: raw :: c_int , divy : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix constructed from rotating by degrees about pivot point" ] # [ doc = "(px, py), multiplied by SkMatrix." ] # [ doc = "This can be thought of as rotating about a pivot point after applying SkMatrix." ] # [ doc = "" ] # [ doc = "Positive degrees rotates clockwise." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |                        | c -s dx |" ] # [ doc = "Matrix = | M N O |,  R(degrees, px, py) = | s  c dy |" ] # [ doc = "| P Q R |                        | 0  0  1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "c  = cos(degrees)" ] # [ doc = "s  = sin(degrees)" ] # [ doc = "dx =  s * py + (1 - c) * px" ] # [ doc = "dy = -s * px + (1 - c) * py" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "|c -s dx| |J K L|   |cJ-sM+dx*P cK-sN+dx*Q cL-sO+dx+R|" ] # [ doc = "R(degrees, px, py) * Matrix = |s  c dy| |M N O| = |sJ+cM+dy*P sK+cN+dy*Q sL+cO+dy*R|" ] # [ doc = "|0  0  1| |P Q R|   |         P          Q          R|" ] # [ doc = "" ] # [ doc = "@param degrees  angle of axes relative to upright axes" ] # [ doc = "@param px       pivot on x-axis" ] # [ doc = "@param py       pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix10postRotateEfff" ] pub fn SkMatrix_postRotate ( this : * mut SkMatrix , degrees : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix constructed from rotating by degrees about pivot point" ] # [ doc = "(0, 0), multiplied by SkMatrix." ] # [ doc = "This can be thought of as rotating about the origin after applying SkMatrix." ] # [ doc = "" ] # [ doc = "Positive degrees rotates clockwise." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |                        | c -s 0 |" ] # [ doc = "Matrix = | M N O |,  R(degrees, px, py) = | s  c 0 |" ] # [ doc = "| P Q R |                        | 0  0 1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "c  = cos(degrees)" ] # [ doc = "s  = sin(degrees)" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| c -s dx | | J K L |   | cJ-sM cK-sN cL-sO |" ] # [ doc = "R(degrees, px, py) * Matrix = | s  c dy | | M N O | = | sJ+cM sK+cN sL+cO |" ] # [ doc = "| 0  0  1 | | P Q R |   |     P     Q     R |" ] # [ doc = "" ] # [ doc = "@param degrees  angle of axes relative to upright axes" ] # [ link_name = "\u{1}__ZN8SkMatrix10postRotateEf" ] pub fn SkMatrix_postRotate1 ( this : * mut SkMatrix , degrees : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix constructed from skewing by (kx, ky) about pivot point" ] # [ doc = "(px, py), multiplied by SkMatrix." ] # [ doc = "This can be thought of as skewing about a pivot point after applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |                       |  1 kx dx |" ] # [ doc = "Matrix = | M N O |,  K(kx, ky, px, py) = | ky  1 dy |" ] # [ doc = "| P Q R |                       |  0  0  1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "dx = -kx * py" ] # [ doc = "dy = -ky * px" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| 1 kx dx| |J K L|   |J+kx*M+dx*P K+kx*N+dx*Q L+kx*O+dx+R|" ] # [ doc = "K(kx, ky, px, py) * Matrix = |ky  1 dy| |M N O| = |ky*J+M+dy*P ky*K+N+dy*Q ky*L+O+dy*R|" ] # [ doc = "| 0  0  1| |P Q R|   |          P           Q           R|" ] # [ doc = "" ] # [ doc = "@param kx  horizontal skew factor" ] # [ doc = "@param ky  vertical skew factor" ] # [ doc = "@param px  pivot on x-axis" ] # [ doc = "@param py  pivot on y-axis" ] # [ link_name = "\u{1}__ZN8SkMatrix8postSkewEffff" ] pub fn SkMatrix_postSkew ( this : * mut SkMatrix , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix constructed from skewing by (kx, ky) about pivot point" ] # [ doc = "(0, 0), multiplied by SkMatrix." ] # [ doc = "This can be thought of as skewing about the origin after applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |               |  1 kx 0 |" ] # [ doc = "Matrix = | M N O |,  K(kx, ky) = | ky  1 0 |" ] # [ doc = "| P Q R |               |  0  0 1 |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "|  1 kx 0 | | J K L |   | J+kx*M K+kx*N L+kx*O |" ] # [ doc = "K(kx, ky) * Matrix = | ky  1 0 | | M N O | = | ky*J+M ky*K+N ky*L+O |" ] # [ doc = "|  0  0 1 | | P Q R |   |      P      Q      R |" ] # [ doc = "" ] # [ doc = "@param kx  horizontal skew factor" ] # [ doc = "@param ky  vertical skew factor" ] # [ link_name = "\u{1}__ZN8SkMatrix8postSkewEff" ] pub fn SkMatrix_postSkew1 ( this : * mut SkMatrix , kx : SkScalar , ky : SkScalar ) ; } extern "C" { # [ doc = " Sets SkMatrix to SkMatrix other multiplied by SkMatrix." ] # [ doc = "This can be thought of mapping by other after applying SkMatrix." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| J K L |           | A B C |" ] # [ doc = "Matrix = | M N O |,  other = | D E F |" ] # [ doc = "| P Q R |           | G H I |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |" ] # [ doc = "other * Matrix = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |" ] # [ doc = "| G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |" ] # [ doc = "" ] # [ doc = "@param other  SkMatrix on left side of multiply expression" ] # [ link_name = "\u{1}__ZN8SkMatrix10postConcatERKS_" ] pub fn SkMatrix_postConcat ( this : * mut SkMatrix , other : * const SkMatrix ) ; } extern "C" { # [ doc = " Sets SkMatrix to scale and translate src SkRect to dst SkRect. stf selects whether" ] # [ doc = "mapping completely fills dst or preserves the aspect ratio, and how to align" ] # [ doc = "src within dst. Returns false if src is empty, and sets SkMatrix to identity." ] # [ doc = "Returns true if dst is empty, and sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| 0 0 0 |" ] # [ doc = "| 0 0 0 |" ] # [ doc = "| 0 0 1 |" ] # [ doc = "" ] # [ doc = "@param src  SkRect to map from" ] # [ doc = "@param dst  SkRect to map to" ] # [ doc = "@param stf  one of: kFill_ScaleToFit, kStart_ScaleToFit," ] # [ doc = "kCenter_ScaleToFit, kEnd_ScaleToFit" ] # [ doc = "@return     true if SkMatrix can represent SkRect mapping" ] # [ link_name = "\u{1}__ZN8SkMatrix13setRectToRectERK6SkRectS2_NS_10ScaleToFitE" ] pub fn SkMatrix_setRectToRect ( this : * mut SkMatrix , src : * const SkRect , dst : * const SkRect , stf : SkMatrix_ScaleToFit ) -> bool ; } extern "C" { # [ doc = " Returns SkMatrix set to scale and translate src SkRect to dst SkRect. stf selects" ] # [ doc = "whether mapping completely fills dst or preserves the aspect ratio, and how to" ] # [ doc = "align src within dst. Returns the identity SkMatrix if src is empty. If dst is" ] # [ doc = "empty, returns SkMatrix set to:" ] # [ doc = "" ] # [ doc = "| 0 0 0 |" ] # [ doc = "| 0 0 0 |" ] # [ doc = "| 0 0 1 |" ] # [ doc = "" ] # [ doc = "@param src  SkRect to map from" ] # [ doc = "@param dst  SkRect to map to" ] # [ doc = "@param stf  one of: kFill_ScaleToFit, kStart_ScaleToFit," ] # [ doc = "kCenter_ScaleToFit, kEnd_ScaleToFit" ] # [ doc = "@return     SkMatrix mapping src to dst" ] # [ link_name = "\u{1}__ZN8SkMatrix14MakeRectToRectERK6SkRectS2_NS_10ScaleToFitE" ] pub fn SkMatrix_MakeRectToRect ( src : * const SkRect , dst : * const SkRect , stf : SkMatrix_ScaleToFit ) -> SkMatrix ; } extern "C" { # [ doc = " Sets SkMatrix to map src to dst. count must be zero or greater, and four or less." ] # [ doc = "" ] # [ doc = "If count is zero, sets SkMatrix to identity and returns true." ] # [ doc = "If count is one, sets SkMatrix to translate and returns true." ] # [ doc = "If count is two or more, sets SkMatrix to map SkPoint if possible; returns false" ] # [ doc = "if SkMatrix cannot be constructed. If count is four, SkMatrix may include" ] # [ doc = "perspective." ] # [ doc = "" ] # [ doc = "@param src    SkPoint to map from" ] # [ doc = "@param dst    SkPoint to map to" ] # [ doc = "@param count  number of SkPoint in src and dst" ] # [ doc = "@return       true if SkMatrix was constructed successfully" ] # [ link_name = "\u{1}__ZN8SkMatrix13setPolyToPolyEPK7SkPointS2_i" ] pub fn SkMatrix_setPolyToPoly ( this : * mut SkMatrix , src : * const SkPoint , dst : * const SkPoint , count : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Sets inverse to reciprocal matrix, returning true if SkMatrix can be inverted." ] # [ doc = "Geometrically, if SkMatrix maps from source to destination, inverse SkMatrix" ] # [ doc = "maps from destination to source. If SkMatrix can not be inverted, inverse is" ] # [ doc = "unchanged." ] # [ doc = "" ] # [ doc = "@param inverse  storage for inverted SkMatrix; may be nullptr" ] # [ doc = "@return         true if SkMatrix can be inverted" ] # [ link_name = "\u{1}__ZNK8SkMatrix6invertEPS_" ] pub fn SkMatrix_invert ( this : * const SkMatrix , inverse : * mut SkMatrix ) -> bool ; } extern "C" { # [ doc = " Fills affine with identity values in column major order." ] # [ doc = "Sets affine to:" ] # [ doc = "" ] # [ doc = "| 1 0 0 |" ] # [ doc = "| 0 1 0 |" ] # [ doc = "" ] # [ doc = "Affine 3 by 2 matrices in column major order are used by OpenGL and XPS." ] # [ doc = "" ] # [ doc = "@param affine  storage for 3 by 2 affine matrix" ] # [ link_name = "\u{1}__ZN8SkMatrix17SetAffineIdentityEPf" ] pub fn SkMatrix_SetAffineIdentity ( affine : * mut SkScalar ) ; } extern "C" { # [ doc = " Fills affine in column major order. Sets affine to:" ] # [ doc = "" ] # [ doc = "| scale-x  skew-x translate-x |" ] # [ doc = "| skew-y  scale-y translate-y |" ] # [ doc = "" ] # [ doc = "If SkMatrix contains perspective, returns false and leaves affine unchanged." ] # [ doc = "" ] # [ doc = "@param affine  storage for 3 by 2 affine matrix; may be nullptr" ] # [ doc = "@return        true if SkMatrix does not contain perspective" ] # [ link_name = "\u{1}__ZNK8SkMatrix8asAffineEPf" ] pub fn SkMatrix_asAffine ( this : * const SkMatrix , affine : * mut SkScalar ) -> bool ; } extern "C" { # [ doc = " Sets SkMatrix to affine values, passed in column major order. Given affine," ] # [ doc = "column, then row, as:" ] # [ doc = "" ] # [ doc = "| scale-x  skew-x translate-x |" ] # [ doc = "|  skew-y scale-y translate-y |" ] # [ doc = "" ] # [ doc = "SkMatrix is set, row, then column, to:" ] # [ doc = "" ] # [ doc = "| scale-x  skew-x translate-x |" ] # [ doc = "|  skew-y scale-y translate-y |" ] # [ doc = "|       0       0           1 |" ] # [ doc = "" ] # [ doc = "@param affine  3 by 2 affine matrix" ] # [ link_name = "\u{1}__ZN8SkMatrix9setAffineEPKf" ] pub fn SkMatrix_setAffine ( this : * mut SkMatrix , affine : * const SkScalar ) ; } extern "C" { # [ doc = " Maps src SkPoint array of length count to dst SkPoint array of equal or greater" ] # [ doc = "length. SkPoint are mapped by multiplying each SkPoint by SkMatrix. Given:" ] # [ doc = "" ] # [ doc = "| A B C |        | x |" ] # [ doc = "Matrix = | D E F |,  pt = | y |" ] # [ doc = "| G H I |        | 1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "for (i = 0; i < count; ++i) {" ] # [ doc = "x = src[i].fX" ] # [ doc = "y = src[i].fY" ] # [ doc = "}" ] # [ doc = "" ] # [ doc = "each dst SkPoint is computed as:" ] # [ doc = "" ] # [ doc = "|A B C| |x|                               Ax+By+C   Dx+Ey+F" ] # [ doc = "Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------" ] # [ doc = "|G H I| |1|                               Gx+Hy+I   Gx+Hy+I" ] # [ doc = "" ] # [ doc = "src and dst may point to the same storage." ] # [ doc = "" ] # [ doc = "@param dst    storage for mapped SkPoint" ] # [ doc = "@param src    SkPoint to transform" ] # [ doc = "@param count  number of SkPoint to transform" ] # [ link_name = "\u{1}__ZNK8SkMatrix9mapPointsEP7SkPointPKS0_i" ] pub fn SkMatrix_mapPoints ( this : * const SkMatrix , dst : * mut SkPoint , src : * const SkPoint , count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Maps pts SkPoint array of length count in place. SkPoint are mapped by multiplying" ] # [ doc = "each SkPoint by SkMatrix. Given:" ] # [ doc = "" ] # [ doc = "| A B C |        | x |" ] # [ doc = "Matrix = | D E F |,  pt = | y |" ] # [ doc = "| G H I |        | 1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "for (i = 0; i < count; ++i) {" ] # [ doc = "x = pts[i].fX" ] # [ doc = "y = pts[i].fY" ] # [ doc = "}" ] # [ doc = "" ] # [ doc = "each resulting pts SkPoint is computed as:" ] # [ doc = "" ] # [ doc = "|A B C| |x|                               Ax+By+C   Dx+Ey+F" ] # [ doc = "Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------" ] # [ doc = "|G H I| |1|                               Gx+Hy+I   Gx+Hy+I" ] # [ doc = "" ] # [ doc = "@param pts    storage for mapped SkPoint" ] # [ doc = "@param count  number of SkPoint to transform" ] # [ link_name = "\u{1}__ZNK8SkMatrix9mapPointsEP7SkPointi" ] pub fn SkMatrix_mapPoints1 ( this : * const SkMatrix , pts : * mut SkPoint , count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Maps src SkPoint3 array of length count to dst SkPoint3 array, which must of length count or" ] # [ doc = "greater. SkPoint3 array is mapped by multiplying each SkPoint3 by SkMatrix. Given:" ] # [ doc = "" ] # [ doc = "| A B C |         | x |" ] # [ doc = "Matrix = | D E F |,  src = | y |" ] # [ doc = "| G H I |         | z |" ] # [ doc = "" ] # [ doc = "each resulting dst SkPoint is computed as:" ] # [ doc = "" ] # [ doc = "|A B C| |x|" ] # [ doc = "Matrix * src = |D E F| |y| = |Ax+By+Cz Dx+Ey+Fz Gx+Hy+Iz|" ] # [ doc = "|G H I| |z|" ] # [ doc = "" ] # [ doc = "@param dst    storage for mapped SkPoint3 array" ] # [ doc = "@param src    SkPoint3 array to transform" ] # [ doc = "@param count  items in SkPoint3 array to transform" ] # [ link_name = "\u{1}__ZNK8SkMatrix20mapHomogeneousPointsEP8SkPoint3PKS0_i" ] pub fn SkMatrix_mapHomogeneousPoints ( this : * const SkMatrix , dst : * mut SkPoint3 , src : * const SkPoint3 , count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Maps SkPoint (x, y) to result. SkPoint is mapped by multiplying by SkMatrix. Given:" ] # [ doc = "" ] # [ doc = "| A B C |        | x |" ] # [ doc = "Matrix = | D E F |,  pt = | y |" ] # [ doc = "| G H I |        | 1 |" ] # [ doc = "" ] # [ doc = "result is computed as:" ] # [ doc = "" ] # [ doc = "|A B C| |x|                               Ax+By+C   Dx+Ey+F" ] # [ doc = "Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------" ] # [ doc = "|G H I| |1|                               Gx+Hy+I   Gx+Hy+I" ] # [ doc = "" ] # [ doc = "@param x       x-axis value of SkPoint to map" ] # [ doc = "@param y       y-axis value of SkPoint to map" ] # [ doc = "@param result  storage for mapped SkPoint" ] # [ link_name = "\u{1}__ZNK8SkMatrix5mapXYEffP7SkPoint" ] pub fn SkMatrix_mapXY ( this : * const SkMatrix , x : SkScalar , y : SkScalar , result : * mut SkPoint ) ; } extern "C" { # [ doc = " Returns SkPoint (x, y) multiplied by SkMatrix. Given:" ] # [ doc = "" ] # [ doc = "| A B C |        | x |" ] # [ doc = "Matrix = | D E F |,  pt = | y |" ] # [ doc = "| G H I |        | 1 |" ] # [ doc = "" ] # [ doc = "result is computed as:" ] # [ doc = "" ] # [ doc = "|A B C| |x|                               Ax+By+C   Dx+Ey+F" ] # [ doc = "Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------" ] # [ doc = "|G H I| |1|                               Gx+Hy+I   Gx+Hy+I" ] # [ doc = "" ] # [ doc = "@param x  x-axis value of SkPoint to map" ] # [ doc = "@param y  y-axis value of SkPoint to map" ] # [ doc = "@return   mapped SkPoint" ] # [ link_name = "\u{1}__ZNK8SkMatrix5mapXYEff" ] pub fn SkMatrix_mapXY1 ( this : * const SkMatrix , x : SkScalar , y : SkScalar ) -> SkPoint ; } extern "C" { # [ doc = " Maps src vector array of length count to vector SkPoint array of equal or greater" ] # [ doc = "length. Vectors are mapped by multiplying each vector by SkMatrix, treating" ] # [ doc = "SkMatrix translation as zero. Given:" ] # [ doc = "" ] # [ doc = "| A B 0 |         | x |" ] # [ doc = "Matrix = | D E 0 |,  src = | y |" ] # [ doc = "| G H I |         | 1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "for (i = 0; i < count; ++i) {" ] # [ doc = "x = src[i].fX" ] # [ doc = "y = src[i].fY" ] # [ doc = "}" ] # [ doc = "" ] # [ doc = "each dst vector is computed as:" ] # [ doc = "" ] # [ doc = "|A B 0| |x|                            Ax+By     Dx+Ey" ] # [ doc = "Matrix * src = |D E 0| |y| = |Ax+By Dx+Ey Gx+Hy+I| = ------- , -------" ] # [ doc = "|G H I| |1|                           Gx+Hy+I   Gx+Hy+I" ] # [ doc = "" ] # [ doc = "src and dst may point to the same storage." ] # [ doc = "" ] # [ doc = "@param dst    storage for mapped vectors" ] # [ doc = "@param src    vectors to transform" ] # [ doc = "@param count  number of vectors to transform" ] # [ link_name = "\u{1}__ZNK8SkMatrix10mapVectorsEP7SkPointPKS0_i" ] pub fn SkMatrix_mapVectors ( this : * const SkMatrix , dst : * mut SkVector , src : * const SkVector , count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Maps vecs vector array of length count in place, multiplying each vector by" ] # [ doc = "SkMatrix, treating SkMatrix translation as zero. Given:" ] # [ doc = "" ] # [ doc = "| A B 0 |         | x |" ] # [ doc = "Matrix = | D E 0 |,  vec = | y |" ] # [ doc = "| G H I |         | 1 |" ] # [ doc = "" ] # [ doc = "where" ] # [ doc = "" ] # [ doc = "for (i = 0; i < count; ++i) {" ] # [ doc = "x = vecs[i].fX" ] # [ doc = "y = vecs[i].fY" ] # [ doc = "}" ] # [ doc = "" ] # [ doc = "each result vector is computed as:" ] # [ doc = "" ] # [ doc = "|A B 0| |x|                            Ax+By     Dx+Ey" ] # [ doc = "Matrix * vec = |D E 0| |y| = |Ax+By Dx+Ey Gx+Hy+I| = ------- , -------" ] # [ doc = "|G H I| |1|                           Gx+Hy+I   Gx+Hy+I" ] # [ doc = "" ] # [ doc = "@param vecs   vectors to transform, and storage for mapped vectors" ] # [ doc = "@param count  number of vectors to transform" ] # [ link_name = "\u{1}__ZNK8SkMatrix10mapVectorsEP7SkPointi" ] pub fn SkMatrix_mapVectors1 ( this : * const SkMatrix , vecs : * mut SkVector , count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Maps vector (dx, dy) to result. Vector is mapped by multiplying by SkMatrix," ] # [ doc = "treating SkMatrix translation as zero. Given:" ] # [ doc = "" ] # [ doc = "| A B 0 |         | dx |" ] # [ doc = "Matrix = | D E 0 |,  vec = | dy |" ] # [ doc = "| G H I |         |  1 |" ] # [ doc = "" ] # [ doc = "each result vector is computed as:" ] # [ doc = "" ] # [ doc = "|A B 0| |dx|                                        A*dx+B*dy     D*dx+E*dy" ] # [ doc = "Matrix * vec = |D E 0| |dy| = |A*dx+B*dy D*dx+E*dy G*dx+H*dy+I| = ----------- , -----------" ] # [ doc = "|G H I| | 1|                                       G*dx+H*dy+I   G*dx+*dHy+I" ] # [ doc = "" ] # [ doc = "@param dx      x-axis value of vector to map" ] # [ doc = "@param dy      y-axis value of vector to map" ] # [ doc = "@param result  storage for mapped vector" ] # [ link_name = "\u{1}__ZNK8SkMatrix9mapVectorEffP7SkPoint" ] pub fn SkMatrix_mapVector ( this : * const SkMatrix , dx : SkScalar , dy : SkScalar , result : * mut SkVector ) ; } extern "C" { # [ doc = " Returns vector (dx, dy) multiplied by SkMatrix, treating SkMatrix translation as zero." ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B 0 |         | dx |" ] # [ doc = "Matrix = | D E 0 |,  vec = | dy |" ] # [ doc = "| G H I |         |  1 |" ] # [ doc = "" ] # [ doc = "each result vector is computed as:" ] # [ doc = "" ] # [ doc = "|A B 0| |dx|                                        A*dx+B*dy     D*dx+E*dy" ] # [ doc = "Matrix * vec = |D E 0| |dy| = |A*dx+B*dy D*dx+E*dy G*dx+H*dy+I| = ----------- , -----------" ] # [ doc = "|G H I| | 1|                                       G*dx+H*dy+I   G*dx+*dHy+I" ] # [ doc = "" ] # [ doc = "@param dx  x-axis value of vector to map" ] # [ doc = "@param dy  y-axis value of vector to map" ] # [ doc = "@return    mapped vector" ] # [ link_name = "\u{1}__ZNK8SkMatrix9mapVectorEff" ] pub fn SkMatrix_mapVector1 ( this : * const SkMatrix , dx : SkScalar , dy : SkScalar ) -> SkVector ; } extern "C" { # [ doc = " Sets dst to bounds of src corners mapped by SkMatrix." ] # [ doc = "Returns true if mapped corners are dst corners." ] # [ doc = "" ] # [ doc = "Returned value is the same as calling rectStaysRect()." ] # [ doc = "" ] # [ doc = "@param dst  storage for bounds of mapped SkPoint" ] # [ doc = "@param src  SkRect to map" ] # [ doc = "@return     true if dst is equivalent to mapped src" ] # [ link_name = "\u{1}__ZNK8SkMatrix7mapRectEP6SkRectRKS0_" ] pub fn SkMatrix_mapRect ( this : * const SkMatrix , dst : * mut SkRect , src : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Sets rect to bounds of rect corners mapped by SkMatrix." ] # [ doc = "Returns true if mapped corners are computed rect corners." ] # [ doc = "" ] # [ doc = "Returned value is the same as calling rectStaysRect()." ] # [ doc = "" ] # [ doc = "@param rect  rectangle to map, and storage for bounds of mapped corners" ] # [ doc = "@return      true if result is equivalent to mapped rect" ] # [ link_name = "\u{1}__ZNK8SkMatrix7mapRectEP6SkRect" ] pub fn SkMatrix_mapRect1 ( this : * const SkMatrix , rect : * mut SkRect ) -> bool ; } extern "C" { # [ doc = " Returns bounds of src corners mapped by SkMatrix." ] # [ doc = "" ] # [ doc = "@param src  rectangle to map" ] # [ doc = "@return     mapped bounds" ] # [ link_name = "\u{1}__ZNK8SkMatrix7mapRectERK6SkRect" ] pub fn SkMatrix_mapRect2 ( this : * const SkMatrix , src : * const SkRect ) -> SkRect ; } extern "C" { # [ doc = " Maps four corners of rect to dst. SkPoint are mapped by multiplying each" ] # [ doc = "rect corner by SkMatrix. rect corner is processed in this order:" ] # [ doc = "(rect.fLeft, rect.fTop), (rect.fRight, rect.fTop), (rect.fRight, rect.fBottom)," ] # [ doc = "(rect.fLeft, rect.fBottom)." ] # [ doc = "" ] # [ doc = "rect may be empty: rect.fLeft may be greater than or equal to rect.fRight;" ] # [ doc = "rect.fTop may be greater than or equal to rect.fBottom." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |        | x |" ] # [ doc = "Matrix = | D E F |,  pt = | y |" ] # [ doc = "| G H I |        | 1 |" ] # [ doc = "" ] # [ doc = "where pt is initialized from each of (rect.fLeft, rect.fTop)," ] # [ doc = "(rect.fRight, rect.fTop), (rect.fRight, rect.fBottom), (rect.fLeft, rect.fBottom)," ] # [ doc = "each dst SkPoint is computed as:" ] # [ doc = "" ] # [ doc = "|A B C| |x|                               Ax+By+C   Dx+Ey+F" ] # [ doc = "Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------" ] # [ doc = "|G H I| |1|                               Gx+Hy+I   Gx+Hy+I" ] # [ doc = "" ] # [ doc = "@param dst   storage for mapped corner SkPoint" ] # [ doc = "@param rect  SkRect to map" ] # [ link_name = "\u{1}__ZNK8SkMatrix13mapRectToQuadEP7SkPointRK6SkRect" ] pub fn SkMatrix_mapRectToQuad ( this : * const SkMatrix , dst : * mut SkPoint , rect : * const SkRect ) ; } extern "C" { # [ doc = " Sets dst to bounds of src corners mapped by SkMatrix. If matrix contains" ] # [ doc = "elements other than scale or translate: asserts if SK_DEBUG is defined;" ] # [ doc = "otherwise, results are undefined." ] # [ doc = "" ] # [ doc = "@param dst  storage for bounds of mapped SkPoint" ] # [ doc = "@param src  SkRect to map" ] # [ link_name = "\u{1}__ZNK8SkMatrix21mapRectScaleTranslateEP6SkRectRKS0_" ] pub fn SkMatrix_mapRectScaleTranslate ( this : * const SkMatrix , dst : * mut SkRect , src : * const SkRect ) ; } extern "C" { # [ doc = " Returns geometric mean radius of ellipse formed by constructing circle of" ] # [ doc = "size radius, and mapping constructed circle with SkMatrix. The result squared is" ] # [ doc = "equal to the major axis length times the minor axis length." ] # [ doc = "Result is not meaningful if SkMatrix contains perspective elements." ] # [ doc = "" ] # [ doc = "@param radius  circle size to map" ] # [ doc = "@return        average mapped radius" ] # [ link_name = "\u{1}__ZNK8SkMatrix9mapRadiusEf" ] pub fn SkMatrix_mapRadius ( this : * const SkMatrix , radius : SkScalar ) -> SkScalar ; } extern "C" { # [ doc = " Returns true if a unit step on x-axis at some y-axis value mapped through SkMatrix" ] # [ doc = "can be represented by a constant vector. Returns true if getType() returns" ] # [ doc = "kIdentity_Mask, or combinations of: kTranslate_Mask, kScale_Mask, and kAffine_Mask." ] # [ doc = "" ] # [ doc = "May return true if getType() returns kPerspective_Mask, but only when SkMatrix" ] # [ doc = "does not include rotation or skewing along the y-axis." ] # [ doc = "" ] # [ doc = "@return  true if SkMatrix does not have complex perspective" ] # [ link_name = "\u{1}__ZNK8SkMatrix14isFixedStepInXEv" ] pub fn SkMatrix_isFixedStepInX ( this : * const SkMatrix ) -> bool ; } extern "C" { # [ doc = " Returns vector representing a unit step on x-axis at y mapped through SkMatrix." ] # [ doc = "If isFixedStepInX() is false, returned value is undefined." ] # [ doc = "" ] # [ doc = "@param y  position of line parallel to x-axis" ] # [ doc = "@return   vector advance of mapped unit step on x-axis" ] # [ link_name = "\u{1}__ZNK8SkMatrix12fixedStepInXEf" ] pub fn SkMatrix_fixedStepInX ( this : * const SkMatrix , y : SkScalar ) -> SkVector ; } extern "C" { # [ doc = " Returns true if SkMatrix equals m, using an efficient comparison." ] # [ doc = "" ] # [ doc = "Returns false when the sign of zero values is the different; when one" ] # [ doc = "matrix has positive zero value and the other has negative zero value." ] # [ doc = "" ] # [ doc = "Returns true even when both SkMatrix contain NaN." ] # [ doc = "" ] # [ doc = "NaN never equals any value, including itself. To improve performance, NaN values" ] # [ doc = "are treated as bit patterns that are equal if their bit patterns are equal." ] # [ doc = "" ] # [ doc = "@param m  SkMatrix to compare" ] # [ doc = "@return   true if m and SkMatrix are represented by identical bit patterns" ] # [ link_name = "\u{1}__ZNK8SkMatrix12cheapEqualToERKS_" ] pub fn SkMatrix_cheapEqualTo ( this : * const SkMatrix , m : * const SkMatrix ) -> bool ; } extern "C" { # [ doc = " Writes text representation of SkMatrix to standard output. Floating point values" ] # [ doc = "are written with limited precision; it may not be possible to reconstruct" ] # [ doc = "original SkMatrix from output." ] # [ link_name = "\u{1}__ZNK8SkMatrix4dumpEv" ] pub fn SkMatrix_dump ( this : * const SkMatrix ) ; } extern "C" { # [ doc = " Returns the minimum scaling factor of SkMatrix by decomposing the scaling and" ] # [ doc = "skewing elements." ] # [ doc = "Returns -1 if scale factor overflows or SkMatrix contains perspective." ] # [ doc = "" ] # [ doc = "@return  minimum scale factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix11getMinScaleEv" ] pub fn SkMatrix_getMinScale ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Returns the maximum scaling factor of SkMatrix by decomposing the scaling and" ] # [ doc = "skewing elements." ] # [ doc = "Returns -1 if scale factor overflows or SkMatrix contains perspective." ] # [ doc = "" ] # [ doc = "@return  maximum scale factor" ] # [ link_name = "\u{1}__ZNK8SkMatrix11getMaxScaleEv" ] pub fn SkMatrix_getMaxScale ( this : * const SkMatrix ) -> SkScalar ; } extern "C" { # [ doc = " Sets scaleFactors[0] to the minimum scaling factor, and scaleFactors[1] to the" ] # [ doc = "maximum scaling factor. Scaling factors are computed by decomposing" ] # [ doc = "the SkMatrix scaling and skewing elements." ] # [ doc = "" ] # [ doc = "Returns true if scaleFactors are found; otherwise, returns false and sets" ] # [ doc = "scaleFactors to undefined values." ] # [ doc = "" ] # [ doc = "@param scaleFactors  storage for minimum and maximum scale factors" ] # [ doc = "@return              true if scale factors were computed correctly" ] # [ link_name = "\u{1}__ZNK8SkMatrix15getMinMaxScalesEPf" ] pub fn SkMatrix_getMinMaxScales ( this : * const SkMatrix , scaleFactors : * mut SkScalar ) -> bool ; } extern "C" { # [ doc = " Decomposes SkMatrix into scale components and whatever remains. Returns false if" ] # [ doc = "SkMatrix could not be decomposed." ] # [ doc = "" ] # [ doc = "Sets scale to portion of SkMatrix that scale axes. Sets remaining to SkMatrix" ] # [ doc = "with scaling factored out. remaining may be passed as nullptr" ] # [ doc = "to determine if SkMatrix can be decomposed without computing remainder." ] # [ doc = "" ] # [ doc = "Returns true if scale components are found. scale and remaining are" ] # [ doc = "unchanged if SkMatrix contains perspective; scale factors are not finite, or" ] # [ doc = "are nearly zero." ] # [ doc = "" ] # [ doc = "On success: Matrix = scale * Remaining." ] # [ doc = "" ] # [ doc = "@param scale      axes scaling factors; may be nullptr" ] # [ doc = "@param remaining  SkMatrix without scaling; may be nullptr" ] # [ doc = "@return           true if scale can be computed" ] # [ link_name = "\u{1}__ZNK8SkMatrix14decomposeScaleEP6SkSizePS_" ] pub fn SkMatrix_decomposeScale ( this : * const SkMatrix , scale : * mut SkSize , remaining : * mut SkMatrix ) -> bool ; } extern "C" { # [ doc = " Returns reference to const identity SkMatrix. Returned SkMatrix is set to:" ] # [ doc = "" ] # [ doc = "| 1 0 0 |" ] # [ doc = "| 0 1 0 |" ] # [ doc = "| 0 0 1 |" ] # [ doc = "" ] # [ doc = "@return  const identity SkMatrix" ] # [ link_name = "\u{1}__ZN8SkMatrix1IEv" ] pub fn SkMatrix_I ( ) -> * const SkMatrix ; } extern "C" { # [ doc = " Returns reference to a const SkMatrix with invalid values. Returned SkMatrix is set" ] # [ doc = "to:" ] # [ doc = "" ] # [ doc = "| SK_ScalarMax SK_ScalarMax SK_ScalarMax |" ] # [ doc = "| SK_ScalarMax SK_ScalarMax SK_ScalarMax |" ] # [ doc = "| SK_ScalarMax SK_ScalarMax SK_ScalarMax |" ] # [ doc = "" ] # [ doc = "@return  const invalid SkMatrix" ] # [ link_name = "\u{1}__ZN8SkMatrix13InvalidMatrixEv" ] pub fn SkMatrix_InvalidMatrix ( ) -> * const SkMatrix ; } extern "C" { # [ doc = " Returns SkMatrix a multiplied by SkMatrix b." ] # [ doc = "" ] # [ doc = "Given:" ] # [ doc = "" ] # [ doc = "| A B C |      | J K L |" ] # [ doc = "a = | D E F |, b = | M N O |" ] # [ doc = "| G H I |      | P Q R |" ] # [ doc = "" ] # [ doc = "sets SkMatrix to:" ] # [ doc = "" ] # [ doc = "| A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |" ] # [ doc = "a * b = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |" ] # [ doc = "| G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |" ] # [ doc = "" ] # [ doc = "@param a  SkMatrix on left side of multiply expression" ] # [ doc = "@param b  SkMatrix on right side of multiply expression" ] # [ doc = "@return   SkMatrix computed from a times b" ] # [ link_name = "\u{1}__ZN8SkMatrix6ConcatERKS_S1_" ] pub fn SkMatrix_Concat ( a : * const SkMatrix , b : * const SkMatrix ) -> SkMatrix ; } extern "C" { # [ doc = " Sets internal cache to unknown state. Use to force update after repeated" ] # [ doc = "modifications to SkMatrix element reference returned by operator[](int index)." ] # [ link_name = "\u{1}__ZN8SkMatrix20dirtyMatrixTypeCacheEv" ] pub fn SkMatrix_dirtyMatrixTypeCache ( this : * mut SkMatrix ) ; } extern "C" { # [ doc = " Initializes SkMatrix with scale and translate elements." ] # [ doc = "" ] # [ doc = "| sx  0 tx |" ] # [ doc = "|  0 sy ty |" ] # [ doc = "|  0  0  1 |" ] # [ doc = "" ] # [ doc = "@param sx  horizontal scale factor to store" ] # [ doc = "@param sy  vertical scale factor to store" ] # [ doc = "@param tx  horizontal translation to store" ] # [ doc = "@param ty  vertical translation to store" ] # [ link_name = "\u{1}__ZN8SkMatrix17setScaleTranslateEffff" ] pub fn SkMatrix_setScaleTranslate ( this : * mut SkMatrix , sx : SkScalar , sy : SkScalar , tx : SkScalar , ty : SkScalar ) ; } extern "C" { # [ doc = " Returns true if all elements of the matrix are finite. Returns false if any" ] # [ doc = "element is infinity, or NaN." ] # [ doc = "" ] # [ doc = "@return  true if matrix has only finite elements" ] # [ link_name = "\u{1}__ZNK8SkMatrix8isFiniteEv" ] pub fn SkMatrix_isFinite ( this : * const SkMatrix ) -> bool ; } impl SkMatrix { # [ inline ] pub unsafe fn MakeScale ( sx : SkScalar , sy : SkScalar ) -> SkMatrix { SkMatrix_MakeScale ( sx , sy ) } # [ inline ] pub unsafe fn MakeScale1 ( scale : SkScalar ) -> SkMatrix { SkMatrix_MakeScale1 ( scale ) } # [ inline ] pub unsafe fn MakeTrans ( dx : SkScalar , dy : SkScalar ) -> SkMatrix { SkMatrix_MakeTrans ( dx , dy ) } # [ inline ] pub unsafe fn MakeAll ( scaleX : SkScalar , skewX : SkScalar , transX : SkScalar , skewY : SkScalar , scaleY : SkScalar , transY : SkScalar , pers0 : SkScalar , pers1 : SkScalar , pers2 : SkScalar ) -> SkMatrix { SkMatrix_MakeAll ( scaleX , skewX , transX , skewY , scaleY , transY , pers0 , pers1 , pers2 ) } # [ inline ] pub unsafe fn getType ( & self ) -> SkMatrix_TypeMask { SkMatrix_getType ( self ) } # [ inline ] pub unsafe fn isIdentity ( & self ) -> bool { SkMatrix_isIdentity ( self ) } # [ inline ] pub unsafe fn isScaleTranslate ( & self ) -> bool { SkMatrix_isScaleTranslate ( self ) } # [ inline ] pub unsafe fn isTranslate ( & self ) -> bool { SkMatrix_isTranslate ( self ) } # [ inline ] pub unsafe fn rectStaysRect ( & self ) -> bool { SkMatrix_rectStaysRect ( self ) } # [ inline ] pub unsafe fn preservesAxisAlignment ( & self ) -> bool { SkMatrix_preservesAxisAlignment ( self ) } # [ inline ] pub unsafe fn hasPerspective ( & self ) -> bool { SkMatrix_hasPerspective ( self ) } # [ inline ] pub unsafe fn isSimilarity ( & self , tol : SkScalar ) -> bool { SkMatrix_isSimilarity ( self , tol ) } # [ inline ] pub unsafe fn preservesRightAngles ( & self , tol : SkScalar ) -> bool { SkMatrix_preservesRightAngles ( self , tol ) } # [ inline ] pub unsafe fn get ( & self , index : :: std :: os :: raw :: c_int ) -> SkScalar { SkMatrix_get ( self , index ) } # [ inline ] pub unsafe fn getScaleX ( & self ) -> SkScalar { SkMatrix_getScaleX ( self ) } # [ inline ] pub unsafe fn getScaleY ( & self ) -> SkScalar { SkMatrix_getScaleY ( self ) } # [ inline ] pub unsafe fn getSkewY ( & self ) -> SkScalar { SkMatrix_getSkewY ( self ) } # [ inline ] pub unsafe fn getSkewX ( & self ) -> SkScalar { SkMatrix_getSkewX ( self ) } # [ inline ] pub unsafe fn getTranslateX ( & self ) -> SkScalar { SkMatrix_getTranslateX ( self ) } # [ inline ] pub unsafe fn getTranslateY ( & self ) -> SkScalar { SkMatrix_getTranslateY ( self ) } # [ inline ] pub unsafe fn getPerspX ( & self ) -> SkScalar { SkMatrix_getPerspX ( self ) } # [ inline ] pub unsafe fn getPerspY ( & self ) -> SkScalar { SkMatrix_getPerspY ( self ) } # [ inline ] pub unsafe fn set ( & mut self , index : :: std :: os :: raw :: c_int , value : SkScalar ) { SkMatrix_set ( self , index , value ) } # [ inline ] pub unsafe fn setScaleX ( & mut self , v : SkScalar ) { SkMatrix_setScaleX ( self , v ) } # [ inline ] pub unsafe fn setScaleY ( & mut self , v : SkScalar ) { SkMatrix_setScaleY ( self , v ) } # [ inline ] pub unsafe fn setSkewY ( & mut self , v : SkScalar ) { SkMatrix_setSkewY ( self , v ) } # [ inline ] pub unsafe fn setSkewX ( & mut self , v : SkScalar ) { SkMatrix_setSkewX ( self , v ) } # [ inline ] pub unsafe fn setTranslateX ( & mut self , v : SkScalar ) { SkMatrix_setTranslateX ( self , v ) } # [ inline ] pub unsafe fn setTranslateY ( & mut self , v : SkScalar ) { SkMatrix_setTranslateY ( self , v ) } # [ inline ] pub unsafe fn setPerspX ( & mut self , v : SkScalar ) { SkMatrix_setPerspX ( self , v ) } # [ inline ] pub unsafe fn setPerspY ( & mut self , v : SkScalar ) { SkMatrix_setPerspY ( self , v ) } # [ inline ] pub unsafe fn setAll ( & mut self , scaleX : SkScalar , skewX : SkScalar , transX : SkScalar , skewY : SkScalar , scaleY : SkScalar , transY : SkScalar , persp0 : SkScalar , persp1 : SkScalar , persp2 : SkScalar ) { SkMatrix_setAll ( self , scaleX , skewX , transX , skewY , scaleY , transY , persp0 , persp1 , persp2 ) } # [ inline ] pub unsafe fn get9 ( & self , buffer : * mut SkScalar ) { SkMatrix_get9 ( self , buffer ) } # [ inline ] pub unsafe fn set9 ( & mut self , buffer : * const SkScalar ) { SkMatrix_set9 ( self , buffer ) } # [ inline ] pub unsafe fn reset ( & mut self ) { SkMatrix_reset ( self ) } # [ inline ] pub unsafe fn setIdentity ( & mut self ) { SkMatrix_setIdentity ( self ) } # [ inline ] pub unsafe fn setTranslate ( & mut self , dx : SkScalar , dy : SkScalar ) { SkMatrix_setTranslate ( self , dx , dy ) } # [ inline ] pub unsafe fn setTranslate1 ( & mut self , v : * const SkVector ) { SkMatrix_setTranslate1 ( self , v ) } # [ inline ] pub unsafe fn setScale ( & mut self , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_setScale ( self , sx , sy , px , py ) } # [ inline ] pub unsafe fn setScale1 ( & mut self , sx : SkScalar , sy : SkScalar ) { SkMatrix_setScale1 ( self , sx , sy ) } # [ inline ] pub unsafe fn setRotate ( & mut self , degrees : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_setRotate ( self , degrees , px , py ) } # [ inline ] pub unsafe fn setRotate1 ( & mut self , degrees : SkScalar ) { SkMatrix_setRotate1 ( self , degrees ) } # [ inline ] pub unsafe fn setSinCos ( & mut self , sinValue : SkScalar , cosValue : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_setSinCos ( self , sinValue , cosValue , px , py ) } # [ inline ] pub unsafe fn setSinCos1 ( & mut self , sinValue : SkScalar , cosValue : SkScalar ) { SkMatrix_setSinCos1 ( self , sinValue , cosValue ) } # [ inline ] pub unsafe fn setRSXform ( & mut self , rsxForm : * const SkRSXform ) -> * mut SkMatrix { SkMatrix_setRSXform ( self , rsxForm ) } # [ inline ] pub unsafe fn setSkew ( & mut self , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_setSkew ( self , kx , ky , px , py ) } # [ inline ] pub unsafe fn setSkew1 ( & mut self , kx : SkScalar , ky : SkScalar ) { SkMatrix_setSkew1 ( self , kx , ky ) } # [ inline ] pub unsafe fn setConcat ( & mut self , a : * const SkMatrix , b : * const SkMatrix ) { SkMatrix_setConcat ( self , a , b ) } # [ inline ] pub unsafe fn preTranslate ( & mut self , dx : SkScalar , dy : SkScalar ) { SkMatrix_preTranslate ( self , dx , dy ) } # [ inline ] pub unsafe fn preScale ( & mut self , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_preScale ( self , sx , sy , px , py ) } # [ inline ] pub unsafe fn preScale1 ( & mut self , sx : SkScalar , sy : SkScalar ) { SkMatrix_preScale1 ( self , sx , sy ) } # [ inline ] pub unsafe fn preRotate ( & mut self , degrees : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_preRotate ( self , degrees , px , py ) } # [ inline ] pub unsafe fn preRotate1 ( & mut self , degrees : SkScalar ) { SkMatrix_preRotate1 ( self , degrees ) } # [ inline ] pub unsafe fn preSkew ( & mut self , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_preSkew ( self , kx , ky , px , py ) } # [ inline ] pub unsafe fn preSkew1 ( & mut self , kx : SkScalar , ky : SkScalar ) { SkMatrix_preSkew1 ( self , kx , ky ) } # [ inline ] pub unsafe fn preConcat ( & mut self , other : * const SkMatrix ) { SkMatrix_preConcat ( self , other ) } # [ inline ] pub unsafe fn postTranslate ( & mut self , dx : SkScalar , dy : SkScalar ) { SkMatrix_postTranslate ( self , dx , dy ) } # [ inline ] pub unsafe fn postScale ( & mut self , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_postScale ( self , sx , sy , px , py ) } # [ inline ] pub unsafe fn postScale1 ( & mut self , sx : SkScalar , sy : SkScalar ) { SkMatrix_postScale1 ( self , sx , sy ) } # [ inline ] pub unsafe fn postIDiv ( & mut self , divx : :: std :: os :: raw :: c_int , divy : :: std :: os :: raw :: c_int ) -> bool { SkMatrix_postIDiv ( self , divx , divy ) } # [ inline ] pub unsafe fn postRotate ( & mut self , degrees : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_postRotate ( self , degrees , px , py ) } # [ inline ] pub unsafe fn postRotate1 ( & mut self , degrees : SkScalar ) { SkMatrix_postRotate1 ( self , degrees ) } # [ inline ] pub unsafe fn postSkew ( & mut self , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar ) { SkMatrix_postSkew ( self , kx , ky , px , py ) } # [ inline ] pub unsafe fn postSkew1 ( & mut self , kx : SkScalar , ky : SkScalar ) { SkMatrix_postSkew1 ( self , kx , ky ) } # [ inline ] pub unsafe fn postConcat ( & mut self , other : * const SkMatrix ) { SkMatrix_postConcat ( self , other ) } # [ inline ] pub unsafe fn setRectToRect ( & mut self , src : * const SkRect , dst : * const SkRect , stf : SkMatrix_ScaleToFit ) -> bool { SkMatrix_setRectToRect ( self , src , dst , stf ) } # [ inline ] pub unsafe fn MakeRectToRect ( src : * const SkRect , dst : * const SkRect , stf : SkMatrix_ScaleToFit ) -> SkMatrix { SkMatrix_MakeRectToRect ( src , dst , stf ) } # [ inline ] pub unsafe fn setPolyToPoly ( & mut self , src : * const SkPoint , dst : * const SkPoint , count : :: std :: os :: raw :: c_int ) -> bool { SkMatrix_setPolyToPoly ( self , src , dst , count ) } # [ inline ] pub unsafe fn invert ( & self , inverse : * mut SkMatrix ) -> bool { SkMatrix_invert ( self , inverse ) } # [ inline ] pub unsafe fn SetAffineIdentity ( affine : * mut SkScalar ) { SkMatrix_SetAffineIdentity ( affine ) } # [ inline ] pub unsafe fn asAffine ( & self , affine : * mut SkScalar ) -> bool { SkMatrix_asAffine ( self , affine ) } # [ inline ] pub unsafe fn setAffine ( & mut self , affine : * const SkScalar ) { SkMatrix_setAffine ( self , affine ) } # [ inline ] pub unsafe fn mapPoints ( & self , dst : * mut SkPoint , src : * const SkPoint , count : :: std :: os :: raw :: c_int ) { SkMatrix_mapPoints ( self , dst , src , count ) } # [ inline ] pub unsafe fn mapPoints1 ( & self , pts : * mut SkPoint , count : :: std :: os :: raw :: c_int ) { SkMatrix_mapPoints1 ( self , pts , count ) } # [ inline ] pub unsafe fn mapHomogeneousPoints ( & self , dst : * mut SkPoint3 , src : * const SkPoint3 , count : :: std :: os :: raw :: c_int ) { SkMatrix_mapHomogeneousPoints ( self , dst , src , count ) } # [ inline ] pub unsafe fn mapXY ( & self , x : SkScalar , y : SkScalar , result : * mut SkPoint ) { SkMatrix_mapXY ( self , x , y , result ) } # [ inline ] pub unsafe fn mapXY1 ( & self , x : SkScalar , y : SkScalar ) -> SkPoint { SkMatrix_mapXY1 ( self , x , y ) } # [ inline ] pub unsafe fn mapVectors ( & self , dst : * mut SkVector , src : * const SkVector , count : :: std :: os :: raw :: c_int ) { SkMatrix_mapVectors ( self , dst , src , count ) } # [ inline ] pub unsafe fn mapVectors1 ( & self , vecs : * mut SkVector , count : :: std :: os :: raw :: c_int ) { SkMatrix_mapVectors1 ( self , vecs , count ) } # [ inline ] pub unsafe fn mapVector ( & self , dx : SkScalar , dy : SkScalar , result : * mut SkVector ) { SkMatrix_mapVector ( self , dx , dy , result ) } # [ inline ] pub unsafe fn mapVector1 ( & self , dx : SkScalar , dy : SkScalar ) -> SkVector { SkMatrix_mapVector1 ( self , dx , dy ) } # [ inline ] pub unsafe fn mapRect ( & self , dst : * mut SkRect , src : * const SkRect ) -> bool { SkMatrix_mapRect ( self , dst , src ) } # [ inline ] pub unsafe fn mapRect1 ( & self , rect : * mut SkRect ) -> bool { SkMatrix_mapRect1 ( self , rect ) } # [ inline ] pub unsafe fn mapRect2 ( & self , src : * const SkRect ) -> SkRect { SkMatrix_mapRect2 ( self , src ) } # [ inline ] pub unsafe fn mapRectToQuad ( & self , dst : * mut SkPoint , rect : * const SkRect ) { SkMatrix_mapRectToQuad ( self , dst , rect ) } # [ inline ] pub unsafe fn mapRectScaleTranslate ( & self , dst : * mut SkRect , src : * const SkRect ) { SkMatrix_mapRectScaleTranslate ( self , dst , src ) } # [ inline ] pub unsafe fn mapRadius ( & self , radius : SkScalar ) -> SkScalar { SkMatrix_mapRadius ( self , radius ) } # [ inline ] pub unsafe fn isFixedStepInX ( & self ) -> bool { SkMatrix_isFixedStepInX ( self ) } # [ inline ] pub unsafe fn fixedStepInX ( & self , y : SkScalar ) -> SkVector { SkMatrix_fixedStepInX ( self , y ) } # [ inline ] pub unsafe fn cheapEqualTo ( & self , m : * const SkMatrix ) -> bool { SkMatrix_cheapEqualTo ( self , m ) } # [ inline ] pub unsafe fn dump ( & self ) { SkMatrix_dump ( self ) } # [ inline ] pub unsafe fn getMinScale ( & self ) -> SkScalar { SkMatrix_getMinScale ( self ) } # [ inline ] pub unsafe fn getMaxScale ( & self ) -> SkScalar { SkMatrix_getMaxScale ( self ) } # [ inline ] pub unsafe fn getMinMaxScales ( & self , scaleFactors : * mut SkScalar ) -> bool { SkMatrix_getMinMaxScales ( self , scaleFactors ) } # [ inline ] pub unsafe fn decomposeScale ( & self , scale : * mut SkSize , remaining : * mut SkMatrix ) -> bool { SkMatrix_decomposeScale ( self , scale , remaining ) } # [ inline ] pub unsafe fn I ( ) -> * const SkMatrix { SkMatrix_I ( ) } # [ inline ] pub unsafe fn InvalidMatrix ( ) -> * const SkMatrix { SkMatrix_InvalidMatrix ( ) } # [ inline ] pub unsafe fn Concat ( a : * const SkMatrix , b : * const SkMatrix ) -> SkMatrix { SkMatrix_Concat ( a , b ) } # [ inline ] pub unsafe fn dirtyMatrixTypeCache ( & mut self ) { SkMatrix_dirtyMatrixTypeCache ( self ) } # [ inline ] pub unsafe fn setScaleTranslate ( & mut self , sx : SkScalar , sy : SkScalar , tx : SkScalar , ty : SkScalar ) { SkMatrix_setScaleTranslate ( self , sx , sy , tx , ty ) } # [ inline ] pub unsafe fn isFinite ( & self ) -> bool { SkMatrix_isFinite ( self ) } } pub type SkMScalar = f32 ; # [ doc = "" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkVector4 { pub fData : [ SkScalar ; 4usize ] , } # [ test ] fn bindgen_test_layout_SkVector4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkVector4 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkVector4 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkVector4 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkVector4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVector4 > ( ) ) ) . fData as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkVector4 ) , "::" , stringify ! ( fData ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkVector46equalsEffff" ] pub fn SkVector4_equals ( this : * mut SkVector4 , x : SkScalar , y : SkScalar , z : SkScalar , w : SkScalar ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkVector43setEffff" ] pub fn SkVector4_set ( this : * mut SkVector4 , x : SkScalar , y : SkScalar , z : SkScalar , w : SkScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkVector4C1Ev" ] pub fn SkVector4_SkVector4 ( this : * mut SkVector4 ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkVector4C1ERKS_" ] pub fn SkVector4_SkVector41 ( this : * mut SkVector4 , src : * const SkVector4 ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkVector4C1Effff" ] pub fn SkVector4_SkVector42 ( this : * mut SkVector4 , x : SkScalar , y : SkScalar , z : SkScalar , w : SkScalar ) ; } impl SkVector4 { # [ inline ] pub unsafe fn equals ( & mut self , x : SkScalar , y : SkScalar , z : SkScalar , w : SkScalar ) -> bool { SkVector4_equals ( self , x , y , z , w ) } # [ inline ] pub unsafe fn set ( & mut self , x : SkScalar , y : SkScalar , z : SkScalar , w : SkScalar ) { SkVector4_set ( self , x , y , z , w ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkVector4_SkVector4 ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( src : * const SkVector4 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkVector4_SkVector41 ( & mut __bindgen_tmp , src ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( x : SkScalar , y : SkScalar , z : SkScalar , w : SkScalar ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkVector4_SkVector42 ( & mut __bindgen_tmp , x , y , z , w ) ; __bindgen_tmp } } # [ doc = " \\class SkMatrix44" ] # [ doc = "" ] # [ doc = "The SkMatrix44 class holds a 4x4 matrix." ] # [ doc = "" ] # [ doc = "SkMatrix44 is not thread safe unless you\'ve first called SkMatrix44::getType()." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkMatrix44 { pub fMat : [ [ SkMScalar ; 4usize ] ; 4usize ] , pub fTypeMask : std_atomic , } pub const SkMatrix44_Uninitialized_Constructor_kUninitialized_Constructor : SkMatrix44_Uninitialized_Constructor = 0 ; pub type SkMatrix44_Uninitialized_Constructor = u32 ; pub const SkMatrix44_Identity_Constructor_kIdentity_Constructor : SkMatrix44_Identity_Constructor = 0 ; pub type SkMatrix44_Identity_Constructor = u32 ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkMatrix44_TypeMask { kIdentity_Mask = 0 , # [ doc = "!< set if the matrix has translation" ] kTranslate_Mask = 1 , # [ doc = "!< set if the matrix has any scale != 1" ] kScale_Mask = 2 , # [ doc = "!< set if the matrix skews or rotates" ] kAffine_Mask = 4 , # [ doc = "!< set if the matrix is in perspective" ] kPerspective_Mask = 8 , } pub const SkMatrix44_kUnknown_Mask : :: std :: os :: raw :: c_int = 128 ; pub const SkMatrix44_kAllPublic_Masks : :: std :: os :: raw :: c_int = 15 ; # [ test ] fn bindgen_test_layout_SkMatrix44 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkMatrix44 > ( ) , 68usize , concat ! ( "Size of: " , stringify ! ( SkMatrix44 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkMatrix44 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkMatrix44 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkMatrix44 > ( ) ) ) . fMat as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkMatrix44 ) , "::" , stringify ! ( fMat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkMatrix44 > ( ) ) ) . fTypeMask as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( SkMatrix44 ) , "::" , stringify ! ( fTypeMask ) ) ) ; } extern "C" { # [ doc = "  Return a reference to a const identity matrix" ] # [ link_name = "\u{1}__ZN10SkMatrix441IEv" ] pub fn SkMatrix44_I ( ) -> * const SkMatrix44 ; } extern "C" { # [ doc = "  Returns a bitfield describing the transformations the matrix may" ] # [ doc = "  perform. The bitfield is computed conservatively, so it may include" ] # [ doc = "  false positives. For example, when kPerspective_Mask is true, all" ] # [ doc = "  other bits may be set to true even in the case of a pure perspective" ] # [ doc = "  transform." ] # [ link_name = "\u{1}__ZNK10SkMatrix447getTypeEv" ] pub fn SkMatrix44_getType ( this : * const SkMatrix44 ) -> SkMatrix44_TypeMask ; } extern "C" { # [ doc = "  Return true if the matrix is identity." ] # [ link_name = "\u{1}__ZNK10SkMatrix4410isIdentityEv" ] pub fn SkMatrix44_isIdentity ( this : * const SkMatrix44 ) -> bool ; } extern "C" { # [ doc = "  Return true if the matrix contains translate or is identity." ] # [ link_name = "\u{1}__ZNK10SkMatrix4411isTranslateEv" ] pub fn SkMatrix44_isTranslate ( this : * const SkMatrix44 ) -> bool ; } extern "C" { # [ doc = "  Return true if the matrix only contains scale or translate or is identity." ] # [ link_name = "\u{1}__ZNK10SkMatrix4416isScaleTranslateEv" ] pub fn SkMatrix44_isScaleTranslate ( this : * const SkMatrix44 ) -> bool ; } extern "C" { # [ doc = "  Returns true if the matrix only contains scale or is identity." ] # [ link_name = "\u{1}__ZNK10SkMatrix447isScaleEv" ] pub fn SkMatrix44_isScale ( this : * const SkMatrix44 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix4414hasPerspectiveEv" ] pub fn SkMatrix44_hasPerspective ( this : * const SkMatrix44 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4411setIdentityEv" ] pub fn SkMatrix44_setIdentity ( this : * mut SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix445resetEv" ] pub fn SkMatrix44_reset ( this : * mut SkMatrix44 ) ; } extern "C" { # [ doc = "  get a value from the matrix. The row,col parameters work as follows:" ] # [ doc = "  (0, 0)  scale-x" ] # [ doc = "  (0, 3)  translate-x" ] # [ doc = "  (3, 0)  perspective-x" ] # [ link_name = "\u{1}__ZNK10SkMatrix443getEii" ] pub fn SkMatrix44_get ( this : * const SkMatrix44 , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int ) -> SkMScalar ; } extern "C" { # [ doc = "  set a value in the matrix. The row,col parameters work as follows:" ] # [ doc = "  (0, 0)  scale-x" ] # [ doc = "  (0, 3)  translate-x" ] # [ doc = "  (3, 0)  perspective-x" ] # [ link_name = "\u{1}__ZN10SkMatrix443setEiif" ] pub fn SkMatrix44_set ( this : * mut SkMatrix44 , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int , value : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix449getDoubleEii" ] pub fn SkMatrix44_getDouble ( this : * const SkMatrix44 , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int ) -> f64 ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix449setDoubleEiid" ] pub fn SkMatrix44_setDouble ( this : * mut SkMatrix44 , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int , value : f64 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix448getFloatEii" ] pub fn SkMatrix44_getFloat ( this : * const SkMatrix44 , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int ) -> f32 ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix448setFloatEiif" ] pub fn SkMatrix44_setFloat ( this : * mut SkMatrix44 , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int , value : f32 ) ; } extern "C" { # [ doc = " These methods allow one to efficiently read matrix entries into an" ] # [ doc = "  array. The given array must have room for exactly 16 entries. Whenever" ] # [ doc = "  possible, they will try to use memcpy rather than an entry-by-entry" ] # [ doc = "  copy." ] # [ doc = "" ] # [ doc = "  Col major indicates that consecutive elements of columns will be stored" ] # [ doc = "  contiguously in memory.  Row major indicates that consecutive elements" ] # [ doc = "  of rows will be stored contiguously in memory." ] # [ link_name = "\u{1}__ZNK10SkMatrix4411asColMajorfEPf" ] pub fn SkMatrix44_asColMajorf ( this : * const SkMatrix44 , arg1 : * mut f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix4411asColMajordEPd" ] pub fn SkMatrix44_asColMajord ( this : * const SkMatrix44 , arg1 : * mut f64 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix4411asRowMajorfEPf" ] pub fn SkMatrix44_asRowMajorf ( this : * const SkMatrix44 , arg1 : * mut f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix4411asRowMajordEPd" ] pub fn SkMatrix44_asRowMajord ( this : * const SkMatrix44 , arg1 : * mut f64 ) ; } extern "C" { # [ doc = " These methods allow one to efficiently set all matrix entries from an" ] # [ doc = "  array. The given array must have room for exactly 16 entries. Whenever" ] # [ doc = "  possible, they will try to use memcpy rather than an entry-by-entry" ] # [ doc = "  copy." ] # [ doc = "" ] # [ doc = "  Col major indicates that input memory will be treated as if consecutive" ] # [ doc = "  elements of columns are stored contiguously in memory.  Row major" ] # [ doc = "  indicates that input memory will be treated as if consecutive elements" ] # [ doc = "  of rows are stored contiguously in memory." ] # [ link_name = "\u{1}__ZN10SkMatrix4412setColMajorfEPKf" ] pub fn SkMatrix44_setColMajorf ( this : * mut SkMatrix44 , arg1 : * const f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4412setColMajordEPKd" ] pub fn SkMatrix44_setColMajord ( this : * mut SkMatrix44 , arg1 : * const f64 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4412setRowMajorfEPKf" ] pub fn SkMatrix44_setRowMajorf ( this : * mut SkMatrix44 , arg1 : * const f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4412setRowMajordEPKd" ] pub fn SkMatrix44_setRowMajord ( this : * mut SkMatrix44 , arg1 : * const f64 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4411setColMajorEPKf" ] pub fn SkMatrix44_setColMajor ( this : * mut SkMatrix44 , data : * const SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4411setRowMajorEPKf" ] pub fn SkMatrix44_setRowMajor ( this : * mut SkMatrix44 , data : * const SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix446set3x3Efffffffff" ] pub fn SkMatrix44_set3x3 ( this : * mut SkMatrix44 , m_00 : SkMScalar , m_10 : SkMScalar , m_20 : SkMScalar , m_01 : SkMScalar , m_11 : SkMScalar , m_21 : SkMScalar , m_02 : SkMScalar , m_12 : SkMScalar , m_22 : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4415set3x3RowMajorfEPKf" ] pub fn SkMatrix44_set3x3RowMajorf ( this : * mut SkMatrix44 , arg1 : * const f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4412setTranslateEfff" ] pub fn SkMatrix44_setTranslate ( this : * mut SkMatrix44 , dx : SkMScalar , dy : SkMScalar , dz : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4412preTranslateEfff" ] pub fn SkMatrix44_preTranslate ( this : * mut SkMatrix44 , dx : SkMScalar , dy : SkMScalar , dz : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4413postTranslateEfff" ] pub fn SkMatrix44_postTranslate ( this : * mut SkMatrix44 , dx : SkMScalar , dy : SkMScalar , dz : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix448setScaleEfff" ] pub fn SkMatrix44_setScale ( this : * mut SkMatrix44 , sx : SkMScalar , sy : SkMScalar , sz : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix448preScaleEfff" ] pub fn SkMatrix44_preScale ( this : * mut SkMatrix44 , sx : SkMScalar , sy : SkMScalar , sz : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix449postScaleEfff" ] pub fn SkMatrix44_postScale ( this : * mut SkMatrix44 , sx : SkMScalar , sy : SkMScalar , sz : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix448setScaleEf" ] pub fn SkMatrix44_setScale1 ( this : * mut SkMatrix44 , scale : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix448preScaleEf" ] pub fn SkMatrix44_preScale1 ( this : * mut SkMatrix44 , scale : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix449postScaleEf" ] pub fn SkMatrix44_postScale1 ( this : * mut SkMatrix44 , scale : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4421setRotateDegreesAboutEffff" ] pub fn SkMatrix44_setRotateDegreesAbout ( this : * mut SkMatrix44 , x : SkMScalar , y : SkMScalar , z : SkMScalar , degrees : SkMScalar ) ; } extern "C" { # [ doc = " Rotate about the vector [x,y,z]. If that vector is not unit-length," ] # [ doc = "it will be automatically resized." ] # [ link_name = "\u{1}__ZN10SkMatrix4414setRotateAboutEffff" ] pub fn SkMatrix44_setRotateAbout ( this : * mut SkMatrix44 , x : SkMScalar , y : SkMScalar , z : SkMScalar , radians : SkMScalar ) ; } extern "C" { # [ doc = " Rotate about the vector [x,y,z]. Does not check the length of the" ] # [ doc = "vector, assuming it is unit-length." ] # [ link_name = "\u{1}__ZN10SkMatrix4418setRotateAboutUnitEffff" ] pub fn SkMatrix44_setRotateAboutUnit ( this : * mut SkMatrix44 , x : SkMScalar , y : SkMScalar , z : SkMScalar , radians : SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix449setConcatERKS_S1_" ] pub fn SkMatrix44_setConcat ( this : * mut SkMatrix44 , a : * const SkMatrix44 , b : * const SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix449preConcatERKS_" ] pub fn SkMatrix44_preConcat ( this : * mut SkMatrix44 , m : * const SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix4410postConcatERKS_" ] pub fn SkMatrix44_postConcat ( this : * mut SkMatrix44 , m : * const SkMatrix44 ) ; } extern "C" { # [ doc = " If this is invertible, return that in inverse and return true. If it is" ] # [ doc = "not invertible, return false and leave the inverse parameter in an" ] # [ doc = "unspecified state." ] # [ link_name = "\u{1}__ZNK10SkMatrix446invertEPS_" ] pub fn SkMatrix44_invert ( this : * const SkMatrix44 , inverse : * mut SkMatrix44 ) -> bool ; } extern "C" { # [ doc = " Transpose this matrix in place." ] # [ link_name = "\u{1}__ZN10SkMatrix449transposeEv" ] pub fn SkMatrix44_transpose ( this : * mut SkMatrix44 ) ; } extern "C" { # [ doc = " Apply the matrix to the src vector, returning the new vector in dst." ] # [ doc = "It is legal for src and dst to point to the same memory." ] # [ link_name = "\u{1}__ZNK10SkMatrix4410mapScalarsEPKfPf" ] pub fn SkMatrix44_mapScalars ( this : * const SkMatrix44 , src : * const SkScalar , dst : * mut SkScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix4410mapScalarsEPf" ] pub fn SkMatrix44_mapScalars1 ( this : * const SkMatrix44 , vec : * mut SkScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix4411mapMScalarsEPKfPf" ] pub fn SkMatrix44_mapMScalars ( this : * const SkMatrix44 , src : * const SkMScalar , dst : * mut SkMScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix4411mapMScalarsEPf" ] pub fn SkMatrix44_mapMScalars1 ( this : * const SkMatrix44 , vec : * mut SkMScalar ) ; } extern "C" { # [ doc = "  map an array of [x, y, 0, 1] through the matrix, returning an array" ] # [ doc = "  of [x\', y\', z\', w\']." ] # [ doc = "" ] # [ doc = "  @param src2     array of [x, y] pairs, with implied z=0 and w=1" ] # [ doc = "  @param count    number of [x, y] pairs in src2" ] # [ doc = "  @param dst4     array of [x\', y\', z\', w\'] quads as the output." ] # [ link_name = "\u{1}__ZNK10SkMatrix444map2EPKfiPf" ] pub fn SkMatrix44_map2 ( this : * const SkMatrix44 , src2 : * const f32 , count : :: std :: os :: raw :: c_int , dst4 : * mut f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix444map2EPKdiPd" ] pub fn SkMatrix44_map21 ( this : * const SkMatrix44 , src2 : * const f64 , count : :: std :: os :: raw :: c_int , dst4 : * mut f64 ) ; } extern "C" { # [ doc = " Returns true if transformating an axis-aligned square in 2d by this matrix" ] # [ doc = "will produce another 2d axis-aligned square; typically means the matrix" ] # [ doc = "is a scale with perhaps a 90-degree rotation. A 3d rotation through 90" ] # [ doc = "degrees into a perpendicular plane collapses a square to a line, but" ] # [ doc = "is still considered to be axis-aligned." ] # [ doc = "" ] # [ doc = "By default, tolerates very slight error due to float imprecisions;" ] # [ doc = "a 90-degree rotation can still end up with 10^-17 of" ] # [ doc = "\"non-axis-aligned\" result." ] # [ link_name = "\u{1}__ZNK10SkMatrix4424preserves2dAxisAlignmentEf" ] pub fn SkMatrix44_preserves2dAxisAlignment ( this : * const SkMatrix44 , epsilon : SkMScalar ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix444dumpEv" ] pub fn SkMatrix44_dump ( this : * const SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkMatrix4411determinantEv" ] pub fn SkMatrix44_determinant ( this : * const SkMatrix44 ) -> f64 ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix44C1ENS_25Uninitialized_ConstructorE" ] pub fn SkMatrix44_SkMatrix44 ( this : * mut SkMatrix44 , arg1 : SkMatrix44_Uninitialized_Constructor ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix44C1ENS_20Identity_ConstructorE" ] pub fn SkMatrix44_SkMatrix441 ( this : * mut SkMatrix44 , arg1 : SkMatrix44_Identity_Constructor ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix44C1Ev" ] pub fn SkMatrix44_SkMatrix442 ( this : * mut SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix44C1ERKS_" ] pub fn SkMatrix44_SkMatrix443 ( this : * mut SkMatrix44 , src : * const SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix44C1ERKS_S1_" ] pub fn SkMatrix44_SkMatrix444 ( this : * mut SkMatrix44 , a : * const SkMatrix44 , b : * const SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}__ZN10SkMatrix44C1ERK8SkMatrix" ] pub fn SkMatrix44_SkMatrix445 ( this : * mut SkMatrix44 , arg1 : * const SkMatrix ) ; } impl SkMatrix44 { # [ inline ] pub unsafe fn I ( ) -> * const SkMatrix44 { SkMatrix44_I ( ) } # [ inline ] pub unsafe fn getType ( & self ) -> SkMatrix44_TypeMask { SkMatrix44_getType ( self ) } # [ inline ] pub unsafe fn isIdentity ( & self ) -> bool { SkMatrix44_isIdentity ( self ) } # [ inline ] pub unsafe fn isTranslate ( & self ) -> bool { SkMatrix44_isTranslate ( self ) } # [ inline ] pub unsafe fn isScaleTranslate ( & self ) -> bool { SkMatrix44_isScaleTranslate ( self ) } # [ inline ] pub unsafe fn isScale ( & self ) -> bool { SkMatrix44_isScale ( self ) } # [ inline ] pub unsafe fn hasPerspective ( & self ) -> bool { SkMatrix44_hasPerspective ( self ) } # [ inline ] pub unsafe fn setIdentity ( & mut self ) { SkMatrix44_setIdentity ( self ) } # [ inline ] pub unsafe fn reset ( & mut self ) { SkMatrix44_reset ( self ) } # [ inline ] pub unsafe fn get ( & self , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int ) -> SkMScalar { SkMatrix44_get ( self , row , col ) } # [ inline ] pub unsafe fn set ( & mut self , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int , value : SkMScalar ) { SkMatrix44_set ( self , row , col , value ) } # [ inline ] pub unsafe fn getDouble ( & self , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int ) -> f64 { SkMatrix44_getDouble ( self , row , col ) } # [ inline ] pub unsafe fn setDouble ( & mut self , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int , value : f64 ) { SkMatrix44_setDouble ( self , row , col , value ) } # [ inline ] pub unsafe fn getFloat ( & self , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int ) -> f32 { SkMatrix44_getFloat ( self , row , col ) } # [ inline ] pub unsafe fn setFloat ( & mut self , row : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int , value : f32 ) { SkMatrix44_setFloat ( self , row , col , value ) } # [ inline ] pub unsafe fn asColMajorf ( & self , arg1 : * mut f32 ) { SkMatrix44_asColMajorf ( self , arg1 ) } # [ inline ] pub unsafe fn asColMajord ( & self , arg1 : * mut f64 ) { SkMatrix44_asColMajord ( self , arg1 ) } # [ inline ] pub unsafe fn asRowMajorf ( & self , arg1 : * mut f32 ) { SkMatrix44_asRowMajorf ( self , arg1 ) } # [ inline ] pub unsafe fn asRowMajord ( & self , arg1 : * mut f64 ) { SkMatrix44_asRowMajord ( self , arg1 ) } # [ inline ] pub unsafe fn setColMajorf ( & mut self , arg1 : * const f32 ) { SkMatrix44_setColMajorf ( self , arg1 ) } # [ inline ] pub unsafe fn setColMajord ( & mut self , arg1 : * const f64 ) { SkMatrix44_setColMajord ( self , arg1 ) } # [ inline ] pub unsafe fn setRowMajorf ( & mut self , arg1 : * const f32 ) { SkMatrix44_setRowMajorf ( self , arg1 ) } # [ inline ] pub unsafe fn setRowMajord ( & mut self , arg1 : * const f64 ) { SkMatrix44_setRowMajord ( self , arg1 ) } # [ inline ] pub unsafe fn setColMajor ( & mut self , data : * const SkMScalar ) { SkMatrix44_setColMajor ( self , data ) } # [ inline ] pub unsafe fn setRowMajor ( & mut self , data : * const SkMScalar ) { SkMatrix44_setRowMajor ( self , data ) } # [ inline ] pub unsafe fn set3x3 ( & mut self , m_00 : SkMScalar , m_10 : SkMScalar , m_20 : SkMScalar , m_01 : SkMScalar , m_11 : SkMScalar , m_21 : SkMScalar , m_02 : SkMScalar , m_12 : SkMScalar , m_22 : SkMScalar ) { SkMatrix44_set3x3 ( self , m_00 , m_10 , m_20 , m_01 , m_11 , m_21 , m_02 , m_12 , m_22 ) } # [ inline ] pub unsafe fn set3x3RowMajorf ( & mut self , arg1 : * const f32 ) { SkMatrix44_set3x3RowMajorf ( self , arg1 ) } # [ inline ] pub unsafe fn setTranslate ( & mut self , dx : SkMScalar , dy : SkMScalar , dz : SkMScalar ) { SkMatrix44_setTranslate ( self , dx , dy , dz ) } # [ inline ] pub unsafe fn preTranslate ( & mut self , dx : SkMScalar , dy : SkMScalar , dz : SkMScalar ) { SkMatrix44_preTranslate ( self , dx , dy , dz ) } # [ inline ] pub unsafe fn postTranslate ( & mut self , dx : SkMScalar , dy : SkMScalar , dz : SkMScalar ) { SkMatrix44_postTranslate ( self , dx , dy , dz ) } # [ inline ] pub unsafe fn setScale ( & mut self , sx : SkMScalar , sy : SkMScalar , sz : SkMScalar ) { SkMatrix44_setScale ( self , sx , sy , sz ) } # [ inline ] pub unsafe fn preScale ( & mut self , sx : SkMScalar , sy : SkMScalar , sz : SkMScalar ) { SkMatrix44_preScale ( self , sx , sy , sz ) } # [ inline ] pub unsafe fn postScale ( & mut self , sx : SkMScalar , sy : SkMScalar , sz : SkMScalar ) { SkMatrix44_postScale ( self , sx , sy , sz ) } # [ inline ] pub unsafe fn setScale1 ( & mut self , scale : SkMScalar ) { SkMatrix44_setScale1 ( self , scale ) } # [ inline ] pub unsafe fn preScale1 ( & mut self , scale : SkMScalar ) { SkMatrix44_preScale1 ( self , scale ) } # [ inline ] pub unsafe fn postScale1 ( & mut self , scale : SkMScalar ) { SkMatrix44_postScale1 ( self , scale ) } # [ inline ] pub unsafe fn setRotateDegreesAbout ( & mut self , x : SkMScalar , y : SkMScalar , z : SkMScalar , degrees : SkMScalar ) { SkMatrix44_setRotateDegreesAbout ( self , x , y , z , degrees ) } # [ inline ] pub unsafe fn setRotateAbout ( & mut self , x : SkMScalar , y : SkMScalar , z : SkMScalar , radians : SkMScalar ) { SkMatrix44_setRotateAbout ( self , x , y , z , radians ) } # [ inline ] pub unsafe fn setRotateAboutUnit ( & mut self , x : SkMScalar , y : SkMScalar , z : SkMScalar , radians : SkMScalar ) { SkMatrix44_setRotateAboutUnit ( self , x , y , z , radians ) } # [ inline ] pub unsafe fn setConcat ( & mut self , a : * const SkMatrix44 , b : * const SkMatrix44 ) { SkMatrix44_setConcat ( self , a , b ) } # [ inline ] pub unsafe fn preConcat ( & mut self , m : * const SkMatrix44 ) { SkMatrix44_preConcat ( self , m ) } # [ inline ] pub unsafe fn postConcat ( & mut self , m : * const SkMatrix44 ) { SkMatrix44_postConcat ( self , m ) } # [ inline ] pub unsafe fn invert ( & self , inverse : * mut SkMatrix44 ) -> bool { SkMatrix44_invert ( self , inverse ) } # [ inline ] pub unsafe fn transpose ( & mut self ) { SkMatrix44_transpose ( self ) } # [ inline ] pub unsafe fn mapScalars ( & self , src : * const SkScalar , dst : * mut SkScalar ) { SkMatrix44_mapScalars ( self , src , dst ) } # [ inline ] pub unsafe fn mapScalars1 ( & self , vec : * mut SkScalar ) { SkMatrix44_mapScalars1 ( self , vec ) } # [ inline ] pub unsafe fn mapMScalars ( & self , src : * const SkMScalar , dst : * mut SkMScalar ) { SkMatrix44_mapMScalars ( self , src , dst ) } # [ inline ] pub unsafe fn mapMScalars1 ( & self , vec : * mut SkMScalar ) { SkMatrix44_mapMScalars1 ( self , vec ) } # [ inline ] pub unsafe fn map2 ( & self , src2 : * const f32 , count : :: std :: os :: raw :: c_int , dst4 : * mut f32 ) { SkMatrix44_map2 ( self , src2 , count , dst4 ) } # [ inline ] pub unsafe fn map21 ( & self , src2 : * const f64 , count : :: std :: os :: raw :: c_int , dst4 : * mut f64 ) { SkMatrix44_map21 ( self , src2 , count , dst4 ) } # [ inline ] pub unsafe fn preserves2dAxisAlignment ( & self , epsilon : SkMScalar ) -> bool { SkMatrix44_preserves2dAxisAlignment ( self , epsilon ) } # [ inline ] pub unsafe fn dump ( & self ) { SkMatrix44_dump ( self ) } # [ inline ] pub unsafe fn determinant ( & self ) -> f64 { SkMatrix44_determinant ( self ) } # [ inline ] pub unsafe fn new ( arg1 : SkMatrix44_Uninitialized_Constructor ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkMatrix44_SkMatrix44 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : SkMatrix44_Identity_Constructor ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkMatrix44_SkMatrix441 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkMatrix44_SkMatrix442 ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( src : * const SkMatrix44 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkMatrix44_SkMatrix443 ( & mut __bindgen_tmp , src ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new4 ( a : * const SkMatrix44 , b : * const SkMatrix44 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkMatrix44_SkMatrix444 ( & mut __bindgen_tmp , a , b ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new5 ( arg1 : * const SkMatrix ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkMatrix44_SkMatrix445 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } } # [ doc = "  Describes a color gamut with primaries and a white point." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkColorSpacePrimaries { pub fRX : f32 , pub fRY : f32 , pub fGX : f32 , pub fGY : f32 , pub fBX : f32 , pub fBY : f32 , pub fWX : f32 , pub fWY : f32 , } # [ test ] fn bindgen_test_layout_SkColorSpacePrimaries ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkColorSpacePrimaries > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SkColorSpacePrimaries ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkColorSpacePrimaries > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkColorSpacePrimaries ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpacePrimaries > ( ) ) ) . fRX as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpacePrimaries ) , "::" , stringify ! ( fRX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpacePrimaries > ( ) ) ) . fRY as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpacePrimaries ) , "::" , stringify ! ( fRY ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpacePrimaries > ( ) ) ) . fGX as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpacePrimaries ) , "::" , stringify ! ( fGX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpacePrimaries > ( ) ) ) . fGY as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpacePrimaries ) , "::" , stringify ! ( fGY ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpacePrimaries > ( ) ) ) . fBX as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpacePrimaries ) , "::" , stringify ! ( fBX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpacePrimaries > ( ) ) ) . fBY as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpacePrimaries ) , "::" , stringify ! ( fBY ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpacePrimaries > ( ) ) ) . fWX as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpacePrimaries ) , "::" , stringify ! ( fWX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpacePrimaries > ( ) ) ) . fWY as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpacePrimaries ) , "::" , stringify ! ( fWY ) ) ) ; } extern "C" { # [ doc = "  Convert primaries and a white point to a toXYZD50 matrix, the preferred color gamut" ] # [ doc = "  representation of SkColorSpace." ] # [ link_name = "\u{1}__ZNK21SkColorSpacePrimaries8toXYZD50EP15skcms_Matrix3x3" ] pub fn SkColorSpacePrimaries_toXYZD50 ( this : * const SkColorSpacePrimaries , toXYZD50 : * mut skcms_Matrix3x3 ) -> bool ; } impl SkColorSpacePrimaries { # [ inline ] pub unsafe fn toXYZD50 ( & self , toXYZD50 : * mut skcms_Matrix3x3 ) -> bool { SkColorSpacePrimaries_toXYZD50 ( self , toXYZD50 ) } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkColorSpace { pub _base : SkNVRefCnt , pub fTransferFnHash : u32 , pub fToXYZD50Hash : u32 , pub fTransferFn : [ f32 ; 7usize ] , pub fToXYZD50_3x3 : [ f32 ; 9usize ] , pub fInvTransferFn : [ f32 ; 7usize ] , pub fFromXYZD50_3x3 : [ f32 ; 9usize ] , pub fLazyDstFieldsOnce : SkOnce , } # [ test ] fn bindgen_test_layout_SkColorSpace ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkColorSpace > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( SkColorSpace ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkColorSpace > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkColorSpace ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpace > ( ) ) ) . fTransferFnHash as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpace ) , "::" , stringify ! ( fTransferFnHash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpace > ( ) ) ) . fToXYZD50Hash as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpace ) , "::" , stringify ! ( fToXYZD50Hash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpace > ( ) ) ) . fTransferFn as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpace ) , "::" , stringify ! ( fTransferFn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpace > ( ) ) ) . fToXYZD50_3x3 as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpace ) , "::" , stringify ! ( fToXYZD50_3x3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpace > ( ) ) ) . fInvTransferFn as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpace ) , "::" , stringify ! ( fInvTransferFn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpace > ( ) ) ) . fFromXYZD50_3x3 as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpace ) , "::" , stringify ! ( fFromXYZD50_3x3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkColorSpace > ( ) ) ) . fLazyDstFieldsOnce as * const _ as usize } , 140usize , concat ! ( "Offset of field: " , stringify ! ( SkColorSpace ) , "::" , stringify ! ( fLazyDstFieldsOnce ) ) ) ; } extern "C" { # [ doc = "  Create the sRGB color space." ] # [ link_name = "\u{1}__ZN12SkColorSpace8MakeSRGBEv" ] pub fn SkColorSpace_MakeSRGB ( ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = "  Colorspace with the sRGB primaries, but a linear (1.0) gamma." ] # [ link_name = "\u{1}__ZN12SkColorSpace14MakeSRGBLinearEv" ] pub fn SkColorSpace_MakeSRGBLinear ( ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = "  Create an SkColorSpace from a transfer function and a row-major 3x3 transformation to XYZ." ] # [ link_name = "\u{1}__ZN12SkColorSpace7MakeRGBERK22skcms_TransferFunctionRK15skcms_Matrix3x3" ] pub fn SkColorSpace_MakeRGB ( transferFn : * const skcms_TransferFunction , toXYZ : * const skcms_Matrix3x3 ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = "  Create an SkColorSpace from a parsed (skcms) ICC profile." ] # [ link_name = "\u{1}__ZN12SkColorSpace4MakeERK16skcms_ICCProfile" ] pub fn SkColorSpace_Make ( arg1 : * const skcms_ICCProfile ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = "  Convert this color space to an skcms ICC profile struct." ] # [ link_name = "\u{1}__ZNK12SkColorSpace9toProfileEP16skcms_ICCProfile" ] pub fn SkColorSpace_toProfile ( this : * const SkColorSpace , arg1 : * mut skcms_ICCProfile ) ; } extern "C" { # [ doc = "  Returns true if the color space gamma is near enough to be approximated as sRGB." ] # [ link_name = "\u{1}__ZNK12SkColorSpace16gammaCloseToSRGBEv" ] pub fn SkColorSpace_gammaCloseToSRGB ( this : * const SkColorSpace ) -> bool ; } extern "C" { # [ doc = "  Returns true if the color space gamma is linear." ] # [ link_name = "\u{1}__ZNK12SkColorSpace13gammaIsLinearEv" ] pub fn SkColorSpace_gammaIsLinear ( this : * const SkColorSpace ) -> bool ; } extern "C" { # [ doc = "  If the transfer function can be represented as coefficients to the standard" ] # [ doc = "  equation, returns true and sets |fn| to the proper values." ] # [ doc = "" ] # [ doc = "  If not, returns false." ] # [ link_name = "\u{1}__ZNK12SkColorSpace21isNumericalTransferFnEP22skcms_TransferFunction" ] pub fn SkColorSpace_isNumericalTransferFn ( this : * const SkColorSpace , fn_ : * mut skcms_TransferFunction ) -> bool ; } extern "C" { # [ doc = "  Returns true and sets |toXYZD50| if the color gamut can be described as a matrix." ] # [ doc = "  Returns false otherwise." ] # [ link_name = "\u{1}__ZNK12SkColorSpace8toXYZD50EP10SkMatrix44" ] pub fn SkColorSpace_toXYZD50 ( this : * const SkColorSpace , toXYZD50 : * mut SkMatrix44 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkColorSpace8toXYZD50EP15skcms_Matrix3x3" ] pub fn SkColorSpace_toXYZD501 ( this : * const SkColorSpace , toXYZD50 : * mut skcms_Matrix3x3 ) -> bool ; } extern "C" { # [ doc = "  Returns a hash of the gamut transformation to XYZ D50. Allows for fast equality checking" ] # [ doc = "  of gamuts, at the (very small) risk of collision." ] # [ link_name = "\u{1}__ZNK12SkColorSpace12toXYZD50HashEv" ] pub fn SkColorSpace_toXYZD50Hash ( this : * const SkColorSpace ) -> u32 ; } extern "C" { # [ doc = "  Returns a color space with the same gamut as this one, but with a linear gamma." ] # [ doc = "  For color spaces whose gamut can not be described in terms of XYZ D50, returns" ] # [ doc = "  linear sRGB." ] # [ link_name = "\u{1}__ZNK12SkColorSpace15makeLinearGammaEv" ] pub fn SkColorSpace_makeLinearGamma ( this : * const SkColorSpace ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = "  Returns a color space with the same gamut as this one, with with the sRGB transfer" ] # [ doc = "  function. For color spaces whose gamut can not be described in terms of XYZ D50, returns" ] # [ doc = "  sRGB." ] # [ link_name = "\u{1}__ZNK12SkColorSpace13makeSRGBGammaEv" ] pub fn SkColorSpace_makeSRGBGamma ( this : * const SkColorSpace ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = "  Returns a color space with the same transfer function as this one, but with the primary" ] # [ doc = "  colors rotated. For any XYZ space, this produces a new color space that maps RGB to GBR" ] # [ doc = "  (when applied to a source), and maps RGB to BRG (when applied to a destination). For other" ] # [ doc = "  types of color spaces, returns nullptr." ] # [ doc = "" ] # [ doc = "  This is used for testing, to construct color spaces that have severe and testable behavior." ] # [ link_name = "\u{1}__ZNK12SkColorSpace13makeColorSpinEv" ] pub fn SkColorSpace_makeColorSpin ( this : * const SkColorSpace ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = "  Returns true if the color space is sRGB." ] # [ doc = "  Returns false otherwise." ] # [ doc = "" ] # [ doc = "  This allows a little bit of tolerance, given that we might see small numerical error" ] # [ doc = "  in some cases: converting ICC fixed point to float, converting white point to D50," ] # [ doc = "  rounding decisions on transfer function and matrix." ] # [ doc = "" ] # [ doc = "  This does not consider a 2.2f exponential transfer function to be sRGB.  While these" ] # [ doc = "  functions are similar (and it is sometimes useful to consider them together), this" ] # [ doc = "  function checks for logical equality." ] # [ link_name = "\u{1}__ZNK12SkColorSpace6isSRGBEv" ] pub fn SkColorSpace_isSRGB ( this : * const SkColorSpace ) -> bool ; } extern "C" { # [ doc = "  Returns nullptr on failure.  Fails when we fallback to serializing ICC data and" ] # [ doc = "  the data is too large to serialize." ] # [ link_name = "\u{1}__ZNK12SkColorSpace9serializeEv" ] pub fn SkColorSpace_serialize ( this : * const SkColorSpace ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  If |memory| is nullptr, returns the size required to serialize." ] # [ doc = "  Otherwise, serializes into |memory| and returns the size." ] # [ link_name = "\u{1}__ZNK12SkColorSpace13writeToMemoryEPv" ] pub fn SkColorSpace_writeToMemory ( this : * const SkColorSpace , memory : * mut :: std :: os :: raw :: c_void ) -> usize ; } extern "C" { # [ link_name = "\u{1}__ZN12SkColorSpace11DeserializeEPKvm" ] pub fn SkColorSpace_Deserialize ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = "  If both are null, we return true.  If one is null and the other is not, we return false." ] # [ doc = "  If both are non-null, we do a deeper compare." ] # [ link_name = "\u{1}__ZN12SkColorSpace6EqualsEPKS_S1_" ] pub fn SkColorSpace_Equals ( arg1 : * const SkColorSpace , arg2 : * const SkColorSpace ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkColorSpace10transferFnEPf" ] pub fn SkColorSpace_transferFn ( this : * const SkColorSpace , gabcdef : * mut f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkColorSpace13invTransferFnEPf" ] pub fn SkColorSpace_invTransferFn ( this : * const SkColorSpace , gabcdef : * mut f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkColorSpace16gamutTransformToEPKS_Pf" ] pub fn SkColorSpace_gamutTransformTo ( this : * const SkColorSpace , dst : * const SkColorSpace , src_to_dst_row_major : * mut f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkColorSpace14transferFnHashEv" ] pub fn SkColorSpace_transferFnHash ( this : * const SkColorSpace ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkColorSpace4hashEv" ] pub fn SkColorSpace_hash ( this : * const SkColorSpace ) -> u64 ; } impl SkColorSpace { # [ inline ] pub unsafe fn MakeSRGB ( ) -> sk_sp < SkColorSpace > { SkColorSpace_MakeSRGB ( ) } # [ inline ] pub unsafe fn MakeSRGBLinear ( ) -> sk_sp < SkColorSpace > { SkColorSpace_MakeSRGBLinear ( ) } # [ inline ] pub unsafe fn MakeRGB ( transferFn : * const skcms_TransferFunction , toXYZ : * const skcms_Matrix3x3 ) -> sk_sp < SkColorSpace > { SkColorSpace_MakeRGB ( transferFn , toXYZ ) } # [ inline ] pub unsafe fn Make ( arg1 : * const skcms_ICCProfile ) -> sk_sp < SkColorSpace > { SkColorSpace_Make ( arg1 ) } # [ inline ] pub unsafe fn toProfile ( & self , arg1 : * mut skcms_ICCProfile ) { SkColorSpace_toProfile ( self , arg1 ) } # [ inline ] pub unsafe fn gammaCloseToSRGB ( & self ) -> bool { SkColorSpace_gammaCloseToSRGB ( self ) } # [ inline ] pub unsafe fn gammaIsLinear ( & self ) -> bool { SkColorSpace_gammaIsLinear ( self ) } # [ inline ] pub unsafe fn isNumericalTransferFn ( & self , fn_ : * mut skcms_TransferFunction ) -> bool { SkColorSpace_isNumericalTransferFn ( self , fn_ ) } # [ inline ] pub unsafe fn toXYZD50 ( & self , toXYZD50 : * mut SkMatrix44 ) -> bool { SkColorSpace_toXYZD50 ( self , toXYZD50 ) } # [ inline ] pub unsafe fn toXYZD501 ( & self , toXYZD50 : * mut skcms_Matrix3x3 ) -> bool { SkColorSpace_toXYZD501 ( self , toXYZD50 ) } # [ inline ] pub unsafe fn toXYZD50Hash ( & self ) -> u32 { SkColorSpace_toXYZD50Hash ( self ) } # [ inline ] pub unsafe fn makeLinearGamma ( & self ) -> sk_sp < SkColorSpace > { SkColorSpace_makeLinearGamma ( self ) } # [ inline ] pub unsafe fn makeSRGBGamma ( & self ) -> sk_sp < SkColorSpace > { SkColorSpace_makeSRGBGamma ( self ) } # [ inline ] pub unsafe fn makeColorSpin ( & self ) -> sk_sp < SkColorSpace > { SkColorSpace_makeColorSpin ( self ) } # [ inline ] pub unsafe fn isSRGB ( & self ) -> bool { SkColorSpace_isSRGB ( self ) } # [ inline ] pub unsafe fn serialize ( & self ) -> sk_sp < SkData > { SkColorSpace_serialize ( self ) } # [ inline ] pub unsafe fn writeToMemory ( & self , memory : * mut :: std :: os :: raw :: c_void ) -> usize { SkColorSpace_writeToMemory ( self , memory ) } # [ inline ] pub unsafe fn Deserialize ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkColorSpace > { SkColorSpace_Deserialize ( data , length ) } # [ inline ] pub unsafe fn Equals ( arg1 : * const SkColorSpace , arg2 : * const SkColorSpace ) -> bool { SkColorSpace_Equals ( arg1 , arg2 ) } # [ inline ] pub unsafe fn transferFn ( & self , gabcdef : * mut f32 ) { SkColorSpace_transferFn ( self , gabcdef ) } # [ inline ] pub unsafe fn invTransferFn ( & self , gabcdef : * mut f32 ) { SkColorSpace_invTransferFn ( self , gabcdef ) } # [ inline ] pub unsafe fn gamutTransformTo ( & self , dst : * const SkColorSpace , src_to_dst_row_major : * mut f32 ) { SkColorSpace_gamutTransformTo ( self , dst , src_to_dst_row_major ) } # [ inline ] pub unsafe fn transferFnHash ( & self ) -> u32 { SkColorSpace_transferFnHash ( self ) } # [ inline ] pub unsafe fn hash ( & self ) -> u64 { SkColorSpace_hash ( self ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkReadBuffer { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkWriteBuffer { _unused : [ u8 ; 0 ] , } impl SkAlphaType { pub const kLastEnum_SkAlphaType : SkAlphaType = SkAlphaType :: kUnpremul_SkAlphaType ; } # [ repr ( u32 ) ] # [ doc = " \\enum SkImageInfo::SkAlphaType" ] # [ doc = "Describes how to interpret the alpha component of a pixel. A pixel may" ] # [ doc = "be opaque, or alpha, describing multiple levels of transparency." ] # [ doc = "" ] # [ doc = "In simple blending, alpha weights the draw color and the destination" ] # [ doc = "color to create a new color. If alpha describes a weight from zero to one:" ] # [ doc = "" ] # [ doc = "new color = draw color * alpha + destination color * (1 - alpha)" ] # [ doc = "" ] # [ doc = "In practice alpha is encoded in two or more bits, where 1.0 equals all bits set." ] # [ doc = "" ] # [ doc = "RGB may have alpha included in each component value; the stored" ] # [ doc = "value is the original RGB multiplied by alpha. Premultiplied color" ] # [ doc = "components improve performance." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkAlphaType { # [ doc = "!< uninitialized" ] kUnknown_SkAlphaType = 0 , # [ doc = "!< pixel is opaque" ] kOpaque_SkAlphaType = 1 , # [ doc = "!< pixel components are premultiplied by alpha" ] kPremul_SkAlphaType = 2 , # [ doc = "!< pixel components are independent of alpha" ] kUnpremul_SkAlphaType = 3 , } impl SkColorType { pub const kLastEnum_SkColorType : SkColorType = SkColorType :: kRGBA_F32_SkColorType ; } impl SkColorType { pub const kN32_SkColorType : SkColorType = SkColorType :: kRGBA_8888_SkColorType ; } # [ repr ( u32 ) ] # [ doc = " \\enum SkImageInfo::SkColorType" ] # [ doc = "Describes how pixel bits encode color. A pixel may be an alpha mask, a" ] # [ doc = "grayscale, RGB, or ARGB." ] # [ doc = "" ] # [ doc = "kN32_SkColorType selects the native 32-bit ARGB format. On little endian" ] # [ doc = "processors, pixels containing 8-bit ARGB components pack into 32-bit" ] # [ doc = "kBGRA_8888_SkColorType. On big endian processors, pixels pack into 32-bit" ] # [ doc = "kRGBA_8888_SkColorType." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkColorType { # [ doc = "!< uninitialized" ] kUnknown_SkColorType = 0 , # [ doc = "!< pixel with alpha in 8-bit byte" ] kAlpha_8_SkColorType = 1 , # [ doc = "!< pixel with 5 bits red, 6 bits green, 5 bits blue, in 16-bit word" ] kRGB_565_SkColorType = 2 , # [ doc = "!< pixel with 4 bits for alpha, red, green, blue; in 16-bit word" ] kARGB_4444_SkColorType = 3 , # [ doc = "!< pixel with 8 bits for red, green, blue, alpha; in 32-bit word" ] kRGBA_8888_SkColorType = 4 , # [ doc = "!< pixel with 8 bits each for red, green, blue; in 32-bit word" ] kRGB_888x_SkColorType = 5 , # [ doc = "!< pixel with 8 bits for blue, green, red, alpha; in 32-bit word" ] kBGRA_8888_SkColorType = 6 , # [ doc = "!< 10 bits for red, green, blue; 2 bits for alpha; in 32-bit word" ] kRGBA_1010102_SkColorType = 7 , # [ doc = "!< pixel with 10 bits each for red, green, blue; in 32-bit word" ] kRGB_101010x_SkColorType = 8 , # [ doc = "!< pixel with grayscale level in 8-bit byte" ] kGray_8_SkColorType = 9 , # [ doc = "!< pixel with half floats in [0,1] for red, green, blue, alpha; in 64-bit word" ] kRGBA_F16Norm_SkColorType = 10 , # [ doc = "!< pixel with half floats for red, green, blue, alpha; in 64-bit word" ] kRGBA_F16_SkColorType = 11 , # [ doc = "!< pixel using C float for red, green, blue, alpha; in 128-bit word" ] kRGBA_F32_SkColorType = 12 , } extern "C" { # [ doc = " Returns the number of bytes required to store a pixel, including unused padding." ] # [ doc = "Returns zero if ct is kUnknown_SkColorType or invalid." ] # [ doc = "" ] # [ doc = "@param ct  one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@return    bytes per pixel" ] # [ link_name = "\u{1}__Z24SkColorTypeBytesPerPixel11SkColorType" ] pub fn SkColorTypeBytesPerPixel ( ct : SkColorType ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns true if SkColorType always decodes alpha to 1.0, making the pixel" ] # [ doc = "fully opaque. If true, SkColorType does not reserve bits to encode alpha." ] # [ doc = "" ] # [ doc = "@param ct  one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@return    true if alpha is always set to 1.0" ] # [ link_name = "\u{1}__Z25SkColorTypeIsAlwaysOpaque11SkColorType" ] pub fn SkColorTypeIsAlwaysOpaque ( ct : SkColorType ) -> bool ; } extern "C" { # [ doc = " Returns true if canonical can be set to a valid SkAlphaType for colorType. If" ] # [ doc = "there is more than one valid canonical SkAlphaType, set to alphaType, if valid." ] # [ doc = "If true is returned and canonical is not nullptr, store valid SkAlphaType." ] # [ doc = "" ] # [ doc = "Returns false only if alphaType is kUnknown_SkAlphaType, color type is not" ] # [ doc = "kUnknown_SkColorType, and SkColorType is not always opaque. If false is returned," ] # [ doc = "canonical is ignored." ] # [ doc = "" ] # [ doc = "For kUnknown_SkColorType: set canonical to kUnknown_SkAlphaType and return true." ] # [ doc = "For kAlpha_8_SkColorType: set canonical to kPremul_SkAlphaType or" ] # [ doc = "kOpaque_SkAlphaType and return true if alphaType is not kUnknown_SkAlphaType." ] # [ doc = "For kRGB_565_SkColorType, kRGB_888x_SkColorType, kRGB_101010x_SkColorType, and" ] # [ doc = "kGray_8_SkColorType: set canonical to kOpaque_SkAlphaType and return true." ] # [ doc = "For kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kBGRA_8888_SkColorType," ] # [ doc = "kRGBA_1010102_SkColorType, and kRGBA_F16_SkColorType: set canonical to alphaType" ] # [ doc = "and return true if alphaType is not kUnknown_SkAlphaType." ] # [ doc = "" ] # [ doc = "@param colorType  one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@param alphaType  one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@param canonical  storage for SkAlphaType" ] # [ doc = "@return           true if valid SkAlphaType can be associated with colorType" ] # [ link_name = "\u{1}__Z28SkColorTypeValidateAlphaType11SkColorType11SkAlphaTypePS0_" ] pub fn SkColorTypeValidateAlphaType ( colorType : SkColorType , alphaType : SkAlphaType , canonical : * mut SkAlphaType ) -> bool ; } impl SkYUVColorSpace { pub const kLastEnum_SkYUVColorSpace : SkYUVColorSpace = SkYUVColorSpace :: kRec709_SkYUVColorSpace ; } # [ repr ( u32 ) ] # [ doc = " \\enum SkImageInfo::SkYUVColorSpace" ] # [ doc = "Describes color range of YUV pixels. The color mapping from YUV to RGB varies" ] # [ doc = "depending on the source. YUV pixels may be generated by JPEG images, standard" ] # [ doc = "video streams, or high definition video streams. Each has its own mapping from" ] # [ doc = "YUV and RGB." ] # [ doc = "" ] # [ doc = "JPEG YUV values encode the full range of 0 to 255 for all three components." ] # [ doc = "Video YUV values range from 16 to 235 for all three components. Details of" ] # [ doc = "encoding and conversion to RGB are described in YCbCr color space." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkYUVColorSpace { # [ doc = "!< describes full range" ] kJPEG_SkYUVColorSpace = 0 , # [ doc = "!< describes SDTV range" ] kRec601_SkYUVColorSpace = 1 , # [ doc = "!< describes HDTV range" ] kRec709_SkYUVColorSpace = 2 , } # [ doc = " \\struct SkImageInfo" ] # [ doc = "Describes pixel dimensions and encoding. SkBitmap, SkImage, PixMap, and SkSurface" ] # [ doc = "can be created from SkImageInfo. SkImageInfo can be retrieved from SkBitmap and" ] # [ doc = "SkPixmap, but not from SkImage and SkSurface. For example, SkImage and SkSurface" ] # [ doc = "implementations may defer pixel depth, so may not completely specify SkImageInfo." ] # [ doc = "" ] # [ doc = "SkImageInfo contains dimensions, the pixel integral width and height. It encodes" ] # [ doc = "how pixel bits describe alpha, transparency; color components red, blue," ] # [ doc = "and green; and SkColorSpace, the range and linearity of colors." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkImageInfo { pub fColorSpace : sk_sp < SkColorSpace > , pub fDimensions : SkISize , pub fColorType : SkColorType , pub fAlphaType : SkAlphaType , } # [ test ] fn bindgen_test_layout_SkImageInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkImageInfo > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkImageInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkImageInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkImageInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkImageInfo > ( ) ) ) . fColorSpace as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkImageInfo ) , "::" , stringify ! ( fColorSpace ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkImageInfo > ( ) ) ) . fDimensions as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkImageInfo ) , "::" , stringify ! ( fDimensions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkImageInfo > ( ) ) ) . fColorType as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkImageInfo ) , "::" , stringify ! ( fColorType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkImageInfo > ( ) ) ) . fAlphaType as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SkImageInfo ) , "::" , stringify ! ( fAlphaType ) ) ) ; } extern "C" { # [ doc = " Creates SkImageInfo from integral dimensions width and height, SkColorType ct," ] # [ doc = "SkAlphaType at, and optionally SkColorSpace cs." ] # [ doc = "" ] # [ doc = "If SkColorSpace cs is nullptr and SkImageInfo is part of drawing source: SkColorSpace" ] # [ doc = "defaults to sRGB, mapping into SkSurface SkColorSpace." ] # [ doc = "" ] # [ doc = "Parameters are not validated to see if their values are legal, or that the" ] # [ doc = "combination is supported." ] # [ doc = "" ] # [ doc = "@param width   pixel column count; must be zero or greater" ] # [ doc = "@param height  pixel row count; must be zero or greater" ] # [ doc = "@param ct      one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@param at      one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@param cs      range of colors; may be nullptr" ] # [ doc = "@return        created SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfo4MakeEii11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE" ] pub fn SkImageInfo_Make ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , ct : SkColorType , at : SkAlphaType , cs : sk_sp < SkColorSpace > ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo from integral dimensions width and height, kN32_SkColorType," ] # [ doc = "SkAlphaType at, and optionally SkColorSpace cs. kN32_SkColorType will equal either" ] # [ doc = "kBGRA_8888_SkColorType or kRGBA_8888_SkColorType, whichever is optimal." ] # [ doc = "" ] # [ doc = "If SkColorSpace cs is nullptr and SkImageInfo is part of drawing source: SkColorSpace" ] # [ doc = "defaults to sRGB, mapping into SkSurface SkColorSpace." ] # [ doc = "" ] # [ doc = "Parameters are not validated to see if their values are legal, or that the" ] # [ doc = "combination is supported." ] # [ doc = "" ] # [ doc = "@param width   pixel column count; must be zero or greater" ] # [ doc = "@param height  pixel row count; must be zero or greater" ] # [ doc = "@param at      one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@param cs      range of colors; may be nullptr" ] # [ doc = "@return        created SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfo7MakeN32Eii11SkAlphaType5sk_spI12SkColorSpaceE" ] pub fn SkImageInfo_MakeN32 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType , cs : sk_sp < SkColorSpace > ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo from integral dimensions width and height, kN32_SkColorType," ] # [ doc = "SkAlphaType at, with sRGB SkColorSpace." ] # [ doc = "" ] # [ doc = "Parameters are not validated to see if their values are legal, or that the" ] # [ doc = "combination is supported." ] # [ doc = "" ] # [ doc = "@param width   pixel column count; must be zero or greater" ] # [ doc = "@param height  pixel row count; must be zero or greater" ] # [ doc = "@param at      one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@return        created SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfo7MakeS32Eii11SkAlphaType" ] pub fn SkImageInfo_MakeS32 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo from integral dimensions width and height, kN32_SkColorType," ] # [ doc = "kPremul_SkAlphaType, with optional SkColorSpace." ] # [ doc = "" ] # [ doc = "If SkColorSpace cs is nullptr and SkImageInfo is part of drawing source: SkColorSpace" ] # [ doc = "defaults to sRGB, mapping into SkSurface SkColorSpace." ] # [ doc = "" ] # [ doc = "Parameters are not validated to see if their values are legal, or that the" ] # [ doc = "combination is supported." ] # [ doc = "" ] # [ doc = "@param width   pixel column count; must be zero or greater" ] # [ doc = "@param height  pixel row count; must be zero or greater" ] # [ doc = "@param cs      range of colors; may be nullptr" ] # [ doc = "@return        created SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulEii5sk_spI12SkColorSpaceE" ] pub fn SkImageInfo_MakeN32Premul ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , cs : sk_sp < SkColorSpace > ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo from integral dimensions width and height, kN32_SkColorType," ] # [ doc = "kPremul_SkAlphaType, with SkColorSpace set to nullptr." ] # [ doc = "" ] # [ doc = "If SkImageInfo is part of drawing source: SkColorSpace defaults to sRGB, mapping" ] # [ doc = "into SkSurface SkColorSpace." ] # [ doc = "" ] # [ doc = "Parameters are not validated to see if their values are legal, or that the" ] # [ doc = "combination is supported." ] # [ doc = "" ] # [ doc = "@param size  width and height, each must be zero or greater" ] # [ doc = "@return      created SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfo13MakeN32PremulERK7SkISize" ] pub fn SkImageInfo_MakeN32Premul1 ( size : * const SkISize ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo from integral dimensions width and height, kAlpha_8_SkColorType," ] # [ doc = "kPremul_SkAlphaType, with SkColorSpace set to nullptr." ] # [ doc = "" ] # [ doc = "@param width   pixel column count; must be zero or greater" ] # [ doc = "@param height  pixel row count; must be zero or greater" ] # [ doc = "@return        created SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfo6MakeA8Eii" ] pub fn SkImageInfo_MakeA8 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo from integral dimensions width and height, kUnknown_SkColorType," ] # [ doc = "kUnknown_SkAlphaType, with SkColorSpace set to nullptr." ] # [ doc = "" ] # [ doc = "Returned SkImageInfo as part of source does not draw, and as part of destination" ] # [ doc = "can not be drawn to." ] # [ doc = "" ] # [ doc = "@param width   pixel column count; must be zero or greater" ] # [ doc = "@param height  pixel row count; must be zero or greater" ] # [ doc = "@return        created SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfo11MakeUnknownEii" ] pub fn SkImageInfo_MakeUnknown ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo from integral dimensions width and height set to zero," ] # [ doc = "kUnknown_SkColorType, kUnknown_SkAlphaType, with SkColorSpace set to nullptr." ] # [ doc = "" ] # [ doc = "Returned SkImageInfo as part of source does not draw, and as part of destination" ] # [ doc = "can not be drawn to." ] # [ doc = "" ] # [ doc = "@return  created SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfo11MakeUnknownEv" ] pub fn SkImageInfo_MakeUnknown1 ( ) -> SkImageInfo ; } extern "C" { # [ doc = " Returns pixel count in each row." ] # [ doc = "" ] # [ doc = "@return  pixel width" ] # [ link_name = "\u{1}__ZNK11SkImageInfo5widthEv" ] pub fn SkImageInfo_width ( this : * const SkImageInfo ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns pixel row count." ] # [ doc = "" ] # [ doc = "@return  pixel height" ] # [ link_name = "\u{1}__ZNK11SkImageInfo6heightEv" ] pub fn SkImageInfo_height ( this : * const SkImageInfo ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns SkColorType, one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType." ] # [ doc = "" ] # [ doc = "@return  SkColorType" ] # [ link_name = "\u{1}__ZNK11SkImageInfo9colorTypeEv" ] pub fn SkImageInfo_colorType ( this : * const SkImageInfo ) -> SkColorType ; } extern "C" { # [ doc = " Returns SkAlphaType, one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType." ] # [ doc = "" ] # [ doc = "@return  SkAlphaType" ] # [ link_name = "\u{1}__ZNK11SkImageInfo9alphaTypeEv" ] pub fn SkImageInfo_alphaType ( this : * const SkImageInfo ) -> SkAlphaType ; } extern "C" { # [ doc = " Returns SkColorSpace, the range of colors. The reference count of" ] # [ doc = "SkColorSpace is unchanged. The returned SkColorSpace is immutable." ] # [ doc = "" ] # [ doc = "@return  SkColorSpace, or nullptr" ] # [ link_name = "\u{1}__ZNK11SkImageInfo10colorSpaceEv" ] pub fn SkImageInfo_colorSpace ( this : * const SkImageInfo ) -> * mut SkColorSpace ; } extern "C" { # [ doc = " Returns smart pointer to SkColorSpace, the range of colors. The smart pointer" ] # [ doc = "tracks the number of objects sharing this SkColorSpace reference so the memory" ] # [ doc = "is released when the owners destruct." ] # [ doc = "" ] # [ doc = "The returned SkColorSpace is immutable." ] # [ doc = "" ] # [ doc = "@return  SkColorSpace wrapped in a smart pointer" ] # [ link_name = "\u{1}__ZNK11SkImageInfo13refColorSpaceEv" ] pub fn SkImageInfo_refColorSpace ( this : * const SkImageInfo ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = " Returns if SkImageInfo describes an empty area of pixels by checking if either" ] # [ doc = "width or height is zero or smaller." ] # [ doc = "" ] # [ doc = "@return  true if either dimension is zero or smaller" ] # [ link_name = "\u{1}__ZNK11SkImageInfo7isEmptyEv" ] pub fn SkImageInfo_isEmpty ( this : * const SkImageInfo ) -> bool ; } extern "C" { # [ doc = " Returns true if SkAlphaType is set to hint that all pixels are opaque; their" ] # [ doc = "alpha value is implicitly or explicitly 1.0. If true, and all pixels are" ] # [ doc = "not opaque, Skia may draw incorrectly." ] # [ doc = "" ] # [ doc = "Does not check if SkColorType allows alpha, or if any pixel value has" ] # [ doc = "transparency." ] # [ doc = "" ] # [ doc = "@return  true if SkAlphaType is kOpaque_SkAlphaType" ] # [ link_name = "\u{1}__ZNK11SkImageInfo8isOpaqueEv" ] pub fn SkImageInfo_isOpaque ( this : * const SkImageInfo ) -> bool ; } extern "C" { # [ doc = " Returns SkISize { width(), height() }." ] # [ doc = "" ] # [ doc = "@return  integral size of width() and height()" ] # [ link_name = "\u{1}__ZNK11SkImageInfo10dimensionsEv" ] pub fn SkImageInfo_dimensions ( this : * const SkImageInfo ) -> SkISize ; } extern "C" { # [ doc = " Returns SkIRect { 0, 0, width(), height() }." ] # [ doc = "" ] # [ doc = "@return  integral rectangle from origin to width() and height()" ] # [ link_name = "\u{1}__ZNK11SkImageInfo6boundsEv" ] pub fn SkImageInfo_bounds ( this : * const SkImageInfo ) -> SkIRect ; } extern "C" { # [ doc = " Returns true if associated SkColorSpace is not nullptr, and SkColorSpace gamma" ] # [ doc = "is approximately the same as sRGB." ] # [ doc = "This includes the" ] # [ doc = "" ] # [ doc = "@return  true if SkColorSpace gamma is approximately the same as sRGB" ] # [ link_name = "\u{1}__ZNK11SkImageInfo16gammaCloseToSRGBEv" ] pub fn SkImageInfo_gammaCloseToSRGB ( this : * const SkImageInfo ) -> bool ; } extern "C" { # [ doc = " Creates SkImageInfo with the same SkColorType, SkColorSpace, and SkAlphaType," ] # [ doc = "with dimensions set to width and height." ] # [ doc = "" ] # [ doc = "@param newWidth   pixel column count; must be zero or greater" ] # [ doc = "@param newHeight  pixel row count; must be zero or greater" ] # [ doc = "@return           created SkImageInfo" ] # [ link_name = "\u{1}__ZNK11SkImageInfo6makeWHEii" ] pub fn SkImageInfo_makeWH ( this : * const SkImageInfo , newWidth : :: std :: os :: raw :: c_int , newHeight : :: std :: os :: raw :: c_int ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo with same SkColorType, SkColorSpace, width, and height," ] # [ doc = "with SkAlphaType set to newAlphaType." ] # [ doc = "" ] # [ doc = "Created SkImageInfo contains newAlphaType even if it is incompatible with" ] # [ doc = "SkColorType, in which case SkAlphaType in SkImageInfo is ignored." ] # [ doc = "" ] # [ doc = "@param newAlphaType  one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@return              created SkImageInfo" ] # [ link_name = "\u{1}__ZNK11SkImageInfo13makeAlphaTypeE11SkAlphaType" ] pub fn SkImageInfo_makeAlphaType ( this : * const SkImageInfo , newAlphaType : SkAlphaType ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo with same SkAlphaType, SkColorSpace, width, and height," ] # [ doc = "with SkColorType set to newColorType." ] # [ doc = "" ] # [ doc = "@param newColorType  one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType," ] # [ doc = "kRGB_101010x_SkColorType, kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@return              created SkImageInfo" ] # [ link_name = "\u{1}__ZNK11SkImageInfo13makeColorTypeE11SkColorType" ] pub fn SkImageInfo_makeColorType ( this : * const SkImageInfo , newColorType : SkColorType ) -> SkImageInfo ; } extern "C" { # [ doc = " Creates SkImageInfo with same SkAlphaType, SkColorType, width, and height," ] # [ doc = "with SkColorSpace set to cs." ] # [ doc = "" ] # [ doc = "@param cs  range of colors; may be nullptr" ] # [ doc = "@return    created SkImageInfo" ] # [ link_name = "\u{1}__ZNK11SkImageInfo14makeColorSpaceE5sk_spI12SkColorSpaceE" ] pub fn SkImageInfo_makeColorSpace ( this : * const SkImageInfo , cs : sk_sp < SkColorSpace > ) -> SkImageInfo ; } extern "C" { # [ doc = " Returns number of bytes per pixel required by SkColorType." ] # [ doc = "Returns zero if colorType( is kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  bytes in pixel" ] # [ link_name = "\u{1}__ZNK11SkImageInfo13bytesPerPixelEv" ] pub fn SkImageInfo_bytesPerPixel ( this : * const SkImageInfo ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns bit shift converting row bytes to row pixels." ] # [ doc = "Returns zero for kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  one of: 0, 1, 2, 3; left shift to convert pixels to bytes" ] # [ link_name = "\u{1}__ZNK11SkImageInfo13shiftPerPixelEv" ] pub fn SkImageInfo_shiftPerPixel ( this : * const SkImageInfo ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns minimum bytes per row, computed from pixel width() and SkColorType, which" ] # [ doc = "specifies bytesPerPixel(). SkBitmap maximum value for row bytes must fit" ] # [ doc = "in 31 bits." ] # [ doc = "" ] # [ doc = "@return  width() times bytesPerPixel() as unsigned 64-bit integer" ] # [ link_name = "\u{1}__ZNK11SkImageInfo13minRowBytes64Ev" ] pub fn SkImageInfo_minRowBytes64 ( this : * const SkImageInfo ) -> u64 ; } extern "C" { # [ doc = " Returns minimum bytes per row, computed from pixel width() and SkColorType, which" ] # [ doc = "specifies bytesPerPixel(). SkBitmap maximum value for row bytes must fit" ] # [ doc = "in 31 bits." ] # [ doc = "" ] # [ doc = "@return  width() times bytesPerPixel() as signed 32-bit integer" ] # [ link_name = "\u{1}__ZNK11SkImageInfo11minRowBytesEv" ] pub fn SkImageInfo_minRowBytes ( this : * const SkImageInfo ) -> usize ; } extern "C" { # [ doc = " Returns byte offset of pixel from pixel base address." ] # [ doc = "" ] # [ doc = "Asserts in debug build if x or y is outside of bounds. Does not assert if" ] # [ doc = "rowBytes is smaller than minRowBytes(), even though result may be incorrect." ] # [ doc = "" ] # [ doc = "@param x         column index, zero or greater, and less than width()" ] # [ doc = "@param y         row index, zero or greater, and less than height()" ] # [ doc = "@param rowBytes  size of pixel row or larger" ] # [ doc = "@return          offset within pixel array" ] # [ link_name = "\u{1}__ZNK11SkImageInfo13computeOffsetEiim" ] pub fn SkImageInfo_computeOffset ( this : * const SkImageInfo , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , rowBytes : usize ) -> usize ; } extern "C" { # [ doc = " Returns storage required by pixel array, given SkImageInfo dimensions, SkColorType," ] # [ doc = "and rowBytes. rowBytes is assumed to be at least as large as minRowBytes()." ] # [ doc = "" ] # [ doc = "Returns zero if height is zero." ] # [ doc = "Returns SIZE_MAX if answer exceeds the range of size_t." ] # [ doc = "" ] # [ doc = "@param rowBytes  size of pixel row or larger" ] # [ doc = "@return          memory required by pixel buffer" ] # [ link_name = "\u{1}__ZNK11SkImageInfo15computeByteSizeEm" ] pub fn SkImageInfo_computeByteSize ( this : * const SkImageInfo , rowBytes : usize ) -> usize ; } extern "C" { # [ doc = " Returns storage required by pixel array, given SkImageInfo dimensions, and" ] # [ doc = "SkColorType. Uses minRowBytes() to compute bytes for pixel row." ] # [ doc = "" ] # [ doc = "Returns zero if height is zero." ] # [ doc = "Returns SIZE_MAX if answer exceeds the range of size_t." ] # [ doc = "" ] # [ doc = "@return  least memory required by pixel buffer" ] # [ link_name = "\u{1}__ZNK11SkImageInfo18computeMinByteSizeEv" ] pub fn SkImageInfo_computeMinByteSize ( this : * const SkImageInfo ) -> usize ; } extern "C" { # [ doc = " Returns true if byteSize equals SIZE_MAX. computeByteSize() and" ] # [ doc = "computeMinByteSize() return SIZE_MAX if size_t can not hold buffer size." ] # [ doc = "" ] # [ doc = "@param byteSize  result of computeByteSize() or computeMinByteSize()" ] # [ doc = "@return          true if computeByteSize() or computeMinByteSize() result exceeds size_t" ] # [ link_name = "\u{1}__ZN11SkImageInfo18ByteSizeOverflowedEm" ] pub fn SkImageInfo_ByteSizeOverflowed ( byteSize : usize ) -> bool ; } extern "C" { # [ doc = " Returns true if rowBytes is smaller than width times pixel size." ] # [ doc = "" ] # [ doc = "@param rowBytes  size of pixel row or larger" ] # [ doc = "@return          true if rowBytes is large enough to contain pixel row" ] # [ link_name = "\u{1}__ZNK11SkImageInfo13validRowBytesEm" ] pub fn SkImageInfo_validRowBytes ( this : * const SkImageInfo , rowBytes : usize ) -> bool ; } extern "C" { # [ doc = " Creates an empty SkImageInfo with kUnknown_SkColorType, kUnknown_SkAlphaType," ] # [ doc = "a width and height of zero, and no SkColorSpace." ] # [ link_name = "\u{1}__ZN11SkImageInfo5resetEv" ] pub fn SkImageInfo_reset ( this : * mut SkImageInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZNK11SkImageInfo8validateEv" ] pub fn SkImageInfo_validate ( this : * const SkImageInfo ) ; } extern "C" { # [ doc = " Creates an empty SkImageInfo with kUnknown_SkColorType, kUnknown_SkAlphaType," ] # [ doc = "a width and height of zero, and no SkColorSpace." ] # [ doc = "" ] # [ doc = "@return  empty SkImageInfo" ] # [ link_name = "\u{1}__ZN11SkImageInfoC1Ev" ] pub fn SkImageInfo_SkImageInfo ( this : * mut SkImageInfo ) ; } impl SkImageInfo { # [ inline ] pub unsafe fn Make ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , ct : SkColorType , at : SkAlphaType , cs : sk_sp < SkColorSpace > ) -> SkImageInfo { SkImageInfo_Make ( width , height , ct , at , cs ) } # [ inline ] pub unsafe fn MakeN32 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType , cs : sk_sp < SkColorSpace > ) -> SkImageInfo { SkImageInfo_MakeN32 ( width , height , at , cs ) } # [ inline ] pub unsafe fn MakeS32 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType ) -> SkImageInfo { SkImageInfo_MakeS32 ( width , height , at ) } # [ inline ] pub unsafe fn MakeN32Premul ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , cs : sk_sp < SkColorSpace > ) -> SkImageInfo { SkImageInfo_MakeN32Premul ( width , height , cs ) } # [ inline ] pub unsafe fn MakeN32Premul1 ( size : * const SkISize ) -> SkImageInfo { SkImageInfo_MakeN32Premul1 ( size ) } # [ inline ] pub unsafe fn MakeA8 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> SkImageInfo { SkImageInfo_MakeA8 ( width , height ) } # [ inline ] pub unsafe fn MakeUnknown ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> SkImageInfo { SkImageInfo_MakeUnknown ( width , height ) } # [ inline ] pub unsafe fn MakeUnknown1 ( ) -> SkImageInfo { SkImageInfo_MakeUnknown1 ( ) } # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { SkImageInfo_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { SkImageInfo_height ( self ) } # [ inline ] pub unsafe fn colorType ( & self ) -> SkColorType { SkImageInfo_colorType ( self ) } # [ inline ] pub unsafe fn alphaType ( & self ) -> SkAlphaType { SkImageInfo_alphaType ( self ) } # [ inline ] pub unsafe fn colorSpace ( & self ) -> * mut SkColorSpace { SkImageInfo_colorSpace ( self ) } # [ inline ] pub unsafe fn refColorSpace ( & self ) -> sk_sp < SkColorSpace > { SkImageInfo_refColorSpace ( self ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkImageInfo_isEmpty ( self ) } # [ inline ] pub unsafe fn isOpaque ( & self ) -> bool { SkImageInfo_isOpaque ( self ) } # [ inline ] pub unsafe fn dimensions ( & self ) -> SkISize { SkImageInfo_dimensions ( self ) } # [ inline ] pub unsafe fn bounds ( & self ) -> SkIRect { SkImageInfo_bounds ( self ) } # [ inline ] pub unsafe fn gammaCloseToSRGB ( & self ) -> bool { SkImageInfo_gammaCloseToSRGB ( self ) } # [ inline ] pub unsafe fn makeWH ( & self , newWidth : :: std :: os :: raw :: c_int , newHeight : :: std :: os :: raw :: c_int ) -> SkImageInfo { SkImageInfo_makeWH ( self , newWidth , newHeight ) } # [ inline ] pub unsafe fn makeAlphaType ( & self , newAlphaType : SkAlphaType ) -> SkImageInfo { SkImageInfo_makeAlphaType ( self , newAlphaType ) } # [ inline ] pub unsafe fn makeColorType ( & self , newColorType : SkColorType ) -> SkImageInfo { SkImageInfo_makeColorType ( self , newColorType ) } # [ inline ] pub unsafe fn makeColorSpace ( & self , cs : sk_sp < SkColorSpace > ) -> SkImageInfo { SkImageInfo_makeColorSpace ( self , cs ) } # [ inline ] pub unsafe fn bytesPerPixel ( & self ) -> :: std :: os :: raw :: c_int { SkImageInfo_bytesPerPixel ( self ) } # [ inline ] pub unsafe fn shiftPerPixel ( & self ) -> :: std :: os :: raw :: c_int { SkImageInfo_shiftPerPixel ( self ) } # [ inline ] pub unsafe fn minRowBytes64 ( & self ) -> u64 { SkImageInfo_minRowBytes64 ( self ) } # [ inline ] pub unsafe fn minRowBytes ( & self ) -> usize { SkImageInfo_minRowBytes ( self ) } # [ inline ] pub unsafe fn computeOffset ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , rowBytes : usize ) -> usize { SkImageInfo_computeOffset ( self , x , y , rowBytes ) } # [ inline ] pub unsafe fn computeByteSize ( & self , rowBytes : usize ) -> usize { SkImageInfo_computeByteSize ( self , rowBytes ) } # [ inline ] pub unsafe fn computeMinByteSize ( & self ) -> usize { SkImageInfo_computeMinByteSize ( self ) } # [ inline ] pub unsafe fn ByteSizeOverflowed ( byteSize : usize ) -> bool { SkImageInfo_ByteSizeOverflowed ( byteSize ) } # [ inline ] pub unsafe fn validRowBytes ( & self , rowBytes : usize ) -> bool { SkImageInfo_validRowBytes ( self , rowBytes ) } # [ inline ] pub unsafe fn reset ( & mut self ) { SkImageInfo_reset ( self ) } # [ inline ] pub unsafe fn validate ( & self ) { SkImageInfo_validate ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkImageInfo_SkImageInfo ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ doc = " 32-bit ARGB color value, unpremultiplied. Color components are always in" ] # [ doc = "a known order. This is different from SkPMColor, which has its bytes in a configuration" ] # [ doc = "dependent order, to match the format of kBGRA_8888_SkColorType bitmaps. SkColor" ] # [ doc = "is the type used to specify colors in SkPaint and in gradients." ] # [ doc = "" ] # [ doc = "Color that is premultiplied has the same component values as color" ] # [ doc = "that is unpremultiplied if alpha is 255, fully opaque, although may have the" ] # [ doc = "component values in a different order." ] pub type SkColor = u32 ; pub const SK_ColorTRANSPARENT : SkColor = 0 ; pub const SK_ColorBLACK : SkColor = 4278190080 ; pub const SK_ColorDKGRAY : SkColor = 4282664004 ; pub const SK_ColorGRAY : SkColor = 4287137928 ; pub const SK_ColorLTGRAY : SkColor = 4291611852 ; pub const SK_ColorWHITE : SkColor = 4294967295 ; pub const SK_ColorRED : SkColor = 4294901760 ; pub const SK_ColorGREEN : SkColor = 4278255360 ; pub const SK_ColorBLUE : SkColor = 4278190335 ; pub const SK_ColorYELLOW : SkColor = 4294967040 ; pub const SK_ColorCYAN : SkColor = 4278255615 ; pub const SK_ColorMAGENTA : SkColor = 4294902015 ; # [ doc = " 32-bit ARGB color value, premultiplied. The byte order for this value is" ] # [ doc = "configuration dependent, matching the format of kBGRA_8888_SkColorType bitmaps." ] # [ doc = "This is different from SkColor, which is unpremultiplied, and is always in the" ] # [ doc = "same byte order." ] pub type SkPMColor = u32 ; extern "C" { # [ doc = " Returns a pointer to components of SkRGBA4f, for array access." ] # [ doc = "" ] # [ doc = "@return       pointer to array [fR, fG, fB, fA]" ] # [ link_name = "\u{1}vec" ] pub fn SkRGBA4f_vec ( this : * const u8 ) -> * const f32 ; } extern "C" { # [ doc = " Returns a pointer to components of SkRGBA4f, for array access." ] # [ doc = "" ] # [ doc = "@return       pointer to array [fR, fG, fB, fA]" ] # [ link_name = "\u{1}vec" ] pub fn SkRGBA4f_vec1 ( this : * mut u8 ) -> * mut f32 ; } extern "C" { # [ doc = " Returns true if SkRGBA4f is an opaque color. Asserts if fA is out of range and" ] # [ doc = "SK_DEBUG is defined." ] # [ doc = "" ] # [ doc = "@return       true if SkRGBA4f is opaque" ] # [ link_name = "\u{1}isOpaque" ] pub fn SkRGBA4f_isOpaque ( this : * const u8 ) -> bool ; } extern "C" { # [ doc = " Returns true if all channels are in [0, 1]." ] # [ link_name = "\u{1}fitsInBytes" ] pub fn SkRGBA4f_fitsInBytes ( this : * const u8 ) -> bool ; } extern "C" { # [ doc = " Returns closest SkRGBA4f to SkColor. Only allowed if SkRGBA4f is unpremultiplied." ] # [ doc = "" ] # [ doc = "@param color   Color with Alpha, red, blue, and green components" ] # [ doc = "@return        SkColor as SkRGBA4f" ] # [ link_name = "\u{1}FromColor" ] pub fn SkRGBA4f_FromColor ( color : SkColor ) -> u8 ; } extern "C" { # [ doc = " Returns closest SkColor to SkRGBA4f. Only allowed if SkRGBA4f is unpremultiplied." ] # [ doc = "" ] # [ doc = "@return       color as SkColor" ] # [ link_name = "\u{1}toSkColor" ] pub fn SkRGBA4f_toSkColor ( this : * const u8 ) -> SkColor ; } extern "C" { # [ doc = " Returns closest SkRGBA4f to SkPMColor. Only allowed if SkRGBA4f is premultiplied." ] # [ doc = "" ] # [ doc = "@return        SkPMColor as SkRGBA4f" ] # [ link_name = "\u{1}FromPMColor" ] pub fn SkRGBA4f_FromPMColor ( arg1 : SkPMColor ) -> u8 ; } extern "C" { # [ doc = " Returns SkRGBA4f premultiplied by alpha. Asserts at compile time if SkRGBA4f is" ] # [ doc = "already premultiplied." ] # [ doc = "" ] # [ doc = "@return       premultiplied color" ] # [ link_name = "\u{1}premul" ] pub fn SkRGBA4f_premul ( this : * const u8 ) -> [ u32 ; 4usize ] ; } extern "C" { # [ doc = " Returns SkRGBA4f unpremultiplied by alpha. Asserts at compile time if SkRGBA4f is" ] # [ doc = "already unpremultiplied." ] # [ doc = "" ] # [ doc = "@return       unpremultiplied color" ] # [ link_name = "\u{1}unpremul" ] pub fn SkRGBA4f_unpremul ( this : * const u8 ) -> [ u32 ; 4usize ] ; } extern "C" { # [ link_name = "\u{1}toBytes_RGBA" ] pub fn SkRGBA4f_toBytes_RGBA ( this : * const u8 ) -> u32 ; } extern "C" { # [ link_name = "\u{1}FromBytes_RGBA" ] pub fn SkRGBA4f_FromBytes_RGBA ( color : u32 ) -> u8 ; } extern "C" { # [ link_name = "\u{1}makeOpaque" ] pub fn SkRGBA4f_makeOpaque ( this : * const u8 ) -> u8 ; } # [ doc = " \\struct SkColor4f" ] # [ doc = "RGBA color value, holding four floating point components. Color components are always in" ] # [ doc = "a known order, and are unpremultiplied." ] # [ doc = "" ] # [ doc = "This is a specialization of SkRGBA4f. For details, @see SkRGBA4f." ] pub type SkColor4f = [ u32 ; 4usize ] ; # [ doc = "!< fastest but lowest quality, typically nearest-neighbor" ] pub const SkFilterQuality_kNone_SkFilterQuality : SkFilterQuality = 0 ; # [ doc = "!< typically bilerp" ] pub const SkFilterQuality_kLow_SkFilterQuality : SkFilterQuality = 1 ; # [ doc = "!< typically bilerp + mipmaps for down-scaling" ] pub const SkFilterQuality_kMedium_SkFilterQuality : SkFilterQuality = 2 ; # [ doc = "!< slowest but highest quality, typically bicubic or better" ] pub const SkFilterQuality_kHigh_SkFilterQuality : SkFilterQuality = 3 ; pub const SkFilterQuality_kLast_SkFilterQuality : SkFilterQuality = 3 ; # [ doc = "  Controls how much filtering to be done when scaling/transforming complex colors" ] # [ doc = "  e.g. images" ] pub type SkFilterQuality = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkColorFilter { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDrawLooper { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkImageFilter { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkMaskFilter { _unused : [ u8 ; 0 ] , } # [ doc = " \\class SkPaint" ] # [ doc = "SkPaint controls options applied when drawing. SkPaint collects all" ] # [ doc = "options outside of the SkCanvas clip and SkCanvas matrix." ] # [ doc = "" ] # [ doc = "Various options apply to strokes and fills, and images." ] # [ doc = "" ] # [ doc = "SkPaint collects effects and filters that describe single-pass and multiple-pass" ] # [ doc = "algorithms that alter the drawing geometry, color, and transparency. For instance," ] # [ doc = "SkPaint does not directly implement dashing or blur, but contains the objects that do so." ] # [ repr ( C ) ] pub struct SkPaint { pub fPathEffect : sk_sp < SkPathEffect > , pub fShader : sk_sp < SkShader > , pub fMaskFilter : sk_sp < SkMaskFilter > , pub fColorFilter : sk_sp < SkColorFilter > , pub fDrawLooper : sk_sp < SkDrawLooper > , pub fImageFilter : sk_sp < SkImageFilter > , pub fColor4f : SkColor4f , pub fWidth : SkScalar , pub fMiterLimit : SkScalar , pub __bindgen_anon_1 : SkPaint__bindgen_ty_1 , } # [ repr ( u8 ) ] # [ doc = " \\enum SkPaint::Style" ] # [ doc = "Set Style to fill, stroke, or both fill and stroke geometry." ] # [ doc = "The stroke and fill" ] # [ doc = "share all paint attributes; for instance, they are drawn with the same color." ] # [ doc = "" ] # [ doc = "Use kStrokeAndFill_Style to avoid hitting the same pixels twice with a stroke draw and" ] # [ doc = "a fill draw." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkPaint_Style { # [ doc = "!< set to fill geometry" ] kFill_Style = 0 , # [ doc = "!< set to stroke geometry" ] kStroke_Style = 1 , # [ doc = "!< sets to stroke and fill geometry" ] kStrokeAndFill_Style = 2 , } impl SkPaint_Cap { pub const kLast_Cap : SkPaint_Cap = SkPaint_Cap :: kSquare_Cap ; } impl SkPaint_Cap { pub const kDefault_Cap : SkPaint_Cap = SkPaint_Cap :: kButt_Cap ; } # [ repr ( u32 ) ] # [ doc = " \\enum SkPaint::Cap" ] # [ doc = "Cap draws at the beginning and end of an open path contour." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkPaint_Cap { # [ doc = "!< no stroke extension" ] kButt_Cap = 0 , # [ doc = "!< adds circle" ] kRound_Cap = 1 , # [ doc = "!< adds square" ] kSquare_Cap = 2 , } impl SkPaint_Join { pub const kLast_Join : SkPaint_Join = SkPaint_Join :: kBevel_Join ; } impl SkPaint_Join { pub const kDefault_Join : SkPaint_Join = SkPaint_Join :: kMiter_Join ; } # [ repr ( u8 ) ] # [ doc = " \\enum SkPaint::Join" ] # [ doc = "Join specifies how corners are drawn when a shape is stroked. Join" ] # [ doc = "affects the four corners of a stroked rectangle, and the connected segments in a" ] # [ doc = "stroked path." ] # [ doc = "" ] # [ doc = "Choose miter join to draw sharp corners. Choose round join to draw a circle with a" ] # [ doc = "radius equal to the stroke width on top of the corner. Choose bevel join to minimally" ] # [ doc = "connect the thick strokes." ] # [ doc = "" ] # [ doc = "The fill path constructed to describe the stroked path respects the join setting but may" ] # [ doc = "not contain the actual join. For instance, a fill path constructed with round joins does" ] # [ doc = "not necessarily include circles at each connected segment." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkPaint_Join { # [ doc = "!< extends to miter limit" ] kMiter_Join = 0 , # [ doc = "!< adds circle" ] kRound_Join = 1 , # [ doc = "!< connects outside edges" ] kBevel_Join = 2 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union SkPaint__bindgen_ty_1 { pub fBitfields : SkPaint__bindgen_ty_1__bindgen_ty_1 , pub fBitfieldsUInt : u32 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ repr ( align ( 4 ) ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkPaint__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , } # [ test ] fn bindgen_test_layout_SkPaint__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPaint__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( SkPaint__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPaint__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkPaint__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } impl SkPaint__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn fAntiAlias ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fAntiAlias ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fDither ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fDither ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fCapType ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_fCapType ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn fJoinType ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_fJoinType ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 2u8 , val as u64 ) } } # [ inline ] pub fn fStyle ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_fStyle ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn fFilterQuality ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_fFilterQuality ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn fBlendMode ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_fBlendMode ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 8u8 , val as u64 ) } } # [ inline ] pub fn fPadding ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 14u8 ) as u32 ) } } # [ inline ] pub fn set_fPadding ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 14u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( fAntiAlias : :: std :: os :: raw :: c_uint , fDither : :: std :: os :: raw :: c_uint , fCapType : :: std :: os :: raw :: c_uint , fJoinType : :: std :: os :: raw :: c_uint , fStyle : :: std :: os :: raw :: c_uint , fFilterQuality : :: std :: os :: raw :: c_uint , fBlendMode : :: std :: os :: raw :: c_uint , fPadding : :: std :: os :: raw :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let fAntiAlias : u32 = unsafe { :: core :: mem :: transmute ( fAntiAlias ) } ; fAntiAlias as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let fDither : u32 = unsafe { :: core :: mem :: transmute ( fDither ) } ; fDither as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let fCapType : u32 = unsafe { :: core :: mem :: transmute ( fCapType ) } ; fCapType as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 2u8 , { let fJoinType : u32 = unsafe { :: core :: mem :: transmute ( fJoinType ) } ; fJoinType as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let fStyle : u32 = unsafe { :: core :: mem :: transmute ( fStyle ) } ; fStyle as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let fFilterQuality : u32 = unsafe { :: core :: mem :: transmute ( fFilterQuality ) } ; fFilterQuality as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 8u8 , { let fBlendMode : u32 = unsafe { :: core :: mem :: transmute ( fBlendMode ) } ; fBlendMode as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 14u8 , { let fPadding : u32 = unsafe { :: core :: mem :: transmute ( fPadding ) } ; fPadding as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_SkPaint__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPaint__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( SkPaint__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPaint__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkPaint__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint__bindgen_ty_1 > ( ) ) ) . fBitfields as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint__bindgen_ty_1 ) , "::" , stringify ! ( fBitfields ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint__bindgen_ty_1 > ( ) ) ) . fBitfieldsUInt as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint__bindgen_ty_1 ) , "::" , stringify ! ( fBitfieldsUInt ) ) ) ; } pub const SkPaint_kStyleCount : :: std :: os :: raw :: c_int = 3 ; pub const SkPaint_kCapCount : :: std :: os :: raw :: c_int = 3 ; pub const SkPaint_kJoinCount : :: std :: os :: raw :: c_int = 3 ; # [ test ] fn bindgen_test_layout_SkPaint ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPaint > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( SkPaint ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPaint > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPaint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fPathEffect as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fPathEffect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fShader as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fShader ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fMaskFilter as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fMaskFilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fColorFilter as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fColorFilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fDrawLooper as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fDrawLooper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fImageFilter as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fImageFilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fColor4f as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fColor4f ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fWidth as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPaint > ( ) ) ) . fMiterLimit as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( SkPaint ) , "::" , stringify ! ( fMiterLimit ) ) ) ; } extern "C" { # [ doc = " Returns a hash generated from SkPaint values and pointers." ] # [ doc = "Identical hashes guarantee that the paints are" ] # [ doc = "equivalent, but differing hashes do not guarantee that the paints have differing" ] # [ doc = "contents." ] # [ doc = "" ] # [ doc = "If operator==(const SkPaint& a, const SkPaint& b) returns true for two paints," ] # [ doc = "their hashes are also equal." ] # [ doc = "" ] # [ doc = "The hash returned is platform and implementation specific." ] # [ doc = "" ] # [ doc = "@return  a shallow hash" ] # [ link_name = "\u{1}__ZNK7SkPaint7getHashEv" ] pub fn SkPaint_getHash ( this : * const SkPaint ) -> u32 ; } extern "C" { # [ doc = " Sets all SkPaint contents to their initial values. This is equivalent to replacing" ] # [ doc = "SkPaint with the result of SkPaint()." ] # [ link_name = "\u{1}__ZN7SkPaint5resetEv" ] pub fn SkPaint_reset ( this : * mut SkPaint ) ; } extern "C" { # [ doc = " Returns true if pixels on the active edges of SkPath may be drawn with partial transparency." ] # [ doc = "@return  antialiasing state" ] # [ link_name = "\u{1}__ZNK7SkPaint11isAntiAliasEv" ] pub fn SkPaint_isAntiAlias ( this : * const SkPaint ) -> bool ; } extern "C" { # [ doc = " Requests, but does not require, that edge pixels draw opaque or with" ] # [ doc = "partial transparency." ] # [ doc = "@param aa  setting for antialiasing" ] # [ link_name = "\u{1}__ZN7SkPaint12setAntiAliasEb" ] pub fn SkPaint_setAntiAlias ( this : * mut SkPaint , aa : bool ) ; } extern "C" { # [ doc = " Returns true if color error may be distributed to smooth color transition." ] # [ doc = "@return  dithering state" ] # [ link_name = "\u{1}__ZNK7SkPaint8isDitherEv" ] pub fn SkPaint_isDither ( this : * const SkPaint ) -> bool ; } extern "C" { # [ doc = " Requests, but does not require, to distribute color error." ] # [ doc = "@param dither  setting for ditering" ] # [ link_name = "\u{1}__ZN7SkPaint9setDitherEb" ] pub fn SkPaint_setDither ( this : * mut SkPaint , dither : bool ) ; } extern "C" { # [ doc = " Returns SkFilterQuality, the image filtering level. A lower setting" ] # [ doc = "draws faster; a higher setting looks better when the image is scaled." ] # [ doc = "" ] # [ doc = "@return  one of: kNone_SkFilterQuality, kLow_SkFilterQuality," ] # [ doc = "kMedium_SkFilterQuality, kHigh_SkFilterQuality" ] # [ link_name = "\u{1}__ZNK7SkPaint16getFilterQualityEv" ] pub fn SkPaint_getFilterQuality ( this : * const SkPaint ) -> SkFilterQuality ; } extern "C" { # [ doc = " Sets SkFilterQuality, the image filtering level. A lower setting" ] # [ doc = "draws faster; a higher setting looks better when the image is scaled." ] # [ doc = "Does not check to see if quality is valid." ] # [ doc = "" ] # [ doc = "@param quality  one of: kNone_SkFilterQuality, kLow_SkFilterQuality," ] # [ doc = "kMedium_SkFilterQuality, kHigh_SkFilterQuality" ] # [ link_name = "\u{1}__ZN7SkPaint16setFilterQualityE15SkFilterQuality" ] pub fn SkPaint_setFilterQuality ( this : * mut SkPaint , quality : SkFilterQuality ) ; } extern "C" { # [ doc = " Returns whether the geometry is filled, stroked, or filled and stroked." ] # [ doc = "" ] # [ doc = "@return  one of:kFill_Style, kStroke_Style, kStrokeAndFill_Style" ] # [ link_name = "\u{1}__ZNK7SkPaint8getStyleEv" ] pub fn SkPaint_getStyle ( this : * const SkPaint ) -> SkPaint_Style ; } extern "C" { # [ doc = " Sets whether the geometry is filled, stroked, or filled and stroked." ] # [ doc = "Has no effect if style is not a legal SkPaint::Style value." ] # [ doc = "" ] # [ doc = "@param style  one of: kFill_Style, kStroke_Style, kStrokeAndFill_Style" ] # [ link_name = "\u{1}__ZN7SkPaint8setStyleENS_5StyleE" ] pub fn SkPaint_setStyle ( this : * mut SkPaint , style : SkPaint_Style ) ; } extern "C" { # [ doc = " Retrieves alpha and RGB, unpremultiplied, packed into 32 bits." ] # [ doc = "Use helpers SkColorGetA(), SkColorGetR(), SkColorGetG(), and SkColorGetB() to extract" ] # [ doc = "a color component." ] # [ doc = "" ] # [ doc = "@return  unpremultiplied ARGB" ] # [ link_name = "\u{1}__ZNK7SkPaint8getColorEv" ] pub fn SkPaint_getColor ( this : * const SkPaint ) -> SkColor ; } extern "C" { # [ doc = " Retrieves alpha and RGB, unpremultiplied, as four floating point values. RGB are" ] # [ doc = "are extended sRGB values (sRGB gamut, and encoded with the sRGB transfer function)." ] # [ doc = "" ] # [ doc = "@return  unpremultiplied RGBA" ] # [ link_name = "\u{1}__ZNK7SkPaint10getColor4fEv" ] pub fn SkPaint_getColor4f ( this : * const SkPaint ) -> SkColor4f ; } extern "C" { # [ doc = " Sets alpha and RGB used when stroking and filling. The color is a 32-bit value," ] # [ doc = "unpremultiplied, packing 8-bit components for alpha, red, blue, and green." ] # [ doc = "" ] # [ doc = "@param color  unpremultiplied ARGB" ] # [ link_name = "\u{1}__ZN7SkPaint8setColorEj" ] pub fn SkPaint_setColor ( this : * mut SkPaint , color : SkColor ) ; } extern "C" { # [ doc = " Sets alpha and RGB used when stroking and filling. The color is four floating" ] # [ doc = "point values, unpremultiplied. The color values are interpreted as being in" ] # [ doc = "the colorSpace. If colorSpace is nullptr, then color is assumed to be in the" ] # [ doc = "sRGB color space." ] # [ doc = "" ] # [ doc = "@param color       unpremultiplied RGBA" ] # [ doc = "@param colorSpace  SkColorSpace describing the encoding of color" ] # [ link_name = "\u{1}__ZN7SkPaint10setColor4fERK8SkRGBA4fIL11SkAlphaType3EEP12SkColorSpace" ] pub fn SkPaint_setColor4f ( this : * mut SkPaint , color : * const SkColor4f , colorSpace : * mut SkColorSpace ) ; } extern "C" { # [ doc = " Retrieves alpha from the color used when stroking and filling." ] # [ doc = "" ] # [ doc = "@return  alpha ranging from zero, fully transparent, to 255, fully opaque" ] # [ link_name = "\u{1}__ZNK7SkPaint9getAlphafEv" ] pub fn SkPaint_getAlphaf ( this : * const SkPaint ) -> f32 ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkPaint8getAlphaEv" ] pub fn SkPaint_getAlpha ( this : * const SkPaint ) -> u8 ; } extern "C" { # [ doc = " Replaces alpha, leaving RGB" ] # [ doc = "unchanged. An out of range value triggers an assert in the debug" ] # [ doc = "build. a is a value from 0.0 to 1.0." ] # [ doc = "a set to zero makes color fully transparent; a set to 1.0 makes color" ] # [ doc = "fully opaque." ] # [ doc = "" ] # [ doc = "@param a  alpha component of color" ] # [ link_name = "\u{1}__ZN7SkPaint9setAlphafEf" ] pub fn SkPaint_setAlphaf ( this : * mut SkPaint , a : f32 ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkPaint8setAlphaEj" ] pub fn SkPaint_setAlpha ( this : * mut SkPaint , a : U8CPU ) ; } extern "C" { # [ doc = " Sets color used when drawing solid fills. The color components range from 0 to 255." ] # [ doc = "The color is unpremultiplied; alpha sets the transparency independent of RGB." ] # [ doc = "" ] # [ doc = "@param a  amount of alpha, from fully transparent (0) to fully opaque (255)" ] # [ doc = "@param r  amount of red, from no red (0) to full red (255)" ] # [ doc = "@param g  amount of green, from no green (0) to full green (255)" ] # [ doc = "@param b  amount of blue, from no blue (0) to full blue (255)" ] # [ link_name = "\u{1}__ZN7SkPaint7setARGBEjjjj" ] pub fn SkPaint_setARGB ( this : * mut SkPaint , a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU ) ; } extern "C" { # [ doc = " Returns the thickness of the pen used by SkPaint to" ] # [ doc = "outline the shape." ] # [ doc = "" ] # [ doc = "@return  zero for hairline, greater than zero for pen thickness" ] # [ link_name = "\u{1}__ZNK7SkPaint14getStrokeWidthEv" ] pub fn SkPaint_getStrokeWidth ( this : * const SkPaint ) -> SkScalar ; } extern "C" { # [ doc = " Sets the thickness of the pen used by the paint to" ] # [ doc = "outline the shape." ] # [ doc = "Has no effect if width is less than zero." ] # [ doc = "" ] # [ doc = "@param width  zero thickness for hairline; greater than zero for pen thickness" ] # [ link_name = "\u{1}__ZN7SkPaint14setStrokeWidthEf" ] pub fn SkPaint_setStrokeWidth ( this : * mut SkPaint , width : SkScalar ) ; } extern "C" { # [ doc = " Returns the limit at which a sharp corner is drawn beveled." ] # [ doc = "" ] # [ doc = "@return  zero and greater miter limit" ] # [ link_name = "\u{1}__ZNK7SkPaint14getStrokeMiterEv" ] pub fn SkPaint_getStrokeMiter ( this : * const SkPaint ) -> SkScalar ; } extern "C" { # [ doc = " Sets the limit at which a sharp corner is drawn beveled." ] # [ doc = "Valid values are zero and greater." ] # [ doc = "Has no effect if miter is less than zero." ] # [ doc = "" ] # [ doc = "@param miter  zero and greater miter limit" ] # [ link_name = "\u{1}__ZN7SkPaint14setStrokeMiterEf" ] pub fn SkPaint_setStrokeMiter ( this : * mut SkPaint , miter : SkScalar ) ; } extern "C" { # [ doc = " Returns the geometry drawn at the beginning and end of strokes." ] # [ doc = "" ] # [ doc = "@return  one of: kButt_Cap, kRound_Cap, kSquare_Cap" ] # [ link_name = "\u{1}__ZNK7SkPaint12getStrokeCapEv" ] pub fn SkPaint_getStrokeCap ( this : * const SkPaint ) -> SkPaint_Cap ; } extern "C" { # [ doc = " Sets the geometry drawn at the beginning and end of strokes." ] # [ doc = "" ] # [ doc = "@param cap  one of: kButt_Cap, kRound_Cap, kSquare_Cap;" ] # [ doc = "has no effect if cap is not valid" ] # [ link_name = "\u{1}__ZN7SkPaint12setStrokeCapENS_3CapE" ] pub fn SkPaint_setStrokeCap ( this : * mut SkPaint , cap : SkPaint_Cap ) ; } extern "C" { # [ doc = " Returns the geometry drawn at the corners of strokes." ] # [ doc = "" ] # [ doc = "@return  one of: kMiter_Join, kRound_Join, kBevel_Join" ] # [ link_name = "\u{1}__ZNK7SkPaint13getStrokeJoinEv" ] pub fn SkPaint_getStrokeJoin ( this : * const SkPaint ) -> SkPaint_Join ; } extern "C" { # [ doc = " Sets the geometry drawn at the corners of strokes." ] # [ doc = "" ] # [ doc = "@param join  one of: kMiter_Join, kRound_Join, kBevel_Join;" ] # [ doc = "otherwise, has no effect" ] # [ link_name = "\u{1}__ZN7SkPaint13setStrokeJoinENS_4JoinE" ] pub fn SkPaint_setStrokeJoin ( this : * mut SkPaint , join : SkPaint_Join ) ; } extern "C" { # [ doc = " Returns the filled equivalent of the stroked path." ] # [ doc = "" ] # [ doc = "@param src       SkPath read to create a filled version" ] # [ doc = "@param dst       resulting SkPath; may be the same as src, but may not be nullptr" ] # [ doc = "@param cullRect  optional limit passed to SkPathEffect" ] # [ doc = "@param resScale  if > 1, increase precision, else if (0 < resScale < 1) reduce precision" ] # [ doc = "to favor speed and size" ] # [ doc = "@return          true if the path represents style fill, or false if it represents hairline" ] # [ link_name = "\u{1}__ZNK7SkPaint11getFillPathERK6SkPathPS0_PK6SkRectf" ] pub fn SkPaint_getFillPath ( this : * const SkPaint , src : * const SkPath , dst : * mut SkPath , cullRect : * const SkRect , resScale : SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns the filled equivalent of the stroked path." ] # [ doc = "" ] # [ doc = "Replaces dst with the src path modified by SkPathEffect and style stroke." ] # [ doc = "SkPathEffect, if any, is not culled. stroke width is created with default precision." ] # [ doc = "" ] # [ doc = "@param src  SkPath read to create a filled version" ] # [ doc = "@param dst  resulting SkPath dst may be the same as src, but may not be nullptr" ] # [ doc = "@return     true if the path represents style fill, or false if it represents hairline" ] # [ link_name = "\u{1}__ZNK7SkPaint11getFillPathERK6SkPathPS0_" ] pub fn SkPaint_getFillPath1 ( this : * const SkPaint , src : * const SkPath , dst : * mut SkPath ) -> bool ; } extern "C" { # [ doc = " Returns optional colors used when filling a path, such as a gradient." ] # [ doc = "" ] # [ doc = "Does not alter SkShader SkRefCnt." ] # [ doc = "" ] # [ doc = "@return  SkShader if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint9getShaderEv" ] pub fn SkPaint_getShader ( this : * const SkPaint ) -> * mut SkShader ; } extern "C" { # [ doc = " Returns optional colors used when filling a path, such as a gradient." ] # [ doc = "" ] # [ doc = "Increases SkShader SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@return  SkShader if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint9refShaderEv" ] pub fn SkPaint_refShader ( this : * const SkPaint ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = " Sets optional colors used when filling a path, such as a gradient." ] # [ doc = "" ] # [ doc = "Sets SkShader to shader, decreasing SkRefCnt of the previous SkShader." ] # [ doc = "Increments shader SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@param shader  how geometry is filled with color; if nullptr, color is used instead" ] # [ link_name = "\u{1}__ZN7SkPaint9setShaderE5sk_spI8SkShaderE" ] pub fn SkPaint_setShader ( this : * mut SkPaint , shader : sk_sp < SkShader > ) ; } extern "C" { # [ doc = " Returns SkColorFilter if set, or nullptr." ] # [ doc = "Does not alter SkColorFilter SkRefCnt." ] # [ doc = "" ] # [ doc = "@return  SkColorFilter if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint14getColorFilterEv" ] pub fn SkPaint_getColorFilter ( this : * const SkPaint ) -> * mut SkColorFilter ; } extern "C" { # [ doc = " Returns SkColorFilter if set, or nullptr." ] # [ doc = "Increases SkColorFilter SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@return  SkColorFilter if set, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkPaint14refColorFilterEv" ] pub fn SkPaint_refColorFilter ( this : * const SkPaint ) -> sk_sp < SkColorFilter > ; } extern "C" { # [ doc = " Sets SkColorFilter to filter, decreasing SkRefCnt of the previous" ] # [ doc = "SkColorFilter. Pass nullptr to clear SkColorFilter." ] # [ doc = "" ] # [ doc = "Increments filter SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@param colorFilter  SkColorFilter to apply to subsequent draw" ] # [ link_name = "\u{1}__ZN7SkPaint14setColorFilterE5sk_spI13SkColorFilterE" ] pub fn SkPaint_setColorFilter ( this : * mut SkPaint , colorFilter : sk_sp < SkColorFilter > ) ; } extern "C" { # [ doc = " Returns SkBlendMode." ] # [ doc = "By default, returns SkBlendMode::kSrcOver." ] # [ doc = "" ] # [ doc = "@return  mode used to combine source color with destination color" ] # [ link_name = "\u{1}__ZNK7SkPaint12getBlendModeEv" ] pub fn SkPaint_getBlendMode ( this : * const SkPaint ) -> SkBlendMode ; } extern "C" { # [ doc = " Returns true if SkBlendMode is SkBlendMode::kSrcOver, the default." ] # [ doc = "" ] # [ doc = "@return  true if SkBlendMode is SkBlendMode::kSrcOver" ] # [ link_name = "\u{1}__ZNK7SkPaint9isSrcOverEv" ] pub fn SkPaint_isSrcOver ( this : * const SkPaint ) -> bool ; } extern "C" { # [ doc = " Sets SkBlendMode to mode." ] # [ doc = "Does not check for valid input." ] # [ doc = "" ] # [ doc = "@param mode  SkBlendMode used to combine source color and destination" ] # [ link_name = "\u{1}__ZN7SkPaint12setBlendModeE11SkBlendMode" ] pub fn SkPaint_setBlendMode ( this : * mut SkPaint , mode : SkBlendMode ) ; } extern "C" { # [ doc = " Returns SkPathEffect if set, or nullptr." ] # [ doc = "Does not alter SkPathEffect SkRefCnt." ] # [ doc = "" ] # [ doc = "@return  SkPathEffect if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint13getPathEffectEv" ] pub fn SkPaint_getPathEffect ( this : * const SkPaint ) -> * mut SkPathEffect ; } extern "C" { # [ doc = " Returns SkPathEffect if set, or nullptr." ] # [ doc = "Increases SkPathEffect SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@return  SkPathEffect if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint13refPathEffectEv" ] pub fn SkPaint_refPathEffect ( this : * const SkPaint ) -> sk_sp < SkPathEffect > ; } extern "C" { # [ doc = " Sets SkPathEffect to pathEffect, decreasing SkRefCnt of the previous" ] # [ doc = "SkPathEffect. Pass nullptr to leave the path geometry unaltered." ] # [ doc = "" ] # [ doc = "Increments pathEffect SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@param pathEffect  replace SkPath with a modification when drawn" ] # [ link_name = "\u{1}__ZN7SkPaint13setPathEffectE5sk_spI12SkPathEffectE" ] pub fn SkPaint_setPathEffect ( this : * mut SkPaint , pathEffect : sk_sp < SkPathEffect > ) ; } extern "C" { # [ doc = " Returns SkMaskFilter if set, or nullptr." ] # [ doc = "Does not alter SkMaskFilter SkRefCnt." ] # [ doc = "" ] # [ doc = "@return  SkMaskFilter if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint13getMaskFilterEv" ] pub fn SkPaint_getMaskFilter ( this : * const SkPaint ) -> * mut SkMaskFilter ; } extern "C" { # [ doc = " Returns SkMaskFilter if set, or nullptr." ] # [ doc = "" ] # [ doc = "Increases SkMaskFilter SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@return  SkMaskFilter if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint13refMaskFilterEv" ] pub fn SkPaint_refMaskFilter ( this : * const SkPaint ) -> sk_sp < SkMaskFilter > ; } extern "C" { # [ doc = " Sets SkMaskFilter to maskFilter, decreasing SkRefCnt of the previous" ] # [ doc = "SkMaskFilter. Pass nullptr to clear SkMaskFilter and leave SkMaskFilter effect on" ] # [ doc = "mask alpha unaltered." ] # [ doc = "" ] # [ doc = "Increments maskFilter SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@param maskFilter  modifies clipping mask generated from drawn geometry" ] # [ link_name = "\u{1}__ZN7SkPaint13setMaskFilterE5sk_spI12SkMaskFilterE" ] pub fn SkPaint_setMaskFilter ( this : * mut SkPaint , maskFilter : sk_sp < SkMaskFilter > ) ; } extern "C" { # [ doc = " Returns SkImageFilter if set, or nullptr." ] # [ doc = "Does not alter SkImageFilter SkRefCnt." ] # [ doc = "" ] # [ doc = "@return  SkImageFilter if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint14getImageFilterEv" ] pub fn SkPaint_getImageFilter ( this : * const SkPaint ) -> * mut SkImageFilter ; } extern "C" { # [ doc = " Returns SkImageFilter if set, or nullptr." ] # [ doc = "Increases SkImageFilter SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@return  SkImageFilter if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint14refImageFilterEv" ] pub fn SkPaint_refImageFilter ( this : * const SkPaint ) -> sk_sp < SkImageFilter > ; } extern "C" { # [ doc = " Sets SkImageFilter to imageFilter, decreasing SkRefCnt of the previous" ] # [ doc = "SkImageFilter. Pass nullptr to clear SkImageFilter, and remove SkImageFilter effect" ] # [ doc = "on drawing." ] # [ doc = "" ] # [ doc = "Increments imageFilter SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@param imageFilter  how SkImage is sampled when transformed" ] # [ link_name = "\u{1}__ZN7SkPaint14setImageFilterE5sk_spI13SkImageFilterE" ] pub fn SkPaint_setImageFilter ( this : * mut SkPaint , imageFilter : sk_sp < SkImageFilter > ) ; } extern "C" { # [ doc = " Returns SkDrawLooper if set, or nullptr." ] # [ doc = "Does not alter SkDrawLooper SkRefCnt." ] # [ doc = "" ] # [ doc = "@return  SkDrawLooper if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint13getDrawLooperEv" ] pub fn SkPaint_getDrawLooper ( this : * const SkPaint ) -> * mut SkDrawLooper ; } extern "C" { # [ doc = " Returns SkDrawLooper if set, or nullptr." ] # [ doc = "Increases SkDrawLooper SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@return  SkDrawLooper if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK7SkPaint13refDrawLooperEv" ] pub fn SkPaint_refDrawLooper ( this : * const SkPaint ) -> sk_sp < SkDrawLooper > ; } extern "C" { # [ doc = " Deprecated." ] # [ doc = "(see skbug.com/6259)" ] # [ link_name = "\u{1}__ZNK7SkPaint9getLooperEv" ] pub fn SkPaint_getLooper ( this : * const SkPaint ) -> * mut SkDrawLooper ; } extern "C" { # [ doc = " Sets SkDrawLooper to drawLooper, decreasing SkRefCnt of the previous" ] # [ doc = "drawLooper.  Pass nullptr to clear SkDrawLooper and leave SkDrawLooper effect on" ] # [ doc = "drawing unaltered." ] # [ doc = "" ] # [ doc = "Increments drawLooper SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@param drawLooper  iterates through drawing one or more time, altering SkPaint" ] # [ link_name = "\u{1}__ZN7SkPaint13setDrawLooperE5sk_spI12SkDrawLooperE" ] pub fn SkPaint_setDrawLooper ( this : * mut SkPaint , drawLooper : sk_sp < SkDrawLooper > ) ; } extern "C" { # [ doc = " Deprecated." ] # [ doc = "(see skbug.com/6259)" ] # [ link_name = "\u{1}__ZN7SkPaint9setLooperE5sk_spI12SkDrawLooperE" ] pub fn SkPaint_setLooper ( this : * mut SkPaint , drawLooper : sk_sp < SkDrawLooper > ) ; } extern "C" { # [ doc = " Returns true if SkPaint prevents all drawing;" ] # [ doc = "otherwise, the SkPaint may or may not allow drawing." ] # [ doc = "" ] # [ doc = "Returns true if, for example, SkBlendMode combined with alpha computes a" ] # [ doc = "new alpha of zero." ] # [ doc = "" ] # [ doc = "@return  true if SkPaint prevents all drawing" ] # [ link_name = "\u{1}__ZNK7SkPaint13nothingToDrawEv" ] pub fn SkPaint_nothingToDraw ( this : * const SkPaint ) -> bool ; } extern "C" { # [ doc = "     (to be made private)" ] # [ doc = "Returns true if SkPaint does not include elements requiring extensive computation" ] # [ doc = "to compute SkBaseDevice bounds of drawn geometry. For instance, SkPaint with SkPathEffect" ] # [ doc = "always returns false." ] # [ doc = "" ] # [ doc = "@return  true if SkPaint allows for fast computation of bounds" ] # [ link_name = "\u{1}__ZNK7SkPaint20canComputeFastBoundsEv" ] pub fn SkPaint_canComputeFastBounds ( this : * const SkPaint ) -> bool ; } extern "C" { # [ doc = "     (to be made private)" ] # [ doc = "Only call this if canComputeFastBounds() returned true. This takes a" ] # [ doc = "raw rectangle (the raw bounds of a shape), and adjusts it for stylistic" ] # [ doc = "effects in the paint (e.g. stroking). If needed, it uses the storage" ] # [ doc = "parameter. It returns the adjusted bounds that can then be used" ] # [ doc = "for SkCanvas::quickReject tests." ] # [ doc = "" ] # [ doc = "The returned SkRect will either be orig or storage, thus the caller" ] # [ doc = "should not rely on storage being set to the result, but should always" ] # [ doc = "use the returned value. It is legal for orig and storage to be the same" ] # [ doc = "SkRect." ] # [ doc = "For example:" ] # [ doc = "if (!path.isInverseFillType() && paint.canComputeFastBounds()) {" ] # [ doc = "SkRect storage;" ] # [ doc = "if (canvas->quickReject(paint.computeFastBounds(path.getBounds(), &storage))) {" ] # [ doc = "return; // do not draw the path" ] # [ doc = "}" ] # [ doc = "}" ] # [ doc = "" ] # [ doc = "@param orig     geometry modified by SkPaint when drawn" ] # [ doc = "@param storage  computed bounds of geometry; may not be nullptr" ] # [ doc = "@return         fast computed bounds" ] # [ link_name = "\u{1}__ZNK7SkPaint17computeFastBoundsERK6SkRectPS0_" ] pub fn SkPaint_computeFastBounds ( this : * const SkPaint , orig : * const SkRect , storage : * mut SkRect ) -> * const SkRect ; } extern "C" { # [ doc = "     (to be made private)" ] # [ doc = "" ] # [ doc = "@param orig     geometry modified by SkPaint when drawn" ] # [ doc = "@param storage  computed bounds of geometry" ] # [ doc = "@return         fast computed bounds" ] # [ link_name = "\u{1}__ZNK7SkPaint23computeFastStrokeBoundsERK6SkRectPS0_" ] pub fn SkPaint_computeFastStrokeBounds ( this : * const SkPaint , orig : * const SkRect , storage : * mut SkRect ) -> * const SkRect ; } extern "C" { # [ doc = "     (to be made private)" ] # [ doc = "Computes the bounds, overriding the SkPaint SkPaint::Style. This can be used to" ] # [ doc = "account for additional width required by stroking orig, without" ] # [ doc = "altering SkPaint::Style set to fill." ] # [ doc = "" ] # [ doc = "@param orig     geometry modified by SkPaint when drawn" ] # [ doc = "@param storage  computed bounds of geometry" ] # [ doc = "@param style    overrides SkPaint::Style" ] # [ doc = "@return         fast computed bounds" ] # [ link_name = "\u{1}__ZNK7SkPaint19doComputeFastBoundsERK6SkRectPS0_NS_5StyleE" ] pub fn SkPaint_doComputeFastBounds ( this : * const SkPaint , orig : * const SkRect , storage : * mut SkRect , style : SkPaint_Style ) -> * const SkRect ; } extern "C" { # [ doc = " Constructs SkPaint with default values." ] # [ doc = "" ] # [ doc = "@return  default initialized SkPaint" ] # [ link_name = "\u{1}__ZN7SkPaintC1Ev" ] pub fn SkPaint_SkPaint ( this : * mut SkPaint ) ; } extern "C" { # [ doc = " Makes a shallow copy of SkPaint. SkPathEffect, SkShader," ] # [ doc = "SkMaskFilter, SkColorFilter, SkDrawLooper, and SkImageFilter are shared" ] # [ doc = "between the original paint and the copy. Objects containing SkRefCnt increment" ] # [ doc = "their references by one." ] # [ doc = "" ] # [ doc = "The referenced objects SkPathEffect, SkShader, SkMaskFilter, SkColorFilter," ] # [ doc = "SkDrawLooper, and SkImageFilter cannot be modified after they are created." ] # [ doc = "This prevents objects with SkRefCnt from being modified once SkPaint refers to them." ] # [ doc = "" ] # [ doc = "@param paint  original to copy" ] # [ doc = "@return       shallow copy of paint" ] # [ link_name = "\u{1}__ZN7SkPaintC1ERKS_" ] pub fn SkPaint_SkPaint1 ( this : * mut SkPaint , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Implements a move constructor to avoid increasing the reference counts" ] # [ doc = "of objects referenced by the paint." ] # [ doc = "" ] # [ doc = "After the call, paint is undefined, and can be safely destructed." ] # [ doc = "" ] # [ doc = "@param paint  original to move" ] # [ doc = "@return       content of paint" ] # [ link_name = "\u{1}__ZN7SkPaintC1EOS_" ] pub fn SkPaint_SkPaint2 ( this : * mut SkPaint , paint : * mut SkPaint ) ; } extern "C" { # [ doc = " Decreases SkPaint SkRefCnt of owned objects: SkPathEffect, SkShader," ] # [ doc = "SkMaskFilter, SkColorFilter, SkDrawLooper, and SkImageFilter. If the" ] # [ doc = "objects containing SkRefCnt go to zero, they are deleted." ] # [ link_name = "\u{1}__ZN7SkPaintD1Ev" ] pub fn SkPaint_SkPaint_destructor ( this : * mut SkPaint ) ; } impl SkPaint { # [ inline ] pub unsafe fn getHash ( & self ) -> u32 { SkPaint_getHash ( self ) } # [ inline ] pub unsafe fn reset ( & mut self ) { SkPaint_reset ( self ) } # [ inline ] pub unsafe fn isAntiAlias ( & self ) -> bool { SkPaint_isAntiAlias ( self ) } # [ inline ] pub unsafe fn setAntiAlias ( & mut self , aa : bool ) { SkPaint_setAntiAlias ( self , aa ) } # [ inline ] pub unsafe fn isDither ( & self ) -> bool { SkPaint_isDither ( self ) } # [ inline ] pub unsafe fn setDither ( & mut self , dither : bool ) { SkPaint_setDither ( self , dither ) } # [ inline ] pub unsafe fn getFilterQuality ( & self ) -> SkFilterQuality { SkPaint_getFilterQuality ( self ) } # [ inline ] pub unsafe fn setFilterQuality ( & mut self , quality : SkFilterQuality ) { SkPaint_setFilterQuality ( self , quality ) } # [ inline ] pub unsafe fn getStyle ( & self ) -> SkPaint_Style { SkPaint_getStyle ( self ) } # [ inline ] pub unsafe fn setStyle ( & mut self , style : SkPaint_Style ) { SkPaint_setStyle ( self , style ) } # [ inline ] pub unsafe fn getColor ( & self ) -> SkColor { SkPaint_getColor ( self ) } # [ inline ] pub unsafe fn getColor4f ( & self ) -> SkColor4f { SkPaint_getColor4f ( self ) } # [ inline ] pub unsafe fn setColor ( & mut self , color : SkColor ) { SkPaint_setColor ( self , color ) } # [ inline ] pub unsafe fn setColor4f ( & mut self , color : * const SkColor4f , colorSpace : * mut SkColorSpace ) { SkPaint_setColor4f ( self , color , colorSpace ) } # [ inline ] pub unsafe fn getAlphaf ( & self ) -> f32 { SkPaint_getAlphaf ( self ) } # [ inline ] pub unsafe fn getAlpha ( & self ) -> u8 { SkPaint_getAlpha ( self ) } # [ inline ] pub unsafe fn setAlphaf ( & mut self , a : f32 ) { SkPaint_setAlphaf ( self , a ) } # [ inline ] pub unsafe fn setAlpha ( & mut self , a : U8CPU ) { SkPaint_setAlpha ( self , a ) } # [ inline ] pub unsafe fn setARGB ( & mut self , a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU ) { SkPaint_setARGB ( self , a , r , g , b ) } # [ inline ] pub unsafe fn getStrokeWidth ( & self ) -> SkScalar { SkPaint_getStrokeWidth ( self ) } # [ inline ] pub unsafe fn setStrokeWidth ( & mut self , width : SkScalar ) { SkPaint_setStrokeWidth ( self , width ) } # [ inline ] pub unsafe fn getStrokeMiter ( & self ) -> SkScalar { SkPaint_getStrokeMiter ( self ) } # [ inline ] pub unsafe fn setStrokeMiter ( & mut self , miter : SkScalar ) { SkPaint_setStrokeMiter ( self , miter ) } # [ inline ] pub unsafe fn getStrokeCap ( & self ) -> SkPaint_Cap { SkPaint_getStrokeCap ( self ) } # [ inline ] pub unsafe fn setStrokeCap ( & mut self , cap : SkPaint_Cap ) { SkPaint_setStrokeCap ( self , cap ) } # [ inline ] pub unsafe fn getStrokeJoin ( & self ) -> SkPaint_Join { SkPaint_getStrokeJoin ( self ) } # [ inline ] pub unsafe fn setStrokeJoin ( & mut self , join : SkPaint_Join ) { SkPaint_setStrokeJoin ( self , join ) } # [ inline ] pub unsafe fn getFillPath ( & self , src : * const SkPath , dst : * mut SkPath , cullRect : * const SkRect , resScale : SkScalar ) -> bool { SkPaint_getFillPath ( self , src , dst , cullRect , resScale ) } # [ inline ] pub unsafe fn getFillPath1 ( & self , src : * const SkPath , dst : * mut SkPath ) -> bool { SkPaint_getFillPath1 ( self , src , dst ) } # [ inline ] pub unsafe fn getShader ( & self ) -> * mut SkShader { SkPaint_getShader ( self ) } # [ inline ] pub unsafe fn refShader ( & self ) -> sk_sp < SkShader > { SkPaint_refShader ( self ) } # [ inline ] pub unsafe fn setShader ( & mut self , shader : sk_sp < SkShader > ) { SkPaint_setShader ( self , shader ) } # [ inline ] pub unsafe fn getColorFilter ( & self ) -> * mut SkColorFilter { SkPaint_getColorFilter ( self ) } # [ inline ] pub unsafe fn refColorFilter ( & self ) -> sk_sp < SkColorFilter > { SkPaint_refColorFilter ( self ) } # [ inline ] pub unsafe fn setColorFilter ( & mut self , colorFilter : sk_sp < SkColorFilter > ) { SkPaint_setColorFilter ( self , colorFilter ) } # [ inline ] pub unsafe fn getBlendMode ( & self ) -> SkBlendMode { SkPaint_getBlendMode ( self ) } # [ inline ] pub unsafe fn isSrcOver ( & self ) -> bool { SkPaint_isSrcOver ( self ) } # [ inline ] pub unsafe fn setBlendMode ( & mut self , mode : SkBlendMode ) { SkPaint_setBlendMode ( self , mode ) } # [ inline ] pub unsafe fn getPathEffect ( & self ) -> * mut SkPathEffect { SkPaint_getPathEffect ( self ) } # [ inline ] pub unsafe fn refPathEffect ( & self ) -> sk_sp < SkPathEffect > { SkPaint_refPathEffect ( self ) } # [ inline ] pub unsafe fn setPathEffect ( & mut self , pathEffect : sk_sp < SkPathEffect > ) { SkPaint_setPathEffect ( self , pathEffect ) } # [ inline ] pub unsafe fn getMaskFilter ( & self ) -> * mut SkMaskFilter { SkPaint_getMaskFilter ( self ) } # [ inline ] pub unsafe fn refMaskFilter ( & self ) -> sk_sp < SkMaskFilter > { SkPaint_refMaskFilter ( self ) } # [ inline ] pub unsafe fn setMaskFilter ( & mut self , maskFilter : sk_sp < SkMaskFilter > ) { SkPaint_setMaskFilter ( self , maskFilter ) } # [ inline ] pub unsafe fn getImageFilter ( & self ) -> * mut SkImageFilter { SkPaint_getImageFilter ( self ) } # [ inline ] pub unsafe fn refImageFilter ( & self ) -> sk_sp < SkImageFilter > { SkPaint_refImageFilter ( self ) } # [ inline ] pub unsafe fn setImageFilter ( & mut self , imageFilter : sk_sp < SkImageFilter > ) { SkPaint_setImageFilter ( self , imageFilter ) } # [ inline ] pub unsafe fn getDrawLooper ( & self ) -> * mut SkDrawLooper { SkPaint_getDrawLooper ( self ) } # [ inline ] pub unsafe fn refDrawLooper ( & self ) -> sk_sp < SkDrawLooper > { SkPaint_refDrawLooper ( self ) } # [ inline ] pub unsafe fn getLooper ( & self ) -> * mut SkDrawLooper { SkPaint_getLooper ( self ) } # [ inline ] pub unsafe fn setDrawLooper ( & mut self , drawLooper : sk_sp < SkDrawLooper > ) { SkPaint_setDrawLooper ( self , drawLooper ) } # [ inline ] pub unsafe fn setLooper ( & mut self , drawLooper : sk_sp < SkDrawLooper > ) { SkPaint_setLooper ( self , drawLooper ) } # [ inline ] pub unsafe fn nothingToDraw ( & self ) -> bool { SkPaint_nothingToDraw ( self ) } # [ inline ] pub unsafe fn canComputeFastBounds ( & self ) -> bool { SkPaint_canComputeFastBounds ( self ) } # [ inline ] pub unsafe fn computeFastBounds ( & self , orig : * const SkRect , storage : * mut SkRect ) -> * const SkRect { SkPaint_computeFastBounds ( self , orig , storage ) } # [ inline ] pub unsafe fn computeFastStrokeBounds ( & self , orig : * const SkRect , storage : * mut SkRect ) -> * const SkRect { SkPaint_computeFastStrokeBounds ( self , orig , storage ) } # [ inline ] pub unsafe fn doComputeFastBounds ( & self , orig : * const SkRect , storage : * mut SkRect , style : SkPaint_Style ) -> * const SkRect { SkPaint_doComputeFastBounds ( self , orig , storage , style ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPaint_SkPaint ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( paint : * const SkPaint ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPaint_SkPaint1 ( & mut __bindgen_tmp , paint ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( paint : * mut SkPaint ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPaint_SkPaint2 ( & mut __bindgen_tmp , paint ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkPaint_SkPaint_destructor ( self ) } } # [ repr ( C ) ] pub struct SkRasterHandleAllocator__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ doc = "  If a client wants to control the allocation of raster layers in a canvas, it should subclass" ] # [ doc = "  SkRasterHandleAllocator. This allocator performs two tasks:" ] # [ doc = "      1. controls how the memory for the pixels is allocated" ] # [ doc = "      2. associates a \"handle\" to a private object that can track the matrix/clip of the SkCanvas" ] # [ doc = "" ] # [ doc = "  This example allocates a canvas, and defers to the allocator to create the base layer." ] # [ doc = "" ] # [ doc = "      std::unique_ptr<SkCanvas> canvas = SkRasterHandleAllocator::MakeCanvas(" ] # [ doc = "              SkImageInfo::Make(...)," ] # [ doc = "              skstd::make_unique<MySubclassRasterHandleAllocator>(...)," ] # [ doc = "              nullptr);" ] # [ doc = "" ] # [ doc = "  If you have already allocated the base layer (and its handle, release-proc etc.) then you" ] # [ doc = "  can pass those in using the last parameter to MakeCanvas()." ] # [ doc = "" ] # [ doc = "  Regardless of how the base layer is allocated, each time canvas->saveLayer() is called," ] # [ doc = "  your allocator\'s allocHandle() will be called." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkRasterHandleAllocator { pub vtable_ : * const SkRasterHandleAllocator__bindgen_vtable , } pub type SkRasterHandleAllocator_Handle = * mut :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRasterHandleAllocator_Rec { pub fReleaseProc : :: core :: option :: Option < unsafe extern "C" fn ( pixels : * mut :: std :: os :: raw :: c_void , ctx : * mut :: std :: os :: raw :: c_void ) > , pub fReleaseCtx : * mut :: std :: os :: raw :: c_void , pub fPixels : * mut :: std :: os :: raw :: c_void , pub fRowBytes : usize , pub fHandle : SkRasterHandleAllocator_Handle , } # [ test ] fn bindgen_test_layout_SkRasterHandleAllocator_Rec ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRasterHandleAllocator_Rec > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( SkRasterHandleAllocator_Rec ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRasterHandleAllocator_Rec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkRasterHandleAllocator_Rec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRasterHandleAllocator_Rec > ( ) ) ) . fReleaseProc as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkRasterHandleAllocator_Rec ) , "::" , stringify ! ( fReleaseProc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRasterHandleAllocator_Rec > ( ) ) ) . fReleaseCtx as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkRasterHandleAllocator_Rec ) , "::" , stringify ! ( fReleaseCtx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRasterHandleAllocator_Rec > ( ) ) ) . fPixels as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkRasterHandleAllocator_Rec ) , "::" , stringify ! ( fPixels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRasterHandleAllocator_Rec > ( ) ) ) . fRowBytes as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkRasterHandleAllocator_Rec ) , "::" , stringify ! ( fRowBytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRasterHandleAllocator_Rec > ( ) ) ) . fHandle as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkRasterHandleAllocator_Rec ) , "::" , stringify ! ( fHandle ) ) ) ; } # [ test ] fn bindgen_test_layout_SkRasterHandleAllocator ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRasterHandleAllocator > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkRasterHandleAllocator ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRasterHandleAllocator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkRasterHandleAllocator ) ) ) ; } extern "C" { # [ doc = "  This creates a canvas which will use the allocator to manage pixel allocations, including" ] # [ doc = "  all calls to saveLayer()." ] # [ doc = "" ] # [ doc = "  If rec is non-null, then it will be used as the base-layer of pixels/handle." ] # [ doc = "  If rec is null, then the allocator will be called for the base-layer as well." ] # [ link_name = "\u{1}__ZN23SkRasterHandleAllocator10MakeCanvasENSt3__110unique_ptrIS_NS0_14default_deleteIS_EEEERK11SkImageInfoPKNS_3RecE" ] pub fn SkRasterHandleAllocator_MakeCanvas ( arg1 : std_unique_ptr , arg2 : * const SkImageInfo , rec : * const SkRasterHandleAllocator_Rec ) -> std_unique_ptr ; } impl SkRasterHandleAllocator { # [ inline ] pub unsafe fn MakeCanvas ( arg1 : std_unique_ptr , arg2 : * const SkImageInfo , rec : * const SkRasterHandleAllocator_Rec ) -> std_unique_ptr { SkRasterHandleAllocator_MakeCanvas ( arg1 , arg2 , rec ) } } extern "C" { # [ link_name = "\u{1}__ZN23SkRasterHandleAllocatorD1Ev" ] pub fn SkRasterHandleAllocator_SkRasterHandleAllocator_destructor ( this : * mut SkRasterHandleAllocator ) ; } # [ repr ( u32 ) ] # [ doc = "  Description of how the LCD strips are arranged for each pixel. If this is unknown, or the" ] # [ doc = "  pixels are meant to be \"portable\" and/or transformed before showing (e.g. rotated, scaled)" ] # [ doc = "  then use kUnknown_SkPixelGeometry." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkPixelGeometry { kUnknown_SkPixelGeometry = 0 , kRGB_H_SkPixelGeometry = 1 , kBGR_H_SkPixelGeometry = 2 , kRGB_V_SkPixelGeometry = 3 , kBGR_V_SkPixelGeometry = 4 , } # [ doc = "  Describes properties and constraints of a given SkSurface. The rendering engine can parse these" ] # [ doc = "  during drawing, and can sometimes optimize its performance (e.g. disabling an expensive" ] # [ doc = "  feature)." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkSurfaceProps { pub fFlags : u32 , pub fPixelGeometry : SkPixelGeometry , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkSurfaceProps_Flags { kUseDeviceIndependentFonts_Flag = 1 , } pub const SkSurfaceProps_InitType_kLegacyFontHost_InitType : SkSurfaceProps_InitType = 0 ; pub type SkSurfaceProps_InitType = u32 ; extern "C" { # [ link_name = "\u{1}__ZN14SkSurfaceProps27kUseDistanceFieldFonts_FlagE" ] pub static SkSurfaceProps_kUseDistanceFieldFonts_Flag : SkSurfaceProps_Flags ; } # [ test ] fn bindgen_test_layout_SkSurfaceProps ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkSurfaceProps > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkSurfaceProps ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkSurfaceProps > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkSurfaceProps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkSurfaceProps > ( ) ) ) . fFlags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkSurfaceProps ) , "::" , stringify ! ( fFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkSurfaceProps > ( ) ) ) . fPixelGeometry as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkSurfaceProps ) , "::" , stringify ! ( fPixelGeometry ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK14SkSurfaceProps5flagsEv" ] pub fn SkSurfaceProps_flags ( this : * const SkSurfaceProps ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZNK14SkSurfaceProps13pixelGeometryEv" ] pub fn SkSurfaceProps_pixelGeometry ( this : * const SkSurfaceProps ) -> SkPixelGeometry ; } extern "C" { # [ link_name = "\u{1}__ZNK14SkSurfaceProps27isUseDeviceIndependentFontsEv" ] pub fn SkSurfaceProps_isUseDeviceIndependentFonts ( this : * const SkSurfaceProps ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN14SkSurfacePropsC1Ej15SkPixelGeometry" ] pub fn SkSurfaceProps_SkSurfaceProps ( this : * mut SkSurfaceProps , flags : u32 , arg1 : SkPixelGeometry ) ; } extern "C" { # [ link_name = "\u{1}__ZN14SkSurfacePropsC1ENS_8InitTypeE" ] pub fn SkSurfaceProps_SkSurfaceProps1 ( this : * mut SkSurfaceProps , arg1 : SkSurfaceProps_InitType ) ; } extern "C" { # [ link_name = "\u{1}__ZN14SkSurfacePropsC1EjNS_8InitTypeE" ] pub fn SkSurfaceProps_SkSurfaceProps2 ( this : * mut SkSurfaceProps , flags : u32 , arg1 : SkSurfaceProps_InitType ) ; } extern "C" { # [ link_name = "\u{1}__ZN14SkSurfacePropsC1ERKS_" ] pub fn SkSurfaceProps_SkSurfaceProps3 ( this : * mut SkSurfaceProps , other : * const SkSurfaceProps ) ; } impl SkSurfaceProps { # [ inline ] pub unsafe fn flags ( & self ) -> u32 { SkSurfaceProps_flags ( self ) } # [ inline ] pub unsafe fn pixelGeometry ( & self ) -> SkPixelGeometry { SkSurfaceProps_pixelGeometry ( self ) } # [ inline ] pub unsafe fn isUseDeviceIndependentFonts ( & self ) -> bool { SkSurfaceProps_isUseDeviceIndependentFonts ( self ) } # [ inline ] pub unsafe fn new ( flags : u32 , arg1 : SkPixelGeometry ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkSurfaceProps_SkSurfaceProps ( & mut __bindgen_tmp , flags , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : SkSurfaceProps_InitType ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkSurfaceProps_SkSurfaceProps1 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( flags : u32 , arg1 : SkSurfaceProps_InitType ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkSurfaceProps_SkSurfaceProps2 ( & mut __bindgen_tmp , flags , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( other : * const SkSurfaceProps ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkSurfaceProps_SkSurfaceProps3 ( & mut __bindgen_tmp , other ) ; __bindgen_tmp } } # [ doc = "  SkData holds an immutable data buffer. Not only is the data immutable," ] # [ doc = "  but the actual ptr that is returned (by data() or bytes()) is guaranteed" ] # [ doc = "  to always be the same for the life of this instance." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkData { pub _base : SkNVRefCnt , pub fReleaseProc : SkData_ReleaseProc , pub fReleaseProcContext : * mut :: std :: os :: raw :: c_void , pub fPtr : * mut :: std :: os :: raw :: c_void , pub fSize : usize , } # [ doc = "  Function that, if provided, will be called when the SkData goes out" ] # [ doc = "  of scope, allowing for custom allocation/freeing of the data\'s contents." ] pub type SkData_ReleaseProc = :: core :: option :: Option < unsafe extern "C" fn ( ptr : * const :: std :: os :: raw :: c_void , context : * mut :: std :: os :: raw :: c_void ) > ; pub type SkData_INHERITED = SkRefCnt ; # [ test ] fn bindgen_test_layout_SkData ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkData > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( SkData ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkData > ( ) ) ) . fReleaseProc as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkData ) , "::" , stringify ! ( fReleaseProc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkData > ( ) ) ) . fReleaseProcContext as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkData ) , "::" , stringify ! ( fReleaseProcContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkData > ( ) ) ) . fPtr as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkData ) , "::" , stringify ! ( fPtr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkData > ( ) ) ) . fSize as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkData ) , "::" , stringify ! ( fSize ) ) ) ; } extern "C" { # [ doc = "  Returns the number of bytes stored." ] # [ link_name = "\u{1}__ZNK6SkData4sizeEv" ] pub fn SkData_size ( this : * const SkData ) -> usize ; } extern "C" { # [ link_name = "\u{1}__ZNK6SkData7isEmptyEv" ] pub fn SkData_isEmpty ( this : * const SkData ) -> bool ; } extern "C" { # [ doc = "  Returns the ptr to the data." ] # [ link_name = "\u{1}__ZNK6SkData4dataEv" ] pub fn SkData_data ( this : * const SkData ) -> * const :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = "  Like data(), returns a read-only ptr into the data, but in this case" ] # [ doc = "  it is cast to uint8_t*, to make it easy to add an offset to it." ] # [ link_name = "\u{1}__ZNK6SkData5bytesEv" ] pub fn SkData_bytes ( this : * const SkData ) -> * const u8 ; } extern "C" { # [ doc = "  USE WITH CAUTION." ] # [ doc = "  This call will assert that the refcnt is 1, as a precaution against modifying the" ] # [ doc = "  contents when another client/thread has access to the data." ] # [ link_name = "\u{1}__ZN6SkData13writable_dataEv" ] pub fn SkData_writable_data ( this : * mut SkData ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = "  Helper to copy a range of the data into a caller-provided buffer." ] # [ doc = "  Returns the actual number of bytes copied, after clamping offset and" ] # [ doc = "  length to the size of the data. If buffer is NULL, it is ignored, and" ] # [ doc = "  only the computed number of bytes is returned." ] # [ link_name = "\u{1}__ZNK6SkData9copyRangeEmmPv" ] pub fn SkData_copyRange ( this : * const SkData , offset : usize , length : usize , buffer : * mut :: std :: os :: raw :: c_void ) -> usize ; } extern "C" { # [ doc = "  Returns true if these two objects have the same length and contents," ] # [ doc = "  effectively returning 0 == memcmp(...)" ] # [ link_name = "\u{1}__ZNK6SkData6equalsEPKS_" ] pub fn SkData_equals ( this : * const SkData , other : * const SkData ) -> bool ; } extern "C" { # [ doc = "  Create a new dataref by copying the specified data" ] # [ link_name = "\u{1}__ZN6SkData12MakeWithCopyEPKvm" ] pub fn SkData_MakeWithCopy ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Create a new data with uninitialized contents. The caller should call writable_data()" ] # [ doc = "  to write into the buffer, but this must be done before another ref() is made." ] # [ link_name = "\u{1}__ZN6SkData17MakeUninitializedEm" ] pub fn SkData_MakeUninitialized ( length : usize ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Create a new dataref by copying the specified c-string" ] # [ doc = "  (a null-terminated array of bytes). The returned SkData will have size()" ] # [ doc = "  equal to strlen(cstr) + 1. If cstr is NULL, it will be treated the same" ] # [ doc = "  as \"\"." ] # [ link_name = "\u{1}__ZN6SkData15MakeWithCStringEPKc" ] pub fn SkData_MakeWithCString ( cstr : * const :: std :: os :: raw :: c_char ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Create a new dataref, taking the ptr as is, and using the" ] # [ doc = "  releaseproc to free it. The proc may be NULL." ] # [ link_name = "\u{1}__ZN6SkData12MakeWithProcEPKvmPFvS1_PvES2_" ] pub fn SkData_MakeWithProc ( ptr : * const :: std :: os :: raw :: c_void , length : usize , proc_ : SkData_ReleaseProc , ctx : * mut :: std :: os :: raw :: c_void ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Call this when the data parameter is already const and will outlive the lifetime of the" ] # [ doc = "  SkData. Suitable for with const globals." ] # [ link_name = "\u{1}__ZN6SkData15MakeWithoutCopyEPKvm" ] pub fn SkData_MakeWithoutCopy ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Create a new dataref from a pointer allocated by malloc. The Data object" ] # [ doc = "  takes ownership of that allocation, and will handling calling sk_free." ] # [ link_name = "\u{1}__ZN6SkData14MakeFromMallocEPKvm" ] pub fn SkData_MakeFromMalloc ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Create a new dataref the file with the specified path." ] # [ doc = "  If the file cannot be opened, this returns NULL." ] # [ link_name = "\u{1}__ZN6SkData16MakeFromFileNameEPKc" ] pub fn SkData_MakeFromFileName ( path : * const :: std :: os :: raw :: c_char ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Create a new dataref from a stdio FILE." ] # [ doc = "  This does not take ownership of the FILE, nor close it." ] # [ doc = "  The caller is free to close the FILE at its convenience." ] # [ doc = "  The FILE must be open for reading only." ] # [ doc = "  Returns NULL on failure." ] # [ link_name = "\u{1}__ZN6SkData12MakeFromFILEEP7__sFILE" ] pub fn SkData_MakeFromFILE ( f : * mut FILE ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Create a new dataref from a file descriptor." ] # [ doc = "  This does not take ownership of the file descriptor, nor close it." ] # [ doc = "  The caller is free to close the file descriptor at its convenience." ] # [ doc = "  The file descriptor must be open for reading only." ] # [ doc = "  Returns NULL on failure." ] # [ link_name = "\u{1}__ZN6SkData10MakeFromFDEi" ] pub fn SkData_MakeFromFD ( fd : :: std :: os :: raw :: c_int ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Attempt to read size bytes into a SkData. If the read succeeds, return the data," ] # [ doc = "  else return NULL. Either way the stream\'s cursor may have been changed as a result" ] # [ doc = "  of calling read()." ] # [ link_name = "\u{1}__ZN6SkData14MakeFromStreamEP8SkStreamm" ] pub fn SkData_MakeFromStream ( arg1 : * mut SkStream , size : usize ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Create a new dataref using a subset of the data in the specified" ] # [ doc = "  src dataref." ] # [ link_name = "\u{1}__ZN6SkData10MakeSubsetEPKS_mm" ] pub fn SkData_MakeSubset ( src : * const SkData , offset : usize , length : usize ) -> sk_sp < SkData > ; } extern "C" { # [ doc = "  Returns a new empty dataref (or a reference to a shared empty dataref)." ] # [ doc = "  New or shared, the caller must see that unref() is eventually called." ] # [ link_name = "\u{1}__ZN6SkData9MakeEmptyEv" ] pub fn SkData_MakeEmpty ( ) -> sk_sp < SkData > ; } impl SkData { # [ inline ] pub unsafe fn size ( & self ) -> usize { SkData_size ( self ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkData_isEmpty ( self ) } # [ inline ] pub unsafe fn data ( & self ) -> * const :: std :: os :: raw :: c_void { SkData_data ( self ) } # [ inline ] pub unsafe fn bytes ( & self ) -> * const u8 { SkData_bytes ( self ) } # [ inline ] pub unsafe fn writable_data ( & mut self ) -> * mut :: std :: os :: raw :: c_void { SkData_writable_data ( self ) } # [ inline ] pub unsafe fn copyRange ( & self , offset : usize , length : usize , buffer : * mut :: std :: os :: raw :: c_void ) -> usize { SkData_copyRange ( self , offset , length , buffer ) } # [ inline ] pub unsafe fn equals ( & self , other : * const SkData ) -> bool { SkData_equals ( self , other ) } # [ inline ] pub unsafe fn MakeWithCopy ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkData > { SkData_MakeWithCopy ( data , length ) } # [ inline ] pub unsafe fn MakeUninitialized ( length : usize ) -> sk_sp < SkData > { SkData_MakeUninitialized ( length ) } # [ inline ] pub unsafe fn MakeWithCString ( cstr : * const :: std :: os :: raw :: c_char ) -> sk_sp < SkData > { SkData_MakeWithCString ( cstr ) } # [ inline ] pub unsafe fn MakeWithProc ( ptr : * const :: std :: os :: raw :: c_void , length : usize , proc_ : SkData_ReleaseProc , ctx : * mut :: std :: os :: raw :: c_void ) -> sk_sp < SkData > { SkData_MakeWithProc ( ptr , length , proc_ , ctx ) } # [ inline ] pub unsafe fn MakeWithoutCopy ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkData > { SkData_MakeWithoutCopy ( data , length ) } # [ inline ] pub unsafe fn MakeFromMalloc ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkData > { SkData_MakeFromMalloc ( data , length ) } # [ inline ] pub unsafe fn MakeFromFileName ( path : * const :: std :: os :: raw :: c_char ) -> sk_sp < SkData > { SkData_MakeFromFileName ( path ) } # [ inline ] pub unsafe fn MakeFromFILE ( f : * mut FILE ) -> sk_sp < SkData > { SkData_MakeFromFILE ( f ) } # [ inline ] pub unsafe fn MakeFromFD ( fd : :: std :: os :: raw :: c_int ) -> sk_sp < SkData > { SkData_MakeFromFD ( fd ) } # [ inline ] pub unsafe fn MakeFromStream ( arg1 : * mut SkStream , size : usize ) -> sk_sp < SkData > { SkData_MakeFromStream ( arg1 , size ) } # [ inline ] pub unsafe fn MakeSubset ( src : * const SkData , offset : usize , length : usize ) -> sk_sp < SkData > { SkData_MakeSubset ( src , offset , length ) } # [ inline ] pub unsafe fn MakeEmpty ( ) -> sk_sp < SkData > { SkData_MakeEmpty ( ) } } # [ doc = " An immutable set of vertex data that can be used with SkCanvas::drawVertices." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkVertices { pub _base : SkNVRefCnt , pub fUniqueID : u32 , pub fPositions : * mut SkPoint , pub fTexs : * mut SkPoint , pub fColors : * mut SkColor , pub fBoneIndices : * mut SkVertices_BoneIndices , pub fBoneWeights : * mut SkVertices_BoneWeights , pub fIndices : * mut u16 , pub fBounds : SkRect , pub fVertexCnt : :: std :: os :: raw :: c_int , pub fIndexCnt : :: std :: os :: raw :: c_int , pub fIsVolatile : bool , pub fMode : SkVertices_VertexMode , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkVertices_BoneIndices { pub indices : [ u32 ; 4usize ] , } # [ test ] fn bindgen_test_layout_SkVertices_BoneIndices ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkVertices_BoneIndices > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkVertices_BoneIndices ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkVertices_BoneIndices > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkVertices_BoneIndices ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices_BoneIndices > ( ) ) ) . indices as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices_BoneIndices ) , "::" , stringify ! ( indices ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkVertices_BoneWeights { pub weights : [ f32 ; 4usize ] , } # [ test ] fn bindgen_test_layout_SkVertices_BoneWeights ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkVertices_BoneWeights > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkVertices_BoneWeights ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkVertices_BoneWeights > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkVertices_BoneWeights ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices_BoneWeights > ( ) ) ) . weights as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices_BoneWeights ) , "::" , stringify ! ( weights ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkVertices_Bone { pub values : [ f32 ; 6usize ] , } # [ test ] fn bindgen_test_layout_SkVertices_Bone ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkVertices_Bone > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkVertices_Bone ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkVertices_Bone > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkVertices_Bone ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices_Bone > ( ) ) ) . values as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices_Bone ) , "::" , stringify ! ( values ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices4Bone8mapPointERK7SkPoint" ] pub fn SkVertices_Bone_mapPoint ( this : * const SkVertices_Bone , point : * const SkPoint ) -> SkPoint ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices4Bone7mapRectERK6SkRect" ] pub fn SkVertices_Bone_mapRect ( this : * const SkVertices_Bone , rect : * const SkRect ) -> SkRect ; } impl SkVertices_Bone { # [ inline ] pub unsafe fn mapPoint ( & self , point : * const SkPoint ) -> SkPoint { SkVertices_Bone_mapPoint ( self , point ) } # [ inline ] pub unsafe fn mapRect ( & self , rect : * const SkRect ) -> SkRect { SkVertices_Bone_mapRect ( self , rect ) } } pub const SkVertices_VertexMode_kTriangles_VertexMode : SkVertices_VertexMode = 0 ; pub const SkVertices_VertexMode_kTriangleStrip_VertexMode : SkVertices_VertexMode = 1 ; pub const SkVertices_VertexMode_kTriangleFan_VertexMode : SkVertices_VertexMode = 2 ; pub const SkVertices_VertexMode_kLast_VertexMode : SkVertices_VertexMode = 2 ; pub type SkVertices_VertexMode = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkVertices_Sizes { _unused : [ u8 ; 0 ] , } pub const SkVertices_BuilderFlags_kHasTexCoords_BuilderFlag : SkVertices_BuilderFlags = 1 ; pub const SkVertices_BuilderFlags_kHasColors_BuilderFlag : SkVertices_BuilderFlags = 2 ; pub const SkVertices_BuilderFlags_kHasBones_BuilderFlag : SkVertices_BuilderFlags = 4 ; pub const SkVertices_BuilderFlags_kIsNonVolatile_BuilderFlag : SkVertices_BuilderFlags = 8 ; pub type SkVertices_BuilderFlags = u32 ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkVertices_Builder { pub fVertices : sk_sp < SkVertices > , pub fIntermediateFanIndices : u64 , } # [ test ] fn bindgen_test_layout_SkVertices_Builder ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkVertices_Builder > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkVertices_Builder ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkVertices_Builder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkVertices_Builder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices_Builder > ( ) ) ) . fVertices as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices_Builder ) , "::" , stringify ! ( fVertices ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices_Builder > ( ) ) ) . fIntermediateFanIndices as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices_Builder ) , "::" , stringify ! ( fIntermediateFanIndices ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices7Builder7isValidEv" ] pub fn SkVertices_Builder_isValid ( this : * const SkVertices_Builder ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices7Builder11vertexCountEv" ] pub fn SkVertices_Builder_vertexCount ( this : * const SkVertices_Builder ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices7Builder10indexCountEv" ] pub fn SkVertices_Builder_indexCount ( this : * const SkVertices_Builder ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices7Builder10isVolatileEv" ] pub fn SkVertices_Builder_isVolatile ( this : * const SkVertices_Builder ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices7Builder9positionsEv" ] pub fn SkVertices_Builder_positions ( this : * mut SkVertices_Builder ) -> * mut SkPoint ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices7Builder9texCoordsEv" ] pub fn SkVertices_Builder_texCoords ( this : * mut SkVertices_Builder ) -> * mut SkPoint ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices7Builder6colorsEv" ] pub fn SkVertices_Builder_colors ( this : * mut SkVertices_Builder ) -> * mut SkColor ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices7Builder11boneIndicesEv" ] pub fn SkVertices_Builder_boneIndices ( this : * mut SkVertices_Builder ) -> * mut SkVertices_BoneIndices ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices7Builder11boneWeightsEv" ] pub fn SkVertices_Builder_boneWeights ( this : * mut SkVertices_Builder ) -> * mut SkVertices_BoneWeights ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices7Builder7indicesEv" ] pub fn SkVertices_Builder_indices ( this : * mut SkVertices_Builder ) -> * mut u16 ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices7Builder6detachEv" ] pub fn SkVertices_Builder_detach ( this : * mut SkVertices_Builder ) -> sk_sp < SkVertices > ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices7BuilderC1ENS_10VertexModeEiij" ] pub fn SkVertices_Builder_Builder ( this : * mut SkVertices_Builder , mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , indexCount : :: std :: os :: raw :: c_int , flags : u32 ) ; } impl SkVertices_Builder { # [ inline ] pub unsafe fn isValid ( & self ) -> bool { SkVertices_Builder_isValid ( self ) } # [ inline ] pub unsafe fn vertexCount ( & self ) -> :: std :: os :: raw :: c_int { SkVertices_Builder_vertexCount ( self ) } # [ inline ] pub unsafe fn indexCount ( & self ) -> :: std :: os :: raw :: c_int { SkVertices_Builder_indexCount ( self ) } # [ inline ] pub unsafe fn isVolatile ( & self ) -> bool { SkVertices_Builder_isVolatile ( self ) } # [ inline ] pub unsafe fn positions ( & mut self ) -> * mut SkPoint { SkVertices_Builder_positions ( self ) } # [ inline ] pub unsafe fn texCoords ( & mut self ) -> * mut SkPoint { SkVertices_Builder_texCoords ( self ) } # [ inline ] pub unsafe fn colors ( & mut self ) -> * mut SkColor { SkVertices_Builder_colors ( self ) } # [ inline ] pub unsafe fn boneIndices ( & mut self ) -> * mut SkVertices_BoneIndices { SkVertices_Builder_boneIndices ( self ) } # [ inline ] pub unsafe fn boneWeights ( & mut self ) -> * mut SkVertices_BoneWeights { SkVertices_Builder_boneWeights ( self ) } # [ inline ] pub unsafe fn indices ( & mut self ) -> * mut u16 { SkVertices_Builder_indices ( self ) } # [ inline ] pub unsafe fn detach ( & mut self ) -> sk_sp < SkVertices > { SkVertices_Builder_detach ( self ) } # [ inline ] pub unsafe fn new ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , indexCount : :: std :: os :: raw :: c_int , flags : u32 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkVertices_Builder_Builder ( & mut __bindgen_tmp , mode , vertexCount , indexCount , flags ) ; __bindgen_tmp } } # [ test ] fn bindgen_test_layout_SkVertices ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkVertices > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( SkVertices ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkVertices > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkVertices ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fUniqueID as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fUniqueID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fPositions as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fPositions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fTexs as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fTexs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fColors as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fColors ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fBoneIndices as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fBoneIndices ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fBoneWeights as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fBoneWeights ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fIndices as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fIndices ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fBounds as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fVertexCnt as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fVertexCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fIndexCnt as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fIndexCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fIsVolatile as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fIsVolatile ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkVertices > ( ) ) ) . fMode as * const _ as usize } , 84usize , concat ! ( "Offset of field: " , stringify ! ( SkVertices ) , "::" , stringify ! ( fMode ) ) ) ; } extern "C" { # [ doc = "  Create a vertices by copying the specified arrays. texs, colors, boneIndices, and" ] # [ doc = "  boneWeights may be nullptr, and indices is ignored if indexCount == 0." ] # [ doc = "" ] # [ doc = "  boneIndices and boneWeights must either both be nullptr or both point to valid data." ] # [ doc = "  If specified, they must both contain \'vertexCount\' entries." ] # [ link_name = "\u{1}__ZN10SkVertices8MakeCopyENS_10VertexModeEiPK7SkPointS3_PKjPKNS_11BoneIndicesEPKNS_11BoneWeightsEiPKtb" ] pub fn SkVertices_MakeCopy ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , boneIndices : * const SkVertices_BoneIndices , boneWeights : * const SkVertices_BoneWeights , indexCount : :: std :: os :: raw :: c_int , indices : * const u16 , isVolatile : bool ) -> sk_sp < SkVertices > ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices8MakeCopyENS_10VertexModeEiPK7SkPointS3_PKjPKNS_11BoneIndicesEPKNS_11BoneWeightsEb" ] pub fn SkVertices_MakeCopy1 ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , boneIndices : * const SkVertices_BoneIndices , boneWeights : * const SkVertices_BoneWeights , isVolatile : bool ) -> sk_sp < SkVertices > ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices8MakeCopyENS_10VertexModeEiPK7SkPointS3_PKjiPKtb" ] pub fn SkVertices_MakeCopy2 ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , indexCount : :: std :: os :: raw :: c_int , indices : * const u16 , isVolatile : bool ) -> sk_sp < SkVertices > ; } extern "C" { # [ link_name = "\u{1}__ZN10SkVertices8MakeCopyENS_10VertexModeEiPK7SkPointS3_PKjb" ] pub fn SkVertices_MakeCopy3 ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , isVolatile : bool ) -> sk_sp < SkVertices > ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices8uniqueIDEv" ] pub fn SkVertices_uniqueID ( this : * const SkVertices ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices4modeEv" ] pub fn SkVertices_mode ( this : * const SkVertices ) -> SkVertices_VertexMode ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices6boundsEv" ] pub fn SkVertices_bounds ( this : * const SkVertices ) -> * const SkRect ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices9hasColorsEv" ] pub fn SkVertices_hasColors ( this : * const SkVertices ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices12hasTexCoordsEv" ] pub fn SkVertices_hasTexCoords ( this : * const SkVertices ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices8hasBonesEv" ] pub fn SkVertices_hasBones ( this : * const SkVertices ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices10hasIndicesEv" ] pub fn SkVertices_hasIndices ( this : * const SkVertices ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices11vertexCountEv" ] pub fn SkVertices_vertexCount ( this : * const SkVertices ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices9positionsEv" ] pub fn SkVertices_positions ( this : * const SkVertices ) -> * const SkPoint ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices9texCoordsEv" ] pub fn SkVertices_texCoords ( this : * const SkVertices ) -> * const SkPoint ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices6colorsEv" ] pub fn SkVertices_colors ( this : * const SkVertices ) -> * const SkColor ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices11boneIndicesEv" ] pub fn SkVertices_boneIndices ( this : * const SkVertices ) -> * const SkVertices_BoneIndices ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices11boneWeightsEv" ] pub fn SkVertices_boneWeights ( this : * const SkVertices ) -> * const SkVertices_BoneWeights ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices10indexCountEv" ] pub fn SkVertices_indexCount ( this : * const SkVertices ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices7indicesEv" ] pub fn SkVertices_indices ( this : * const SkVertices ) -> * const u16 ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices10isVolatileEv" ] pub fn SkVertices_isVolatile ( this : * const SkVertices ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices10applyBonesEPKNS_4BoneEi" ] pub fn SkVertices_applyBones ( this : * const SkVertices , bones : * const SkVertices_Bone , boneCount : :: std :: os :: raw :: c_int ) -> sk_sp < SkVertices > ; } extern "C" { # [ link_name = "\u{1}__ZNK10SkVertices15approximateSizeEv" ] pub fn SkVertices_approximateSize ( this : * const SkVertices ) -> usize ; } extern "C" { # [ doc = "  Recreate a vertices from a buffer previously created by calling encode()." ] # [ doc = "  Returns null if the data is corrupt or the length is incorrect for the contents." ] # [ link_name = "\u{1}__ZN10SkVertices6DecodeEPKvm" ] pub fn SkVertices_Decode ( buffer : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkVertices > ; } extern "C" { # [ doc = "  Pack the vertices object into a byte buffer. This can be used to recreate the vertices" ] # [ doc = "  by calling Decode() with the buffer." ] # [ link_name = "\u{1}__ZNK10SkVertices6encodeEv" ] pub fn SkVertices_encode ( this : * const SkVertices ) -> sk_sp < SkData > ; } impl SkVertices { # [ inline ] pub unsafe fn MakeCopy ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , boneIndices : * const SkVertices_BoneIndices , boneWeights : * const SkVertices_BoneWeights , indexCount : :: std :: os :: raw :: c_int , indices : * const u16 , isVolatile : bool ) -> sk_sp < SkVertices > { SkVertices_MakeCopy ( mode , vertexCount , positions , texs , colors , boneIndices , boneWeights , indexCount , indices , isVolatile ) } # [ inline ] pub unsafe fn MakeCopy1 ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , boneIndices : * const SkVertices_BoneIndices , boneWeights : * const SkVertices_BoneWeights , isVolatile : bool ) -> sk_sp < SkVertices > { SkVertices_MakeCopy1 ( mode , vertexCount , positions , texs , colors , boneIndices , boneWeights , isVolatile ) } # [ inline ] pub unsafe fn MakeCopy2 ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , indexCount : :: std :: os :: raw :: c_int , indices : * const u16 , isVolatile : bool ) -> sk_sp < SkVertices > { SkVertices_MakeCopy2 ( mode , vertexCount , positions , texs , colors , indexCount , indices , isVolatile ) } # [ inline ] pub unsafe fn MakeCopy3 ( mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , isVolatile : bool ) -> sk_sp < SkVertices > { SkVertices_MakeCopy3 ( mode , vertexCount , positions , texs , colors , isVolatile ) } # [ inline ] pub unsafe fn uniqueID ( & self ) -> u32 { SkVertices_uniqueID ( self ) } # [ inline ] pub unsafe fn mode ( & self ) -> SkVertices_VertexMode { SkVertices_mode ( self ) } # [ inline ] pub unsafe fn bounds ( & self ) -> * const SkRect { SkVertices_bounds ( self ) } # [ inline ] pub unsafe fn hasColors ( & self ) -> bool { SkVertices_hasColors ( self ) } # [ inline ] pub unsafe fn hasTexCoords ( & self ) -> bool { SkVertices_hasTexCoords ( self ) } # [ inline ] pub unsafe fn hasBones ( & self ) -> bool { SkVertices_hasBones ( self ) } # [ inline ] pub unsafe fn hasIndices ( & self ) -> bool { SkVertices_hasIndices ( self ) } # [ inline ] pub unsafe fn vertexCount ( & self ) -> :: std :: os :: raw :: c_int { SkVertices_vertexCount ( self ) } # [ inline ] pub unsafe fn positions ( & self ) -> * const SkPoint { SkVertices_positions ( self ) } # [ inline ] pub unsafe fn texCoords ( & self ) -> * const SkPoint { SkVertices_texCoords ( self ) } # [ inline ] pub unsafe fn colors ( & self ) -> * const SkColor { SkVertices_colors ( self ) } # [ inline ] pub unsafe fn boneIndices ( & self ) -> * const SkVertices_BoneIndices { SkVertices_boneIndices ( self ) } # [ inline ] pub unsafe fn boneWeights ( & self ) -> * const SkVertices_BoneWeights { SkVertices_boneWeights ( self ) } # [ inline ] pub unsafe fn indexCount ( & self ) -> :: std :: os :: raw :: c_int { SkVertices_indexCount ( self ) } # [ inline ] pub unsafe fn indices ( & self ) -> * const u16 { SkVertices_indices ( self ) } # [ inline ] pub unsafe fn isVolatile ( & self ) -> bool { SkVertices_isVolatile ( self ) } # [ inline ] pub unsafe fn applyBones ( & self , bones : * const SkVertices_Bone , boneCount : :: std :: os :: raw :: c_int ) -> sk_sp < SkVertices > { SkVertices_applyBones ( self , bones , boneCount ) } # [ inline ] pub unsafe fn approximateSize ( & self ) -> usize { SkVertices_approximateSize ( self ) } # [ inline ] pub unsafe fn Decode ( buffer : * const :: std :: os :: raw :: c_void , length : usize ) -> sk_sp < SkVertices > { SkVertices_Decode ( buffer , length ) } # [ inline ] pub unsafe fn encode ( & self ) -> sk_sp < SkData > { SkVertices_encode ( self ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrRenderTargetContext { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkBaseDevice { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDrawable { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDrawShadowRec { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkGlyphRunBuilder { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkSurface_Base { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkTextBlob { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] pub struct SkCanvas__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ doc = " \\class SkCanvas" ] # [ doc = "SkCanvas provides an interface for drawing, and how the drawing is clipped and transformed." ] # [ doc = "SkCanvas contains a stack of SkMatrix and clip values." ] # [ doc = "" ] # [ doc = "SkCanvas and SkPaint together provide the state to draw into SkSurface or SkBaseDevice." ] # [ doc = "Each SkCanvas draw call transforms the geometry of the object by the concatenation of all" ] # [ doc = "SkMatrix values in the stack. The transformed geometry is clipped by the intersection" ] # [ doc = "of all of clip values in the stack. The SkCanvas draw calls use SkPaint to supply drawing" ] # [ doc = "state such as color, SkTypeface, text size, stroke width, SkShader and so on." ] # [ doc = "" ] # [ doc = "To draw to a pixel-based destination, create raster surface or GPU surface." ] # [ doc = "Request SkCanvas from SkSurface to obtain the interface to draw." ] # [ doc = "SkCanvas generated by raster surface draws to memory visible to the CPU." ] # [ doc = "SkCanvas generated by GPU surface uses Vulkan or OpenGL to draw to the GPU." ] # [ doc = "" ] # [ doc = "To draw to a document, obtain SkCanvas from SVG canvas, document PDF, or SkPictureRecorder." ] # [ doc = "SkDocument based SkCanvas and other SkCanvas subclasses reference SkBaseDevice describing the" ] # [ doc = "destination." ] # [ doc = "" ] # [ doc = "SkCanvas can be constructed to draw to SkBitmap without first creating raster surface." ] # [ doc = "This approach may be deprecated in the future." ] # [ repr ( C ) ] pub struct SkCanvas { pub vtable_ : * const SkCanvas__bindgen_vtable , pub fMCStack : SkDeque , pub fMCRec : * mut SkCanvas_MCRec , pub fMCRecStorage : [ isize ; 512usize ] , pub fDeviceCMStorage : [ isize ; 28usize ] , pub fProps : SkSurfaceProps , pub fSaveCount : :: std :: os :: raw :: c_int , pub fAllocator : std_unique_ptr , pub fSurfaceBase : * mut SkSurface_Base , pub fClipRestrictionRect : SkIRect , # [ doc = "  Keep track of the device clip bounds and if the matrix is scale-translate.  This allows" ] # [ doc = "  us to do a fast quick reject in the common case." ] pub fIsScaleTranslate : bool , pub fDeviceClipBounds : SkRect , pub fAllowSoftClip : bool , pub fAllowSimplifyClip : bool , pub fScratchGlyphRunBuilder : std_unique_ptr , } pub const SkCanvas_PrivateSaveLayerFlags_kDontClipToLayer_PrivateSaveLayerFlag : SkCanvas_PrivateSaveLayerFlags = 2147483648 ; pub type SkCanvas_PrivateSaveLayerFlags = u32 ; # [ doc = "!< initializes with previous contents" ] pub const SkCanvas_SaveLayerFlagsSet_kInitWithPrevious_SaveLayerFlag : SkCanvas_SaveLayerFlagsSet = 4 ; pub const SkCanvas_SaveLayerFlagsSet_kMaskAgainstCoverage_EXPERIMENTAL_DONT_USE_SaveLayerFlag : SkCanvas_SaveLayerFlagsSet = 8 ; # [ doc = " \\enum SkCanvas::SaveLayerFlagsSet" ] # [ doc = "SaveLayerFlags provides options that may be used in any combination in SaveLayerRec," ] # [ doc = "defining how layer allocated by saveLayer() operates. It may be set to zero," ] # [ doc = "kPreserveLCDText_SaveLayerFlag, kInitWithPrevious_SaveLayerFlag, or both flags." ] pub type SkCanvas_SaveLayerFlagsSet = u32 ; pub type SkCanvas_SaveLayerFlags = u32 ; # [ doc = " \\struct SkCanvas::SaveLayerRec" ] # [ doc = "SaveLayerRec contains the state used to create the layer." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkCanvas_SaveLayerRec { # [ doc = " hints at layer size limit" ] pub fBounds : * const SkRect , # [ doc = " modifies overlay" ] pub fPaint : * const SkPaint , # [ doc = "  If not null, this triggers the same initialization behavior as setting" ] # [ doc = "  kInitWithPrevious_SaveLayerFlag on fSaveLayerFlags: the current layer is copied into" ] # [ doc = "  the new layer, rather than initializing the new layer with transparent-black." ] # [ doc = "  This is then filtered by fBackdrop (respecting the current clip)." ] pub fBackdrop : * const SkImageFilter , # [ doc = " clips layer with mask alpha" ] pub fClipMask : * const SkImage , # [ doc = " transforms mask alpha used to clip" ] pub fClipMatrix : * const SkMatrix , # [ doc = " preserves LCD text, creates with prior layer contents" ] pub fSaveLayerFlags : SkCanvas_SaveLayerFlags , } # [ test ] fn bindgen_test_layout_SkCanvas_SaveLayerRec ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkCanvas_SaveLayerRec > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SkCanvas_SaveLayerRec ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkCanvas_SaveLayerRec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkCanvas_SaveLayerRec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_SaveLayerRec > ( ) ) ) . fBounds as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_SaveLayerRec ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_SaveLayerRec > ( ) ) ) . fPaint as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_SaveLayerRec ) , "::" , stringify ! ( fPaint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_SaveLayerRec > ( ) ) ) . fBackdrop as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_SaveLayerRec ) , "::" , stringify ! ( fBackdrop ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_SaveLayerRec > ( ) ) ) . fClipMask as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_SaveLayerRec ) , "::" , stringify ! ( fClipMask ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_SaveLayerRec > ( ) ) ) . fClipMatrix as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_SaveLayerRec ) , "::" , stringify ! ( fClipMatrix ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_SaveLayerRec > ( ) ) ) . fSaveLayerFlags as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_SaveLayerRec ) , "::" , stringify ! ( fSaveLayerFlags ) ) ) ; } extern "C" { # [ doc = " Sets fBounds, fPaint, and fBackdrop to nullptr. Clears fSaveLayerFlags." ] # [ doc = "" ] # [ doc = "@return  empty SaveLayerRec" ] # [ link_name = "\u{1}__ZN8SkCanvas12SaveLayerRecC1Ev" ] pub fn SkCanvas_SaveLayerRec_SaveLayerRec ( this : * mut SkCanvas_SaveLayerRec ) ; } extern "C" { # [ doc = " Sets fBounds, fPaint, and fSaveLayerFlags; sets fBackdrop to nullptr." ] # [ doc = "" ] # [ doc = "@param bounds          layer dimensions; may be nullptr" ] # [ doc = "@param paint           applied to layer when overlaying prior layer; may be nullptr" ] # [ doc = "@param saveLayerFlags  SaveLayerRec options to modify layer" ] # [ doc = "@return                SaveLayerRec with empty fBackdrop" ] # [ link_name = "\u{1}__ZN8SkCanvas12SaveLayerRecC1EPK6SkRectPK7SkPaintj" ] pub fn SkCanvas_SaveLayerRec_SaveLayerRec1 ( this : * mut SkCanvas_SaveLayerRec , bounds : * const SkRect , paint : * const SkPaint , saveLayerFlags : SkCanvas_SaveLayerFlags ) ; } extern "C" { # [ doc = " Sets fBounds, fPaint, fBackdrop, and fSaveLayerFlags." ] # [ doc = "" ] # [ doc = "@param bounds          layer dimensions; may be nullptr" ] # [ doc = "@param paint           applied to layer when overlaying prior layer;" ] # [ doc = "may be nullptr" ] # [ doc = "@param backdrop        If not null, this causes the current layer to be filtered by" ] # [ doc = "backdrop, and then drawn into the new layer" ] # [ doc = "(respecting the current clip)." ] # [ doc = "If null, the new layer is initialized with transparent-black." ] # [ doc = "@param saveLayerFlags  SaveLayerRec options to modify layer" ] # [ doc = "@return                SaveLayerRec fully specified" ] # [ link_name = "\u{1}__ZN8SkCanvas12SaveLayerRecC1EPK6SkRectPK7SkPaintPK13SkImageFilterj" ] pub fn SkCanvas_SaveLayerRec_SaveLayerRec2 ( this : * mut SkCanvas_SaveLayerRec , bounds : * const SkRect , paint : * const SkPaint , backdrop : * const SkImageFilter , saveLayerFlags : SkCanvas_SaveLayerFlags ) ; } extern "C" { # [ doc = " Experimental. Not ready for general use." ] # [ doc = "Sets fBounds, fPaint, fBackdrop, fClipMask, fClipMatrix, and fSaveLayerFlags." ] # [ doc = "clipMatrix uses alpha channel of image, transformed by clipMatrix, to clip" ] # [ doc = "layer when drawn to SkCanvas." ] # [ doc = "" ] # [ doc = "Implementation is not complete; has no effect if SkBaseDevice is GPU-backed." ] # [ doc = "" ] # [ doc = "@param bounds          layer dimensions; may be nullptr" ] # [ doc = "@param paint           graphics state applied to layer when overlaying prior" ] # [ doc = "layer; may be nullptr" ] # [ doc = "@param backdrop        If not null, this causes the current layer to be filtered by" ] # [ doc = "backdrop, and then drawn into the new layer" ] # [ doc = "(respecting the current clip)." ] # [ doc = "If null, the new layer is initialized with transparent-black." ] # [ doc = "@param clipMask        clip applied to layer; may be nullptr" ] # [ doc = "@param clipMatrix      matrix applied to clipMask; may be nullptr to use" ] # [ doc = "identity matrix" ] # [ doc = "@param saveLayerFlags  SaveLayerRec options to modify layer" ] # [ doc = "@return                SaveLayerRec fully specified" ] # [ link_name = "\u{1}__ZN8SkCanvas12SaveLayerRecC1EPK6SkRectPK7SkPaintPK13SkImageFilterPK7SkImagePK8SkMatrixj" ] pub fn SkCanvas_SaveLayerRec_SaveLayerRec3 ( this : * mut SkCanvas_SaveLayerRec , bounds : * const SkRect , paint : * const SkPaint , backdrop : * const SkImageFilter , clipMask : * const SkImage , clipMatrix : * const SkMatrix , saveLayerFlags : SkCanvas_SaveLayerFlags ) ; } impl SkCanvas_SaveLayerRec { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SaveLayerRec_SaveLayerRec ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( bounds : * const SkRect , paint : * const SkPaint , saveLayerFlags : SkCanvas_SaveLayerFlags ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SaveLayerRec_SaveLayerRec1 ( & mut __bindgen_tmp , bounds , paint , saveLayerFlags ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( bounds : * const SkRect , paint : * const SkPaint , backdrop : * const SkImageFilter , saveLayerFlags : SkCanvas_SaveLayerFlags ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SaveLayerRec_SaveLayerRec2 ( & mut __bindgen_tmp , bounds , paint , backdrop , saveLayerFlags ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( bounds : * const SkRect , paint : * const SkPaint , backdrop : * const SkImageFilter , clipMask : * const SkImage , clipMatrix : * const SkMatrix , saveLayerFlags : SkCanvas_SaveLayerFlags ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SaveLayerRec_SaveLayerRec3 ( & mut __bindgen_tmp , bounds , paint , backdrop , clipMask , clipMatrix , saveLayerFlags ) ; __bindgen_tmp } } # [ doc = "!< draw each point separately" ] pub const SkCanvas_PointMode_kPoints_PointMode : SkCanvas_PointMode = 0 ; # [ doc = "!< draw each pair of points as a line segment" ] pub const SkCanvas_PointMode_kLines_PointMode : SkCanvas_PointMode = 1 ; # [ doc = "!< draw the array of points as a open polygon" ] pub const SkCanvas_PointMode_kPolygon_PointMode : SkCanvas_PointMode = 2 ; # [ doc = " \\enum SkCanvas::PointMode" ] # [ doc = "Selects if an array of points are drawn as discrete points, as lines, or as" ] # [ doc = "an open polygon." ] pub type SkCanvas_PointMode = u32 ; # [ doc = "!< sample only inside bounds; slower" ] pub const SkCanvas_SrcRectConstraint_kStrict_SrcRectConstraint : SkCanvas_SrcRectConstraint = 0 ; # [ doc = "!< sample outside bounds; faster" ] pub const SkCanvas_SrcRectConstraint_kFast_SrcRectConstraint : SkCanvas_SrcRectConstraint = 1 ; # [ doc = " \\enum SkCanvas::SrcRectConstraint" ] # [ doc = "SrcRectConstraint controls the behavior at the edge of source SkRect," ] # [ doc = "provided to drawImageRect(), trading off speed for precision." ] # [ doc = "" ] # [ doc = "SkFilterQuality in SkPaint may sample multiple pixels in the image. Source SkRect" ] # [ doc = "restricts the bounds of pixels that may be read. SkFilterQuality may slow down if" ] # [ doc = "it cannot read outside the bounds, when sampling near the edge of source SkRect." ] # [ doc = "SrcRectConstraint specifies whether an SkImageFilter is allowed to read pixels" ] # [ doc = "outside source SkRect." ] pub type SkCanvas_SrcRectConstraint = u32 ; # [ doc = " \\struct SkCanvas::Lattice" ] # [ doc = "SkCanvas::Lattice divides SkBitmap or SkImage into a rectangular grid." ] # [ doc = "Grid entries on even columns and even rows are fixed; these entries are" ] # [ doc = "always drawn at their original size if the destination is large enough." ] # [ doc = "If the destination side is too small to hold the fixed entries, all fixed" ] # [ doc = "entries are proportionately scaled down to fit." ] # [ doc = "The grid entries not on even columns and rows are scaled to fit the" ] # [ doc = "remaining space, if any." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkCanvas_Lattice { # [ doc = "!< x-axis values dividing bitmap" ] pub fXDivs : * const :: std :: os :: raw :: c_int , # [ doc = "!< y-axis values dividing bitmap" ] pub fYDivs : * const :: std :: os :: raw :: c_int , # [ doc = "!< array of fill types" ] pub fRectTypes : * const SkCanvas_Lattice_RectType , # [ doc = "!< number of x-coordinates" ] pub fXCount : :: std :: os :: raw :: c_int , # [ doc = "!< number of y-coordinates" ] pub fYCount : :: std :: os :: raw :: c_int , # [ doc = "!< source bounds to draw from" ] pub fBounds : * const SkIRect , # [ doc = "!< array of colors" ] pub fColors : * const SkColor , } # [ doc = "!< draws SkBitmap into lattice rectangle" ] pub const SkCanvas_Lattice_RectType_kDefault : SkCanvas_Lattice_RectType = 0 ; # [ doc = "!< skips lattice rectangle by making it transparent" ] pub const SkCanvas_Lattice_RectType_kTransparent : SkCanvas_Lattice_RectType = 1 ; # [ doc = "!< draws one of fColors into lattice rectangle" ] pub const SkCanvas_Lattice_RectType_kFixedColor : SkCanvas_Lattice_RectType = 2 ; # [ doc = " \\enum SkCanvas::Lattice::RectType" ] # [ doc = "Optional setting per rectangular grid entry to make it transparent," ] # [ doc = "or to fill the grid entry with a color." ] pub type SkCanvas_Lattice_RectType = u8 ; # [ test ] fn bindgen_test_layout_SkCanvas_Lattice ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkCanvas_Lattice > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SkCanvas_Lattice ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkCanvas_Lattice > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkCanvas_Lattice ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_Lattice > ( ) ) ) . fXDivs as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_Lattice ) , "::" , stringify ! ( fXDivs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_Lattice > ( ) ) ) . fYDivs as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_Lattice ) , "::" , stringify ! ( fYDivs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_Lattice > ( ) ) ) . fRectTypes as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_Lattice ) , "::" , stringify ! ( fRectTypes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_Lattice > ( ) ) ) . fXCount as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_Lattice ) , "::" , stringify ! ( fXCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_Lattice > ( ) ) ) . fYCount as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_Lattice ) , "::" , stringify ! ( fYCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_Lattice > ( ) ) ) . fBounds as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_Lattice ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_Lattice > ( ) ) ) . fColors as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_Lattice ) , "::" , stringify ! ( fColors ) ) ) ; } pub const SkCanvas_QuadAAFlags_kLeft_QuadAAFlag : SkCanvas_QuadAAFlags = 1 ; pub const SkCanvas_QuadAAFlags_kTop_QuadAAFlag : SkCanvas_QuadAAFlags = 2 ; pub const SkCanvas_QuadAAFlags_kRight_QuadAAFlag : SkCanvas_QuadAAFlags = 4 ; pub const SkCanvas_QuadAAFlags_kBottom_QuadAAFlag : SkCanvas_QuadAAFlags = 8 ; pub const SkCanvas_QuadAAFlags_kNone_QuadAAFlags : SkCanvas_QuadAAFlags = 0 ; pub const SkCanvas_QuadAAFlags_kAll_QuadAAFlags : SkCanvas_QuadAAFlags = 15 ; # [ doc = " Experimental. Controls anti-aliasing of each edge of images in an image-set." ] pub type SkCanvas_QuadAAFlags = u32 ; # [ doc = " This is used by the experimental API below." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkCanvas_ImageSetEntry { pub fImage : sk_sp < SkImage > , pub fSrcRect : SkRect , pub fDstRect : SkRect , pub fAlpha : f32 , pub fAAFlags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_SkCanvas_ImageSetEntry ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkCanvas_ImageSetEntry > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SkCanvas_ImageSetEntry ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkCanvas_ImageSetEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkCanvas_ImageSetEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_ImageSetEntry > ( ) ) ) . fImage as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_ImageSetEntry ) , "::" , stringify ! ( fImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_ImageSetEntry > ( ) ) ) . fSrcRect as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_ImageSetEntry ) , "::" , stringify ! ( fSrcRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_ImageSetEntry > ( ) ) ) . fDstRect as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_ImageSetEntry ) , "::" , stringify ! ( fDstRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_ImageSetEntry > ( ) ) ) . fAlpha as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_ImageSetEntry ) , "::" , stringify ! ( fAlpha ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_ImageSetEntry > ( ) ) ) . fAAFlags as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_ImageSetEntry ) , "::" , stringify ! ( fAAFlags ) ) ) ; } pub const SkCanvas_SaveLayerStrategy_kFullLayer_SaveLayerStrategy : SkCanvas_SaveLayerStrategy = 0 ; pub const SkCanvas_SaveLayerStrategy_kNoLayer_SaveLayerStrategy : SkCanvas_SaveLayerStrategy = 1 ; pub type SkCanvas_SaveLayerStrategy = u32 ; pub const SkCanvas_ClipEdgeStyle_kHard_ClipEdgeStyle : SkCanvas_ClipEdgeStyle = 0 ; pub const SkCanvas_ClipEdgeStyle_kSoft_ClipEdgeStyle : SkCanvas_ClipEdgeStyle = 1 ; pub type SkCanvas_ClipEdgeStyle = u32 ; # [ doc = " After calling saveLayer(), there can be any number of devices that make" ] # [ doc = "up the top-most drawing area. LayerIter can be used to iterate through" ] # [ doc = "those devices. Note that the iterator is only valid until the next API" ] # [ doc = "call made on the canvas. Ownership of all pointers in the iterator stays" ] # [ doc = "with the canvas, so none of them should be modified or deleted." ] # [ repr ( C ) ] pub struct SkCanvas_LayerIter { pub fStorage : [ isize ; 32usize ] , pub fImpl : * mut SkDrawIter , pub fDefaultPaint : SkPaint , pub fDone : bool , } # [ test ] fn bindgen_test_layout_SkCanvas_LayerIter ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkCanvas_LayerIter > ( ) , 352usize , concat ! ( "Size of: " , stringify ! ( SkCanvas_LayerIter ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkCanvas_LayerIter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkCanvas_LayerIter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_LayerIter > ( ) ) ) . fStorage as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_LayerIter ) , "::" , stringify ! ( fStorage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_LayerIter > ( ) ) ) . fImpl as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_LayerIter ) , "::" , stringify ! ( fImpl ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_LayerIter > ( ) ) ) . fDefaultPaint as * const _ as usize } , 264usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_LayerIter ) , "::" , stringify ! ( fDefaultPaint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_LayerIter > ( ) ) ) . fDone as * const _ as usize } , 344usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_LayerIter ) , "::" , stringify ! ( fDone ) ) ) ; } extern "C" { # [ doc = " Return true if the iterator is done" ] # [ link_name = "\u{1}__ZNK8SkCanvas9LayerIter4doneEv" ] pub fn SkCanvas_LayerIter_done ( this : * const SkCanvas_LayerIter ) -> bool ; } extern "C" { # [ doc = " Cycle to the next device" ] # [ link_name = "\u{1}__ZN8SkCanvas9LayerIter4nextEv" ] pub fn SkCanvas_LayerIter_next ( this : * mut SkCanvas_LayerIter ) ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas9LayerIter6deviceEv" ] pub fn SkCanvas_LayerIter_device ( this : * const SkCanvas_LayerIter ) -> * mut SkBaseDevice ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas9LayerIter6matrixEv" ] pub fn SkCanvas_LayerIter_matrix ( this : * const SkCanvas_LayerIter ) -> * const SkMatrix ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas9LayerIter10clipBoundsEv" ] pub fn SkCanvas_LayerIter_clipBounds ( this : * const SkCanvas_LayerIter ) -> SkIRect ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas9LayerIter5paintEv" ] pub fn SkCanvas_LayerIter_paint ( this : * const SkCanvas_LayerIter ) -> * const SkPaint ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas9LayerIter1xEv" ] pub fn SkCanvas_LayerIter_x ( this : * const SkCanvas_LayerIter ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas9LayerIter1yEv" ] pub fn SkCanvas_LayerIter_y ( this : * const SkCanvas_LayerIter ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Initialize iterator with canvas, and set values for 1st device" ] # [ link_name = "\u{1}__ZN8SkCanvas9LayerIterC1EPS_" ] pub fn SkCanvas_LayerIter_LayerIter ( this : * mut SkCanvas_LayerIter , arg1 : * mut SkCanvas ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas9LayerIterD1Ev" ] pub fn SkCanvas_LayerIter_LayerIter_destructor ( this : * mut SkCanvas_LayerIter ) ; } impl SkCanvas_LayerIter { # [ inline ] pub unsafe fn done ( & self ) -> bool { SkCanvas_LayerIter_done ( self ) } # [ inline ] pub unsafe fn next ( & mut self ) { SkCanvas_LayerIter_next ( self ) } # [ inline ] pub unsafe fn device ( & self ) -> * mut SkBaseDevice { SkCanvas_LayerIter_device ( self ) } # [ inline ] pub unsafe fn matrix ( & self ) -> * const SkMatrix { SkCanvas_LayerIter_matrix ( self ) } # [ inline ] pub unsafe fn clipBounds ( & self ) -> SkIRect { SkCanvas_LayerIter_clipBounds ( self ) } # [ inline ] pub unsafe fn paint ( & self ) -> * const SkPaint { SkCanvas_LayerIter_paint ( self ) } # [ inline ] pub unsafe fn x ( & self ) -> :: std :: os :: raw :: c_int { SkCanvas_LayerIter_x ( self ) } # [ inline ] pub unsafe fn y ( & self ) -> :: std :: os :: raw :: c_int { SkCanvas_LayerIter_y ( self ) } # [ inline ] pub unsafe fn new ( arg1 : * mut SkCanvas ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_LayerIter_LayerIter ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkCanvas_LayerIter_LayerIter_destructor ( self ) } } # [ doc = "!< there is no overriding shader (bitmap or image)" ] pub const SkCanvas_ShaderOverrideOpacity_kNone_ShaderOverrideOpacity : SkCanvas_ShaderOverrideOpacity = 0 ; # [ doc = "!< the overriding shader is opaque" ] pub const SkCanvas_ShaderOverrideOpacity_kOpaque_ShaderOverrideOpacity : SkCanvas_ShaderOverrideOpacity = 1 ; # [ doc = "!< the overriding shader may not be opaque" ] pub const SkCanvas_ShaderOverrideOpacity_kNotOpaque_ShaderOverrideOpacity : SkCanvas_ShaderOverrideOpacity = 2 ; pub type SkCanvas_ShaderOverrideOpacity = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkCanvas_MCRec { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkCanvas_AutoValidateClip { pub fCanvas : * const SkCanvas , } # [ test ] fn bindgen_test_layout_SkCanvas_AutoValidateClip ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkCanvas_AutoValidateClip > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkCanvas_AutoValidateClip ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkCanvas_AutoValidateClip > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkCanvas_AutoValidateClip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas_AutoValidateClip > ( ) ) ) . fCanvas as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas_AutoValidateClip ) , "::" , stringify ! ( fCanvas ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas16AutoValidateClipC1EPS_" ] pub fn SkCanvas_AutoValidateClip_AutoValidateClip ( this : * mut SkCanvas_AutoValidateClip , canvas : * mut SkCanvas ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas16AutoValidateClipD1Ev" ] pub fn SkCanvas_AutoValidateClip_AutoValidateClip_destructor ( this : * mut SkCanvas_AutoValidateClip ) ; } impl SkCanvas_AutoValidateClip { # [ inline ] pub unsafe fn new ( canvas : * mut SkCanvas ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_AutoValidateClip_AutoValidateClip ( & mut __bindgen_tmp , canvas ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkCanvas_AutoValidateClip_AutoValidateClip_destructor ( self ) } } pub type SkCanvas_INHERITED = SkRefCnt ; pub const SkCanvas_kMCRecSize : :: std :: os :: raw :: c_int = 128 ; pub const SkCanvas_kMCRecCount : :: std :: os :: raw :: c_int = 32 ; pub const SkCanvas_kDeviceCMSize : :: std :: os :: raw :: c_int = 224 ; # [ test ] fn bindgen_test_layout_SkCanvas ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkCanvas > ( ) , 4472usize , concat ! ( "Size of: " , stringify ! ( SkCanvas ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkCanvas > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkCanvas ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fMCStack as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fMCStack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fMCRec as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fMCRec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fMCRecStorage as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fMCRecStorage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fDeviceCMStorage as * const _ as usize } , 4168usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fDeviceCMStorage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fProps as * const _ as usize } , 4392usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fProps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fSaveCount as * const _ as usize } , 4400usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fSaveCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fAllocator as * const _ as usize } , 4408usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fAllocator ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fSurfaceBase as * const _ as usize } , 4416usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fSurfaceBase ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fClipRestrictionRect as * const _ as usize } , 4424usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fClipRestrictionRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fIsScaleTranslate as * const _ as usize } , 4440usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fIsScaleTranslate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fDeviceClipBounds as * const _ as usize } , 4444usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fDeviceClipBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fAllowSoftClip as * const _ as usize } , 4460usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fAllowSoftClip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fAllowSimplifyClip as * const _ as usize } , 4461usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fAllowSimplifyClip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkCanvas > ( ) ) ) . fScratchGlyphRunBuilder as * const _ as usize } , 4464usize , concat ! ( "Offset of field: " , stringify ! ( SkCanvas ) , "::" , stringify ! ( fScratchGlyphRunBuilder ) ) ) ; } extern "C" { # [ doc = " Allocates raster SkCanvas that will draw directly into pixels." ] # [ doc = "" ] # [ doc = "SkCanvas is returned if all parameters are valid." ] # [ doc = "Valid parameters include:" ] # [ doc = "info dimensions are zero or positive;" ] # [ doc = "info contains SkColorType and SkAlphaType supported by raster surface;" ] # [ doc = "pixels is not nullptr;" ] # [ doc = "rowBytes is zero or large enough to contain info width pixels of SkColorType." ] # [ doc = "" ] # [ doc = "Pass zero for rowBytes to compute rowBytes from info width and size of pixel." ] # [ doc = "If rowBytes is greater than zero, it must be equal to or greater than" ] # [ doc = "info width times bytes required for SkColorType." ] # [ doc = "" ] # [ doc = "Pixel buffer size should be info height times computed rowBytes." ] # [ doc = "Pixels are not initialized." ] # [ doc = "To access pixels after drawing, call flush() or peekPixels()." ] # [ doc = "" ] # [ doc = "@param info      width, height, SkColorType, SkAlphaType, SkColorSpace, of raster surface;" ] # [ doc = "width, or height, or both, may be zero" ] # [ doc = "@param pixels    pointer to destination pixels buffer" ] # [ doc = "@param rowBytes  interval from one SkSurface row to the next, or zero" ] # [ doc = "@param props     LCD striping orientation and setting for device independent fonts;" ] # [ doc = "may be nullptr" ] # [ doc = "@return          SkCanvas if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas16MakeRasterDirectERK11SkImageInfoPvmPK14SkSurfaceProps" ] pub fn SkCanvas_MakeRasterDirect ( info : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize , props : * const SkSurfaceProps ) -> std_unique_ptr ; } extern "C" { # [ doc = " Allocates raster SkCanvas specified by inline image specification. Subsequent SkCanvas" ] # [ doc = "calls draw into pixels." ] # [ doc = "SkColorType is set to kN32_SkColorType." ] # [ doc = "SkAlphaType is set to kPremul_SkAlphaType." ] # [ doc = "To access pixels after drawing, call flush() or peekPixels()." ] # [ doc = "" ] # [ doc = "SkCanvas is returned if all parameters are valid." ] # [ doc = "Valid parameters include:" ] # [ doc = "width and height are zero or positive;" ] # [ doc = "pixels is not nullptr;" ] # [ doc = "rowBytes is zero or large enough to contain width pixels of kN32_SkColorType." ] # [ doc = "" ] # [ doc = "Pass zero for rowBytes to compute rowBytes from width and size of pixel." ] # [ doc = "If rowBytes is greater than zero, it must be equal to or greater than" ] # [ doc = "width times bytes required for SkColorType." ] # [ doc = "" ] # [ doc = "Pixel buffer size should be height times rowBytes." ] # [ doc = "" ] # [ doc = "@param width     pixel column count on raster surface created; must be zero or greater" ] # [ doc = "@param height    pixel row count on raster surface created; must be zero or greater" ] # [ doc = "@param pixels    pointer to destination pixels buffer; buffer size should be height" ] # [ doc = "times rowBytes" ] # [ doc = "@param rowBytes  interval from one SkSurface row to the next, or zero" ] # [ doc = "@return          SkCanvas if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas19MakeRasterDirectN32EiiPjm" ] pub fn SkCanvas_MakeRasterDirectN32 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , pixels : * mut SkPMColor , rowBytes : usize ) -> std_unique_ptr ; } extern "C" { # [ doc = " Returns SkImageInfo for SkCanvas. If SkCanvas is not associated with raster surface or" ] # [ doc = "GPU surface, returned SkColorType is set to kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  dimensions and SkColorType of SkCanvas" ] # [ link_name = "\u{1}__ZNK8SkCanvas9imageInfoEv" ] pub fn SkCanvas_imageInfo ( this : * const SkCanvas ) -> SkImageInfo ; } extern "C" { # [ doc = " Copies SkSurfaceProps, if SkCanvas is associated with raster surface or" ] # [ doc = "GPU surface, and returns true. Otherwise, returns false and leave props unchanged." ] # [ doc = "" ] # [ doc = "@param props  storage for writable SkSurfaceProps" ] # [ doc = "@return       true if SkSurfaceProps was copied" ] # [ link_name = "\u{1}__ZNK8SkCanvas8getPropsEP14SkSurfaceProps" ] pub fn SkCanvas_getProps ( this : * const SkCanvas , props : * mut SkSurfaceProps ) -> bool ; } extern "C" { # [ doc = " Triggers the immediate execution of all pending draw operations." ] # [ doc = "If SkCanvas is associated with GPU surface, resolves all pending GPU operations." ] # [ doc = "If SkCanvas is associated with raster surface, has no effect; raster draw" ] # [ doc = "operations are never deferred." ] # [ link_name = "\u{1}__ZN8SkCanvas5flushEv" ] pub fn SkCanvas_flush ( this : * mut SkCanvas ) ; } extern "C" { # [ doc = " Creates SkSurface matching info and props, and associates it with SkCanvas." ] # [ doc = "Returns nullptr if no match found." ] # [ doc = "" ] # [ doc = "If props is nullptr, matches SkSurfaceProps in SkCanvas. If props is nullptr and SkCanvas" ] # [ doc = "does not have SkSurfaceProps, creates SkSurface with default SkSurfaceProps." ] # [ doc = "" ] # [ doc = "@param info   width, height, SkColorType, SkAlphaType, and SkColorSpace" ] # [ doc = "@param props  SkSurfaceProps to match; may be nullptr to match SkCanvas" ] # [ doc = "@return       SkSurface matching info and props, or nullptr if no match is available" ] # [ link_name = "\u{1}__ZN8SkCanvas11makeSurfaceERK11SkImageInfoPK14SkSurfaceProps" ] pub fn SkCanvas_makeSurface ( this : * mut SkCanvas , info : * const SkImageInfo , props : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Returns the pixel base address, SkImageInfo, rowBytes, and origin if the pixels" ] # [ doc = "can be read directly. The returned address is only valid" ] # [ doc = "while SkCanvas is in scope and unchanged. Any SkCanvas call or SkSurface call" ] # [ doc = "may invalidate the returned address and other returned values." ] # [ doc = "" ] # [ doc = "If pixels are inaccessible, info, rowBytes, and origin are unchanged." ] # [ doc = "" ] # [ doc = "@param info      storage for writable pixels\' SkImageInfo; may be nullptr" ] # [ doc = "@param rowBytes  storage for writable pixels\' row bytes; may be nullptr" ] # [ doc = "@param origin    storage for SkCanvas top layer origin, its top-left corner;" ] # [ doc = "may be nullptr" ] # [ doc = "@return          address of pixels, or nullptr if inaccessible" ] # [ link_name = "\u{1}__ZN8SkCanvas20accessTopLayerPixelsEP11SkImageInfoPmP8SkIPoint" ] pub fn SkCanvas_accessTopLayerPixels ( this : * mut SkCanvas , info : * mut SkImageInfo , rowBytes : * mut usize , origin : * mut SkIPoint ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " Returns custom context that tracks the SkMatrix and clip." ] # [ doc = "" ] # [ doc = "Use SkRasterHandleAllocator to blend Skia drawing with custom drawing, typically performed" ] # [ doc = "by the host platform user interface. The custom context returned is generated by" ] # [ doc = "SkRasterHandleAllocator::MakeCanvas, which creates a custom canvas with raster storage for" ] # [ doc = "the drawing destination." ] # [ doc = "" ] # [ doc = "@return  context of custom allocation" ] # [ link_name = "\u{1}__ZNK8SkCanvas21accessTopRasterHandleEv" ] pub fn SkCanvas_accessTopRasterHandle ( this : * const SkCanvas ) -> SkRasterHandleAllocator_Handle ; } extern "C" { # [ doc = " Returns true if SkCanvas has direct access to its pixels." ] # [ doc = "" ] # [ doc = "Pixels are readable when SkBaseDevice is raster. Pixels are not readable when SkCanvas" ] # [ doc = "is returned from GPU surface, returned by SkDocument::beginPage, returned by" ] # [ doc = "SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility class" ] # [ doc = "like SkDebugCanvas." ] # [ doc = "" ] # [ doc = "pixmap is valid only while SkCanvas is in scope and unchanged. Any" ] # [ doc = "SkCanvas or SkSurface call may invalidate the pixmap values." ] # [ doc = "" ] # [ doc = "@param pixmap  storage for pixel state if pixels are readable; otherwise, ignored" ] # [ doc = "@return        true if SkCanvas has direct access to pixels" ] # [ link_name = "\u{1}__ZN8SkCanvas10peekPixelsEP8SkPixmap" ] pub fn SkCanvas_peekPixels ( this : * mut SkCanvas , pixmap : * mut SkPixmap ) -> bool ; } extern "C" { # [ doc = " Copies SkRect of pixels from SkCanvas into dstPixels. SkMatrix and clip are" ] # [ doc = "ignored." ] # [ doc = "" ] # [ doc = "Source SkRect corners are (srcX, srcY) and (imageInfo().width(), imageInfo().height())." ] # [ doc = "Destination SkRect corners are (0, 0) and (dstInfo.width(), dstInfo.height())." ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to dstInfo.colorType() and dstInfo.alphaType() if required." ] # [ doc = "" ] # [ doc = "Pixels are readable when SkBaseDevice is raster, or backed by a GPU." ] # [ doc = "Pixels are not readable when SkCanvas is returned by SkDocument::beginPage," ] # [ doc = "returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility" ] # [ doc = "class like SkDebugCanvas." ] # [ doc = "" ] # [ doc = "The destination pixel storage must be allocated by the caller." ] # [ doc = "" ] # [ doc = "Pixel values are converted only if SkColorType and SkAlphaType" ] # [ doc = "do not match. Only pixels within both source and destination rectangles" ] # [ doc = "are copied. dstPixels contents outside SkRect intersection are unchanged." ] # [ doc = "" ] # [ doc = "Pass negative values for srcX or srcY to offset pixels across or down destination." ] # [ doc = "" ] # [ doc = "Does not copy, and returns false if:" ] # [ doc = "- Source and destination rectangles do not intersect." ] # [ doc = "- SkCanvas pixels could not be converted to dstInfo.colorType() or dstInfo.alphaType()." ] # [ doc = "- SkCanvas pixels are not readable; for instance, SkCanvas is document-based." ] # [ doc = "- dstRowBytes is too small to contain one row of pixels." ] # [ doc = "" ] # [ doc = "@param dstInfo      width, height, SkColorType, and SkAlphaType of dstPixels" ] # [ doc = "@param dstPixels    storage for pixels; dstInfo.height() times dstRowBytes, or larger" ] # [ doc = "@param dstRowBytes  size of one destination row; dstInfo.width() times pixel size, or larger" ] # [ doc = "@param srcX         offset into readable pixels on x-axis; may be negative" ] # [ doc = "@param srcY         offset into readable pixels on y-axis; may be negative" ] # [ doc = "@return             true if pixels were copied" ] # [ link_name = "\u{1}__ZN8SkCanvas10readPixelsERK11SkImageInfoPvmii" ] pub fn SkCanvas_readPixels ( this : * mut SkCanvas , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies SkRect of pixels from SkCanvas into pixmap. SkMatrix and clip are" ] # [ doc = "ignored." ] # [ doc = "" ] # [ doc = "Source SkRect corners are (srcX, srcY) and (imageInfo().width(), imageInfo().height())." ] # [ doc = "Destination SkRect corners are (0, 0) and (pixmap.width(), pixmap.height())." ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to pixmap.colorType() and pixmap.alphaType() if required." ] # [ doc = "" ] # [ doc = "Pixels are readable when SkBaseDevice is raster, or backed by a GPU." ] # [ doc = "Pixels are not readable when SkCanvas is returned by SkDocument::beginPage," ] # [ doc = "returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility" ] # [ doc = "class like SkDebugCanvas." ] # [ doc = "" ] # [ doc = "Caller must allocate pixel storage in pixmap if needed." ] # [ doc = "" ] # [ doc = "Pixel values are converted only if SkColorType and SkAlphaType" ] # [ doc = "do not match. Only pixels within both source and destination SkRect" ] # [ doc = "are copied. pixmap pixels contents outside SkRect intersection are unchanged." ] # [ doc = "" ] # [ doc = "Pass negative values for srcX or srcY to offset pixels across or down pixmap." ] # [ doc = "" ] # [ doc = "Does not copy, and returns false if:" ] # [ doc = "- Source and destination rectangles do not intersect." ] # [ doc = "- SkCanvas pixels could not be converted to pixmap.colorType() or pixmap.alphaType()." ] # [ doc = "- SkCanvas pixels are not readable; for instance, SkCanvas is document-based." ] # [ doc = "- SkPixmap pixels could not be allocated." ] # [ doc = "- pixmap.rowBytes() is too small to contain one row of pixels." ] # [ doc = "" ] # [ doc = "@param pixmap  storage for pixels copied from SkCanvas" ] # [ doc = "@param srcX    offset into readable pixels on x-axis; may be negative" ] # [ doc = "@param srcY    offset into readable pixels on y-axis; may be negative" ] # [ doc = "@return        true if pixels were copied" ] # [ link_name = "\u{1}__ZN8SkCanvas10readPixelsERK8SkPixmapii" ] pub fn SkCanvas_readPixels1 ( this : * mut SkCanvas , pixmap : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies SkRect of pixels from SkCanvas into bitmap. SkMatrix and clip are" ] # [ doc = "ignored." ] # [ doc = "" ] # [ doc = "Source SkRect corners are (srcX, srcY) and (imageInfo().width(), imageInfo().height())." ] # [ doc = "Destination SkRect corners are (0, 0) and (bitmap.width(), bitmap.height())." ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to bitmap.colorType() and bitmap.alphaType() if required." ] # [ doc = "" ] # [ doc = "Pixels are readable when SkBaseDevice is raster, or backed by a GPU." ] # [ doc = "Pixels are not readable when SkCanvas is returned by SkDocument::beginPage," ] # [ doc = "returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility" ] # [ doc = "class like SkDebugCanvas." ] # [ doc = "" ] # [ doc = "Caller must allocate pixel storage in bitmap if needed." ] # [ doc = "" ] # [ doc = "SkBitmap values are converted only if SkColorType and SkAlphaType" ] # [ doc = "do not match. Only pixels within both source and destination rectangles" ] # [ doc = "are copied. SkBitmap pixels outside SkRect intersection are unchanged." ] # [ doc = "" ] # [ doc = "Pass negative values for srcX or srcY to offset pixels across or down bitmap." ] # [ doc = "" ] # [ doc = "Does not copy, and returns false if:" ] # [ doc = "- Source and destination rectangles do not intersect." ] # [ doc = "- SkCanvas pixels could not be converted to bitmap.colorType() or bitmap.alphaType()." ] # [ doc = "- SkCanvas pixels are not readable; for instance, SkCanvas is document-based." ] # [ doc = "- bitmap pixels could not be allocated." ] # [ doc = "- bitmap.rowBytes() is too small to contain one row of pixels." ] # [ doc = "" ] # [ doc = "@param bitmap  storage for pixels copied from SkCanvas" ] # [ doc = "@param srcX    offset into readable pixels on x-axis; may be negative" ] # [ doc = "@param srcY    offset into readable pixels on y-axis; may be negative" ] # [ doc = "@return        true if pixels were copied" ] # [ link_name = "\u{1}__ZN8SkCanvas10readPixelsERK8SkBitmapii" ] pub fn SkCanvas_readPixels2 ( this : * mut SkCanvas , bitmap : * const SkBitmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies SkRect from pixels to SkCanvas. SkMatrix and clip are ignored." ] # [ doc = "Source SkRect corners are (0, 0) and (info.width(), info.height())." ] # [ doc = "Destination SkRect corners are (x, y) and" ] # [ doc = "(imageInfo().width(), imageInfo().height())." ] # [ doc = "" ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to imageInfo().colorType() and imageInfo().alphaType() if required." ] # [ doc = "" ] # [ doc = "Pixels are writable when SkBaseDevice is raster, or backed by a GPU." ] # [ doc = "Pixels are not writable when SkCanvas is returned by SkDocument::beginPage," ] # [ doc = "returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility" ] # [ doc = "class like SkDebugCanvas." ] # [ doc = "" ] # [ doc = "Pixel values are converted only if SkColorType and SkAlphaType" ] # [ doc = "do not match. Only pixels within both source and destination rectangles" ] # [ doc = "are copied. SkCanvas pixels outside SkRect intersection are unchanged." ] # [ doc = "" ] # [ doc = "Pass negative values for x or y to offset pixels to the left or" ] # [ doc = "above SkCanvas pixels." ] # [ doc = "" ] # [ doc = "Does not copy, and returns false if:" ] # [ doc = "- Source and destination rectangles do not intersect." ] # [ doc = "- pixels could not be converted to SkCanvas imageInfo().colorType() or" ] # [ doc = "imageInfo().alphaType()." ] # [ doc = "- SkCanvas pixels are not writable; for instance, SkCanvas is document-based." ] # [ doc = "- rowBytes is too small to contain one row of pixels." ] # [ doc = "" ] # [ doc = "@param info      width, height, SkColorType, and SkAlphaType of pixels" ] # [ doc = "@param pixels    pixels to copy, of size info.height() times rowBytes, or larger" ] # [ doc = "@param rowBytes  size of one row of pixels; info.width() times pixel size, or larger" ] # [ doc = "@param x         offset into SkCanvas writable pixels on x-axis; may be negative" ] # [ doc = "@param y         offset into SkCanvas writable pixels on y-axis; may be negative" ] # [ doc = "@return          true if pixels were written to SkCanvas" ] # [ link_name = "\u{1}__ZN8SkCanvas11writePixelsERK11SkImageInfoPKvmii" ] pub fn SkCanvas_writePixels ( this : * mut SkCanvas , info : * const SkImageInfo , pixels : * const :: std :: os :: raw :: c_void , rowBytes : usize , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies SkRect from pixels to SkCanvas. SkMatrix and clip are ignored." ] # [ doc = "Source SkRect corners are (0, 0) and (bitmap.width(), bitmap.height())." ] # [ doc = "" ] # [ doc = "Destination SkRect corners are (x, y) and" ] # [ doc = "(imageInfo().width(), imageInfo().height())." ] # [ doc = "" ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to imageInfo().colorType() and imageInfo().alphaType() if required." ] # [ doc = "" ] # [ doc = "Pixels are writable when SkBaseDevice is raster, or backed by a GPU." ] # [ doc = "Pixels are not writable when SkCanvas is returned by SkDocument::beginPage," ] # [ doc = "returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility" ] # [ doc = "class like SkDebugCanvas." ] # [ doc = "" ] # [ doc = "Pixel values are converted only if SkColorType and SkAlphaType" ] # [ doc = "do not match. Only pixels within both source and destination rectangles" ] # [ doc = "are copied. SkCanvas pixels outside SkRect intersection are unchanged." ] # [ doc = "" ] # [ doc = "Pass negative values for x or y to offset pixels to the left or" ] # [ doc = "above SkCanvas pixels." ] # [ doc = "" ] # [ doc = "Does not copy, and returns false if:" ] # [ doc = "- Source and destination rectangles do not intersect." ] # [ doc = "- bitmap does not have allocated pixels." ] # [ doc = "- bitmap pixels could not be converted to SkCanvas imageInfo().colorType() or" ] # [ doc = "imageInfo().alphaType()." ] # [ doc = "- SkCanvas pixels are not writable; for instance, SkCanvas is document based." ] # [ doc = "- bitmap pixels are inaccessible; for instance, bitmap wraps a texture." ] # [ doc = "" ] # [ doc = "@param bitmap  contains pixels copied to SkCanvas" ] # [ doc = "@param x       offset into SkCanvas writable pixels on x-axis; may be negative" ] # [ doc = "@param y       offset into SkCanvas writable pixels on y-axis; may be negative" ] # [ doc = "@return        true if pixels were written to SkCanvas" ] # [ link_name = "\u{1}__ZN8SkCanvas11writePixelsERK8SkBitmapii" ] pub fn SkCanvas_writePixels1 ( this : * mut SkCanvas , bitmap : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Saves SkMatrix and clip." ] # [ doc = "Calling restore() discards changes to SkMatrix and clip," ] # [ doc = "restoring the SkMatrix and clip to their state when save() was called." ] # [ doc = "" ] # [ doc = "SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat(), setMatrix()," ] # [ doc = "and resetMatrix(). Clip may be changed by clipRect(), clipRRect(), clipPath(), clipRegion()." ] # [ doc = "" ] # [ doc = "Saved SkCanvas state is put on a stack; multiple calls to save() should be balance" ] # [ doc = "by an equal number of calls to restore()." ] # [ doc = "" ] # [ doc = "Call restoreToCount() with result to restore this and subsequent saves." ] # [ doc = "" ] # [ doc = "@return  depth of saved stack" ] # [ link_name = "\u{1}__ZN8SkCanvas4saveEv" ] pub fn SkCanvas_save ( this : * mut SkCanvas ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Saves SkMatrix and clip, and allocates a SkBitmap for subsequent drawing." ] # [ doc = "Calling restore() discards changes to SkMatrix and clip, and draws the SkBitmap." ] # [ doc = "" ] # [ doc = "SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat()," ] # [ doc = "setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect()," ] # [ doc = "clipPath(), clipRegion()." ] # [ doc = "" ] # [ doc = "SkRect bounds suggests but does not define the SkBitmap size. To clip drawing to" ] # [ doc = "a specific rectangle, use clipRect()." ] # [ doc = "" ] # [ doc = "Optional SkPaint paint applies alpha, SkColorFilter, SkImageFilter, and" ] # [ doc = "SkBlendMode when restore() is called." ] # [ doc = "" ] # [ doc = "Call restoreToCount() with returned value to restore this and subsequent saves." ] # [ doc = "" ] # [ doc = "@param bounds  hint to limit the size of the layer; may be nullptr" ] # [ doc = "@param paint   graphics state for layer; may be nullptr" ] # [ doc = "@return        depth of saved stack" ] # [ link_name = "\u{1}__ZN8SkCanvas9saveLayerEPK6SkRectPK7SkPaint" ] pub fn SkCanvas_saveLayer ( this : * mut SkCanvas , bounds : * const SkRect , paint : * const SkPaint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Saves SkMatrix and clip, and allocates a SkBitmap for subsequent drawing." ] # [ doc = "Calling restore() discards changes to SkMatrix and clip, and draws the SkBitmap." ] # [ doc = "" ] # [ doc = "SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat()," ] # [ doc = "setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect()," ] # [ doc = "clipPath(), clipRegion()." ] # [ doc = "" ] # [ doc = "SkRect bounds suggests but does not define the layer size. To clip drawing to" ] # [ doc = "a specific rectangle, use clipRect()." ] # [ doc = "" ] # [ doc = "Optional SkPaint paint applies alpha, SkColorFilter, SkImageFilter, and" ] # [ doc = "SkBlendMode when restore() is called." ] # [ doc = "" ] # [ doc = "Call restoreToCount() with returned value to restore this and subsequent saves." ] # [ doc = "" ] # [ doc = "@param bounds  hint to limit the size of layer; may be nullptr" ] # [ doc = "@param paint   graphics state for layer; may be nullptr" ] # [ doc = "@return        depth of saved stack" ] # [ link_name = "\u{1}__ZN8SkCanvas9saveLayerERK6SkRectPK7SkPaint" ] pub fn SkCanvas_saveLayer1 ( this : * mut SkCanvas , bounds : * const SkRect , paint : * const SkPaint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Saves SkMatrix and clip, and allocates SkBitmap for subsequent drawing." ] # [ doc = "" ] # [ doc = "Calling restore() discards changes to SkMatrix and clip," ] # [ doc = "and blends layer with alpha opacity onto prior layer." ] # [ doc = "" ] # [ doc = "SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat()," ] # [ doc = "setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect()," ] # [ doc = "clipPath(), clipRegion()." ] # [ doc = "" ] # [ doc = "SkRect bounds suggests but does not define layer size. To clip drawing to" ] # [ doc = "a specific rectangle, use clipRect()." ] # [ doc = "" ] # [ doc = "alpha of zero is fully transparent, 255 is fully opaque." ] # [ doc = "" ] # [ doc = "Call restoreToCount() with returned value to restore this and subsequent saves." ] # [ doc = "" ] # [ doc = "@param bounds  hint to limit the size of layer; may be nullptr" ] # [ doc = "@param alpha   opacity of layer" ] # [ doc = "@return        depth of saved stack" ] # [ link_name = "\u{1}__ZN8SkCanvas14saveLayerAlphaEPK6SkRectj" ] pub fn SkCanvas_saveLayerAlpha ( this : * mut SkCanvas , bounds : * const SkRect , alpha : U8CPU ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Saves SkMatrix and clip, and allocates SkBitmap for subsequent drawing." ] # [ doc = "" ] # [ doc = "Calling restore() discards changes to SkMatrix and clip," ] # [ doc = "and blends SkBitmap with alpha opacity onto the prior layer." ] # [ doc = "" ] # [ doc = "SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat()," ] # [ doc = "setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect()," ] # [ doc = "clipPath(), clipRegion()." ] # [ doc = "" ] # [ doc = "SaveLayerRec contains the state used to create the layer." ] # [ doc = "" ] # [ doc = "Call restoreToCount() with returned value to restore this and subsequent saves." ] # [ doc = "" ] # [ doc = "@param layerRec  layer state" ] # [ doc = "@return          depth of save state stack before this call was made." ] # [ link_name = "\u{1}__ZN8SkCanvas9saveLayerERKNS_12SaveLayerRecE" ] pub fn SkCanvas_saveLayer2 ( this : * mut SkCanvas , layerRec : * const SkCanvas_SaveLayerRec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Removes changes to SkMatrix and clip since SkCanvas state was" ] # [ doc = "last saved. The state is removed from the stack." ] # [ doc = "" ] # [ doc = "Does nothing if the stack is empty." ] # [ link_name = "\u{1}__ZN8SkCanvas7restoreEv" ] pub fn SkCanvas_restore ( this : * mut SkCanvas ) ; } extern "C" { # [ doc = " Returns the number of saved states, each containing: SkMatrix and clip." ] # [ doc = "Equals the number of save() calls less the number of restore() calls plus one." ] # [ doc = "The save count of a new canvas is one." ] # [ doc = "" ] # [ doc = "@return  depth of save state stack" ] # [ link_name = "\u{1}__ZNK8SkCanvas12getSaveCountEv" ] pub fn SkCanvas_getSaveCount ( this : * const SkCanvas ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Restores state to SkMatrix and clip values when save(), saveLayer()," ] # [ doc = "saveLayerPreserveLCDTextRequests(), or saveLayerAlpha() returned saveCount." ] # [ doc = "" ] # [ doc = "Does nothing if saveCount is greater than state stack count." ] # [ doc = "Restores state to initial values if saveCount is less than or equal to one." ] # [ doc = "" ] # [ doc = "@param saveCount  depth of state stack to restore" ] # [ link_name = "\u{1}__ZN8SkCanvas14restoreToCountEi" ] pub fn SkCanvas_restoreToCount ( this : * mut SkCanvas , saveCount : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Translates SkMatrix by dx along the x-axis and dy along the y-axis." ] # [ doc = "" ] # [ doc = "Mathematically, replaces SkMatrix with a translation matrix" ] # [ doc = "premultiplied with SkMatrix." ] # [ doc = "" ] # [ doc = "This has the effect of moving the drawing by (dx, dy) before transforming" ] # [ doc = "the result with SkMatrix." ] # [ doc = "" ] # [ doc = "@param dx  distance to translate on x-axis" ] # [ doc = "@param dy  distance to translate on y-axis" ] # [ link_name = "\u{1}__ZN8SkCanvas9translateEff" ] pub fn SkCanvas_translate ( this : * mut SkCanvas , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Scales SkMatrix by sx on the x-axis and sy on the y-axis." ] # [ doc = "" ] # [ doc = "Mathematically, replaces SkMatrix with a scale matrix" ] # [ doc = "premultiplied with SkMatrix." ] # [ doc = "" ] # [ doc = "This has the effect of scaling the drawing by (sx, sy) before transforming" ] # [ doc = "the result with SkMatrix." ] # [ doc = "" ] # [ doc = "@param sx  amount to scale on x-axis" ] # [ doc = "@param sy  amount to scale on y-axis" ] # [ link_name = "\u{1}__ZN8SkCanvas5scaleEff" ] pub fn SkCanvas_scale ( this : * mut SkCanvas , sx : SkScalar , sy : SkScalar ) ; } extern "C" { # [ doc = " Rotates SkMatrix by degrees. Positive degrees rotates clockwise." ] # [ doc = "" ] # [ doc = "Mathematically, replaces SkMatrix with a rotation matrix" ] # [ doc = "premultiplied with SkMatrix." ] # [ doc = "" ] # [ doc = "This has the effect of rotating the drawing by degrees before transforming" ] # [ doc = "the result with SkMatrix." ] # [ doc = "" ] # [ doc = "@param degrees  amount to rotate, in degrees" ] # [ link_name = "\u{1}__ZN8SkCanvas6rotateEf" ] pub fn SkCanvas_rotate ( this : * mut SkCanvas , degrees : SkScalar ) ; } extern "C" { # [ doc = " Rotates SkMatrix by degrees about a point at (px, py). Positive degrees rotates" ] # [ doc = "clockwise." ] # [ doc = "" ] # [ doc = "Mathematically, constructs a rotation matrix; premultiplies the rotation matrix by" ] # [ doc = "a translation matrix; then replaces SkMatrix with the resulting matrix" ] # [ doc = "premultiplied with SkMatrix." ] # [ doc = "" ] # [ doc = "This has the effect of rotating the drawing about a given point before" ] # [ doc = "transforming the result with SkMatrix." ] # [ doc = "" ] # [ doc = "@param degrees  amount to rotate, in degrees" ] # [ doc = "@param px       x-axis value of the point to rotate about" ] # [ doc = "@param py       y-axis value of the point to rotate about" ] # [ link_name = "\u{1}__ZN8SkCanvas6rotateEfff" ] pub fn SkCanvas_rotate1 ( this : * mut SkCanvas , degrees : SkScalar , px : SkScalar , py : SkScalar ) ; } extern "C" { # [ doc = " Skews SkMatrix by sx on the x-axis and sy on the y-axis. A positive value of sx" ] # [ doc = "skews the drawing right as y-axis values increase; a positive value of sy skews" ] # [ doc = "the drawing down as x-axis values increase." ] # [ doc = "" ] # [ doc = "Mathematically, replaces SkMatrix with a skew matrix premultiplied with SkMatrix." ] # [ doc = "" ] # [ doc = "This has the effect of skewing the drawing by (sx, sy) before transforming" ] # [ doc = "the result with SkMatrix." ] # [ doc = "" ] # [ doc = "@param sx  amount to skew on x-axis" ] # [ doc = "@param sy  amount to skew on y-axis" ] # [ link_name = "\u{1}__ZN8SkCanvas4skewEff" ] pub fn SkCanvas_skew ( this : * mut SkCanvas , sx : SkScalar , sy : SkScalar ) ; } extern "C" { # [ doc = " Replaces SkMatrix with matrix premultiplied with existing SkMatrix." ] # [ doc = "" ] # [ doc = "This has the effect of transforming the drawn geometry by matrix, before" ] # [ doc = "transforming the result with existing SkMatrix." ] # [ doc = "" ] # [ doc = "@param matrix  matrix to premultiply with existing SkMatrix" ] # [ link_name = "\u{1}__ZN8SkCanvas6concatERK8SkMatrix" ] pub fn SkCanvas_concat ( this : * mut SkCanvas , matrix : * const SkMatrix ) ; } extern "C" { # [ doc = " Replaces SkMatrix with matrix." ] # [ doc = "Unlike concat(), any prior matrix state is overwritten." ] # [ doc = "" ] # [ doc = "@param matrix  matrix to copy, replacing existing SkMatrix" ] # [ link_name = "\u{1}__ZN8SkCanvas9setMatrixERK8SkMatrix" ] pub fn SkCanvas_setMatrix ( this : * mut SkCanvas , matrix : * const SkMatrix ) ; } extern "C" { # [ doc = " Sets SkMatrix to the identity matrix." ] # [ doc = "Any prior matrix state is overwritten." ] # [ link_name = "\u{1}__ZN8SkCanvas11resetMatrixEv" ] pub fn SkCanvas_resetMatrix ( this : * mut SkCanvas ) ; } extern "C" { # [ doc = " Replaces clip with the intersection or difference of clip and rect," ] # [ doc = "with an aliased or anti-aliased clip edge. rect is transformed by SkMatrix" ] # [ doc = "before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param rect         SkRect to combine with clip" ] # [ doc = "@param op           SkClipOp to apply to clip" ] # [ doc = "@param doAntiAlias  true if clip is to be anti-aliased" ] # [ link_name = "\u{1}__ZN8SkCanvas8clipRectERK6SkRect8SkClipOpb" ] pub fn SkCanvas_clipRect ( this : * mut SkCanvas , rect : * const SkRect , op : SkClipOp , doAntiAlias : bool ) ; } extern "C" { # [ doc = " Replaces clip with the intersection or difference of clip and rect." ] # [ doc = "Resulting clip is aliased; pixels are fully contained by the clip." ] # [ doc = "rect is transformed by SkMatrix before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param rect  SkRect to combine with clip" ] # [ doc = "@param op    SkClipOp to apply to clip" ] # [ link_name = "\u{1}__ZN8SkCanvas8clipRectERK6SkRect8SkClipOp" ] pub fn SkCanvas_clipRect1 ( this : * mut SkCanvas , rect : * const SkRect , op : SkClipOp ) ; } extern "C" { # [ doc = " Replaces clip with the intersection of clip and rect." ] # [ doc = "Resulting clip is aliased; pixels are fully contained by the clip." ] # [ doc = "rect is transformed by SkMatrix" ] # [ doc = "before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param rect         SkRect to combine with clip" ] # [ doc = "@param doAntiAlias  true if clip is to be anti-aliased" ] # [ link_name = "\u{1}__ZN8SkCanvas8clipRectERK6SkRectb" ] pub fn SkCanvas_clipRect2 ( this : * mut SkCanvas , rect : * const SkRect , doAntiAlias : bool ) ; } extern "C" { # [ doc = " Sets the maximum clip rectangle, which can be set by clipRect(), clipRRect() and" ] # [ doc = "clipPath() and intersect the current clip with the specified rect." ] # [ doc = "The maximum clip affects only future clipping operations; it is not retroactive." ] # [ doc = "The clip restriction is not recorded in pictures." ] # [ doc = "" ] # [ doc = "Pass an empty rect to disable maximum clip." ] # [ doc = "This private API is for use by Android framework only." ] # [ doc = "" ] # [ doc = "@param rect  maximum allowed clip in device coordinates" ] # [ link_name = "\u{1}__ZN8SkCanvas41androidFramework_setDeviceClipRestrictionERK7SkIRect" ] pub fn SkCanvas_androidFramework_setDeviceClipRestriction ( this : * mut SkCanvas , rect : * const SkIRect ) ; } extern "C" { # [ doc = " Replaces clip with the intersection or difference of clip and rrect," ] # [ doc = "with an aliased or anti-aliased clip edge." ] # [ doc = "rrect is transformed by SkMatrix" ] # [ doc = "before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param rrect        SkRRect to combine with clip" ] # [ doc = "@param op           SkClipOp to apply to clip" ] # [ doc = "@param doAntiAlias  true if clip is to be anti-aliased" ] # [ link_name = "\u{1}__ZN8SkCanvas9clipRRectERK7SkRRect8SkClipOpb" ] pub fn SkCanvas_clipRRect ( this : * mut SkCanvas , rrect : * const SkRRect , op : SkClipOp , doAntiAlias : bool ) ; } extern "C" { # [ doc = " Replaces clip with the intersection or difference of clip and rrect." ] # [ doc = "Resulting clip is aliased; pixels are fully contained by the clip." ] # [ doc = "rrect is transformed by SkMatrix before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param rrect  SkRRect to combine with clip" ] # [ doc = "@param op     SkClipOp to apply to clip" ] # [ link_name = "\u{1}__ZN8SkCanvas9clipRRectERK7SkRRect8SkClipOp" ] pub fn SkCanvas_clipRRect1 ( this : * mut SkCanvas , rrect : * const SkRRect , op : SkClipOp ) ; } extern "C" { # [ doc = " Replaces clip with the intersection of clip and rrect," ] # [ doc = "with an aliased or anti-aliased clip edge." ] # [ doc = "rrect is transformed by SkMatrix before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param rrect        SkRRect to combine with clip" ] # [ doc = "@param doAntiAlias  true if clip is to be anti-aliased" ] # [ link_name = "\u{1}__ZN8SkCanvas9clipRRectERK7SkRRectb" ] pub fn SkCanvas_clipRRect2 ( this : * mut SkCanvas , rrect : * const SkRRect , doAntiAlias : bool ) ; } extern "C" { # [ doc = " Replaces clip with the intersection or difference of clip and path," ] # [ doc = "with an aliased or anti-aliased clip edge. SkPath::FillType determines if path" ] # [ doc = "describes the area inside or outside its contours; and if path contour overlaps" ] # [ doc = "itself or another path contour, whether the overlaps form part of the area." ] # [ doc = "path is transformed by SkMatrix before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param path         SkPath to combine with clip" ] # [ doc = "@param op           SkClipOp to apply to clip" ] # [ doc = "@param doAntiAlias  true if clip is to be anti-aliased" ] # [ link_name = "\u{1}__ZN8SkCanvas8clipPathERK6SkPath8SkClipOpb" ] pub fn SkCanvas_clipPath ( this : * mut SkCanvas , path : * const SkPath , op : SkClipOp , doAntiAlias : bool ) ; } extern "C" { # [ doc = " Replaces clip with the intersection or difference of clip and path." ] # [ doc = "Resulting clip is aliased; pixels are fully contained by the clip." ] # [ doc = "SkPath::FillType determines if path" ] # [ doc = "describes the area inside or outside its contours; and if path contour overlaps" ] # [ doc = "itself or another path contour, whether the overlaps form part of the area." ] # [ doc = "path is transformed by SkMatrix" ] # [ doc = "before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param path  SkPath to combine with clip" ] # [ doc = "@param op    SkClipOp to apply to clip" ] # [ link_name = "\u{1}__ZN8SkCanvas8clipPathERK6SkPath8SkClipOp" ] pub fn SkCanvas_clipPath1 ( this : * mut SkCanvas , path : * const SkPath , op : SkClipOp ) ; } extern "C" { # [ doc = " Replaces clip with the intersection of clip and path." ] # [ doc = "Resulting clip is aliased; pixels are fully contained by the clip." ] # [ doc = "SkPath::FillType determines if path" ] # [ doc = "describes the area inside or outside its contours; and if path contour overlaps" ] # [ doc = "itself or another path contour, whether the overlaps form part of the area." ] # [ doc = "path is transformed by SkMatrix before it is combined with clip." ] # [ doc = "" ] # [ doc = "@param path         SkPath to combine with clip" ] # [ doc = "@param doAntiAlias  true if clip is to be anti-aliased" ] # [ link_name = "\u{1}__ZN8SkCanvas8clipPathERK6SkPathb" ] pub fn SkCanvas_clipPath2 ( this : * mut SkCanvas , path : * const SkPath , doAntiAlias : bool ) ; } extern "C" { # [ doc = " Experimental. For testing only." ] # [ doc = "Set to simplify clip stack using PathOps." ] # [ link_name = "\u{1}__ZN8SkCanvas20setAllowSimplifyClipEb" ] pub fn SkCanvas_setAllowSimplifyClip ( this : * mut SkCanvas , allow : bool ) ; } extern "C" { # [ doc = " Replaces clip with the intersection or difference of clip and SkRegion deviceRgn." ] # [ doc = "Resulting clip is aliased; pixels are fully contained by the clip." ] # [ doc = "deviceRgn is unaffected by SkMatrix." ] # [ doc = "" ] # [ doc = "@param deviceRgn  SkRegion to combine with clip" ] # [ doc = "@param op         SkClipOp to apply to clip" ] # [ link_name = "\u{1}__ZN8SkCanvas10clipRegionERK8SkRegion8SkClipOp" ] pub fn SkCanvas_clipRegion ( this : * mut SkCanvas , deviceRgn : * const SkRegion , op : SkClipOp ) ; } extern "C" { # [ doc = " Returns true if SkRect rect, transformed by SkMatrix, can be quickly determined to be" ] # [ doc = "outside of clip. May return false even though rect is outside of clip." ] # [ doc = "" ] # [ doc = "Use to check if an area to be drawn is clipped out, to skip subsequent draw calls." ] # [ doc = "" ] # [ doc = "@param rect  SkRect to compare with clip" ] # [ doc = "@return      true if rect, transformed by SkMatrix, does not intersect clip" ] # [ link_name = "\u{1}__ZNK8SkCanvas11quickRejectERK6SkRect" ] pub fn SkCanvas_quickReject ( this : * const SkCanvas , rect : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Returns true if path, transformed by SkMatrix, can be quickly determined to be" ] # [ doc = "outside of clip. May return false even though path is outside of clip." ] # [ doc = "" ] # [ doc = "Use to check if an area to be drawn is clipped out, to skip subsequent draw calls." ] # [ doc = "" ] # [ doc = "@param path  SkPath to compare with clip" ] # [ doc = "@return      true if path, transformed by SkMatrix, does not intersect clip" ] # [ link_name = "\u{1}__ZNK8SkCanvas11quickRejectERK6SkPath" ] pub fn SkCanvas_quickReject1 ( this : * const SkCanvas , path : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Returns bounds of clip, transformed by inverse of SkMatrix. If clip is empty," ] # [ doc = "return SkRect::MakeEmpty, where all SkRect sides equal zero." ] # [ doc = "" ] # [ doc = "SkRect returned is outset by one to account for partial pixel coverage if clip" ] # [ doc = "is anti-aliased." ] # [ doc = "" ] # [ doc = "@return  bounds of clip in local coordinates" ] # [ link_name = "\u{1}__ZNK8SkCanvas18getLocalClipBoundsEv" ] pub fn SkCanvas_getLocalClipBounds ( this : * const SkCanvas ) -> SkRect ; } extern "C" { # [ doc = " Returns bounds of clip, transformed by inverse of SkMatrix. If clip is empty," ] # [ doc = "return false, and set bounds to SkRect::MakeEmpty, where all SkRect sides equal zero." ] # [ doc = "" ] # [ doc = "bounds is outset by one to account for partial pixel coverage if clip" ] # [ doc = "is anti-aliased." ] # [ doc = "" ] # [ doc = "@param bounds  SkRect of clip in local coordinates" ] # [ doc = "@return        true if clip bounds is not empty" ] # [ link_name = "\u{1}__ZNK8SkCanvas18getLocalClipBoundsEP6SkRect" ] pub fn SkCanvas_getLocalClipBounds1 ( this : * const SkCanvas , bounds : * mut SkRect ) -> bool ; } extern "C" { # [ doc = " Returns SkIRect bounds of clip, unaffected by SkMatrix. If clip is empty," ] # [ doc = "return SkRect::MakeEmpty, where all SkRect sides equal zero." ] # [ doc = "" ] # [ doc = "Unlike getLocalClipBounds(), returned SkIRect is not outset." ] # [ doc = "" ] # [ doc = "@return  bounds of clip in SkBaseDevice coordinates" ] # [ link_name = "\u{1}__ZNK8SkCanvas19getDeviceClipBoundsEv" ] pub fn SkCanvas_getDeviceClipBounds ( this : * const SkCanvas ) -> SkIRect ; } extern "C" { # [ doc = " Returns SkIRect bounds of clip, unaffected by SkMatrix. If clip is empty," ] # [ doc = "return false, and set bounds to SkRect::MakeEmpty, where all SkRect sides equal zero." ] # [ doc = "" ] # [ doc = "Unlike getLocalClipBounds(), bounds is not outset." ] # [ doc = "" ] # [ doc = "@param bounds  SkRect of clip in device coordinates" ] # [ doc = "@return        true if clip bounds is not empty" ] # [ link_name = "\u{1}__ZNK8SkCanvas19getDeviceClipBoundsEP7SkIRect" ] pub fn SkCanvas_getDeviceClipBounds1 ( this : * const SkCanvas , bounds : * mut SkIRect ) -> bool ; } extern "C" { # [ doc = " Fills clip with color color." ] # [ doc = "mode determines how ARGB is combined with destination." ] # [ doc = "" ] # [ doc = "@param color  unpremultiplied ARGB" ] # [ doc = "@param mode   SkBlendMode used to combine source color and destination" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawColorEj11SkBlendMode" ] pub fn SkCanvas_drawColor ( this : * mut SkCanvas , color : SkColor , mode : SkBlendMode ) ; } extern "C" { # [ doc = " Fills clip with color color using SkBlendMode::kSrc." ] # [ doc = "This has the effect of replacing all pixels contained by clip with color." ] # [ doc = "" ] # [ doc = "@param color  unpremultiplied ARGB" ] # [ link_name = "\u{1}__ZN8SkCanvas5clearEj" ] pub fn SkCanvas_clear ( this : * mut SkCanvas , color : SkColor ) ; } extern "C" { # [ doc = " Makes SkCanvas contents undefined. Subsequent calls that read SkCanvas pixels," ] # [ doc = "such as drawing with SkBlendMode, return undefined results. discard() does" ] # [ doc = "not change clip or SkMatrix." ] # [ doc = "" ] # [ doc = "discard() may do nothing, depending on the implementation of SkSurface or SkBaseDevice" ] # [ doc = "that created SkCanvas." ] # [ doc = "" ] # [ doc = "discard() allows optimized performance on subsequent draws by removing" ] # [ doc = "cached data associated with SkSurface or SkBaseDevice." ] # [ doc = "It is not necessary to call discard() once done with SkCanvas;" ] # [ doc = "any cached data is deleted when owning SkSurface or SkBaseDevice is deleted." ] # [ link_name = "\u{1}__ZN8SkCanvas7discardEv" ] pub fn SkCanvas_discard ( this : * mut SkCanvas ) ; } extern "C" { # [ doc = " Fills clip with SkPaint paint. SkPaint components SkMaskFilter, SkShader," ] # [ doc = "SkColorFilter, SkImageFilter, and SkBlendMode affect drawing;" ] # [ doc = "SkPathEffect in paint is ignored." ] # [ doc = "" ] # [ doc = "@param paint  graphics state used to fill SkCanvas" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawPaintERK7SkPaint" ] pub fn SkCanvas_drawPaint ( this : * mut SkCanvas , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws pts using clip, SkMatrix and SkPaint paint." ] # [ doc = "count is the number of points; if count is less than one, has no effect." ] # [ doc = "mode may be one of: kPoints_PointMode, kLines_PointMode, or kPolygon_PointMode." ] # [ doc = "" ] # [ doc = "If mode is kPoints_PointMode, the shape of point drawn depends on paint" ] # [ doc = "SkPaint::Cap. If paint is set to SkPaint::kRound_Cap, each point draws a" ] # [ doc = "circle of diameter SkPaint stroke width. If paint is set to SkPaint::kSquare_Cap" ] # [ doc = "or SkPaint::kButt_Cap, each point draws a square of width and height" ] # [ doc = "SkPaint stroke width." ] # [ doc = "" ] # [ doc = "If mode is kLines_PointMode, each pair of points draws a line segment." ] # [ doc = "One line is drawn for every two points; each point is used once. If count is odd," ] # [ doc = "the final point is ignored." ] # [ doc = "" ] # [ doc = "If mode is kPolygon_PointMode, each adjacent pair of points draws a line segment." ] # [ doc = "count minus one lines are drawn; the first and last point are used once." ] # [ doc = "" ] # [ doc = "Each line segment respects paint SkPaint::Cap and SkPaint stroke width." ] # [ doc = "SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style." ] # [ doc = "" ] # [ doc = "Always draws each element one at a time; is not affected by" ] # [ doc = "SkPaint::Join, and unlike drawPath(), does not create a mask from all points" ] # [ doc = "and lines before drawing." ] # [ doc = "" ] # [ doc = "@param mode   whether pts draws points or lines" ] # [ doc = "@param count  number of points in the array" ] # [ doc = "@param pts    array of points to draw" ] # [ doc = "@param paint  stroke, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas10drawPointsENS_9PointModeEmPK7SkPointRK7SkPaint" ] pub fn SkCanvas_drawPoints ( this : * mut SkCanvas , mode : SkCanvas_PointMode , count : usize , pts : * const SkPoint , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws point at (x, y) using clip, SkMatrix and SkPaint paint." ] # [ doc = "" ] # [ doc = "The shape of point drawn depends on paint SkPaint::Cap." ] # [ doc = "If paint is set to SkPaint::kRound_Cap, draw a circle of diameter" ] # [ doc = "SkPaint stroke width. If paint is set to SkPaint::kSquare_Cap or SkPaint::kButt_Cap," ] # [ doc = "draw a square of width and height SkPaint stroke width." ] # [ doc = "SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style." ] # [ doc = "" ] # [ doc = "@param x      left edge of circle or square" ] # [ doc = "@param y      top edge of circle or square" ] # [ doc = "@param paint  stroke, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawPointEffRK7SkPaint" ] pub fn SkCanvas_drawPoint ( this : * mut SkCanvas , x : SkScalar , y : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws point p using clip, SkMatrix and SkPaint paint." ] # [ doc = "" ] # [ doc = "The shape of point drawn depends on paint SkPaint::Cap." ] # [ doc = "If paint is set to SkPaint::kRound_Cap, draw a circle of diameter" ] # [ doc = "SkPaint stroke width. If paint is set to SkPaint::kSquare_Cap or SkPaint::kButt_Cap," ] # [ doc = "draw a square of width and height SkPaint stroke width." ] # [ doc = "SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style." ] # [ doc = "" ] # [ doc = "@param p      top-left edge of circle or square" ] # [ doc = "@param paint  stroke, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawPointE7SkPointRK7SkPaint" ] pub fn SkCanvas_drawPoint1 ( this : * mut SkCanvas , p : SkPoint , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws line segment from (x0, y0) to (x1, y1) using clip, SkMatrix, and SkPaint paint." ] # [ doc = "In paint: SkPaint stroke width describes the line thickness;" ] # [ doc = "SkPaint::Cap draws the end rounded or square;" ] # [ doc = "SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style." ] # [ doc = "" ] # [ doc = "@param x0     start of line segment on x-axis" ] # [ doc = "@param y0     start of line segment on y-axis" ] # [ doc = "@param x1     end of line segment on x-axis" ] # [ doc = "@param y1     end of line segment on y-axis" ] # [ doc = "@param paint  stroke, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas8drawLineEffffRK7SkPaint" ] pub fn SkCanvas_drawLine ( this : * mut SkCanvas , x0 : SkScalar , y0 : SkScalar , x1 : SkScalar , y1 : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws line segment from p0 to p1 using clip, SkMatrix, and SkPaint paint." ] # [ doc = "In paint: SkPaint stroke width describes the line thickness;" ] # [ doc = "SkPaint::Cap draws the end rounded or square;" ] # [ doc = "SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style." ] # [ doc = "" ] # [ doc = "@param p0     start of line segment" ] # [ doc = "@param p1     end of line segment" ] # [ doc = "@param paint  stroke, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas8drawLineE7SkPointS0_RK7SkPaint" ] pub fn SkCanvas_drawLine1 ( this : * mut SkCanvas , p0 : SkPoint , p1 : SkPoint , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkRect rect using clip, SkMatrix, and SkPaint paint." ] # [ doc = "In paint: SkPaint::Style determines if rectangle is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness, and" ] # [ doc = "SkPaint::Join draws the corners rounded or square." ] # [ doc = "" ] # [ doc = "@param rect   rectangle to draw" ] # [ doc = "@param paint  stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas8drawRectERK6SkRectRK7SkPaint" ] pub fn SkCanvas_drawRect ( this : * mut SkCanvas , rect : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkIRect rect using clip, SkMatrix, and SkPaint paint." ] # [ doc = "In paint: SkPaint::Style determines if rectangle is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness, and" ] # [ doc = "SkPaint::Join draws the corners rounded or square." ] # [ doc = "" ] # [ doc = "@param rect   rectangle to draw" ] # [ doc = "@param paint  stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawIRectERK7SkIRectRK7SkPaint" ] pub fn SkCanvas_drawIRect ( this : * mut SkCanvas , rect : * const SkIRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkRegion region using clip, SkMatrix, and SkPaint paint." ] # [ doc = "In paint: SkPaint::Style determines if rectangle is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness, and" ] # [ doc = "SkPaint::Join draws the corners rounded or square." ] # [ doc = "" ] # [ doc = "@param region  region to draw" ] # [ doc = "@param paint   SkPaint stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas10drawRegionERK8SkRegionRK7SkPaint" ] pub fn SkCanvas_drawRegion ( this : * mut SkCanvas , region : * const SkRegion , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws oval oval using clip, SkMatrix, and SkPaint." ] # [ doc = "In paint: SkPaint::Style determines if oval is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness." ] # [ doc = "" ] # [ doc = "@param oval   SkRect bounds of oval" ] # [ doc = "@param paint  SkPaint stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas8drawOvalERK6SkRectRK7SkPaint" ] pub fn SkCanvas_drawOval ( this : * mut SkCanvas , oval : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkRRect rrect using clip, SkMatrix, and SkPaint paint." ] # [ doc = "In paint: SkPaint::Style determines if rrect is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness." ] # [ doc = "" ] # [ doc = "rrect may represent a rectangle, circle, oval, uniformly rounded rectangle, or" ] # [ doc = "may have any combination of positive non-square radii for the four corners." ] # [ doc = "" ] # [ doc = "@param rrect  SkRRect with up to eight corner radii to draw" ] # [ doc = "@param paint  SkPaint stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawRRectERK7SkRRectRK7SkPaint" ] pub fn SkCanvas_drawRRect ( this : * mut SkCanvas , rrect : * const SkRRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkRRect outer and inner" ] # [ doc = "using clip, SkMatrix, and SkPaint paint." ] # [ doc = "outer must contain inner or the drawing is undefined." ] # [ doc = "In paint: SkPaint::Style determines if SkRRect is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness." ] # [ doc = "If stroked and SkRRect corner has zero length radii, SkPaint::Join can" ] # [ doc = "draw corners rounded or square." ] # [ doc = "" ] # [ doc = "GPU-backed platforms optimize drawing when both outer and inner are" ] # [ doc = "concave and outer contains inner. These platforms may not be able to draw" ] # [ doc = "SkPath built with identical data as fast." ] # [ doc = "" ] # [ doc = "@param outer  SkRRect outer bounds to draw" ] # [ doc = "@param inner  SkRRect inner bounds to draw" ] # [ doc = "@param paint  SkPaint stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas10drawDRRectERK7SkRRectS2_RK7SkPaint" ] pub fn SkCanvas_drawDRRect ( this : * mut SkCanvas , outer : * const SkRRect , inner : * const SkRRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws circle at (cx, cy) with radius using clip, SkMatrix, and SkPaint paint." ] # [ doc = "If radius is zero or less, nothing is drawn." ] # [ doc = "In paint: SkPaint::Style determines if circle is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness." ] # [ doc = "" ] # [ doc = "@param cx      circle center on the x-axis" ] # [ doc = "@param cy      circle center on the y-axis" ] # [ doc = "@param radius  half the diameter of circle" ] # [ doc = "@param paint   SkPaint stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas10drawCircleEfffRK7SkPaint" ] pub fn SkCanvas_drawCircle ( this : * mut SkCanvas , cx : SkScalar , cy : SkScalar , radius : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws circle at center with radius using clip, SkMatrix, and SkPaint paint." ] # [ doc = "If radius is zero or less, nothing is drawn." ] # [ doc = "In paint: SkPaint::Style determines if circle is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness." ] # [ doc = "" ] # [ doc = "@param center  circle center" ] # [ doc = "@param radius  half the diameter of circle" ] # [ doc = "@param paint   SkPaint stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas10drawCircleE7SkPointfRK7SkPaint" ] pub fn SkCanvas_drawCircle1 ( this : * mut SkCanvas , center : SkPoint , radius : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws arc using clip, SkMatrix, and SkPaint paint." ] # [ doc = "" ] # [ doc = "Arc is part of oval bounded by oval, sweeping from startAngle to startAngle plus" ] # [ doc = "sweepAngle. startAngle and sweepAngle are in degrees." ] # [ doc = "" ] # [ doc = "startAngle of zero places start point at the right middle edge of oval." ] # [ doc = "A positive sweepAngle places arc end point clockwise from start point;" ] # [ doc = "a negative sweepAngle places arc end point counterclockwise from start point." ] # [ doc = "sweepAngle may exceed 360 degrees, a full circle." ] # [ doc = "If useCenter is true, draw a wedge that includes lines from oval" ] # [ doc = "center to arc end points. If useCenter is false, draw arc between end points." ] # [ doc = "" ] # [ doc = "If SkRect oval is empty or sweepAngle is zero, nothing is drawn." ] # [ doc = "" ] # [ doc = "@param oval        SkRect bounds of oval containing arc to draw" ] # [ doc = "@param startAngle  angle in degrees where arc begins" ] # [ doc = "@param sweepAngle  sweep angle in degrees; positive is clockwise" ] # [ doc = "@param useCenter   if true, include the center of the oval" ] # [ doc = "@param paint       SkPaint stroke or fill, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas7drawArcERK6SkRectffbRK7SkPaint" ] pub fn SkCanvas_drawArc ( this : * mut SkCanvas , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , useCenter : bool , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkRRect bounded by SkRect rect, with corner radii (rx, ry) using clip," ] # [ doc = "SkMatrix, and SkPaint paint." ] # [ doc = "" ] # [ doc = "In paint: SkPaint::Style determines if SkRRect is stroked or filled;" ] # [ doc = "if stroked, SkPaint stroke width describes the line thickness." ] # [ doc = "If rx or ry are less than zero, they are treated as if they are zero." ] # [ doc = "If rx plus ry exceeds rect width or rect height, radii are scaled down to fit." ] # [ doc = "If rx and ry are zero, SkRRect is drawn as SkRect and if stroked is affected by" ] # [ doc = "SkPaint::Join." ] # [ doc = "" ] # [ doc = "@param rect   SkRect bounds of SkRRect to draw" ] # [ doc = "@param rx     axis length on x-axis of oval describing rounded corners" ] # [ doc = "@param ry     axis length on y-axis of oval describing rounded corners" ] # [ doc = "@param paint  stroke, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawRoundRectERK6SkRectffRK7SkPaint" ] pub fn SkCanvas_drawRoundRect ( this : * mut SkCanvas , rect : * const SkRect , rx : SkScalar , ry : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkPath path using clip, SkMatrix, and SkPaint paint." ] # [ doc = "SkPath contains an array of path contour, each of which may be open or closed." ] # [ doc = "" ] # [ doc = "In paint: SkPaint::Style determines if SkRRect is stroked or filled:" ] # [ doc = "if filled, SkPath::FillType determines whether path contour describes inside or" ] # [ doc = "outside of fill; if stroked, SkPaint stroke width describes the line thickness," ] # [ doc = "SkPaint::Cap describes line ends, and SkPaint::Join describes how" ] # [ doc = "corners are drawn." ] # [ doc = "" ] # [ doc = "@param path   SkPath to draw" ] # [ doc = "@param paint  stroke, blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas8drawPathERK6SkPathRK7SkPaint" ] pub fn SkCanvas_drawPath ( this : * mut SkCanvas , path : * const SkPath , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkImage image, with its top-left corner at (left, top)," ] # [ doc = "using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "This is equivalent to drawImageRect() using a dst rect at (x,y) with the" ] # [ doc = "same width and height of the image." ] # [ doc = "" ] # [ doc = "@param image  uncompressed rectangular map of pixels" ] # [ doc = "@param left   left side of image" ] # [ doc = "@param top    top side of image" ] # [ doc = "@param paint  SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawImageEPK7SkImageffPK7SkPaint" ] pub fn SkCanvas_drawImage ( this : * mut SkCanvas , image : * const SkImage , left : SkScalar , top : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkImage image, with its top-left corner at (left, top)," ] # [ doc = "using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "This is equivalent to drawImageRect() using a dst rect at (x,y) with the" ] # [ doc = "same width and height of the image." ] # [ doc = "" ] # [ doc = "@param image  uncompressed rectangular map of pixels" ] # [ doc = "@param left   left side of image" ] # [ doc = "@param top    pop side of image" ] # [ doc = "@param paint  SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawImageERK5sk_spI7SkImageEffPK7SkPaint" ] pub fn SkCanvas_drawImage1 ( this : * mut SkCanvas , image : * const sk_sp < SkImage > , left : SkScalar , top : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkRect src of SkImage image, scaled and translated to fill SkRect dst." ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond image bounds, replicate image edge colors, just" ] # [ doc = "as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set" ] # [ doc = "replicates the image edge color when it samples outside of its bounds." ] # [ doc = "" ] # [ doc = "When using a shader or shader mask filter, its coordinate system is based on the" ] # [ doc = "current CTM, so will reflect the dst rect geometry and is equivalent to" ] # [ doc = "drawRect(dst). The src rect is only used to access the provided image." ] # [ doc = "" ] # [ doc = "constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to" ] # [ doc = "sample within src; set to kFast_SrcRectConstraint allows sampling outside to" ] # [ doc = "improve performance." ] # [ doc = "" ] # [ doc = "@param image       SkImage containing pixels, dimensions, and format" ] # [ doc = "@param src         source SkRect of image to draw from" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ doc = "@param constraint  filter strictly within src or draw faster" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectS5_PK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_drawImageRect ( this : * mut SkCanvas , image : * const SkImage , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ doc = " Draws SkIRect isrc of SkImage image, scaled and translated to fill SkRect dst." ] # [ doc = "Note that isrc is on integer pixel boundaries; dst may include fractional" ] # [ doc = "boundaries. Additionally transform draw using clip, SkMatrix, and optional SkPaint" ] # [ doc = "paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond image bounds, replicate image edge colors, just" ] # [ doc = "as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set" ] # [ doc = "replicates the image edge color when it samples outside of its bounds." ] # [ doc = "" ] # [ doc = "When using a shader or shader mask filter, its coordinate system is based on the" ] # [ doc = "current CTM, so will reflect the dst rect geometry and is equivalent to" ] # [ doc = "drawRect(dst). The src rect is only used to access the provided image." ] # [ doc = "" ] # [ doc = "constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to" ] # [ doc = "sample within isrc; set to kFast_SrcRectConstraint allows sampling outside to" ] # [ doc = "improve performance." ] # [ doc = "" ] # [ doc = "@param image       SkImage containing pixels, dimensions, and format" ] # [ doc = "@param isrc        source SkIRect of image to draw from" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ doc = "@param constraint  filter strictly within isrc or draw faster" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawImageRectEPK7SkImageRK7SkIRectRK6SkRectPK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_drawImageRect1 ( this : * mut SkCanvas , image : * const SkImage , isrc : * const SkIRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ doc = " Draws SkImage image, scaled and translated to fill SkRect dst, using clip, SkMatrix," ] # [ doc = "and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond image bounds, replicate image edge colors, just" ] # [ doc = "as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set" ] # [ doc = "replicates the image edge color when it samples outside of its bounds." ] # [ doc = "" ] # [ doc = "When using a shader or shader mask filter, its coordinate system is based on the" ] # [ doc = "current CTM, so will reflect the dst rect geometry and is equivalent to" ] # [ doc = "drawRect(dst)." ] # [ doc = "" ] # [ doc = "@param image       SkImage containing pixels, dimensions, and format" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawImageRectEPK7SkImageRK6SkRectPK7SkPaint" ] pub fn SkCanvas_drawImageRect2 ( this : * mut SkCanvas , image : * const SkImage , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkRect src of SkImage image, scaled and translated to fill SkRect dst." ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond image bounds, replicate image edge colors, just" ] # [ doc = "as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set" ] # [ doc = "replicates the image edge color when it samples outside of its bounds." ] # [ doc = "" ] # [ doc = "When using a shader or shader mask filter, its coordinate system is based on the" ] # [ doc = "current CTM, so will reflect the dst rect geometry and is equivalent to" ] # [ doc = "drawRect(dst). The src rect is only used to access the provided image." ] # [ doc = "" ] # [ doc = "@param image       SkImage containing pixels, dimensions, and format" ] # [ doc = "@param src         source SkRect of image to draw from" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ doc = "@param constraint  filter strictly within src or draw faster" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawImageRectERK5sk_spI7SkImageERK6SkRectS7_PK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_drawImageRect3 ( this : * mut SkCanvas , image : * const sk_sp < SkImage > , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ doc = " Draws SkIRect isrc of SkImage image, scaled and translated to fill SkRect dst." ] # [ doc = "isrc is on integer pixel boundaries; dst may include fractional boundaries." ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond image bounds, replicate image edge colors, just" ] # [ doc = "as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set" ] # [ doc = "replicates the image edge color when it samples outside of its bounds." ] # [ doc = "" ] # [ doc = "When using a shader or shader mask filter, its coordinate system is based on the" ] # [ doc = "current CTM, so will reflect the dst rect geometry and is equivalent to" ] # [ doc = "drawRect(dst). The src rect is only used to access the provided image." ] # [ doc = "" ] # [ doc = "constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to" ] # [ doc = "sample within image; set to kFast_SrcRectConstraint allows sampling outside to" ] # [ doc = "improve performance." ] # [ doc = "" ] # [ doc = "@param image       SkImage containing pixels, dimensions, and format" ] # [ doc = "@param isrc        source SkIRect of image to draw from" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ doc = "@param constraint  filter strictly within image or draw faster" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawImageRectERK5sk_spI7SkImageERK7SkIRectRK6SkRectPK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_drawImageRect4 ( this : * mut SkCanvas , image : * const sk_sp < SkImage > , isrc : * const SkIRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ doc = " Draws SkImage image, scaled and translated to fill SkRect dst," ] # [ doc = "using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond image bounds, replicate image edge colors, just" ] # [ doc = "as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set" ] # [ doc = "replicates the image edge color when it samples outside of its bounds." ] # [ doc = "" ] # [ doc = "When using a shader or shader mask filter, its coordinate system is based on the" ] # [ doc = "current CTM, so will reflect the dst rect geometry and is equivalent to" ] # [ doc = "drawRect(dst)." ] # [ doc = "" ] # [ doc = "constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to" ] # [ doc = "sample within image; set to kFast_SrcRectConstraint allows sampling outside to" ] # [ doc = "improve performance." ] # [ doc = "" ] # [ doc = "@param image       SkImage containing pixels, dimensions, and format" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawImageRectERK5sk_spI7SkImageERK6SkRectPK7SkPaint" ] pub fn SkCanvas_drawImageRect5 ( this : * mut SkCanvas , image : * const sk_sp < SkImage > , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkImage image stretched proportionally to fit into SkRect dst." ] # [ doc = "SkIRect center divides the image into nine sections: four sides, four corners, and" ] # [ doc = "the center. Corners are unmodified or scaled down proportionately if their sides" ] # [ doc = "are larger than dst; center and four sides are scaled to fit remaining space, if any." ] # [ doc = "" ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds. If paint" ] # [ doc = "SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all" ] # [ doc = "other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels." ] # [ doc = "Any SkMaskFilter on paint is ignored as is paint anti-aliasing state." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond image bounds, replicate image edge colors, just" ] # [ doc = "as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set" ] # [ doc = "replicates the image edge color when it samples outside of its bounds." ] # [ doc = "" ] # [ doc = "@param image   SkImage containing pixels, dimensions, and format" ] # [ doc = "@param center  SkIRect edge of image corners and sides" ] # [ doc = "@param dst     destination SkRect of image to draw to" ] # [ doc = "@param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawImageNineEPK7SkImageRK7SkIRectRK6SkRectPK7SkPaint" ] pub fn SkCanvas_drawImageNine ( this : * mut SkCanvas , image : * const SkImage , center : * const SkIRect , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkImage image stretched proportionally to fit into SkRect dst." ] # [ doc = "SkIRect center divides the image into nine sections: four sides, four corners, and" ] # [ doc = "the center. Corners are not scaled, or scaled down proportionately if their sides" ] # [ doc = "are larger than dst; center and four sides are scaled to fit remaining space, if any." ] # [ doc = "" ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds. If paint" ] # [ doc = "SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all" ] # [ doc = "other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels." ] # [ doc = "Any SkMaskFilter on paint is ignored as is paint anti-aliasing state." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond image bounds, replicate image edge colors, just" ] # [ doc = "as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set" ] # [ doc = "replicates the image edge color when it samples outside of its bounds." ] # [ doc = "" ] # [ doc = "@param image   SkImage containing pixels, dimensions, and format" ] # [ doc = "@param center  SkIRect edge of image corners and sides" ] # [ doc = "@param dst     destination SkRect of image to draw to" ] # [ doc = "@param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas13drawImageNineERK5sk_spI7SkImageERK7SkIRectRK6SkRectPK7SkPaint" ] pub fn SkCanvas_drawImageNine1 ( this : * mut SkCanvas , image : * const sk_sp < SkImage > , center : * const SkIRect , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkBitmap bitmap, with its top-left corner at (left, top)," ] # [ doc = "using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is not nullptr, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from bitmap bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond bitmap bounds, replicate bitmap edge colors," ] # [ doc = "just as SkShader made from SkShader::MakeBitmapShader with" ] # [ doc = "SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples" ] # [ doc = "outside of its bounds." ] # [ doc = "" ] # [ doc = "@param bitmap  SkBitmap containing pixels, dimensions, and format" ] # [ doc = "@param left    left side of bitmap" ] # [ doc = "@param top     top side of bitmap" ] # [ doc = "@param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas10drawBitmapERK8SkBitmapffPK7SkPaint" ] pub fn SkCanvas_drawBitmap ( this : * mut SkCanvas , bitmap : * const SkBitmap , left : SkScalar , top : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkRect src of SkBitmap bitmap, scaled and translated to fill SkRect dst." ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from bitmap bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond bitmap bounds, replicate bitmap edge colors," ] # [ doc = "just as SkShader made from SkShader::MakeBitmapShader with" ] # [ doc = "SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples" ] # [ doc = "outside of its bounds." ] # [ doc = "" ] # [ doc = "constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to" ] # [ doc = "sample within src; set to kFast_SrcRectConstraint allows sampling outside to" ] # [ doc = "improve performance." ] # [ doc = "" ] # [ doc = "@param bitmap      SkBitmap containing pixels, dimensions, and format" ] # [ doc = "@param src         source SkRect of image to draw from" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ doc = "@param constraint  filter strictly within src or draw faster" ] # [ link_name = "\u{1}__ZN8SkCanvas14drawBitmapRectERK8SkBitmapRK6SkRectS5_PK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_drawBitmapRect ( this : * mut SkCanvas , bitmap : * const SkBitmap , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ doc = " Draws SkIRect isrc of SkBitmap bitmap, scaled and translated to fill SkRect dst." ] # [ doc = "isrc is on integer pixel boundaries; dst may include fractional boundaries." ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from bitmap bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond bitmap bounds, replicate bitmap edge colors," ] # [ doc = "just as SkShader made from SkShader::MakeBitmapShader with" ] # [ doc = "SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples" ] # [ doc = "outside of its bounds." ] # [ doc = "" ] # [ doc = "constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to" ] # [ doc = "sample within isrc; set to kFast_SrcRectConstraint allows sampling outside to" ] # [ doc = "improve performance." ] # [ doc = "" ] # [ doc = "@param bitmap      SkBitmap containing pixels, dimensions, and format" ] # [ doc = "@param isrc        source SkIRect of image to draw from" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ doc = "@param constraint  sample strictly within isrc, or draw faster" ] # [ link_name = "\u{1}__ZN8SkCanvas14drawBitmapRectERK8SkBitmapRK7SkIRectRK6SkRectPK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_drawBitmapRect1 ( this : * mut SkCanvas , bitmap : * const SkBitmap , isrc : * const SkIRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ doc = " Draws SkBitmap bitmap, scaled and translated to fill SkRect dst." ] # [ doc = "bitmap bounds is on integer pixel boundaries; dst may include fractional boundaries." ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from bitmap bounds." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond bitmap bounds, replicate bitmap edge colors," ] # [ doc = "just as SkShader made from SkShader::MakeBitmapShader with" ] # [ doc = "SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples" ] # [ doc = "outside of its bounds." ] # [ doc = "" ] # [ doc = "constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to" ] # [ doc = "sample within bitmap; set to kFast_SrcRectConstraint allows sampling outside to" ] # [ doc = "improve performance." ] # [ doc = "" ] # [ doc = "@param bitmap      SkBitmap containing pixels, dimensions, and format" ] # [ doc = "@param dst         destination SkRect of image to draw to" ] # [ doc = "@param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ doc = "@param constraint  filter strictly within bitmap or draw faster" ] # [ link_name = "\u{1}__ZN8SkCanvas14drawBitmapRectERK8SkBitmapRK6SkRectPK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_drawBitmapRect2 ( this : * mut SkCanvas , bitmap : * const SkBitmap , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ doc = " Draws SkBitmap bitmap stretched proportionally to fit into SkRect dst." ] # [ doc = "SkIRect center divides the bitmap into nine sections: four sides, four corners," ] # [ doc = "and the center. Corners are not scaled, or scaled down proportionately if their" ] # [ doc = "sides are larger than dst; center and four sides are scaled to fit remaining" ] # [ doc = "space, if any." ] # [ doc = "" ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from bitmap bounds. If paint" ] # [ doc = "SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all" ] # [ doc = "other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels." ] # [ doc = "Any SkMaskFilter on paint is ignored as is paint anti-aliasing state." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond bitmap bounds, replicate bitmap edge colors," ] # [ doc = "just as SkShader made from SkShader::MakeBitmapShader with" ] # [ doc = "SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples" ] # [ doc = "outside of its bounds." ] # [ doc = "" ] # [ doc = "@param bitmap  SkBitmap containing pixels, dimensions, and format" ] # [ doc = "@param center  SkIRect edge of image corners and sides" ] # [ doc = "@param dst     destination SkRect of image to draw to" ] # [ doc = "@param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas14drawBitmapNineERK8SkBitmapRK7SkIRectRK6SkRectPK7SkPaint" ] pub fn SkCanvas_drawBitmapNine ( this : * mut SkCanvas , bitmap : * const SkBitmap , center : * const SkIRect , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkBitmap bitmap stretched proportionally to fit into SkRect dst." ] # [ doc = "" ] # [ doc = "SkCanvas::Lattice lattice divides bitmap into a rectangular grid." ] # [ doc = "Each intersection of an even-numbered row and column is fixed; like the corners" ] # [ doc = "of drawBitmapNine(), fixed lattice elements never scale larger than their initial" ] # [ doc = "size and shrink proportionately when all fixed elements exceed the bitmap" ] # [ doc = "dimension. All other grid elements scale to fill the available space, if any." ] # [ doc = "" ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from bitmap bounds. If paint" ] # [ doc = "SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all" ] # [ doc = "other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels." ] # [ doc = "Any SkMaskFilter on paint is ignored as is paint anti-aliasing state." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond bitmap bounds, replicate bitmap edge colors," ] # [ doc = "just as SkShader made from SkShader::MakeBitmapShader with" ] # [ doc = "SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples" ] # [ doc = "outside of its bounds." ] # [ doc = "" ] # [ doc = "@param bitmap   SkBitmap containing pixels, dimensions, and format" ] # [ doc = "@param lattice  division of bitmap into fixed and variable rectangles" ] # [ doc = "@param dst      destination SkRect of image to draw to" ] # [ doc = "@param paint    SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas17drawBitmapLatticeERK8SkBitmapRKNS_7LatticeERK6SkRectPK7SkPaint" ] pub fn SkCanvas_drawBitmapLattice ( this : * mut SkCanvas , bitmap : * const SkBitmap , lattice : * const SkCanvas_Lattice , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkImage image stretched proportionally to fit into SkRect dst." ] # [ doc = "" ] # [ doc = "SkCanvas::Lattice lattice divides image into a rectangular grid." ] # [ doc = "Each intersection of an even-numbered row and column is fixed; like the corners" ] # [ doc = "of drawBitmapNine(), fixed lattice elements never scale larger than their initial" ] # [ doc = "size and shrink proportionately when all fixed elements exceed the bitmap" ] # [ doc = "dimension. All other grid elements scale to fill the available space, if any." ] # [ doc = "" ] # [ doc = "Additionally transform draw using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "" ] # [ doc = "If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader." ] # [ doc = "If paint contains SkMaskFilter, generate mask from image bounds. If paint" ] # [ doc = "SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all" ] # [ doc = "other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels." ] # [ doc = "Any SkMaskFilter on paint is ignored as is paint anti-aliasing state." ] # [ doc = "" ] # [ doc = "If generated mask extends beyond bitmap bounds, replicate bitmap edge colors," ] # [ doc = "just as SkShader made from SkShader::MakeBitmapShader with" ] # [ doc = "SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples" ] # [ doc = "outside of its bounds." ] # [ doc = "" ] # [ doc = "@param image    SkImage containing pixels, dimensions, and format" ] # [ doc = "@param lattice  division of bitmap into fixed and variable rectangles" ] # [ doc = "@param dst      destination SkRect of image to draw to" ] # [ doc = "@param paint    SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas16drawImageLatticeEPK7SkImageRKNS_7LatticeERK6SkRectPK7SkPaint" ] pub fn SkCanvas_drawImageLattice ( this : * mut SkCanvas , image : * const SkImage , lattice : * const SkCanvas_Lattice , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " This is an experimental API for the SkiaRenderer Chromium project. The signature will" ] # [ doc = " surely evolve if this is not removed. It currently offers no performance advantage over" ] # [ doc = " drawing images independently, though may in the future. The antialiasing flags are intended" ] # [ doc = " to allow control over each edge\'s AA status, to allow perfect seaming for tile sets. The" ] # [ doc = " current implementation only antialiases if all edges are flagged, however." ] # [ doc = " Results are undefined if an image\'s src rect is not within the image\'s bounds." ] # [ link_name = "\u{1}__ZN8SkCanvas27experimental_DrawImageSetV1EPKNS_13ImageSetEntryEi15SkFilterQuality11SkBlendMode" ] pub fn SkCanvas_experimental_DrawImageSetV1 ( this : * mut SkCanvas , imageSet : * const SkCanvas_ImageSetEntry , cnt : :: std :: os :: raw :: c_int , quality : SkFilterQuality , mode : SkBlendMode ) ; } extern "C" { # [ doc = " This is an experimental API for the SkiaRenderer Chromium project. The signature will" ] # [ doc = " surely evolve if this is not removed. The antialiasing flags are intended to allow control" ] # [ doc = " over each edge\'s AA status, to allow perfect seaming for tile sets." ] # [ doc = "" ] # [ doc = " When not fully supported, the implementation only antialiases if all edges are flagged." ] # [ link_name = "\u{1}__ZN8SkCanvas29experimental_DrawEdgeAARectV1ERK6SkRectNS_11QuadAAFlagsEj11SkBlendMode" ] pub fn SkCanvas_experimental_DrawEdgeAARectV1 ( this : * mut SkCanvas , r : * const SkRect , edgeAA : SkCanvas_QuadAAFlags , color : SkColor , mode : SkBlendMode ) ; } extern "C" { # [ doc = " Draws text, with origin at (x, y), using clip, SkMatrix, SkFont font," ] # [ doc = "and SkPaint paint." ] # [ doc = "" ] # [ doc = "When encoding is SkTextEncoding::kUTF8, SkTextEncoding::kUTF16, or" ] # [ doc = "SkTextEncoding::kUTF32, this function uses the default" ] # [ doc = "character-to-glyph mapping from the SkTypeface in font.  It does not" ] # [ doc = "perform typeface fallback for characters not found in the SkTypeface." ] # [ doc = "It does not perform kerning or other complex shaping; glyphs are" ] # [ doc = "positioned based on their default advances." ] # [ doc = "" ] # [ doc = "Text meaning depends on SkTextEncoding." ] # [ doc = "" ] # [ doc = "Text size is affected by SkMatrix and SkFont text size. Default text" ] # [ doc = "size is 12 point." ] # [ doc = "" ] # [ doc = "All elements of paint: SkPathEffect, SkMaskFilter, SkShader," ] # [ doc = "SkColorFilter, SkImageFilter, and SkDrawLooper; apply to text. By" ] # [ doc = "default, draws filled black glyphs." ] # [ doc = "" ] # [ doc = "@param text        character code points or glyphs drawn" ] # [ doc = "@param byteLength  byte length of text array" ] # [ doc = "@param encoding    text encoding used in the text array" ] # [ doc = "@param x           start of text on x-axis" ] # [ doc = "@param y           start of text on y-axis" ] # [ doc = "@param font        typeface, text size and so, used to describe the text" ] # [ doc = "@param paint       blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas14drawSimpleTextEPKvm14SkTextEncodingffRK6SkFontRK7SkPaint" ] pub fn SkCanvas_drawSimpleText ( this : * mut SkCanvas , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding , x : SkScalar , y : SkScalar , font : * const SkFont , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Experimental." ] # [ doc = "" ] # [ doc = "Draws null terminated string, with origin at (x, y), using clip, SkMatrix," ] # [ doc = "SkFont font, and SkPaint paint." ] # [ doc = "" ] # [ doc = "This function uses the default character-to-glyph mapping from the" ] # [ doc = "SkTypeface in font.  It does not perform typeface fallback for" ] # [ doc = "characters not found in the SkTypeface.  It does not perform kerning;" ] # [ doc = "glyphs are positioned based on their default advances." ] # [ doc = "" ] # [ doc = "String str is encoded as UTF-8." ] # [ doc = "" ] # [ doc = "Text size is affected by SkMatrix and font text size. Default text" ] # [ doc = "size is 12 point." ] # [ doc = "" ] # [ doc = "All elements of paint: SkPathEffect, SkMaskFilter, SkShader," ] # [ doc = "SkColorFilter, SkImageFilter, and SkDrawLooper; apply to text. By" ] # [ doc = "default, draws filled black glyphs." ] # [ doc = "" ] # [ doc = "@param str     character code points drawn," ] # [ doc = "ending with a char value of zero" ] # [ doc = "@param x       start of string on x-axis" ] # [ doc = "@param y       start of string on y-axis" ] # [ doc = "@param font    typeface, text size and so, used to describe the text" ] # [ doc = "@param paint   blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas10drawStringEPKcffRK6SkFontRK7SkPaint" ] pub fn SkCanvas_drawString ( this : * mut SkCanvas , str : * const :: std :: os :: raw :: c_char , x : SkScalar , y : SkScalar , font : * const SkFont , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Experimental." ] # [ doc = "" ] # [ doc = "Draws SkString, with origin at (x, y), using clip, SkMatrix, SkFont font," ] # [ doc = "and SkPaint paint." ] # [ doc = "" ] # [ doc = "This function uses the default character-to-glyph mapping from the" ] # [ doc = "SkTypeface in font.  It does not perform typeface fallback for" ] # [ doc = "characters not found in the SkTypeface.  It does not perform kerning;" ] # [ doc = "glyphs are positioned based on their default advances." ] # [ doc = "" ] # [ doc = "SkString str is encoded as UTF-8." ] # [ doc = "" ] # [ doc = "Text size is affected by SkMatrix and SkFont text size. Default text" ] # [ doc = "size is 12 point." ] # [ doc = "" ] # [ doc = "All elements of paint: SkPathEffect, SkMaskFilter, SkShader," ] # [ doc = "SkColorFilter, SkImageFilter, and SkDrawLooper; apply to text. By" ] # [ doc = "default, draws filled black glyphs." ] # [ doc = "" ] # [ doc = "@param str     character code points drawn," ] # [ doc = "ending with a char value of zero" ] # [ doc = "@param x       start of string on x-axis" ] # [ doc = "@param y       start of string on y-axis" ] # [ doc = "@param font    typeface, text size and so, used to describe the text" ] # [ doc = "@param paint   blend, color, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas10drawStringERK8SkStringffRK6SkFontRK7SkPaint" ] pub fn SkCanvas_drawString1 ( this : * mut SkCanvas , str : * const SkString , x : SkScalar , y : SkScalar , font : * const SkFont , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkTextBlob blob at (x, y), using clip, SkMatrix, and SkPaint paint." ] # [ doc = "" ] # [ doc = "blob contains glyphs, their positions, and paint attributes specific to text:" ] # [ doc = "SkTypeface, SkPaint text size, SkPaint text scale x," ] # [ doc = "SkPaint text skew x, SkPaint::Align, SkPaint::Hinting, anti-alias, SkPaint fake bold," ] # [ doc = "SkPaint font embedded bitmaps, SkPaint full hinting spacing, LCD text, SkPaint linear text," ] # [ doc = "and SkPaint subpixel text." ] # [ doc = "" ] # [ doc = "SkTextEncoding must be set to kGlyphID_SkTextEncoding." ] # [ doc = "" ] # [ doc = "Elements of paint: anti-alias, SkBlendMode, color including alpha," ] # [ doc = "SkColorFilter, SkPaint dither, SkDrawLooper, SkMaskFilter, SkPathEffect, SkShader, and" ] # [ doc = "SkPaint::Style; apply to blob. If SkPaint contains SkPaint::kStroke_Style:" ] # [ doc = "SkPaint miter limit, SkPaint::Cap, SkPaint::Join, and SkPaint stroke width;" ] # [ doc = "apply to SkPath created from blob." ] # [ doc = "" ] # [ doc = "@param blob   glyphs, positions, and their paints\' text size, typeface, and so on" ] # [ doc = "@param x      horizontal offset applied to blob" ] # [ doc = "@param y      vertical offset applied to blob" ] # [ doc = "@param paint  blend, color, stroking, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas12drawTextBlobEPK10SkTextBlobffRK7SkPaint" ] pub fn SkCanvas_drawTextBlob ( this : * mut SkCanvas , blob : * const SkTextBlob , x : SkScalar , y : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkTextBlob blob at (x, y), using clip, SkMatrix, and SkPaint paint." ] # [ doc = "" ] # [ doc = "blob contains glyphs, their positions, and paint attributes specific to text:" ] # [ doc = "SkTypeface, SkPaint text size, SkPaint text scale x," ] # [ doc = "SkPaint text skew x, SkPaint::Align, SkPaint::Hinting, anti-alias, SkPaint fake bold," ] # [ doc = "SkPaint font embedded bitmaps, SkPaint full hinting spacing, LCD text, SkPaint linear text," ] # [ doc = "and SkPaint subpixel text." ] # [ doc = "" ] # [ doc = "SkTextEncoding must be set to kGlyphID_SkTextEncoding." ] # [ doc = "" ] # [ doc = "Elements of paint: SkPathEffect, SkMaskFilter, SkShader, SkColorFilter," ] # [ doc = "SkImageFilter, and SkDrawLooper; apply to blob." ] # [ doc = "" ] # [ doc = "@param blob   glyphs, positions, and their paints\' text size, typeface, and so on" ] # [ doc = "@param x      horizontal offset applied to blob" ] # [ doc = "@param y      vertical offset applied to blob" ] # [ doc = "@param paint  blend, color, stroking, and so on, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas12drawTextBlobERK5sk_spI10SkTextBlobEffRK7SkPaint" ] pub fn SkCanvas_drawTextBlob1 ( this : * mut SkCanvas , blob : * const sk_sp < SkTextBlob > , x : SkScalar , y : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkPicture picture, using clip and SkMatrix." ] # [ doc = "Clip and SkMatrix are unchanged by picture contents, as if" ] # [ doc = "save() was called before and restore() was called after drawPicture()." ] # [ doc = "" ] # [ doc = "SkPicture records a series of draw commands for later playback." ] # [ doc = "" ] # [ doc = "@param picture  recorded drawing commands to play" ] # [ link_name = "\u{1}__ZN8SkCanvas11drawPictureEPK9SkPicture" ] pub fn SkCanvas_drawPicture ( this : * mut SkCanvas , picture : * const SkPicture ) ; } extern "C" { # [ doc = " Draws SkPicture picture, using clip and SkMatrix." ] # [ doc = "Clip and SkMatrix are unchanged by picture contents, as if" ] # [ doc = "save() was called before and restore() was called after drawPicture()." ] # [ doc = "" ] # [ doc = "SkPicture records a series of draw commands for later playback." ] # [ doc = "" ] # [ doc = "@param picture  recorded drawing commands to play" ] # [ link_name = "\u{1}__ZN8SkCanvas11drawPictureERK5sk_spI9SkPictureE" ] pub fn SkCanvas_drawPicture1 ( this : * mut SkCanvas , picture : * const sk_sp < SkPicture > ) ; } extern "C" { # [ doc = " Draws SkPicture picture, using clip and SkMatrix; transforming picture with" ] # [ doc = "SkMatrix matrix, if provided; and use SkPaint paint alpha, SkColorFilter," ] # [ doc = "SkImageFilter, and SkBlendMode, if provided." ] # [ doc = "" ] # [ doc = "matrix transformation is equivalent to: save(), concat(), drawPicture(), restore()." ] # [ doc = "paint use is equivalent to: saveLayer(), drawPicture(), restore()." ] # [ doc = "" ] # [ doc = "@param picture  recorded drawing commands to play" ] # [ doc = "@param matrix   SkMatrix to rotate, scale, translate, and so on; may be nullptr" ] # [ doc = "@param paint    SkPaint to apply transparency, filtering, and so on; may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas11drawPictureEPK9SkPicturePK8SkMatrixPK7SkPaint" ] pub fn SkCanvas_drawPicture2 ( this : * mut SkCanvas , picture : * const SkPicture , matrix : * const SkMatrix , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkPicture picture, using clip and SkMatrix; transforming picture with" ] # [ doc = "SkMatrix matrix, if provided; and use SkPaint paint alpha, SkColorFilter," ] # [ doc = "SkImageFilter, and SkBlendMode, if provided." ] # [ doc = "" ] # [ doc = "matrix transformation is equivalent to: save(), concat(), drawPicture(), restore()." ] # [ doc = "paint use is equivalent to: saveLayer(), drawPicture(), restore()." ] # [ doc = "" ] # [ doc = "@param picture  recorded drawing commands to play" ] # [ doc = "@param matrix   SkMatrix to rotate, scale, translate, and so on; may be nullptr" ] # [ doc = "@param paint    SkPaint to apply transparency, filtering, and so on; may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas11drawPictureERK5sk_spI9SkPictureEPK8SkMatrixPK7SkPaint" ] pub fn SkCanvas_drawPicture3 ( this : * mut SkCanvas , picture : * const sk_sp < SkPicture > , matrix : * const SkMatrix , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix." ] # [ doc = "If vertices texs and vertices colors are defined in vertices, and SkPaint paint" ] # [ doc = "contains SkShader, SkBlendMode mode combines vertices colors with SkShader." ] # [ doc = "" ] # [ doc = "@param vertices  triangle mesh to draw" ] # [ doc = "@param mode      combines vertices colors with SkShader, if both are present" ] # [ doc = "@param paint     specifies the SkShader, used as SkVertices texture; may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas12drawVerticesEPK10SkVertices11SkBlendModeRK7SkPaint" ] pub fn SkCanvas_drawVertices ( this : * mut SkCanvas , vertices : * const SkVertices , mode : SkBlendMode , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix." ] # [ doc = "If vertices texs and vertices colors are defined in vertices, and SkPaint paint" ] # [ doc = "contains SkShader, SkBlendMode mode combines vertices colors with SkShader." ] # [ doc = "" ] # [ doc = "@param vertices  triangle mesh to draw" ] # [ doc = "@param mode      combines vertices colors with SkShader, if both are present" ] # [ doc = "@param paint     specifies the SkShader, used as SkVertices texture, may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas12drawVerticesERK5sk_spI10SkVerticesE11SkBlendModeRK7SkPaint" ] pub fn SkCanvas_drawVertices1 ( this : * mut SkCanvas , vertices : * const sk_sp < SkVertices > , mode : SkBlendMode , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix. Bone data is used to" ] # [ doc = "deform vertices with bone weights." ] # [ doc = "If vertices texs and vertices colors are defined in vertices, and SkPaint paint" ] # [ doc = "contains SkShader, SkBlendMode mode combines vertices colors with SkShader." ] # [ doc = "The first element of bones should be an object to world space transformation matrix that" ] # [ doc = "will be applied before performing mesh deformations. If no such transformation is needed," ] # [ doc = "it should be the identity matrix." ] # [ doc = "boneCount must be at most 80, and thus the size of bones should be at most 80." ] # [ doc = "" ] # [ doc = "@param vertices   triangle mesh to draw" ] # [ doc = "@param bones      bone matrix data" ] # [ doc = "@param boneCount  number of bone matrices" ] # [ doc = "@param mode       combines vertices colors with SkShader, if both are present" ] # [ doc = "@param paint      specifies the SkShader, used as SkVertices texture, may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas12drawVerticesEPK10SkVerticesPKNS0_4BoneEi11SkBlendModeRK7SkPaint" ] pub fn SkCanvas_drawVertices2 ( this : * mut SkCanvas , vertices : * const SkVertices , bones : * const SkVertices_Bone , boneCount : :: std :: os :: raw :: c_int , mode : SkBlendMode , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix. Bone data is used to" ] # [ doc = "deform vertices with bone weights." ] # [ doc = "If vertices texs and vertices colors are defined in vertices, and SkPaint paint" ] # [ doc = "contains SkShader, SkBlendMode mode combines vertices colors with SkShader." ] # [ doc = "The first element of bones should be an object to world space transformation matrix that" ] # [ doc = "will be applied before performing mesh deformations. If no such transformation is needed," ] # [ doc = "it should be the identity matrix." ] # [ doc = "boneCount must be at most 80, and thus the size of bones should be at most 80." ] # [ doc = "" ] # [ doc = "@param vertices   triangle mesh to draw" ] # [ doc = "@param bones      bone matrix data" ] # [ doc = "@param boneCount  number of bone matrices" ] # [ doc = "@param mode       combines vertices colors with SkShader, if both are present" ] # [ doc = "@param paint      specifies the SkShader, used as SkVertices texture, may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas12drawVerticesERK5sk_spI10SkVerticesEPKNS1_4BoneEi11SkBlendModeRK7SkPaint" ] pub fn SkCanvas_drawVertices3 ( this : * mut SkCanvas , vertices : * const sk_sp < SkVertices > , bones : * const SkVertices_Bone , boneCount : :: std :: os :: raw :: c_int , mode : SkBlendMode , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws a Coons patch: the interpolation of four cubics with shared corners," ] # [ doc = "associating a color, and optionally a texture SkPoint, with each corner." ] # [ doc = "" ] # [ doc = "Coons patch uses clip and SkMatrix, paint SkShader, SkColorFilter," ] # [ doc = "alpha, SkImageFilter, and SkBlendMode. If SkShader is provided it is treated" ] # [ doc = "as Coons patch texture; SkBlendMode mode combines color colors and SkShader if" ] # [ doc = "both are provided." ] # [ doc = "" ] # [ doc = "SkPoint array cubics specifies four SkPath cubic starting at the top-left corner," ] # [ doc = "in clockwise order, sharing every fourth point. The last SkPath cubic ends at the" ] # [ doc = "first point." ] # [ doc = "" ] # [ doc = "Color array color associates colors with corners in top-left, top-right," ] # [ doc = "bottom-right, bottom-left order." ] # [ doc = "" ] # [ doc = "If paint contains SkShader, SkPoint array texCoords maps SkShader as texture to" ] # [ doc = "corners in top-left, top-right, bottom-right, bottom-left order." ] # [ doc = "" ] # [ doc = "@param cubics     SkPath cubic array, sharing common points" ] # [ doc = "@param colors     color array, one for each corner" ] # [ doc = "@param texCoords  SkPoint array of texture coordinates, mapping SkShader to corners;" ] # [ doc = "may be nullptr" ] # [ doc = "@param mode       SkBlendMode for colors, and for SkShader if paint has one" ] # [ doc = "@param paint      SkShader, SkColorFilter, SkBlendMode, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawPatchEPK7SkPointPKjS2_11SkBlendModeRK7SkPaint" ] pub fn SkCanvas_drawPatch ( this : * mut SkCanvas , cubics : * const SkPoint , colors : * const SkColor , texCoords : * const SkPoint , mode : SkBlendMode , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkPath cubic Coons patch: the interpolation of four cubics with shared corners," ] # [ doc = "associating a color, and optionally a texture SkPoint, with each corner." ] # [ doc = "" ] # [ doc = "Coons patch uses clip and SkMatrix, paint SkShader, SkColorFilter," ] # [ doc = "alpha, SkImageFilter, and SkBlendMode. If SkShader is provided it is treated" ] # [ doc = "as Coons patch texture; SkBlendMode mode combines color colors and SkShader if" ] # [ doc = "both are provided." ] # [ doc = "" ] # [ doc = "SkPoint array cubics specifies four SkPath cubic starting at the top-left corner," ] # [ doc = "in clockwise order, sharing every fourth point. The last SkPath cubic ends at the" ] # [ doc = "first point." ] # [ doc = "" ] # [ doc = "Color array color associates colors with corners in top-left, top-right," ] # [ doc = "bottom-right, bottom-left order." ] # [ doc = "" ] # [ doc = "If paint contains SkShader, SkPoint array texCoords maps SkShader as texture to" ] # [ doc = "corners in top-left, top-right, bottom-right, bottom-left order." ] # [ doc = "" ] # [ doc = "@param cubics     SkPath cubic array, sharing common points" ] # [ doc = "@param colors     color array, one for each corner" ] # [ doc = "@param texCoords  SkPoint array of texture coordinates, mapping SkShader to corners;" ] # [ doc = "may be nullptr" ] # [ doc = "@param paint      SkShader, SkColorFilter, SkBlendMode, used to draw" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawPatchEPK7SkPointPKjS2_RK7SkPaint" ] pub fn SkCanvas_drawPatch1 ( this : * mut SkCanvas , cubics : * const SkPoint , colors : * const SkColor , texCoords : * const SkPoint , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws a set of sprites from atlas, using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "paint uses anti-alias, alpha, SkColorFilter, SkImageFilter, and SkBlendMode" ] # [ doc = "to draw, if present. For each entry in the array, SkRect tex locates sprite in" ] # [ doc = "atlas, and SkRSXform xform transforms it into destination space." ] # [ doc = "" ] # [ doc = "xform, text, and colors if present, must contain count entries." ] # [ doc = "Optional colors are applied for each sprite using SkBlendMode mode, treating" ] # [ doc = "sprite as source and colors as destination." ] # [ doc = "Optional cullRect is a conservative bounds of all transformed sprites." ] # [ doc = "If cullRect is outside of clip, canvas can skip drawing." ] # [ doc = "" ] # [ doc = "@param atlas     SkImage containing sprites" ] # [ doc = "@param xform     SkRSXform mappings for sprites in atlas" ] # [ doc = "@param tex       SkRect locations of sprites in atlas" ] # [ doc = "@param colors    one per sprite, blended with sprite using SkBlendMode; may be nullptr" ] # [ doc = "@param count     number of sprites to draw" ] # [ doc = "@param mode      SkBlendMode combining colors and sprites" ] # [ doc = "@param cullRect  bounds of transformed sprites for efficient clipping; may be nullptr" ] # [ doc = "@param paint     SkColorFilter, SkImageFilter, SkBlendMode, and so on; may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawAtlasEPK7SkImagePK9SkRSXformPK6SkRectPKji11SkBlendModeS8_PK7SkPaint" ] pub fn SkCanvas_drawAtlas ( this : * mut SkCanvas , atlas : * const SkImage , xform : * const SkRSXform , tex : * const SkRect , colors : * const SkColor , count : :: std :: os :: raw :: c_int , mode : SkBlendMode , cullRect : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws a set of sprites from atlas, using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "paint uses anti-alias, alpha, SkColorFilter, SkImageFilter, and SkBlendMode" ] # [ doc = "to draw, if present. For each entry in the array, SkRect tex locates sprite in" ] # [ doc = "atlas, and SkRSXform xform transforms it into destination space." ] # [ doc = "" ] # [ doc = "xform, text, and colors if present, must contain count entries." ] # [ doc = "Optional colors is applied for each sprite using SkBlendMode." ] # [ doc = "Optional cullRect is a conservative bounds of all transformed sprites." ] # [ doc = "If cullRect is outside of clip, canvas can skip drawing." ] # [ doc = "" ] # [ doc = "@param atlas     SkImage containing sprites" ] # [ doc = "@param xform     SkRSXform mappings for sprites in atlas" ] # [ doc = "@param tex       SkRect locations of sprites in atlas" ] # [ doc = "@param colors    one per sprite, blended with sprite using SkBlendMode; may be nullptr" ] # [ doc = "@param count     number of sprites to draw" ] # [ doc = "@param mode      SkBlendMode combining colors and sprites" ] # [ doc = "@param cullRect  bounds of transformed sprites for efficient clipping; may be nullptr" ] # [ doc = "@param paint     SkColorFilter, SkImageFilter, SkBlendMode, and so on; may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawAtlasERK5sk_spI7SkImageEPK9SkRSXformPK6SkRectPKji11SkBlendModeSA_PK7SkPaint" ] pub fn SkCanvas_drawAtlas1 ( this : * mut SkCanvas , atlas : * const sk_sp < SkImage > , xform : * const SkRSXform , tex : * const SkRect , colors : * const SkColor , count : :: std :: os :: raw :: c_int , mode : SkBlendMode , cullRect : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws a set of sprites from atlas, using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "paint uses anti-alias, alpha, SkColorFilter, SkImageFilter, and SkBlendMode" ] # [ doc = "to draw, if present. For each entry in the array, SkRect tex locates sprite in" ] # [ doc = "atlas, and SkRSXform xform transforms it into destination space." ] # [ doc = "" ] # [ doc = "xform and text must contain count entries." ] # [ doc = "Optional cullRect is a conservative bounds of all transformed sprites." ] # [ doc = "If cullRect is outside of clip, canvas can skip drawing." ] # [ doc = "" ] # [ doc = "@param atlas     SkImage containing sprites" ] # [ doc = "@param xform     SkRSXform mappings for sprites in atlas" ] # [ doc = "@param tex       SkRect locations of sprites in atlas" ] # [ doc = "@param count     number of sprites to draw" ] # [ doc = "@param cullRect  bounds of transformed sprites for efficient clipping; may be nullptr" ] # [ doc = "@param paint     SkColorFilter, SkImageFilter, SkBlendMode, and so on; may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawAtlasEPK7SkImagePK9SkRSXformPK6SkRectiS8_PK7SkPaint" ] pub fn SkCanvas_drawAtlas2 ( this : * mut SkCanvas , atlas : * const SkImage , xform : * const SkRSXform , tex : * const SkRect , count : :: std :: os :: raw :: c_int , cullRect : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws a set of sprites from atlas, using clip, SkMatrix, and optional SkPaint paint." ] # [ doc = "paint uses anti-alias, alpha, SkColorFilter, SkImageFilter, and SkBlendMode" ] # [ doc = "to draw, if present. For each entry in the array, SkRect tex locates sprite in" ] # [ doc = "atlas, and SkRSXform xform transforms it into destination space." ] # [ doc = "" ] # [ doc = "xform and text must contain count entries." ] # [ doc = "Optional cullRect is a conservative bounds of all transformed sprites." ] # [ doc = "If cullRect is outside of clip, canvas can skip drawing." ] # [ doc = "" ] # [ doc = "@param atlas     SkImage containing sprites" ] # [ doc = "@param xform     SkRSXform mappings for sprites in atlas" ] # [ doc = "@param tex       SkRect locations of sprites in atlas" ] # [ doc = "@param count     number of sprites to draw" ] # [ doc = "@param cullRect  bounds of transformed sprites for efficient clipping; may be nullptr" ] # [ doc = "@param paint     SkColorFilter, SkImageFilter, SkBlendMode, and so on; may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas9drawAtlasERK5sk_spI7SkImageEPK9SkRSXformPK6SkRectiSA_PK7SkPaint" ] pub fn SkCanvas_drawAtlas3 ( this : * mut SkCanvas , atlas : * const sk_sp < SkImage > , xform : * const SkRSXform , tex : * const SkRect , count : :: std :: os :: raw :: c_int , cullRect : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Draws SkDrawable drawable using clip and SkMatrix, concatenated with" ] # [ doc = "optional matrix." ] # [ doc = "" ] # [ doc = "If SkCanvas has an asynchronous implementation, as is the case" ] # [ doc = "when it is recording into SkPicture, then drawable will be referenced," ] # [ doc = "so that SkDrawable::draw() can be called when the operation is finalized. To force" ] # [ doc = "immediate drawing, call SkDrawable::draw() instead." ] # [ doc = "" ] # [ doc = "@param drawable  custom struct encapsulating drawing commands" ] # [ doc = "@param matrix    transformation applied to drawing; may be nullptr" ] # [ link_name = "\u{1}__ZN8SkCanvas12drawDrawableEP10SkDrawablePK8SkMatrix" ] pub fn SkCanvas_drawDrawable ( this : * mut SkCanvas , drawable : * mut SkDrawable , matrix : * const SkMatrix ) ; } extern "C" { # [ doc = " Draws SkDrawable drawable using clip and SkMatrix, offset by (x, y)." ] # [ doc = "" ] # [ doc = "If SkCanvas has an asynchronous implementation, as is the case" ] # [ doc = "when it is recording into SkPicture, then drawable will be referenced," ] # [ doc = "so that SkDrawable::draw() can be called when the operation is finalized. To force" ] # [ doc = "immediate drawing, call SkDrawable::draw() instead." ] # [ doc = "" ] # [ doc = "@param drawable  custom struct encapsulating drawing commands" ] # [ doc = "@param x         offset into SkCanvas writable pixels on x-axis" ] # [ doc = "@param y         offset into SkCanvas writable pixels on y-axis" ] # [ link_name = "\u{1}__ZN8SkCanvas12drawDrawableEP10SkDrawableff" ] pub fn SkCanvas_drawDrawable1 ( this : * mut SkCanvas , drawable : * mut SkDrawable , x : SkScalar , y : SkScalar ) ; } extern "C" { # [ doc = " Associates SkRect on SkCanvas with an annotation; a key-value pair, where the key is" ] # [ doc = "a null-terminated UTF-8 string, and optional value is stored as SkData." ] # [ doc = "" ] # [ doc = "Only some canvas implementations, such as recording to SkPicture, or drawing to" ] # [ doc = "document PDF, use annotations." ] # [ doc = "" ] # [ doc = "@param rect   SkRect extent of canvas to annotate" ] # [ doc = "@param key    string used for lookup" ] # [ doc = "@param value  data holding value stored in annotation" ] # [ link_name = "\u{1}__ZN8SkCanvas14drawAnnotationERK6SkRectPKcP6SkData" ] pub fn SkCanvas_drawAnnotation ( this : * mut SkCanvas , rect : * const SkRect , key : * const :: std :: os :: raw :: c_char , value : * mut SkData ) ; } extern "C" { # [ doc = " Associates SkRect on SkCanvas when an annotation; a key-value pair, where the key is" ] # [ doc = "a null-terminated UTF-8 string, and optional value is stored as SkData." ] # [ doc = "" ] # [ doc = "Only some canvas implementations, such as recording to SkPicture, or drawing to" ] # [ doc = "document PDF, use annotations." ] # [ doc = "" ] # [ doc = "@param rect   SkRect extent of canvas to annotate" ] # [ doc = "@param key    string used for lookup" ] # [ doc = "@param value  data holding value stored in annotation" ] # [ link_name = "\u{1}__ZN8SkCanvas14drawAnnotationERK6SkRectPKcRK5sk_spI6SkDataE" ] pub fn SkCanvas_drawAnnotation1 ( this : * mut SkCanvas , rect : * const SkRect , key : * const :: std :: os :: raw :: c_char , value : * const sk_sp < SkData > ) ; } extern "C" { # [ doc = " Returns SkMatrix." ] # [ doc = "This does not account for translation by SkBaseDevice or SkSurface." ] # [ doc = "" ] # [ doc = "@return  SkMatrix in SkCanvas" ] # [ link_name = "\u{1}__ZNK8SkCanvas14getTotalMatrixEv" ] pub fn SkCanvas_getTotalMatrix ( this : * const SkCanvas ) -> * const SkMatrix ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas34internal_private_getTopLayerBoundsEv" ] pub fn SkCanvas_internal_private_getTopLayerBounds ( this : * const SkCanvas ) -> SkIRect ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas20legacy_drawImageRectEPK7SkImagePK6SkRectRS4_PK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_legacy_drawImageRect ( this : * mut SkCanvas , image : * const SkImage , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas21legacy_drawBitmapRectERK8SkBitmapPK6SkRectRS4_PK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_legacy_drawBitmapRect ( this : * mut SkCanvas , bitmap : * const SkBitmap , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ doc = "  Returns the global clip as a region. If the clip contains AA, then only the bounds" ] # [ doc = "  of the clip may be returned." ] # [ link_name = "\u{1}__ZN8SkCanvas29temporary_internal_getRgnClipEP8SkRegion" ] pub fn SkCanvas_temporary_internal_getRgnClip ( this : * mut SkCanvas , region : * mut SkRegion ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas23private_draw_shadow_recERK6SkPathRK15SkDrawShadowRec" ] pub fn SkCanvas_private_draw_shadow_rec ( this : * mut SkCanvas , arg1 : * const SkPath , arg2 : * const SkDrawShadowRec ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas14clipRectBoundsEPK6SkRectjP7SkIRectPK13SkImageFilter" ] pub fn SkCanvas_clipRectBounds ( this : * mut SkCanvas , bounds : * const SkRect , flags : SkCanvas_SaveLayerFlags , intersection : * mut SkIRect , imageFilter : * const SkImageFilter ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas12getTopDeviceEv" ] pub fn SkCanvas_getTopDevice ( this : * const SkCanvas ) -> * mut SkBaseDevice ; } extern "C" { # [ doc = " Creates an empty SkCanvas with no backing device or pixels, with" ] # [ doc = "a width and height of zero." ] # [ doc = "" ] # [ doc = "@return  empty SkCanvas" ] # [ link_name = "\u{1}__ZN8SkCanvasC1Ev" ] pub fn SkCanvas_SkCanvas ( this : * mut SkCanvas ) ; } extern "C" { # [ doc = " Creates SkCanvas of the specified dimensions without a SkSurface." ] # [ doc = "Used by subclasses with custom implementations for draw member functions." ] # [ doc = "" ] # [ doc = "If props equals nullptr, SkSurfaceProps are created with" ] # [ doc = "SkSurfaceProps::InitType settings, which choose the pixel striping" ] # [ doc = "direction and order. Since a platform may dynamically change its direction when" ] # [ doc = "the device is rotated, and since a platform may have multiple monitors with" ] # [ doc = "different characteristics, it is best not to rely on this legacy behavior." ] # [ doc = "" ] # [ doc = "@param width   zero or greater" ] # [ doc = "@param height  zero or greater" ] # [ doc = "@param props   LCD striping orientation and setting for device independent fonts;" ] # [ doc = "may be nullptr" ] # [ doc = "@return        SkCanvas placeholder with dimensions" ] # [ link_name = "\u{1}__ZN8SkCanvasC1EiiPK14SkSurfaceProps" ] pub fn SkCanvas_SkCanvas1 ( this : * mut SkCanvas , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , props : * const SkSurfaceProps ) ; } extern "C" { # [ doc = " Private. For internal use only." ] # [ link_name = "\u{1}__ZN8SkCanvasC1E5sk_spI12SkBaseDeviceE" ] pub fn SkCanvas_SkCanvas2 ( this : * mut SkCanvas , device : sk_sp < SkBaseDevice > ) ; } extern "C" { # [ doc = " Constructs a canvas that draws into bitmap." ] # [ doc = "Sets SkSurfaceProps::kLegacyFontHost_InitType in constructed SkSurface." ] # [ doc = "" ] # [ doc = "SkBitmap is copied so that subsequently editing bitmap will not affect" ] # [ doc = "constructed SkCanvas." ] # [ doc = "" ] # [ doc = "May be deprecated in the future." ] # [ doc = "" ] # [ doc = "@param bitmap  width, height, SkColorType, SkAlphaType, and pixel" ] # [ doc = "storage of raster surface" ] # [ doc = "@return        SkCanvas that can be used to draw into bitmap" ] # [ link_name = "\u{1}__ZN8SkCanvasC1ERK8SkBitmap" ] pub fn SkCanvas_SkCanvas3 ( this : * mut SkCanvas , bitmap : * const SkBitmap ) ; } extern "C" { # [ doc = " Constructs a canvas that draws into bitmap." ] # [ doc = "Use props to match the device characteristics, like LCD striping." ] # [ doc = "" ] # [ doc = "bitmap is copied so that subsequently editing bitmap will not affect" ] # [ doc = "constructed SkCanvas." ] # [ doc = "" ] # [ doc = "@param bitmap  width, height, SkColorType, SkAlphaType," ] # [ doc = "and pixel storage of raster surface" ] # [ doc = "@param props   order and orientation of RGB striping; and whether to use" ] # [ doc = "device independent fonts" ] # [ doc = "@return        SkCanvas that can be used to draw into bitmap" ] # [ link_name = "\u{1}__ZN8SkCanvasC1ERK8SkBitmapRK14SkSurfaceProps" ] pub fn SkCanvas_SkCanvas4 ( this : * mut SkCanvas , bitmap : * const SkBitmap , props : * const SkSurfaceProps ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvasC1ERK7SkIRect" ] pub fn SkCanvas_SkCanvas5 ( this : * mut SkCanvas , bounds : * const SkIRect ) ; } impl SkCanvas { # [ inline ] pub unsafe fn MakeRasterDirect ( info : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize , props : * const SkSurfaceProps ) -> std_unique_ptr { SkCanvas_MakeRasterDirect ( info , pixels , rowBytes , props ) } # [ inline ] pub unsafe fn MakeRasterDirectN32 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , pixels : * mut SkPMColor , rowBytes : usize ) -> std_unique_ptr { SkCanvas_MakeRasterDirectN32 ( width , height , pixels , rowBytes ) } # [ inline ] pub unsafe fn imageInfo ( & self ) -> SkImageInfo { SkCanvas_imageInfo ( self ) } # [ inline ] pub unsafe fn getProps ( & self , props : * mut SkSurfaceProps ) -> bool { SkCanvas_getProps ( self , props ) } # [ inline ] pub unsafe fn flush ( & mut self ) { SkCanvas_flush ( self ) } # [ inline ] pub unsafe fn makeSurface ( & mut self , info : * const SkImageInfo , props : * const SkSurfaceProps ) -> sk_sp < SkSurface > { SkCanvas_makeSurface ( self , info , props ) } # [ inline ] pub unsafe fn accessTopLayerPixels ( & mut self , info : * mut SkImageInfo , rowBytes : * mut usize , origin : * mut SkIPoint ) -> * mut :: std :: os :: raw :: c_void { SkCanvas_accessTopLayerPixels ( self , info , rowBytes , origin ) } # [ inline ] pub unsafe fn accessTopRasterHandle ( & self ) -> SkRasterHandleAllocator_Handle { SkCanvas_accessTopRasterHandle ( self ) } # [ inline ] pub unsafe fn peekPixels ( & mut self , pixmap : * mut SkPixmap ) -> bool { SkCanvas_peekPixels ( self , pixmap ) } # [ inline ] pub unsafe fn readPixels ( & mut self , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkCanvas_readPixels ( self , dstInfo , dstPixels , dstRowBytes , srcX , srcY ) } # [ inline ] pub unsafe fn readPixels1 ( & mut self , pixmap : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkCanvas_readPixels1 ( self , pixmap , srcX , srcY ) } # [ inline ] pub unsafe fn readPixels2 ( & mut self , bitmap : * const SkBitmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkCanvas_readPixels2 ( self , bitmap , srcX , srcY ) } # [ inline ] pub unsafe fn writePixels ( & mut self , info : * const SkImageInfo , pixels : * const :: std :: os :: raw :: c_void , rowBytes : usize , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> bool { SkCanvas_writePixels ( self , info , pixels , rowBytes , x , y ) } # [ inline ] pub unsafe fn writePixels1 ( & mut self , bitmap : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> bool { SkCanvas_writePixels1 ( self , bitmap , x , y ) } # [ inline ] pub unsafe fn save ( & mut self ) -> :: std :: os :: raw :: c_int { SkCanvas_save ( self ) } # [ inline ] pub unsafe fn saveLayer ( & mut self , bounds : * const SkRect , paint : * const SkPaint ) -> :: std :: os :: raw :: c_int { SkCanvas_saveLayer ( self , bounds , paint ) } # [ inline ] pub unsafe fn saveLayer1 ( & mut self , bounds : * const SkRect , paint : * const SkPaint ) -> :: std :: os :: raw :: c_int { SkCanvas_saveLayer1 ( self , bounds , paint ) } # [ inline ] pub unsafe fn saveLayerAlpha ( & mut self , bounds : * const SkRect , alpha : U8CPU ) -> :: std :: os :: raw :: c_int { SkCanvas_saveLayerAlpha ( self , bounds , alpha ) } # [ inline ] pub unsafe fn saveLayer2 ( & mut self , layerRec : * const SkCanvas_SaveLayerRec ) -> :: std :: os :: raw :: c_int { SkCanvas_saveLayer2 ( self , layerRec ) } # [ inline ] pub unsafe fn restore ( & mut self ) { SkCanvas_restore ( self ) } # [ inline ] pub unsafe fn getSaveCount ( & self ) -> :: std :: os :: raw :: c_int { SkCanvas_getSaveCount ( self ) } # [ inline ] pub unsafe fn restoreToCount ( & mut self , saveCount : :: std :: os :: raw :: c_int ) { SkCanvas_restoreToCount ( self , saveCount ) } # [ inline ] pub unsafe fn translate ( & mut self , dx : SkScalar , dy : SkScalar ) { SkCanvas_translate ( self , dx , dy ) } # [ inline ] pub unsafe fn scale ( & mut self , sx : SkScalar , sy : SkScalar ) { SkCanvas_scale ( self , sx , sy ) } # [ inline ] pub unsafe fn rotate ( & mut self , degrees : SkScalar ) { SkCanvas_rotate ( self , degrees ) } # [ inline ] pub unsafe fn rotate1 ( & mut self , degrees : SkScalar , px : SkScalar , py : SkScalar ) { SkCanvas_rotate1 ( self , degrees , px , py ) } # [ inline ] pub unsafe fn skew ( & mut self , sx : SkScalar , sy : SkScalar ) { SkCanvas_skew ( self , sx , sy ) } # [ inline ] pub unsafe fn concat ( & mut self , matrix : * const SkMatrix ) { SkCanvas_concat ( self , matrix ) } # [ inline ] pub unsafe fn setMatrix ( & mut self , matrix : * const SkMatrix ) { SkCanvas_setMatrix ( self , matrix ) } # [ inline ] pub unsafe fn resetMatrix ( & mut self ) { SkCanvas_resetMatrix ( self ) } # [ inline ] pub unsafe fn clipRect ( & mut self , rect : * const SkRect , op : SkClipOp , doAntiAlias : bool ) { SkCanvas_clipRect ( self , rect , op , doAntiAlias ) } # [ inline ] pub unsafe fn clipRect1 ( & mut self , rect : * const SkRect , op : SkClipOp ) { SkCanvas_clipRect1 ( self , rect , op ) } # [ inline ] pub unsafe fn clipRect2 ( & mut self , rect : * const SkRect , doAntiAlias : bool ) { SkCanvas_clipRect2 ( self , rect , doAntiAlias ) } # [ inline ] pub unsafe fn androidFramework_setDeviceClipRestriction ( & mut self , rect : * const SkIRect ) { SkCanvas_androidFramework_setDeviceClipRestriction ( self , rect ) } # [ inline ] pub unsafe fn clipRRect ( & mut self , rrect : * const SkRRect , op : SkClipOp , doAntiAlias : bool ) { SkCanvas_clipRRect ( self , rrect , op , doAntiAlias ) } # [ inline ] pub unsafe fn clipRRect1 ( & mut self , rrect : * const SkRRect , op : SkClipOp ) { SkCanvas_clipRRect1 ( self , rrect , op ) } # [ inline ] pub unsafe fn clipRRect2 ( & mut self , rrect : * const SkRRect , doAntiAlias : bool ) { SkCanvas_clipRRect2 ( self , rrect , doAntiAlias ) } # [ inline ] pub unsafe fn clipPath ( & mut self , path : * const SkPath , op : SkClipOp , doAntiAlias : bool ) { SkCanvas_clipPath ( self , path , op , doAntiAlias ) } # [ inline ] pub unsafe fn clipPath1 ( & mut self , path : * const SkPath , op : SkClipOp ) { SkCanvas_clipPath1 ( self , path , op ) } # [ inline ] pub unsafe fn clipPath2 ( & mut self , path : * const SkPath , doAntiAlias : bool ) { SkCanvas_clipPath2 ( self , path , doAntiAlias ) } # [ inline ] pub unsafe fn setAllowSimplifyClip ( & mut self , allow : bool ) { SkCanvas_setAllowSimplifyClip ( self , allow ) } # [ inline ] pub unsafe fn clipRegion ( & mut self , deviceRgn : * const SkRegion , op : SkClipOp ) { SkCanvas_clipRegion ( self , deviceRgn , op ) } # [ inline ] pub unsafe fn quickReject ( & self , rect : * const SkRect ) -> bool { SkCanvas_quickReject ( self , rect ) } # [ inline ] pub unsafe fn quickReject1 ( & self , path : * const SkPath ) -> bool { SkCanvas_quickReject1 ( self , path ) } # [ inline ] pub unsafe fn getLocalClipBounds ( & self ) -> SkRect { SkCanvas_getLocalClipBounds ( self ) } # [ inline ] pub unsafe fn getLocalClipBounds1 ( & self , bounds : * mut SkRect ) -> bool { SkCanvas_getLocalClipBounds1 ( self , bounds ) } # [ inline ] pub unsafe fn getDeviceClipBounds ( & self ) -> SkIRect { SkCanvas_getDeviceClipBounds ( self ) } # [ inline ] pub unsafe fn getDeviceClipBounds1 ( & self , bounds : * mut SkIRect ) -> bool { SkCanvas_getDeviceClipBounds1 ( self , bounds ) } # [ inline ] pub unsafe fn drawColor ( & mut self , color : SkColor , mode : SkBlendMode ) { SkCanvas_drawColor ( self , color , mode ) } # [ inline ] pub unsafe fn clear ( & mut self , color : SkColor ) { SkCanvas_clear ( self , color ) } # [ inline ] pub unsafe fn discard ( & mut self ) { SkCanvas_discard ( self ) } # [ inline ] pub unsafe fn drawPaint ( & mut self , paint : * const SkPaint ) { SkCanvas_drawPaint ( self , paint ) } # [ inline ] pub unsafe fn drawPoints ( & mut self , mode : SkCanvas_PointMode , count : usize , pts : * const SkPoint , paint : * const SkPaint ) { SkCanvas_drawPoints ( self , mode , count , pts , paint ) } # [ inline ] pub unsafe fn drawPoint ( & mut self , x : SkScalar , y : SkScalar , paint : * const SkPaint ) { SkCanvas_drawPoint ( self , x , y , paint ) } # [ inline ] pub unsafe fn drawPoint1 ( & mut self , p : SkPoint , paint : * const SkPaint ) { SkCanvas_drawPoint1 ( self , p , paint ) } # [ inline ] pub unsafe fn drawLine ( & mut self , x0 : SkScalar , y0 : SkScalar , x1 : SkScalar , y1 : SkScalar , paint : * const SkPaint ) { SkCanvas_drawLine ( self , x0 , y0 , x1 , y1 , paint ) } # [ inline ] pub unsafe fn drawLine1 ( & mut self , p0 : SkPoint , p1 : SkPoint , paint : * const SkPaint ) { SkCanvas_drawLine1 ( self , p0 , p1 , paint ) } # [ inline ] pub unsafe fn drawRect ( & mut self , rect : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawRect ( self , rect , paint ) } # [ inline ] pub unsafe fn drawIRect ( & mut self , rect : * const SkIRect , paint : * const SkPaint ) { SkCanvas_drawIRect ( self , rect , paint ) } # [ inline ] pub unsafe fn drawRegion ( & mut self , region : * const SkRegion , paint : * const SkPaint ) { SkCanvas_drawRegion ( self , region , paint ) } # [ inline ] pub unsafe fn drawOval ( & mut self , oval : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawOval ( self , oval , paint ) } # [ inline ] pub unsafe fn drawRRect ( & mut self , rrect : * const SkRRect , paint : * const SkPaint ) { SkCanvas_drawRRect ( self , rrect , paint ) } # [ inline ] pub unsafe fn drawDRRect ( & mut self , outer : * const SkRRect , inner : * const SkRRect , paint : * const SkPaint ) { SkCanvas_drawDRRect ( self , outer , inner , paint ) } # [ inline ] pub unsafe fn drawCircle ( & mut self , cx : SkScalar , cy : SkScalar , radius : SkScalar , paint : * const SkPaint ) { SkCanvas_drawCircle ( self , cx , cy , radius , paint ) } # [ inline ] pub unsafe fn drawCircle1 ( & mut self , center : SkPoint , radius : SkScalar , paint : * const SkPaint ) { SkCanvas_drawCircle1 ( self , center , radius , paint ) } # [ inline ] pub unsafe fn drawArc ( & mut self , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , useCenter : bool , paint : * const SkPaint ) { SkCanvas_drawArc ( self , oval , startAngle , sweepAngle , useCenter , paint ) } # [ inline ] pub unsafe fn drawRoundRect ( & mut self , rect : * const SkRect , rx : SkScalar , ry : SkScalar , paint : * const SkPaint ) { SkCanvas_drawRoundRect ( self , rect , rx , ry , paint ) } # [ inline ] pub unsafe fn drawPath ( & mut self , path : * const SkPath , paint : * const SkPaint ) { SkCanvas_drawPath ( self , path , paint ) } # [ inline ] pub unsafe fn drawImage ( & mut self , image : * const SkImage , left : SkScalar , top : SkScalar , paint : * const SkPaint ) { SkCanvas_drawImage ( self , image , left , top , paint ) } # [ inline ] pub unsafe fn drawImage1 ( & mut self , image : * const sk_sp < SkImage > , left : SkScalar , top : SkScalar , paint : * const SkPaint ) { SkCanvas_drawImage1 ( self , image , left , top , paint ) } # [ inline ] pub unsafe fn drawImageRect ( & mut self , image : * const SkImage , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_drawImageRect ( self , image , src , dst , paint , constraint ) } # [ inline ] pub unsafe fn drawImageRect1 ( & mut self , image : * const SkImage , isrc : * const SkIRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_drawImageRect1 ( self , image , isrc , dst , paint , constraint ) } # [ inline ] pub unsafe fn drawImageRect2 ( & mut self , image : * const SkImage , dst : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawImageRect2 ( self , image , dst , paint ) } # [ inline ] pub unsafe fn drawImageRect3 ( & mut self , image : * const sk_sp < SkImage > , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_drawImageRect3 ( self , image , src , dst , paint , constraint ) } # [ inline ] pub unsafe fn drawImageRect4 ( & mut self , image : * const sk_sp < SkImage > , isrc : * const SkIRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_drawImageRect4 ( self , image , isrc , dst , paint , constraint ) } # [ inline ] pub unsafe fn drawImageRect5 ( & mut self , image : * const sk_sp < SkImage > , dst : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawImageRect5 ( self , image , dst , paint ) } # [ inline ] pub unsafe fn drawImageNine ( & mut self , image : * const SkImage , center : * const SkIRect , dst : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawImageNine ( self , image , center , dst , paint ) } # [ inline ] pub unsafe fn drawImageNine1 ( & mut self , image : * const sk_sp < SkImage > , center : * const SkIRect , dst : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawImageNine1 ( self , image , center , dst , paint ) } # [ inline ] pub unsafe fn drawBitmap ( & mut self , bitmap : * const SkBitmap , left : SkScalar , top : SkScalar , paint : * const SkPaint ) { SkCanvas_drawBitmap ( self , bitmap , left , top , paint ) } # [ inline ] pub unsafe fn drawBitmapRect ( & mut self , bitmap : * const SkBitmap , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_drawBitmapRect ( self , bitmap , src , dst , paint , constraint ) } # [ inline ] pub unsafe fn drawBitmapRect1 ( & mut self , bitmap : * const SkBitmap , isrc : * const SkIRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_drawBitmapRect1 ( self , bitmap , isrc , dst , paint , constraint ) } # [ inline ] pub unsafe fn drawBitmapRect2 ( & mut self , bitmap : * const SkBitmap , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_drawBitmapRect2 ( self , bitmap , dst , paint , constraint ) } # [ inline ] pub unsafe fn drawBitmapNine ( & mut self , bitmap : * const SkBitmap , center : * const SkIRect , dst : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawBitmapNine ( self , bitmap , center , dst , paint ) } # [ inline ] pub unsafe fn drawBitmapLattice ( & mut self , bitmap : * const SkBitmap , lattice : * const SkCanvas_Lattice , dst : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawBitmapLattice ( self , bitmap , lattice , dst , paint ) } # [ inline ] pub unsafe fn drawImageLattice ( & mut self , image : * const SkImage , lattice : * const SkCanvas_Lattice , dst : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawImageLattice ( self , image , lattice , dst , paint ) } # [ inline ] pub unsafe fn experimental_DrawImageSetV1 ( & mut self , imageSet : * const SkCanvas_ImageSetEntry , cnt : :: std :: os :: raw :: c_int , quality : SkFilterQuality , mode : SkBlendMode ) { SkCanvas_experimental_DrawImageSetV1 ( self , imageSet , cnt , quality , mode ) } # [ inline ] pub unsafe fn experimental_DrawEdgeAARectV1 ( & mut self , r : * const SkRect , edgeAA : SkCanvas_QuadAAFlags , color : SkColor , mode : SkBlendMode ) { SkCanvas_experimental_DrawEdgeAARectV1 ( self , r , edgeAA , color , mode ) } # [ inline ] pub unsafe fn drawSimpleText ( & mut self , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding , x : SkScalar , y : SkScalar , font : * const SkFont , paint : * const SkPaint ) { SkCanvas_drawSimpleText ( self , text , byteLength , encoding , x , y , font , paint ) } # [ inline ] pub unsafe fn drawString ( & mut self , str : * const :: std :: os :: raw :: c_char , x : SkScalar , y : SkScalar , font : * const SkFont , paint : * const SkPaint ) { SkCanvas_drawString ( self , str , x , y , font , paint ) } # [ inline ] pub unsafe fn drawString1 ( & mut self , str : * const SkString , x : SkScalar , y : SkScalar , font : * const SkFont , paint : * const SkPaint ) { SkCanvas_drawString1 ( self , str , x , y , font , paint ) } # [ inline ] pub unsafe fn drawTextBlob ( & mut self , blob : * const SkTextBlob , x : SkScalar , y : SkScalar , paint : * const SkPaint ) { SkCanvas_drawTextBlob ( self , blob , x , y , paint ) } # [ inline ] pub unsafe fn drawTextBlob1 ( & mut self , blob : * const sk_sp < SkTextBlob > , x : SkScalar , y : SkScalar , paint : * const SkPaint ) { SkCanvas_drawTextBlob1 ( self , blob , x , y , paint ) } # [ inline ] pub unsafe fn drawPicture ( & mut self , picture : * const SkPicture ) { SkCanvas_drawPicture ( self , picture ) } # [ inline ] pub unsafe fn drawPicture1 ( & mut self , picture : * const sk_sp < SkPicture > ) { SkCanvas_drawPicture1 ( self , picture ) } # [ inline ] pub unsafe fn drawPicture2 ( & mut self , picture : * const SkPicture , matrix : * const SkMatrix , paint : * const SkPaint ) { SkCanvas_drawPicture2 ( self , picture , matrix , paint ) } # [ inline ] pub unsafe fn drawPicture3 ( & mut self , picture : * const sk_sp < SkPicture > , matrix : * const SkMatrix , paint : * const SkPaint ) { SkCanvas_drawPicture3 ( self , picture , matrix , paint ) } # [ inline ] pub unsafe fn drawVertices ( & mut self , vertices : * const SkVertices , mode : SkBlendMode , paint : * const SkPaint ) { SkCanvas_drawVertices ( self , vertices , mode , paint ) } # [ inline ] pub unsafe fn drawVertices1 ( & mut self , vertices : * const sk_sp < SkVertices > , mode : SkBlendMode , paint : * const SkPaint ) { SkCanvas_drawVertices1 ( self , vertices , mode , paint ) } # [ inline ] pub unsafe fn drawVertices2 ( & mut self , vertices : * const SkVertices , bones : * const SkVertices_Bone , boneCount : :: std :: os :: raw :: c_int , mode : SkBlendMode , paint : * const SkPaint ) { SkCanvas_drawVertices2 ( self , vertices , bones , boneCount , mode , paint ) } # [ inline ] pub unsafe fn drawVertices3 ( & mut self , vertices : * const sk_sp < SkVertices > , bones : * const SkVertices_Bone , boneCount : :: std :: os :: raw :: c_int , mode : SkBlendMode , paint : * const SkPaint ) { SkCanvas_drawVertices3 ( self , vertices , bones , boneCount , mode , paint ) } # [ inline ] pub unsafe fn drawPatch ( & mut self , cubics : * const SkPoint , colors : * const SkColor , texCoords : * const SkPoint , mode : SkBlendMode , paint : * const SkPaint ) { SkCanvas_drawPatch ( self , cubics , colors , texCoords , mode , paint ) } # [ inline ] pub unsafe fn drawPatch1 ( & mut self , cubics : * const SkPoint , colors : * const SkColor , texCoords : * const SkPoint , paint : * const SkPaint ) { SkCanvas_drawPatch1 ( self , cubics , colors , texCoords , paint ) } # [ inline ] pub unsafe fn drawAtlas ( & mut self , atlas : * const SkImage , xform : * const SkRSXform , tex : * const SkRect , colors : * const SkColor , count : :: std :: os :: raw :: c_int , mode : SkBlendMode , cullRect : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawAtlas ( self , atlas , xform , tex , colors , count , mode , cullRect , paint ) } # [ inline ] pub unsafe fn drawAtlas1 ( & mut self , atlas : * const sk_sp < SkImage > , xform : * const SkRSXform , tex : * const SkRect , colors : * const SkColor , count : :: std :: os :: raw :: c_int , mode : SkBlendMode , cullRect : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawAtlas1 ( self , atlas , xform , tex , colors , count , mode , cullRect , paint ) } # [ inline ] pub unsafe fn drawAtlas2 ( & mut self , atlas : * const SkImage , xform : * const SkRSXform , tex : * const SkRect , count : :: std :: os :: raw :: c_int , cullRect : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawAtlas2 ( self , atlas , xform , tex , count , cullRect , paint ) } # [ inline ] pub unsafe fn drawAtlas3 ( & mut self , atlas : * const sk_sp < SkImage > , xform : * const SkRSXform , tex : * const SkRect , count : :: std :: os :: raw :: c_int , cullRect : * const SkRect , paint : * const SkPaint ) { SkCanvas_drawAtlas3 ( self , atlas , xform , tex , count , cullRect , paint ) } # [ inline ] pub unsafe fn drawDrawable ( & mut self , drawable : * mut SkDrawable , matrix : * const SkMatrix ) { SkCanvas_drawDrawable ( self , drawable , matrix ) } # [ inline ] pub unsafe fn drawDrawable1 ( & mut self , drawable : * mut SkDrawable , x : SkScalar , y : SkScalar ) { SkCanvas_drawDrawable1 ( self , drawable , x , y ) } # [ inline ] pub unsafe fn drawAnnotation ( & mut self , rect : * const SkRect , key : * const :: std :: os :: raw :: c_char , value : * mut SkData ) { SkCanvas_drawAnnotation ( self , rect , key , value ) } # [ inline ] pub unsafe fn drawAnnotation1 ( & mut self , rect : * const SkRect , key : * const :: std :: os :: raw :: c_char , value : * const sk_sp < SkData > ) { SkCanvas_drawAnnotation1 ( self , rect , key , value ) } # [ inline ] pub unsafe fn getTotalMatrix ( & self ) -> * const SkMatrix { SkCanvas_getTotalMatrix ( self ) } # [ inline ] pub unsafe fn internal_private_getTopLayerBounds ( & self ) -> SkIRect { SkCanvas_internal_private_getTopLayerBounds ( self ) } # [ inline ] pub unsafe fn legacy_drawImageRect ( & mut self , image : * const SkImage , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_legacy_drawImageRect ( self , image , src , dst , paint , constraint ) } # [ inline ] pub unsafe fn legacy_drawBitmapRect ( & mut self , bitmap : * const SkBitmap , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) { SkCanvas_legacy_drawBitmapRect ( self , bitmap , src , dst , paint , constraint ) } # [ inline ] pub unsafe fn temporary_internal_getRgnClip ( & mut self , region : * mut SkRegion ) { SkCanvas_temporary_internal_getRgnClip ( self , region ) } # [ inline ] pub unsafe fn private_draw_shadow_rec ( & mut self , arg1 : * const SkPath , arg2 : * const SkDrawShadowRec ) { SkCanvas_private_draw_shadow_rec ( self , arg1 , arg2 ) } # [ inline ] pub unsafe fn clipRectBounds ( & mut self , bounds : * const SkRect , flags : SkCanvas_SaveLayerFlags , intersection : * mut SkIRect , imageFilter : * const SkImageFilter ) -> bool { SkCanvas_clipRectBounds ( self , bounds , flags , intersection , imageFilter ) } # [ inline ] pub unsafe fn getTopDevice ( & self ) -> * mut SkBaseDevice { SkCanvas_getTopDevice ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SkCanvas ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , props : * const SkSurfaceProps ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SkCanvas1 ( & mut __bindgen_tmp , width , height , props ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( device : sk_sp < SkBaseDevice > ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SkCanvas2 ( & mut __bindgen_tmp , device ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( bitmap : * const SkBitmap ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SkCanvas3 ( & mut __bindgen_tmp , bitmap ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new4 ( bitmap : * const SkBitmap , props : * const SkSurfaceProps ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SkCanvas4 ( & mut __bindgen_tmp , bitmap , props ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new5 ( bounds : * const SkIRect ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkCanvas_SkCanvas5 ( & mut __bindgen_tmp , bounds ) ; __bindgen_tmp } } extern "C" { # [ doc = " Draws saved layers, if any." ] # [ doc = "Frees up resources used by SkCanvas." ] # [ link_name = "\u{1}__ZN8SkCanvasD1Ev" ] pub fn SkCanvas_SkCanvas_destructor ( this : * mut SkCanvas ) ; } extern "C" { # [ doc = " Gets the size of the base or root layer in global canvas coordinates. The" ] # [ doc = "origin of the base layer is always (0,0). The area available for drawing may be" ] # [ doc = "smaller (due to clipping or saveLayer)." ] # [ doc = "" ] # [ doc = "@return  integral width and height of base layer" ] # [ link_name = "\u{1}__ZNK8SkCanvas16getBaseLayerSizeEv" ] pub fn SkCanvas_getBaseLayerSize ( this : * mut :: std :: os :: raw :: c_void ) -> SkISize ; } extern "C" { # [ doc = " Returns GPU context of the GPU surface associated with SkCanvas." ] # [ doc = "" ] # [ doc = "@return  GPU context, if available; nullptr otherwise" ] # [ link_name = "\u{1}__ZN8SkCanvas12getGrContextEv" ] pub fn SkCanvas_getGrContext ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrContext ; } extern "C" { # [ doc = " Returns true if clip is empty; that is, nothing will draw." ] # [ doc = "" ] # [ doc = "May do work when called; it should not be called" ] # [ doc = "more often than needed. However, once called, subsequent calls perform no" ] # [ doc = "work until clip changes." ] # [ doc = "" ] # [ doc = "@return  true if clip is empty" ] # [ link_name = "\u{1}__ZNK8SkCanvas11isClipEmptyEv" ] pub fn SkCanvas_isClipEmpty ( this : * mut :: std :: os :: raw :: c_void ) -> bool ; } extern "C" { # [ doc = " Returns true if clip is SkRect and not empty." ] # [ doc = "Returns false if the clip is empty, or if it is not SkRect." ] # [ doc = "" ] # [ doc = "@return  true if clip is SkRect and not empty" ] # [ link_name = "\u{1}__ZNK8SkCanvas10isClipRectEv" ] pub fn SkCanvas_isClipRect ( this : * mut :: std :: os :: raw :: c_void ) -> bool ; } extern "C" { # [ doc = "" ] # [ link_name = "\u{1}__ZN8SkCanvas50internal_private_accessTopLayerRenderTargetContextEv" ] pub fn SkCanvas_internal_private_accessTopLayerRenderTargetContext ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrRenderTargetContext ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12onNewSurfaceERK11SkImageInfoRK14SkSurfaceProps" ] pub fn SkCanvas_onNewSurface ( this : * mut :: std :: os :: raw :: c_void , info : * const SkImageInfo , props : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12onPeekPixelsEP8SkPixmap" ] pub fn SkCanvas_onPeekPixels ( this : * mut :: std :: os :: raw :: c_void , pixmap : * mut SkPixmap ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas22onAccessTopLayerPixelsEP8SkPixmap" ] pub fn SkCanvas_onAccessTopLayerPixels ( this : * mut :: std :: os :: raw :: c_void , pixmap : * mut SkPixmap ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas11onImageInfoEv" ] pub fn SkCanvas_onImageInfo ( this : * mut :: std :: os :: raw :: c_void ) -> SkImageInfo ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkCanvas10onGetPropsEP14SkSurfaceProps" ] pub fn SkCanvas_onGetProps ( this : * mut :: std :: os :: raw :: c_void , props : * mut SkSurfaceProps ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas7onFlushEv" ] pub fn SkCanvas_onFlush ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas8willSaveEv" ] pub fn SkCanvas_willSave ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas20getSaveLayerStrategyERKNS_12SaveLayerRecE" ] pub fn SkCanvas_getSaveLayerStrategy ( this : * mut :: std :: os :: raw :: c_void , arg1 : * const SkCanvas_SaveLayerRec ) -> SkCanvas_SaveLayerStrategy ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas14onDoSaveBehindEPK6SkRect" ] pub fn SkCanvas_onDoSaveBehind ( this : * mut :: std :: os :: raw :: c_void , arg1 : * const SkRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas11willRestoreEv" ] pub fn SkCanvas_willRestore ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas10didRestoreEv" ] pub fn SkCanvas_didRestore ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas9didConcatERK8SkMatrix" ] pub fn SkCanvas_didConcat ( this : * mut :: std :: os :: raw :: c_void , arg1 : * const SkMatrix ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12didSetMatrixERK8SkMatrix" ] pub fn SkCanvas_didSetMatrix ( this : * mut :: std :: os :: raw :: c_void , arg1 : * const SkMatrix ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12didTranslateEff" ] pub fn SkCanvas_didTranslate ( this : * mut :: std :: os :: raw :: c_void , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas11onDrawPaintERK7SkPaint" ] pub fn SkCanvas_onDrawPaint ( this : * mut :: std :: os :: raw :: c_void , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas10onDrawRectERK6SkRectRK7SkPaint" ] pub fn SkCanvas_onDrawRect ( this : * mut :: std :: os :: raw :: c_void , rect : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas16onDrawEdgeAARectERK6SkRectNS_11QuadAAFlagsEj11SkBlendMode" ] pub fn SkCanvas_onDrawEdgeAARect ( this : * mut :: std :: os :: raw :: c_void , rect : * const SkRect , edgeAA : SkCanvas_QuadAAFlags , color : SkColor , mode : SkBlendMode ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas11onDrawRRectERK7SkRRectRK7SkPaint" ] pub fn SkCanvas_onDrawRRect ( this : * mut :: std :: os :: raw :: c_void , rrect : * const SkRRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12onDrawDRRectERK7SkRRectS2_RK7SkPaint" ] pub fn SkCanvas_onDrawDRRect ( this : * mut :: std :: os :: raw :: c_void , outer : * const SkRRect , inner : * const SkRRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas10onDrawOvalERK6SkRectRK7SkPaint" ] pub fn SkCanvas_onDrawOval ( this : * mut :: std :: os :: raw :: c_void , rect : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas9onDrawArcERK6SkRectffbRK7SkPaint" ] pub fn SkCanvas_onDrawArc ( this : * mut :: std :: os :: raw :: c_void , rect : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , useCenter : bool , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas10onDrawPathERK6SkPathRK7SkPaint" ] pub fn SkCanvas_onDrawPath ( this : * mut :: std :: os :: raw :: c_void , path : * const SkPath , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12onDrawRegionERK8SkRegionRK7SkPaint" ] pub fn SkCanvas_onDrawRegion ( this : * mut :: std :: os :: raw :: c_void , region : * const SkRegion , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas14onDrawTextBlobEPK10SkTextBlobffRK7SkPaint" ] pub fn SkCanvas_onDrawTextBlob ( this : * mut :: std :: os :: raw :: c_void , blob : * const SkTextBlob , x : SkScalar , y : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas11onDrawPatchEPK7SkPointPKjS2_11SkBlendModeRK7SkPaint" ] pub fn SkCanvas_onDrawPatch ( this : * mut :: std :: os :: raw :: c_void , cubics : * const SkPoint , colors : * const SkColor , texCoords : * const SkPoint , mode : SkBlendMode , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12onDrawPointsENS_9PointModeEmPK7SkPointRK7SkPaint" ] pub fn SkCanvas_onDrawPoints ( this : * mut :: std :: os :: raw :: c_void , mode : SkCanvas_PointMode , count : usize , pts : * const SkPoint , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas20onDrawVerticesObjectEPK10SkVertices11SkBlendModeRK7SkPaint" ] pub fn SkCanvas_onDrawVerticesObject ( this : * mut :: std :: os :: raw :: c_void , vertices : * const SkVertices , mode : SkBlendMode , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas20onDrawVerticesObjectEPK10SkVerticesPKNS0_4BoneEi11SkBlendModeRK7SkPaint" ] pub fn SkCanvas_onDrawVerticesObject1 ( this : * mut :: std :: os :: raw :: c_void , vertices : * const SkVertices , bones : * const SkVertices_Bone , boneCount : :: std :: os :: raw :: c_int , mode : SkBlendMode , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas11onDrawImageEPK7SkImageffPK7SkPaint" ] pub fn SkCanvas_onDrawImage ( this : * mut :: std :: os :: raw :: c_void , image : * const SkImage , dx : SkScalar , dy : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas15onDrawImageRectEPK7SkImagePK6SkRectRS4_PK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_onDrawImageRect ( this : * mut :: std :: os :: raw :: c_void , image : * const SkImage , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas15onDrawImageNineEPK7SkImageRK7SkIRectRK6SkRectPK7SkPaint" ] pub fn SkCanvas_onDrawImageNine ( this : * mut :: std :: os :: raw :: c_void , image : * const SkImage , center : * const SkIRect , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas18onDrawImageLatticeEPK7SkImageRKNS_7LatticeERK6SkRectPK7SkPaint" ] pub fn SkCanvas_onDrawImageLattice ( this : * mut :: std :: os :: raw :: c_void , image : * const SkImage , lattice : * const SkCanvas_Lattice , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas14onDrawImageSetEPKNS_13ImageSetEntryEi15SkFilterQuality11SkBlendMode" ] pub fn SkCanvas_onDrawImageSet ( this : * mut :: std :: os :: raw :: c_void , imageSet : * const SkCanvas_ImageSetEntry , count : :: std :: os :: raw :: c_int , arg1 : SkFilterQuality , arg2 : SkBlendMode ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12onDrawBitmapERK8SkBitmapffPK7SkPaint" ] pub fn SkCanvas_onDrawBitmap ( this : * mut :: std :: os :: raw :: c_void , bitmap : * const SkBitmap , dx : SkScalar , dy : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas16onDrawBitmapRectERK8SkBitmapPK6SkRectRS4_PK7SkPaintNS_17SrcRectConstraintE" ] pub fn SkCanvas_onDrawBitmapRect ( this : * mut :: std :: os :: raw :: c_void , bitmap : * const SkBitmap , src : * const SkRect , dst : * const SkRect , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas16onDrawBitmapNineERK8SkBitmapRK7SkIRectRK6SkRectPK7SkPaint" ] pub fn SkCanvas_onDrawBitmapNine ( this : * mut :: std :: os :: raw :: c_void , bitmap : * const SkBitmap , center : * const SkIRect , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas19onDrawBitmapLatticeERK8SkBitmapRKNS_7LatticeERK6SkRectPK7SkPaint" ] pub fn SkCanvas_onDrawBitmapLattice ( this : * mut :: std :: os :: raw :: c_void , bitmap : * const SkBitmap , lattice : * const SkCanvas_Lattice , dst : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas11onDrawAtlasEPK7SkImagePK9SkRSXformPK6SkRectPKji11SkBlendModeS8_PK7SkPaint" ] pub fn SkCanvas_onDrawAtlas ( this : * mut :: std :: os :: raw :: c_void , atlas : * const SkImage , xform : * const SkRSXform , rect : * const SkRect , colors : * const SkColor , count : :: std :: os :: raw :: c_int , mode : SkBlendMode , cull : * const SkRect , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas16onDrawAnnotationERK6SkRectPKcP6SkData" ] pub fn SkCanvas_onDrawAnnotation ( this : * mut :: std :: os :: raw :: c_void , rect : * const SkRect , key : * const :: std :: os :: raw :: c_char , value : * mut SkData ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas15onDrawShadowRecERK6SkPathRK15SkDrawShadowRec" ] pub fn SkCanvas_onDrawShadowRec ( this : * mut :: std :: os :: raw :: c_void , arg1 : * const SkPath , arg2 : * const SkDrawShadowRec ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas14onDrawDrawableEP10SkDrawablePK8SkMatrix" ] pub fn SkCanvas_onDrawDrawable ( this : * mut :: std :: os :: raw :: c_void , drawable : * mut SkDrawable , matrix : * const SkMatrix ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas13onDrawPictureEPK9SkPicturePK8SkMatrixPK7SkPaint" ] pub fn SkCanvas_onDrawPicture ( this : * mut :: std :: os :: raw :: c_void , picture : * const SkPicture , matrix : * const SkMatrix , paint : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas10onClipRectERK6SkRect8SkClipOpNS_13ClipEdgeStyleE" ] pub fn SkCanvas_onClipRect ( this : * mut :: std :: os :: raw :: c_void , rect : * const SkRect , op : SkClipOp , edgeStyle : SkCanvas_ClipEdgeStyle ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas11onClipRRectERK7SkRRect8SkClipOpNS_13ClipEdgeStyleE" ] pub fn SkCanvas_onClipRRect ( this : * mut :: std :: os :: raw :: c_void , rrect : * const SkRRect , op : SkClipOp , edgeStyle : SkCanvas_ClipEdgeStyle ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas10onClipPathERK6SkPath8SkClipOpNS_13ClipEdgeStyleE" ] pub fn SkCanvas_onClipPath ( this : * mut :: std :: os :: raw :: c_void , path : * const SkPath , op : SkClipOp , edgeStyle : SkCanvas_ClipEdgeStyle ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas12onClipRegionERK8SkRegion8SkClipOp" ] pub fn SkCanvas_onClipRegion ( this : * mut :: std :: os :: raw :: c_void , deviceRgn : * const SkRegion , op : SkClipOp ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkCanvas9onDiscardEv" ] pub fn SkCanvas_onDiscard ( this : * mut :: std :: os :: raw :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkBaseSemaphore { pub fCount : std_atomic , pub fOSSemaphoreOnce : SkOnce , pub fOSSemaphore : * mut SkBaseSemaphore_OSSemaphore , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkBaseSemaphore_OSSemaphore { _unused : [ u8 ; 0 ] , } # [ test ] fn bindgen_test_layout_SkBaseSemaphore ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkBaseSemaphore > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkBaseSemaphore ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkBaseSemaphore > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkBaseSemaphore ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkBaseSemaphore > ( ) ) ) . fCount as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkBaseSemaphore ) , "::" , stringify ! ( fCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkBaseSemaphore > ( ) ) ) . fOSSemaphoreOnce as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkBaseSemaphore ) , "::" , stringify ! ( fOSSemaphoreOnce ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkBaseSemaphore > ( ) ) ) . fOSSemaphore as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkBaseSemaphore ) , "::" , stringify ! ( fOSSemaphore ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN15SkBaseSemaphore6signalEi" ] pub fn SkBaseSemaphore_signal ( this : * mut SkBaseSemaphore , n : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN15SkBaseSemaphore4waitEv" ] pub fn SkBaseSemaphore_wait ( this : * mut SkBaseSemaphore ) ; } extern "C" { # [ link_name = "\u{1}__ZN15SkBaseSemaphore8try_waitEv" ] pub fn SkBaseSemaphore_try_wait ( this : * mut SkBaseSemaphore ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN15SkBaseSemaphore7cleanupEv" ] pub fn SkBaseSemaphore_cleanup ( this : * mut SkBaseSemaphore ) ; } extern "C" { # [ link_name = "\u{1}__ZN15SkBaseSemaphoreC1Ei" ] pub fn SkBaseSemaphore_SkBaseSemaphore ( this : * mut SkBaseSemaphore , count : :: std :: os :: raw :: c_int ) ; } impl SkBaseSemaphore { # [ inline ] pub unsafe fn signal ( & mut self , n : :: std :: os :: raw :: c_int ) { SkBaseSemaphore_signal ( self , n ) } # [ inline ] pub unsafe fn wait ( & mut self ) { SkBaseSemaphore_wait ( self ) } # [ inline ] pub unsafe fn try_wait ( & mut self ) -> bool { SkBaseSemaphore_try_wait ( self ) } # [ inline ] pub unsafe fn cleanup ( & mut self ) { SkBaseSemaphore_cleanup ( self ) } # [ inline ] pub unsafe fn new ( count : :: std :: os :: raw :: c_int ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkBaseSemaphore_SkBaseSemaphore ( & mut __bindgen_tmp , count ) ; __bindgen_tmp } } pub type SkThreadID = i64 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkBaseMutex { pub fSemaphore : SkBaseSemaphore , pub fOwner : SkThreadID , } # [ test ] fn bindgen_test_layout_SkBaseMutex ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkBaseMutex > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkBaseMutex ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkBaseMutex > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkBaseMutex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkBaseMutex > ( ) ) ) . fSemaphore as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkBaseMutex ) , "::" , stringify ! ( fSemaphore ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkBaseMutex > ( ) ) ) . fOwner as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkBaseMutex ) , "::" , stringify ! ( fOwner ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN11SkBaseMutex7acquireEv" ] pub fn SkBaseMutex_acquire ( this : * mut SkBaseMutex ) ; } extern "C" { # [ link_name = "\u{1}__ZN11SkBaseMutex7releaseEv" ] pub fn SkBaseMutex_release ( this : * mut SkBaseMutex ) ; } extern "C" { # [ link_name = "\u{1}__ZN11SkBaseMutex10assertHeldEv" ] pub fn SkBaseMutex_assertHeld ( this : * mut SkBaseMutex ) ; } extern "C" { # [ link_name = "\u{1}__ZN11SkBaseMutexC1Ev" ] pub fn SkBaseMutex_SkBaseMutex ( this : * mut SkBaseMutex ) ; } impl SkBaseMutex { # [ inline ] pub unsafe fn acquire ( & mut self ) { SkBaseMutex_acquire ( self ) } # [ inline ] pub unsafe fn release ( & mut self ) { SkBaseMutex_release ( self ) } # [ inline ] pub unsafe fn assertHeld ( & mut self ) { SkBaseMutex_assertHeld ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkBaseMutex_SkBaseMutex ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkMutex { pub _base : SkBaseMutex , } # [ test ] fn bindgen_test_layout_SkMutex ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkMutex > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkMutex ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkMutex > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkMutex ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN7SkMutexD1Ev" ] pub fn SkMutex_SkMutex_destructor ( this : * mut SkMutex ) ; } impl SkMutex { # [ inline ] pub unsafe fn destruct ( & mut self ) { SkMutex_SkMutex_destructor ( self ) } } # [ doc = " \\class SkRRect" ] # [ doc = "SkRRect describes a rounded rectangle with a bounds and a pair of radii for each corner." ] # [ doc = "The bounds and radii can be set so that SkRRect describes: a rectangle with sharp corners;" ] # [ doc = "a circle; an oval; or a rectangle with one or more rounded corners." ] # [ doc = "" ] # [ doc = "SkRRect allows implementing CSS properties that describe rounded corners." ] # [ doc = "SkRRect may have up to eight different radii, one for each axis on each of its four" ] # [ doc = "corners." ] # [ doc = "" ] # [ doc = "SkRRect may modify the provided parameters when initializing bounds and radii." ] # [ doc = "If either axis radii is zero or less: radii are stored as zero; corner is square." ] # [ doc = "If corner curves overlap, radii are proportionally reduced to fit within bounds." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRRect { pub fRect : SkRect , pub fRadii : [ SkVector ; 4usize ] , pub fType : i32 , } impl SkRRect_Type { pub const kLastType : SkRRect_Type = SkRRect_Type :: kComplex_Type ; } # [ repr ( u32 ) ] # [ doc = " \\enum SkRRect::Type" ] # [ doc = "Type describes possible specializations of SkRRect. Each Type is" ] # [ doc = "exclusive; a SkRRect may only have one type." ] # [ doc = "" ] # [ doc = "Type members become progressively less restrictive; larger values of" ] # [ doc = "Type have more degrees of freedom than smaller values." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkRRect_Type { # [ doc = "!< zero width or height" ] kEmpty_Type = 0 , # [ doc = "!< non-zero width and height, and zeroed radii" ] kRect_Type = 1 , # [ doc = "!< non-zero width and height filled with radii" ] kOval_Type = 2 , # [ doc = "!< non-zero width and height with equal radii" ] kSimple_Type = 3 , # [ doc = "!< non-zero width and height with axis-aligned radii" ] kNinePatch_Type = 4 , # [ doc = "!< non-zero width and height with arbitrary radii" ] kComplex_Type = 5 , } # [ repr ( u32 ) ] # [ doc = " \\enum SkRRect::Corner" ] # [ doc = "The radii are stored: top-left, top-right, bottom-right, bottom-left." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkRRect_Corner { # [ doc = "!< index of top-left corner radii" ] kUpperLeft_Corner = 0 , # [ doc = "!< index of top-right corner radii" ] kUpperRight_Corner = 1 , # [ doc = "!< index of bottom-right corner radii" ] kLowerRight_Corner = 2 , # [ doc = "!< index of bottom-left corner radii" ] kLowerLeft_Corner = 3 , } pub const SkRRect_kSizeInMemory : usize = 48 ; # [ test ] fn bindgen_test_layout_SkRRect ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRRect > ( ) , 52usize , concat ! ( "Size of: " , stringify ! ( SkRRect ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRRect > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkRRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRRect > ( ) ) ) . fRect as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkRRect ) , "::" , stringify ! ( fRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRRect > ( ) ) ) . fRadii as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkRRect ) , "::" , stringify ! ( fRadii ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRRect > ( ) ) ) . fType as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkRRect ) , "::" , stringify ! ( fType ) ) ) ; } extern "C" { # [ doc = " Returns SkRRect::Type, one of:" ] # [ doc = "kEmpty_Type, kRect_Type, kOval_Type, kSimple_Type, kNinePatch_Type," ] # [ doc = "kComplex_Type." ] # [ doc = "" ] # [ doc = "@return  SkRRect::Type" ] # [ link_name = "\u{1}__ZNK7SkRRect7getTypeEv" ] pub fn SkRRect_getType ( this : * const SkRRect ) -> SkRRect_Type ; } extern "C" { # [ doc = " Returns SkRRect::Type, one of:" ] # [ doc = "kEmpty_Type, kRect_Type, kOval_Type, kSimple_Type, kNinePatch_Type," ] # [ doc = "kComplex_Type." ] # [ doc = "" ] # [ doc = "@return  SkRRect::Type" ] # [ link_name = "\u{1}__ZNK7SkRRect4typeEv" ] pub fn SkRRect_type ( this : * const SkRRect ) -> SkRRect_Type ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkRRect7isEmptyEv" ] pub fn SkRRect_isEmpty ( this : * const SkRRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkRRect6isRectEv" ] pub fn SkRRect_isRect ( this : * const SkRRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkRRect6isOvalEv" ] pub fn SkRRect_isOval ( this : * const SkRRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkRRect8isSimpleEv" ] pub fn SkRRect_isSimple ( this : * const SkRRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkRRect11isNinePatchEv" ] pub fn SkRRect_isNinePatch ( this : * const SkRRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK7SkRRect9isComplexEv" ] pub fn SkRRect_isComplex ( this : * const SkRRect ) -> bool ; } extern "C" { # [ doc = " Returns span on the x-axis. This does not check if result fits in 32-bit float;" ] # [ doc = "result may be infinity." ] # [ doc = "" ] # [ doc = "@return  rect().fRight minus rect().fLeft" ] # [ link_name = "\u{1}__ZNK7SkRRect5widthEv" ] pub fn SkRRect_width ( this : * const SkRRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns span on the y-axis. This does not check if result fits in 32-bit float;" ] # [ doc = "result may be infinity." ] # [ doc = "" ] # [ doc = "@return  rect().fBottom minus rect().fTop" ] # [ link_name = "\u{1}__ZNK7SkRRect6heightEv" ] pub fn SkRRect_height ( this : * const SkRRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns top-left corner radii. If type() returns kEmpty_Type, kRect_Type," ] # [ doc = "kOval_Type, or kSimple_Type, returns a value representative of all corner radii." ] # [ doc = "If type() returns kNinePatch_Type or kComplex_Type, at least one of the" ] # [ doc = "remaining three corners has a different value." ] # [ doc = "" ] # [ doc = "@return  corner radii for simple types" ] # [ link_name = "\u{1}__ZNK7SkRRect14getSimpleRadiiEv" ] pub fn SkRRect_getSimpleRadii ( this : * const SkRRect ) -> SkVector ; } extern "C" { # [ doc = " Sets bounds to zero width and height at (0, 0), the origin. Sets" ] # [ doc = "corner radii to zero and sets type to kEmpty_Type." ] # [ link_name = "\u{1}__ZN7SkRRect8setEmptyEv" ] pub fn SkRRect_setEmpty ( this : * mut SkRRect ) ; } extern "C" { # [ doc = " Sets bounds to sorted rect, and sets corner radii to zero." ] # [ doc = "If set bounds has width and height, and sets type to kRect_Type;" ] # [ doc = "otherwise, sets type to kEmpty_Type." ] # [ doc = "" ] # [ doc = "@param rect  bounds to set" ] # [ link_name = "\u{1}__ZN7SkRRect7setRectERK6SkRect" ] pub fn SkRRect_setRect ( this : * mut SkRRect , rect : * const SkRect ) ; } extern "C" { # [ doc = " Initializes bounds at (0, 0), the origin, with zero width and height." ] # [ doc = "Initializes corner radii to (0, 0), and sets type of kEmpty_Type." ] # [ doc = "" ] # [ doc = "@return  empty SkRRect" ] # [ link_name = "\u{1}__ZN7SkRRect9MakeEmptyEv" ] pub fn SkRRect_MakeEmpty ( ) -> SkRRect ; } extern "C" { # [ doc = " Initializes to copy of r bounds and zeroes corner radii." ] # [ doc = "" ] # [ doc = "@param r  bounds to copy" ] # [ doc = "@return   copy of r" ] # [ link_name = "\u{1}__ZN7SkRRect8MakeRectERK6SkRect" ] pub fn SkRRect_MakeRect ( r : * const SkRect ) -> SkRRect ; } extern "C" { # [ doc = " Sets bounds to oval, x-axis radii to half oval.width(), and all y-axis radii" ] # [ doc = "to half oval.height(). If oval bounds is empty, sets to kEmpty_Type." ] # [ doc = "Otherwise, sets to kOval_Type." ] # [ doc = "" ] # [ doc = "@param oval  bounds of oval" ] # [ doc = "@return      oval" ] # [ link_name = "\u{1}__ZN7SkRRect8MakeOvalERK6SkRect" ] pub fn SkRRect_MakeOval ( oval : * const SkRect ) -> SkRRect ; } extern "C" { # [ doc = " Sets to rounded rectangle with the same radii for all four corners." ] # [ doc = "If rect is empty, sets to kEmpty_Type." ] # [ doc = "Otherwise, if xRad and yRad are zero, sets to kRect_Type." ] # [ doc = "Otherwise, if xRad is at least half rect.width() and yRad is at least half" ] # [ doc = "rect.height(), sets to kOval_Type." ] # [ doc = "Otherwise, sets to kSimple_Type." ] # [ doc = "" ] # [ doc = "@param rect  bounds of rounded rectangle" ] # [ doc = "@param xRad  x-axis radius of corners" ] # [ doc = "@param yRad  y-axis radius of corners" ] # [ doc = "@return      rounded rectangle" ] # [ link_name = "\u{1}__ZN7SkRRect10MakeRectXYERK6SkRectff" ] pub fn SkRRect_MakeRectXY ( rect : * const SkRect , xRad : SkScalar , yRad : SkScalar ) -> SkRRect ; } extern "C" { # [ doc = " Sets bounds to oval, x-axis radii to half oval.width(), and all y-axis radii" ] # [ doc = "to half oval.height(). If oval bounds is empty, sets to kEmpty_Type." ] # [ doc = "Otherwise, sets to kOval_Type." ] # [ doc = "" ] # [ doc = "@param oval  bounds of oval" ] # [ link_name = "\u{1}__ZN7SkRRect7setOvalERK6SkRect" ] pub fn SkRRect_setOval ( this : * mut SkRRect , oval : * const SkRect ) ; } extern "C" { # [ doc = " Sets to rounded rectangle with the same radii for all four corners." ] # [ doc = "If rect is empty, sets to kEmpty_Type." ] # [ doc = "Otherwise, if xRad or yRad is zero, sets to kRect_Type." ] # [ doc = "Otherwise, if xRad is at least half rect.width() and yRad is at least half" ] # [ doc = "rect.height(), sets to kOval_Type." ] # [ doc = "Otherwise, sets to kSimple_Type." ] # [ doc = "" ] # [ doc = "@param rect  bounds of rounded rectangle" ] # [ doc = "@param xRad  x-axis radius of corners" ] # [ doc = "@param yRad  y-axis radius of corners" ] # [ link_name = "\u{1}__ZN7SkRRect9setRectXYERK6SkRectff" ] pub fn SkRRect_setRectXY ( this : * mut SkRRect , rect : * const SkRect , xRad : SkScalar , yRad : SkScalar ) ; } extern "C" { # [ doc = " Sets bounds to rect. Sets radii to (leftRad, topRad), (rightRad, topRad)," ] # [ doc = "(rightRad, bottomRad), (leftRad, bottomRad)." ] # [ doc = "" ] # [ doc = "If rect is empty, sets to kEmpty_Type." ] # [ doc = "Otherwise, if leftRad and rightRad are zero, sets to kRect_Type." ] # [ doc = "Otherwise, if topRad and bottomRad are zero, sets to kRect_Type." ] # [ doc = "Otherwise, if leftRad and rightRad are equal and at least half rect.width(), and" ] # [ doc = "topRad and bottomRad are equal at least half rect.height(), sets to kOval_Type." ] # [ doc = "Otherwise, if leftRad and rightRad are equal, and topRad and bottomRad are equal," ] # [ doc = "sets to kSimple_Type. Otherwise, sets to kNinePatch_Type." ] # [ doc = "" ] # [ doc = "Nine patch refers to the nine parts defined by the radii: one center rectangle," ] # [ doc = "four edge patches, and four corner patches." ] # [ doc = "" ] # [ doc = "@param rect       bounds of rounded rectangle" ] # [ doc = "@param leftRad    left-top and left-bottom x-axis radius" ] # [ doc = "@param topRad     left-top and right-top y-axis radius" ] # [ doc = "@param rightRad   right-top and right-bottom x-axis radius" ] # [ doc = "@param bottomRad  left-bottom and right-bottom y-axis radius" ] # [ link_name = "\u{1}__ZN7SkRRect12setNinePatchERK6SkRectffff" ] pub fn SkRRect_setNinePatch ( this : * mut SkRRect , rect : * const SkRect , leftRad : SkScalar , topRad : SkScalar , rightRad : SkScalar , bottomRad : SkScalar ) ; } extern "C" { # [ doc = " Sets bounds to rect. Sets radii array for individual control of all for corners." ] # [ doc = "" ] # [ doc = "If rect is empty, sets to kEmpty_Type." ] # [ doc = "Otherwise, if one of each corner radii are zero, sets to kRect_Type." ] # [ doc = "Otherwise, if all x-axis radii are equal and at least half rect.width(), and" ] # [ doc = "all y-axis radii are equal at least half rect.height(), sets to kOval_Type." ] # [ doc = "Otherwise, if all x-axis radii are equal, and all y-axis radii are equal," ] # [ doc = "sets to kSimple_Type. Otherwise, sets to kNinePatch_Type." ] # [ doc = "" ] # [ doc = "@param rect   bounds of rounded rectangle" ] # [ doc = "@param radii  corner x-axis and y-axis radii" ] # [ link_name = "\u{1}__ZN7SkRRect12setRectRadiiERK6SkRectPK7SkPoint" ] pub fn SkRRect_setRectRadii ( this : * mut SkRRect , rect : * const SkRect , radii : * const SkVector ) ; } extern "C" { # [ doc = " Returns bounds. Bounds may have zero width or zero height. Bounds right is" ] # [ doc = "greater than or equal to left; bounds bottom is greater than or equal to top." ] # [ doc = "Result is identical to getBounds()." ] # [ doc = "" ] # [ doc = "@return  bounding box" ] # [ link_name = "\u{1}__ZNK7SkRRect4rectEv" ] pub fn SkRRect_rect ( this : * const SkRRect ) -> * const SkRect ; } extern "C" { # [ doc = " Returns scalar pair for radius of curve on x-axis and y-axis for one corner." ] # [ doc = "Both radii may be zero. If not zero, both are positive and finite." ] # [ doc = "" ] # [ doc = "@param corner  one of: kUpperLeft_Corner, kUpperRight_Corner," ] # [ doc = "kLowerRight_Corner, kLowerLeft_Corner" ] # [ doc = "@return        x-axis and y-axis radii for one corner" ] # [ link_name = "\u{1}__ZNK7SkRRect5radiiENS_6CornerE" ] pub fn SkRRect_radii ( this : * const SkRRect , corner : SkRRect_Corner ) -> SkVector ; } extern "C" { # [ doc = " Returns bounds. Bounds may have zero width or zero height. Bounds right is" ] # [ doc = "greater than or equal to left; bounds bottom is greater than or equal to top." ] # [ doc = "Result is identical to rect()." ] # [ doc = "" ] # [ doc = "@return  bounding box" ] # [ link_name = "\u{1}__ZNK7SkRRect9getBoundsEv" ] pub fn SkRRect_getBounds ( this : * const SkRRect ) -> * const SkRect ; } extern "C" { # [ doc = " Copies SkRRect to dst, then insets dst bounds by dx and dy, and adjusts dst" ] # [ doc = "radii by dx and dy. dx and dy may be positive, negative, or zero. dst may be" ] # [ doc = "SkRRect." ] # [ doc = "" ] # [ doc = "If either corner radius is zero, the corner has no curvature and is unchanged." ] # [ doc = "Otherwise, if adjusted radius becomes negative, pins radius to zero." ] # [ doc = "If dx exceeds half dst bounds width, dst bounds left and right are set to" ] # [ doc = "bounds x-axis center. If dy exceeds half dst bounds height, dst bounds top and" ] # [ doc = "bottom are set to bounds y-axis center." ] # [ doc = "" ] # [ doc = "If dx or dy cause the bounds to become infinite, dst bounds is zeroed." ] # [ doc = "" ] # [ doc = "@param dx   added to rect().fLeft, and subtracted from rect().fRight" ] # [ doc = "@param dy   added to rect().fTop, and subtracted from rect().fBottom" ] # [ doc = "@param dst  insets bounds and radii" ] # [ link_name = "\u{1}__ZNK7SkRRect5insetEffPS_" ] pub fn SkRRect_inset ( this : * const SkRRect , dx : SkScalar , dy : SkScalar , dst : * mut SkRRect ) ; } extern "C" { # [ doc = " Insets bounds by dx and dy, and adjusts radii by dx and dy. dx and dy may be" ] # [ doc = "positive, negative, or zero." ] # [ doc = "" ] # [ doc = "If either corner radius is zero, the corner has no curvature and is unchanged." ] # [ doc = "Otherwise, if adjusted radius becomes negative, pins radius to zero." ] # [ doc = "If dx exceeds half bounds width, bounds left and right are set to" ] # [ doc = "bounds x-axis center. If dy exceeds half bounds height, bounds top and" ] # [ doc = "bottom are set to bounds y-axis center." ] # [ doc = "" ] # [ doc = "If dx or dy cause the bounds to become infinite, bounds is zeroed." ] # [ doc = "" ] # [ doc = "@param dx  added to rect().fLeft, and subtracted from rect().fRight" ] # [ doc = "@param dy  added to rect().fTop, and subtracted from rect().fBottom" ] # [ link_name = "\u{1}__ZN7SkRRect5insetEff" ] pub fn SkRRect_inset1 ( this : * mut SkRRect , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Outsets dst bounds by dx and dy, and adjusts radii by dx and dy. dx and dy may be" ] # [ doc = "positive, negative, or zero." ] # [ doc = "" ] # [ doc = "If either corner radius is zero, the corner has no curvature and is unchanged." ] # [ doc = "Otherwise, if adjusted radius becomes negative, pins radius to zero." ] # [ doc = "If dx exceeds half dst bounds width, dst bounds left and right are set to" ] # [ doc = "bounds x-axis center. If dy exceeds half dst bounds height, dst bounds top and" ] # [ doc = "bottom are set to bounds y-axis center." ] # [ doc = "" ] # [ doc = "If dx or dy cause the bounds to become infinite, dst bounds is zeroed." ] # [ doc = "" ] # [ doc = "@param dx   subtracted from rect().fLeft, and added to rect().fRight" ] # [ doc = "@param dy   subtracted from rect().fTop, and added to rect().fBottom" ] # [ doc = "@param dst  outset bounds and radii" ] # [ link_name = "\u{1}__ZNK7SkRRect6outsetEffPS_" ] pub fn SkRRect_outset ( this : * const SkRRect , dx : SkScalar , dy : SkScalar , dst : * mut SkRRect ) ; } extern "C" { # [ doc = " Outsets bounds by dx and dy, and adjusts radii by dx and dy. dx and dy may be" ] # [ doc = "positive, negative, or zero." ] # [ doc = "" ] # [ doc = "If either corner radius is zero, the corner has no curvature and is unchanged." ] # [ doc = "Otherwise, if adjusted radius becomes negative, pins radius to zero." ] # [ doc = "If dx exceeds half bounds width, bounds left and right are set to" ] # [ doc = "bounds x-axis center. If dy exceeds half bounds height, bounds top and" ] # [ doc = "bottom are set to bounds y-axis center." ] # [ doc = "" ] # [ doc = "If dx or dy cause the bounds to become infinite, bounds is zeroed." ] # [ doc = "" ] # [ doc = "@param dx  subtracted from rect().fLeft, and added to rect().fRight" ] # [ doc = "@param dy  subtracted from rect().fTop, and added to rect().fBottom" ] # [ link_name = "\u{1}__ZN7SkRRect6outsetEff" ] pub fn SkRRect_outset1 ( this : * mut SkRRect , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Translates SkRRect by (dx, dy)." ] # [ doc = "" ] # [ doc = "@param dx  offset added to rect().fLeft and rect().fRight" ] # [ doc = "@param dy  offset added to rect().fTop and rect().fBottom" ] # [ link_name = "\u{1}__ZN7SkRRect6offsetEff" ] pub fn SkRRect_offset ( this : * mut SkRRect , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Returns SkRRect translated by (dx, dy)." ] # [ doc = "" ] # [ doc = "@param dx  offset added to rect().fLeft and rect().fRight" ] # [ doc = "@param dy  offset added to rect().fTop and rect().fBottom" ] # [ doc = "@return    SkRRect bounds offset by (dx, dy), with unchanged corner radii" ] # [ link_name = "\u{1}__ZNK7SkRRect10makeOffsetEff" ] pub fn SkRRect_makeOffset ( this : * const SkRRect , dx : SkScalar , dy : SkScalar ) -> SkRRect ; } extern "C" { # [ doc = " Returns true if rect is inside the bounds and corner radii, and if" ] # [ doc = "SkRRect and rect are not empty." ] # [ doc = "" ] # [ doc = "@param rect  area tested for containment" ] # [ doc = "@return      true if SkRRect contains rect" ] # [ link_name = "\u{1}__ZNK7SkRRect8containsERK6SkRect" ] pub fn SkRRect_contains ( this : * const SkRRect , rect : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Returns true if bounds and radii values are finite and describe a SkRRect" ] # [ doc = "SkRRect::Type that matches getType(). All SkRRect methods construct valid types," ] # [ doc = "even if the input values are not valid. Invalid SkRRect data can only" ] # [ doc = "be generated by corrupting memory." ] # [ doc = "" ] # [ doc = "@return  true if bounds and radii match type()" ] # [ link_name = "\u{1}__ZNK7SkRRect7isValidEv" ] pub fn SkRRect_isValid ( this : * const SkRRect ) -> bool ; } extern "C" { # [ doc = " Writes SkRRect to buffer. Writes kSizeInMemory bytes, and returns" ] # [ doc = "kSizeInMemory, the number of bytes written." ] # [ doc = "" ] # [ doc = "@param buffer  storage for SkRRect" ] # [ doc = "@return        bytes written, kSizeInMemory" ] # [ link_name = "\u{1}__ZNK7SkRRect13writeToMemoryEPv" ] pub fn SkRRect_writeToMemory ( this : * const SkRRect , buffer : * mut :: std :: os :: raw :: c_void ) -> usize ; } extern "C" { # [ doc = " Reads SkRRect from buffer, reading kSizeInMemory bytes." ] # [ doc = "Returns kSizeInMemory, bytes read if length is at least kSizeInMemory." ] # [ doc = "Otherwise, returns zero." ] # [ doc = "" ] # [ doc = "@param buffer  memory to read from" ] # [ doc = "@param length  size of buffer" ] # [ doc = "@return        bytes read, or 0 if length is less than kSizeInMemory" ] # [ link_name = "\u{1}__ZN7SkRRect14readFromMemoryEPKvm" ] pub fn SkRRect_readFromMemory ( this : * mut SkRRect , buffer : * const :: std :: os :: raw :: c_void , length : usize ) -> usize ; } extern "C" { # [ doc = " Transforms by SkRRect by matrix, storing result in dst." ] # [ doc = "Returns true if SkRRect transformed can be represented by another SkRRect." ] # [ doc = "Returns false if matrix contains transformations other than scale and translate." ] # [ doc = "" ] # [ doc = "Asserts in debug builds if SkRRect equals dst." ] # [ doc = "" ] # [ doc = "@param matrix  SkMatrix specifying the transform" ] # [ doc = "@param dst     SkRRect to store the result" ] # [ doc = "@return        true if transformation succeeded." ] # [ link_name = "\u{1}__ZNK7SkRRect9transformERK8SkMatrixPS_" ] pub fn SkRRect_transform ( this : * const SkRRect , matrix : * const SkMatrix , dst : * mut SkRRect ) -> bool ; } extern "C" { # [ doc = " Writes text representation of SkRRect to standard output." ] # [ doc = "Set asHex true to generate exact binary representations" ] # [ doc = "of floating point numbers." ] # [ doc = "" ] # [ doc = "@param asHex  true if SkScalar values are written as hexadecimal" ] # [ link_name = "\u{1}__ZNK7SkRRect4dumpEb" ] pub fn SkRRect_dump ( this : * const SkRRect , asHex : bool ) ; } extern "C" { # [ doc = " Writes text representation of SkRRect to standard output. The representation" ] # [ doc = "may be directly compiled as C++ code. Floating point values are written" ] # [ doc = "with limited precision; it may not be possible to reconstruct original" ] # [ doc = "SkRRect from output." ] # [ link_name = "\u{1}__ZNK7SkRRect4dumpEv" ] pub fn SkRRect_dump1 ( this : * const SkRRect ) ; } extern "C" { # [ doc = " Writes text representation of SkRRect to standard output. The representation" ] # [ doc = "may be directly compiled as C++ code. Floating point values are written" ] # [ doc = "in hexadecimal to preserve their exact bit pattern. The output reconstructs the" ] # [ doc = "original SkRRect." ] # [ link_name = "\u{1}__ZNK7SkRRect7dumpHexEv" ] pub fn SkRRect_dumpHex ( this : * const SkRRect ) ; } extern "C" { # [ doc = " Initializes bounds at (0, 0), the origin, with zero width and height." ] # [ doc = "Initializes corner radii to (0, 0), and sets type of kEmpty_Type." ] # [ doc = "" ] # [ doc = "@return  empty SkRRect" ] # [ link_name = "\u{1}__ZN7SkRRectC1Ev" ] pub fn SkRRect_SkRRect ( this : * mut SkRRect ) ; } extern "C" { # [ doc = " Initializes to copy of rrect bounds and corner radii." ] # [ doc = "" ] # [ doc = "@param rrect  bounds and corner to copy" ] # [ doc = "@return       copy of rrect" ] # [ link_name = "\u{1}__ZN7SkRRectC1ERKS_" ] pub fn SkRRect_SkRRect1 ( this : * mut SkRRect , rrect : * const SkRRect ) ; } impl SkRRect { # [ inline ] pub unsafe fn getType ( & self ) -> SkRRect_Type { SkRRect_getType ( self ) } # [ inline ] pub unsafe fn type_ ( & self ) -> SkRRect_Type { SkRRect_type ( self ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkRRect_isEmpty ( self ) } # [ inline ] pub unsafe fn isRect ( & self ) -> bool { SkRRect_isRect ( self ) } # [ inline ] pub unsafe fn isOval ( & self ) -> bool { SkRRect_isOval ( self ) } # [ inline ] pub unsafe fn isSimple ( & self ) -> bool { SkRRect_isSimple ( self ) } # [ inline ] pub unsafe fn isNinePatch ( & self ) -> bool { SkRRect_isNinePatch ( self ) } # [ inline ] pub unsafe fn isComplex ( & self ) -> bool { SkRRect_isComplex ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> SkScalar { SkRRect_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> SkScalar { SkRRect_height ( self ) } # [ inline ] pub unsafe fn getSimpleRadii ( & self ) -> SkVector { SkRRect_getSimpleRadii ( self ) } # [ inline ] pub unsafe fn setEmpty ( & mut self ) { SkRRect_setEmpty ( self ) } # [ inline ] pub unsafe fn setRect ( & mut self , rect : * const SkRect ) { SkRRect_setRect ( self , rect ) } # [ inline ] pub unsafe fn MakeEmpty ( ) -> SkRRect { SkRRect_MakeEmpty ( ) } # [ inline ] pub unsafe fn MakeRect ( r : * const SkRect ) -> SkRRect { SkRRect_MakeRect ( r ) } # [ inline ] pub unsafe fn MakeOval ( oval : * const SkRect ) -> SkRRect { SkRRect_MakeOval ( oval ) } # [ inline ] pub unsafe fn MakeRectXY ( rect : * const SkRect , xRad : SkScalar , yRad : SkScalar ) -> SkRRect { SkRRect_MakeRectXY ( rect , xRad , yRad ) } # [ inline ] pub unsafe fn setOval ( & mut self , oval : * const SkRect ) { SkRRect_setOval ( self , oval ) } # [ inline ] pub unsafe fn setRectXY ( & mut self , rect : * const SkRect , xRad : SkScalar , yRad : SkScalar ) { SkRRect_setRectXY ( self , rect , xRad , yRad ) } # [ inline ] pub unsafe fn setNinePatch ( & mut self , rect : * const SkRect , leftRad : SkScalar , topRad : SkScalar , rightRad : SkScalar , bottomRad : SkScalar ) { SkRRect_setNinePatch ( self , rect , leftRad , topRad , rightRad , bottomRad ) } # [ inline ] pub unsafe fn setRectRadii ( & mut self , rect : * const SkRect , radii : * const SkVector ) { SkRRect_setRectRadii ( self , rect , radii ) } # [ inline ] pub unsafe fn rect ( & self ) -> * const SkRect { SkRRect_rect ( self ) } # [ inline ] pub unsafe fn radii ( & self , corner : SkRRect_Corner ) -> SkVector { SkRRect_radii ( self , corner ) } # [ inline ] pub unsafe fn getBounds ( & self ) -> * const SkRect { SkRRect_getBounds ( self ) } # [ inline ] pub unsafe fn inset ( & self , dx : SkScalar , dy : SkScalar , dst : * mut SkRRect ) { SkRRect_inset ( self , dx , dy , dst ) } # [ inline ] pub unsafe fn inset1 ( & mut self , dx : SkScalar , dy : SkScalar ) { SkRRect_inset1 ( self , dx , dy ) } # [ inline ] pub unsafe fn outset ( & self , dx : SkScalar , dy : SkScalar , dst : * mut SkRRect ) { SkRRect_outset ( self , dx , dy , dst ) } # [ inline ] pub unsafe fn outset1 ( & mut self , dx : SkScalar , dy : SkScalar ) { SkRRect_outset1 ( self , dx , dy ) } # [ inline ] pub unsafe fn offset ( & mut self , dx : SkScalar , dy : SkScalar ) { SkRRect_offset ( self , dx , dy ) } # [ inline ] pub unsafe fn makeOffset ( & self , dx : SkScalar , dy : SkScalar ) -> SkRRect { SkRRect_makeOffset ( self , dx , dy ) } # [ inline ] pub unsafe fn contains ( & self , rect : * const SkRect ) -> bool { SkRRect_contains ( self , rect ) } # [ inline ] pub unsafe fn isValid ( & self ) -> bool { SkRRect_isValid ( self ) } # [ inline ] pub unsafe fn writeToMemory ( & self , buffer : * mut :: std :: os :: raw :: c_void ) -> usize { SkRRect_writeToMemory ( self , buffer ) } # [ inline ] pub unsafe fn readFromMemory ( & mut self , buffer : * const :: std :: os :: raw :: c_void , length : usize ) -> usize { SkRRect_readFromMemory ( self , buffer , length ) } # [ inline ] pub unsafe fn transform ( & self , matrix : * const SkMatrix , dst : * mut SkRRect ) -> bool { SkRRect_transform ( self , matrix , dst ) } # [ inline ] pub unsafe fn dump ( & self , asHex : bool ) { SkRRect_dump ( self , asHex ) } # [ inline ] pub unsafe fn dump1 ( & self ) { SkRRect_dump1 ( self ) } # [ inline ] pub unsafe fn dumpHex ( & self ) { SkRRect_dumpHex ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRRect_SkRRect ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( rrect : * const SkRRect ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRRect_SkRRect1 ( & mut __bindgen_tmp , rrect ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkTDArray < T > { pub fArray : * mut T , pub fReserve : :: std :: os :: raw :: c_int , pub fCount : :: std :: os :: raw :: c_int , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRBuffer { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkWBuffer { _unused : [ u8 ; 0 ] , } # [ doc = " Holds the path verbs and points. It is versioned by a generation ID. None of its public methods" ] # [ doc = " modify the contents. To modify or append to the verbs/points wrap the SkPathRef in an" ] # [ doc = " SkPathRef::Editor object. Installing the editor resets the generation ID. It also performs" ] # [ doc = " copy-on-write if the SkPathRef is shared by multiple SkPaths. The caller passes the Editor\'s" ] # [ doc = " constructor a pointer to a sk_sp<SkPathRef>, which may be updated to point to a new SkPathRef" ] # [ doc = " after the editor\'s constructor returns." ] # [ doc = "" ] # [ doc = " The points and verbs are stored in a single allocation. The points are at the begining of the" ] # [ doc = " allocation while the verbs are stored at end of the allocation, in reverse order. Thus the points" ] # [ doc = " and verbs both grow into the middle of the allocation until the meet. To access verb i in the" ] # [ doc = " verb array use ref.verbs()[~i] (because verbs() returns a pointer just beyond the first" ] # [ doc = " logical verb or the last verb in memory)." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPathRef { pub _base : SkNVRefCnt , pub fBounds : SkRect , pub fPoints : * mut SkPoint , pub fVerbs : * mut u8 , pub fVerbCnt : :: std :: os :: raw :: c_int , pub fPointCnt : :: std :: os :: raw :: c_int , pub fFreeSpace : usize , pub fConicWeights : SkTDArray < SkScalar > , pub fGenerationID : u32 , pub fEditorsAttached : std_atomic , pub fGenIDChangeListenersMutex : SkMutex , pub fGenIDChangeListeners : SkTDArray < * mut SkPathRef_GenIDChangeListener > , pub fBoundsIsDirty : u8 , pub fIsFinite : bool , pub fIsOval : bool , pub fIsRRect : bool , pub fRRectOrOvalIsCCW : bool , pub fRRectOrOvalStartIdx : u8 , pub fSegmentMask : u8 , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPathRef_Editor { pub fPathRef : * mut SkPathRef , } # [ test ] fn bindgen_test_layout_SkPathRef_Editor ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPathRef_Editor > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkPathRef_Editor ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPathRef_Editor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPathRef_Editor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef_Editor > ( ) ) ) . fPathRef as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef_Editor ) , "::" , stringify ! ( fPathRef ) ) ) ; } extern "C" { # [ doc = " Returns the array of points." ] # [ link_name = "\u{1}__ZN9SkPathRef6Editor6pointsEv" ] pub fn SkPathRef_Editor_points ( this : * mut SkPathRef_Editor ) -> * mut SkPoint ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef6Editor6pointsEv" ] pub fn SkPathRef_Editor_points1 ( this : * const SkPathRef_Editor ) -> * const SkPoint ; } extern "C" { # [ doc = " Gets the ith point. Shortcut for this->points() + i" ] # [ link_name = "\u{1}__ZN9SkPathRef6Editor7atPointEi" ] pub fn SkPathRef_Editor_atPoint ( this : * mut SkPathRef_Editor , i : :: std :: os :: raw :: c_int ) -> * mut SkPoint ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef6Editor7atPointEi" ] pub fn SkPathRef_Editor_atPoint1 ( this : * const SkPathRef_Editor , i : :: std :: os :: raw :: c_int ) -> * const SkPoint ; } extern "C" { # [ doc = " Adds the verb and allocates space for the number of points indicated by the verb. The" ] # [ doc = " return value is a pointer to where the points for the verb should be written." ] # [ doc = " \'weight\' is only used if \'verb\' is kConic_Verb" ] # [ link_name = "\u{1}__ZN9SkPathRef6Editor11growForVerbEif" ] pub fn SkPathRef_Editor_growForVerb ( this : * mut SkPathRef_Editor , verb : :: std :: os :: raw :: c_int , weight : SkScalar ) -> * mut SkPoint ; } extern "C" { # [ doc = " Allocates space for multiple instances of a particular verb and the" ] # [ doc = " requisite points & weights." ] # [ doc = " The return pointer points at the first new point (indexed normally [<i>])." ] # [ doc = " If \'verb\' is kConic_Verb, \'weights\' will return a pointer to the" ] # [ doc = " space for the conic weights (indexed normally)." ] # [ link_name = "\u{1}__ZN9SkPathRef6Editor19growForRepeatedVerbEiiPPf" ] pub fn SkPathRef_Editor_growForRepeatedVerb ( this : * mut SkPathRef_Editor , verb : :: std :: os :: raw :: c_int , numVbs : :: std :: os :: raw :: c_int , weights : * mut * mut SkScalar ) -> * mut SkPoint ; } extern "C" { # [ doc = " Resets the path ref to a new verb and point count. The new verbs and points are" ] # [ doc = " uninitialized." ] # [ link_name = "\u{1}__ZN9SkPathRef6Editor11resetToSizeEiii" ] pub fn SkPathRef_Editor_resetToSize ( this : * mut SkPathRef_Editor , newVerbCnt : :: std :: os :: raw :: c_int , newPointCnt : :: std :: os :: raw :: c_int , newConicCount : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Gets the path ref that is wrapped in the Editor." ] # [ link_name = "\u{1}__ZN9SkPathRef6Editor7pathRefEv" ] pub fn SkPathRef_Editor_pathRef ( this : * mut SkPathRef_Editor ) -> * mut SkPathRef ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef6Editor9setIsOvalEbbj" ] pub fn SkPathRef_Editor_setIsOval ( this : * mut SkPathRef_Editor , isOval : bool , isCCW : bool , start : :: std :: os :: raw :: c_uint ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef6Editor10setIsRRectEbbj" ] pub fn SkPathRef_Editor_setIsRRect ( this : * mut SkPathRef_Editor , isRRect : bool , isCCW : bool , start : :: std :: os :: raw :: c_uint ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef6Editor9setBoundsERK6SkRect" ] pub fn SkPathRef_Editor_setBounds ( this : * mut SkPathRef_Editor , rect : * const SkRect ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef6EditorC1EP5sk_spIS_Eii" ] pub fn SkPathRef_Editor_Editor ( this : * mut SkPathRef_Editor , pathRef : * mut sk_sp < SkPathRef > , incReserveVerbs : :: std :: os :: raw :: c_int , incReservePoints : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef6EditorD1Ev" ] pub fn SkPathRef_Editor_Editor_destructor ( this : * mut SkPathRef_Editor ) ; } impl SkPathRef_Editor { # [ inline ] pub unsafe fn points ( & mut self ) -> * mut SkPoint { SkPathRef_Editor_points ( self ) } # [ inline ] pub unsafe fn points1 ( & self ) -> * const SkPoint { SkPathRef_Editor_points1 ( self ) } # [ inline ] pub unsafe fn atPoint ( & mut self , i : :: std :: os :: raw :: c_int ) -> * mut SkPoint { SkPathRef_Editor_atPoint ( self , i ) } # [ inline ] pub unsafe fn atPoint1 ( & self , i : :: std :: os :: raw :: c_int ) -> * const SkPoint { SkPathRef_Editor_atPoint1 ( self , i ) } # [ inline ] pub unsafe fn growForVerb ( & mut self , verb : :: std :: os :: raw :: c_int , weight : SkScalar ) -> * mut SkPoint { SkPathRef_Editor_growForVerb ( self , verb , weight ) } # [ inline ] pub unsafe fn growForRepeatedVerb ( & mut self , verb : :: std :: os :: raw :: c_int , numVbs : :: std :: os :: raw :: c_int , weights : * mut * mut SkScalar ) -> * mut SkPoint { SkPathRef_Editor_growForRepeatedVerb ( self , verb , numVbs , weights ) } # [ inline ] pub unsafe fn resetToSize ( & mut self , newVerbCnt : :: std :: os :: raw :: c_int , newPointCnt : :: std :: os :: raw :: c_int , newConicCount : :: std :: os :: raw :: c_int ) { SkPathRef_Editor_resetToSize ( self , newVerbCnt , newPointCnt , newConicCount ) } # [ inline ] pub unsafe fn pathRef ( & mut self ) -> * mut SkPathRef { SkPathRef_Editor_pathRef ( self ) } # [ inline ] pub unsafe fn setIsOval ( & mut self , isOval : bool , isCCW : bool , start : :: std :: os :: raw :: c_uint ) { SkPathRef_Editor_setIsOval ( self , isOval , isCCW , start ) } # [ inline ] pub unsafe fn setIsRRect ( & mut self , isRRect : bool , isCCW : bool , start : :: std :: os :: raw :: c_uint ) { SkPathRef_Editor_setIsRRect ( self , isRRect , isCCW , start ) } # [ inline ] pub unsafe fn setBounds ( & mut self , rect : * const SkRect ) { SkPathRef_Editor_setBounds ( self , rect ) } # [ inline ] pub unsafe fn new ( pathRef : * mut sk_sp < SkPathRef > , incReserveVerbs : :: std :: os :: raw :: c_int , incReservePoints : :: std :: os :: raw :: c_int ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPathRef_Editor_Editor ( & mut __bindgen_tmp , pathRef , incReserveVerbs , incReservePoints ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkPathRef_Editor_Editor_destructor ( self ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkPathRef_Iter { pub fPts : * const SkPoint , pub fVerbs : * const u8 , pub fVerbStop : * const u8 , pub fConicWeights : * const SkScalar , } # [ test ] fn bindgen_test_layout_SkPathRef_Iter ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPathRef_Iter > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SkPathRef_Iter ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPathRef_Iter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPathRef_Iter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef_Iter > ( ) ) ) . fPts as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef_Iter ) , "::" , stringify ! ( fPts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef_Iter > ( ) ) ) . fVerbs as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef_Iter ) , "::" , stringify ! ( fVerbs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef_Iter > ( ) ) ) . fVerbStop as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef_Iter ) , "::" , stringify ! ( fVerbStop ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef_Iter > ( ) ) ) . fConicWeights as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef_Iter ) , "::" , stringify ! ( fConicWeights ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef4Iter10setPathRefERKS_" ] pub fn SkPathRef_Iter_setPathRef ( this : * mut SkPathRef_Iter , arg1 : * const SkPathRef ) ; } extern "C" { # [ doc = " Return the next verb in this iteration of the path. When all" ] # [ doc = "segments have been visited, return kDone_Verb." ] # [ doc = "" ] # [ doc = "If any point in the path is non-finite, return kDone_Verb immediately." ] # [ doc = "" ] # [ doc = "@param  pts The points representing the current verb and/or segment" ] # [ doc = "This must not be NULL." ] # [ doc = "@return The verb for the current segment" ] # [ link_name = "\u{1}__ZN9SkPathRef4Iter4nextEP7SkPoint" ] pub fn SkPathRef_Iter_next ( this : * mut SkPathRef_Iter , pts : * mut SkPoint ) -> u8 ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef4Iter4peekEv" ] pub fn SkPathRef_Iter_peek ( this : * const SkPathRef_Iter ) -> u8 ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef4Iter11conicWeightEv" ] pub fn SkPathRef_Iter_conicWeight ( this : * const SkPathRef_Iter ) -> SkScalar ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef4IterC1Ev" ] pub fn SkPathRef_Iter_Iter ( this : * mut SkPathRef_Iter ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef4IterC1ERKS_" ] pub fn SkPathRef_Iter_Iter1 ( this : * mut SkPathRef_Iter , arg1 : * const SkPathRef ) ; } impl SkPathRef_Iter { # [ inline ] pub unsafe fn setPathRef ( & mut self , arg1 : * const SkPathRef ) { SkPathRef_Iter_setPathRef ( self , arg1 ) } # [ inline ] pub unsafe fn next ( & mut self , pts : * mut SkPoint ) -> u8 { SkPathRef_Iter_next ( self , pts ) } # [ inline ] pub unsafe fn peek ( & self ) -> u8 { SkPathRef_Iter_peek ( self ) } # [ inline ] pub unsafe fn conicWeight ( & self ) -> SkScalar { SkPathRef_Iter_conicWeight ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPathRef_Iter_Iter ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : * const SkPathRef ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPathRef_Iter_Iter1 ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPathRef_GenIDChangeListener { pub _base : SkRefCnt , pub fShouldUnregisterFromPath : std_atomic , } # [ test ] fn bindgen_test_layout_SkPathRef_GenIDChangeListener ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPathRef_GenIDChangeListener > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkPathRef_GenIDChangeListener ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPathRef_GenIDChangeListener > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPathRef_GenIDChangeListener ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef_GenIDChangeListener > ( ) ) ) . fShouldUnregisterFromPath as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef_GenIDChangeListener ) , "::" , stringify ! ( fShouldUnregisterFromPath ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef19GenIDChangeListener28markShouldUnregisterFromPathEv" ] pub fn SkPathRef_GenIDChangeListener_markShouldUnregisterFromPath ( this : * mut SkPathRef_GenIDChangeListener ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef19GenIDChangeListener24shouldUnregisterFromPathEv" ] pub fn SkPathRef_GenIDChangeListener_shouldUnregisterFromPath ( this : * mut SkPathRef_GenIDChangeListener ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef19GenIDChangeListenerC2Ev" ] pub fn SkPathRef_GenIDChangeListener_GenIDChangeListener ( this : * mut SkPathRef_GenIDChangeListener ) ; } impl SkPathRef_GenIDChangeListener { # [ inline ] pub unsafe fn markShouldUnregisterFromPath ( & mut self ) { SkPathRef_GenIDChangeListener_markShouldUnregisterFromPath ( self ) } # [ inline ] pub unsafe fn shouldUnregisterFromPath ( & mut self ) -> bool { SkPathRef_GenIDChangeListener_shouldUnregisterFromPath ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPathRef_GenIDChangeListener_GenIDChangeListener ( & mut __bindgen_tmp ) ; __bindgen_tmp } } pub const SkPathRef_SerializationOffsets_kLegacyRRectOrOvalStartIdx_SerializationShift : SkPathRef_SerializationOffsets = 28 ; pub const SkPathRef_SerializationOffsets_kLegacyRRectOrOvalIsCCW_SerializationShift : SkPathRef_SerializationOffsets = 27 ; pub const SkPathRef_SerializationOffsets_kLegacyIsRRect_SerializationShift : SkPathRef_SerializationOffsets = 26 ; pub const SkPathRef_SerializationOffsets_kIsFinite_SerializationShift : SkPathRef_SerializationOffsets = 25 ; pub const SkPathRef_SerializationOffsets_kLegacyIsOval_SerializationShift : SkPathRef_SerializationOffsets = 24 ; pub const SkPathRef_SerializationOffsets_kSegmentMask_SerializationShift : SkPathRef_SerializationOffsets = 0 ; pub type SkPathRef_SerializationOffsets = u32 ; pub const SkPathRef_kMinSize : SkPathRef__bindgen_ty_1 = 256 ; pub type SkPathRef__bindgen_ty_1 = u32 ; pub const SkPathRef_kEmptyGenID : SkPathRef__bindgen_ty_2 = 1 ; pub type SkPathRef__bindgen_ty_2 = u32 ; # [ test ] fn bindgen_test_layout_SkPathRef ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPathRef > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( SkPathRef ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPathRef > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPathRef ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fBounds as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fPoints as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fPoints ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fVerbs as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fVerbs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fVerbCnt as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fVerbCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fPointCnt as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fPointCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fFreeSpace as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fFreeSpace ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fConicWeights as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fConicWeights ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fGenerationID as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fGenerationID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fEditorsAttached as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fEditorsAttached ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fGenIDChangeListenersMutex as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fGenIDChangeListenersMutex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fGenIDChangeListeners as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fGenIDChangeListeners ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fBoundsIsDirty as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fBoundsIsDirty ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fIsFinite as * const _ as usize } , 121usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fIsFinite ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fIsOval as * const _ as usize } , 122usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fIsOval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fIsRRect as * const _ as usize } , 123usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fIsRRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fRRectOrOvalIsCCW as * const _ as usize } , 124usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fRRectOrOvalIsCCW ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fRRectOrOvalStartIdx as * const _ as usize } , 125usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fRRectOrOvalStartIdx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathRef > ( ) ) ) . fSegmentMask as * const _ as usize } , 126usize , concat ! ( "Offset of field: " , stringify ! ( SkPathRef ) , "::" , stringify ! ( fSegmentMask ) ) ) ; } extern "C" { # [ doc = " Gets a path ref with no verbs or points." ] # [ link_name = "\u{1}__ZN9SkPathRef11CreateEmptyEv" ] pub fn SkPathRef_CreateEmpty ( ) -> * mut SkPathRef ; } extern "C" { # [ doc = "  Returns true if all of the points in this path are finite, meaning there" ] # [ doc = "  are no infinities and no NaNs." ] # [ link_name = "\u{1}__ZNK9SkPathRef8isFiniteEv" ] pub fn SkPathRef_isFinite ( this : * const SkPathRef ) -> bool ; } extern "C" { # [ doc = "  Returns a mask, where each bit corresponding to a SegmentMask is" ] # [ doc = "  set if the path contains 1 or more segments of that type." ] # [ doc = "  Returns 0 for an empty path (no segments)." ] # [ link_name = "\u{1}__ZNK9SkPathRef15getSegmentMasksEv" ] pub fn SkPathRef_getSegmentMasks ( this : * const SkPathRef ) -> u32 ; } extern "C" { # [ doc = " Returns true if the path is an oval." ] # [ doc = "" ] # [ doc = " @param rect      returns the bounding rect of this oval. It\'s a circle" ] # [ doc = "                  if the height and width are the same." ] # [ doc = " @param isCCW     is the oval CCW (or CW if false)." ] # [ doc = " @param start     indicates where the contour starts on the oval (see" ] # [ doc = "                  SkPath::addOval for intepretation of the index)." ] # [ doc = "" ] # [ doc = " @return true if this path is an oval." ] # [ doc = "              Tracking whether a path is an oval is considered an" ] # [ doc = "              optimization for performance and so some paths that are in" ] # [ doc = "              fact ovals can report false." ] # [ link_name = "\u{1}__ZNK9SkPathRef6isOvalEP6SkRectPbPj" ] pub fn SkPathRef_isOval ( this : * const SkPathRef , rect : * mut SkRect , isCCW : * mut bool , start : * mut :: std :: os :: raw :: c_uint ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef7isRRectEP7SkRRectPbPj" ] pub fn SkPathRef_isRRect ( this : * const SkPathRef , rrect : * mut SkRRect , isCCW : * mut bool , start : * mut :: std :: os :: raw :: c_uint ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef17hasComputedBoundsEv" ] pub fn SkPathRef_hasComputedBounds ( this : * const SkPathRef ) -> bool ; } extern "C" { # [ doc = " Returns the bounds of the path\'s points. If the path contains 0 or 1" ] # [ doc = "points, the bounds is set to (0,0,0,0), and isEmpty() will return true." ] # [ doc = "Note: this bounds may be larger than the actual shape, since curves" ] # [ doc = "do not extend as far as their control points." ] # [ link_name = "\u{1}__ZNK9SkPathRef9getBoundsEv" ] pub fn SkPathRef_getBounds ( this : * const SkPathRef ) -> * const SkRect ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef8getRRectEv" ] pub fn SkPathRef_getRRect ( this : * const SkPathRef ) -> SkRRect ; } extern "C" { # [ doc = " Transforms a path ref by a matrix, allocating a new one only if necessary." ] # [ link_name = "\u{1}__ZN9SkPathRef21CreateTransformedCopyEP5sk_spIS_ERKS_RK8SkMatrix" ] pub fn SkPathRef_CreateTransformedCopy ( dst : * mut sk_sp < SkPathRef > , src : * const SkPathRef , matrix : * const SkMatrix ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef16CreateFromBufferEP9SkRBuffer" ] pub fn SkPathRef_CreateFromBuffer ( buffer : * mut SkRBuffer ) -> * mut SkPathRef ; } extern "C" { # [ doc = " Rollsback a path ref to zero verbs and points with the assumption that the path ref will be" ] # [ doc = " repopulated with approximately the same number of verbs and points. A new path ref is created" ] # [ doc = " only if necessary." ] # [ link_name = "\u{1}__ZN9SkPathRef6RewindEP5sk_spIS_E" ] pub fn SkPathRef_Rewind ( pathRef : * mut sk_sp < SkPathRef > ) ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef11countPointsEv" ] pub fn SkPathRef_countPoints ( this : * const SkPathRef ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef10countVerbsEv" ] pub fn SkPathRef_countVerbs ( this : * const SkPathRef ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef12countWeightsEv" ] pub fn SkPathRef_countWeights ( this : * const SkPathRef ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns a pointer one beyond the first logical verb (last verb in memory order)." ] # [ link_name = "\u{1}__ZNK9SkPathRef5verbsEv" ] pub fn SkPathRef_verbs ( this : * const SkPathRef ) -> * const u8 ; } extern "C" { # [ doc = " Returns a const pointer to the first verb in memory (which is the last logical verb)." ] # [ link_name = "\u{1}__ZNK9SkPathRef13verbsMemBeginEv" ] pub fn SkPathRef_verbsMemBegin ( this : * const SkPathRef ) -> * const u8 ; } extern "C" { # [ doc = " Returns a const pointer to the first point." ] # [ link_name = "\u{1}__ZNK9SkPathRef6pointsEv" ] pub fn SkPathRef_points ( this : * const SkPathRef ) -> * const SkPoint ; } extern "C" { # [ doc = " Shortcut for this->points() + this->countPoints()" ] # [ link_name = "\u{1}__ZNK9SkPathRef9pointsEndEv" ] pub fn SkPathRef_pointsEnd ( this : * const SkPathRef ) -> * const SkPoint ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef12conicWeightsEv" ] pub fn SkPathRef_conicWeights ( this : * const SkPathRef ) -> * const SkScalar ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef15conicWeightsEndEv" ] pub fn SkPathRef_conicWeightsEnd ( this : * const SkPathRef ) -> * const SkScalar ; } extern "C" { # [ doc = " Convenience methods for getting to a verb or point by index." ] # [ link_name = "\u{1}__ZNK9SkPathRef6atVerbEi" ] pub fn SkPathRef_atVerb ( this : * const SkPathRef , index : :: std :: os :: raw :: c_int ) -> u8 ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef7atPointEi" ] pub fn SkPathRef_atPoint ( this : * const SkPathRef , index : :: std :: os :: raw :: c_int ) -> * const SkPoint ; } extern "C" { # [ doc = " Writes the path points and verbs to a buffer." ] # [ link_name = "\u{1}__ZNK9SkPathRef13writeToBufferEP9SkWBuffer" ] pub fn SkPathRef_writeToBuffer ( this : * const SkPathRef , buffer : * mut SkWBuffer ) ; } extern "C" { # [ doc = " Gets the number of bytes that would be written in writeBuffer()" ] # [ link_name = "\u{1}__ZNK9SkPathRef9writeSizeEv" ] pub fn SkPathRef_writeSize ( this : * const SkPathRef ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef11interpolateERKS_fPS_" ] pub fn SkPathRef_interpolate ( this : * const SkPathRef , ending : * const SkPathRef , weight : SkScalar , out : * mut SkPathRef ) ; } extern "C" { # [ doc = " Gets an ID that uniquely identifies the contents of the path ref. If two path refs have the" ] # [ doc = " same ID then they have the same verbs and points. However, two path refs may have the same" ] # [ doc = " contents but different genIDs." ] # [ link_name = "\u{1}__ZNK9SkPathRef5genIDEv" ] pub fn SkPathRef_genID ( this : * const SkPathRef ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef22addGenIDChangeListenerE5sk_spINS_19GenIDChangeListenerEE" ] pub fn SkPathRef_addGenIDChangeListener ( this : * mut SkPathRef , arg1 : sk_sp < SkPathRef_GenIDChangeListener > ) ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef7isValidEv" ] pub fn SkPathRef_isValid ( this : * const SkPathRef ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK9SkPathRef8validateEv" ] pub fn SkPathRef_validate ( this : * const SkPathRef ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRefD1Ev" ] pub fn SkPathRef_SkPathRef_destructor ( this : * mut SkPathRef ) ; } impl SkPathRef { # [ inline ] pub unsafe fn CreateEmpty ( ) -> * mut SkPathRef { SkPathRef_CreateEmpty ( ) } # [ inline ] pub unsafe fn isFinite ( & self ) -> bool { SkPathRef_isFinite ( self ) } # [ inline ] pub unsafe fn getSegmentMasks ( & self ) -> u32 { SkPathRef_getSegmentMasks ( self ) } # [ inline ] pub unsafe fn isOval ( & self , rect : * mut SkRect , isCCW : * mut bool , start : * mut :: std :: os :: raw :: c_uint ) -> bool { SkPathRef_isOval ( self , rect , isCCW , start ) } # [ inline ] pub unsafe fn isRRect ( & self , rrect : * mut SkRRect , isCCW : * mut bool , start : * mut :: std :: os :: raw :: c_uint ) -> bool { SkPathRef_isRRect ( self , rrect , isCCW , start ) } # [ inline ] pub unsafe fn hasComputedBounds ( & self ) -> bool { SkPathRef_hasComputedBounds ( self ) } # [ inline ] pub unsafe fn getBounds ( & self ) -> * const SkRect { SkPathRef_getBounds ( self ) } # [ inline ] pub unsafe fn getRRect ( & self ) -> SkRRect { SkPathRef_getRRect ( self ) } # [ inline ] pub unsafe fn CreateTransformedCopy ( dst : * mut sk_sp < SkPathRef > , src : * const SkPathRef , matrix : * const SkMatrix ) { SkPathRef_CreateTransformedCopy ( dst , src , matrix ) } # [ inline ] pub unsafe fn CreateFromBuffer ( buffer : * mut SkRBuffer ) -> * mut SkPathRef { SkPathRef_CreateFromBuffer ( buffer ) } # [ inline ] pub unsafe fn Rewind ( pathRef : * mut sk_sp < SkPathRef > ) { SkPathRef_Rewind ( pathRef ) } # [ inline ] pub unsafe fn countPoints ( & self ) -> :: std :: os :: raw :: c_int { SkPathRef_countPoints ( self ) } # [ inline ] pub unsafe fn countVerbs ( & self ) -> :: std :: os :: raw :: c_int { SkPathRef_countVerbs ( self ) } # [ inline ] pub unsafe fn countWeights ( & self ) -> :: std :: os :: raw :: c_int { SkPathRef_countWeights ( self ) } # [ inline ] pub unsafe fn verbs ( & self ) -> * const u8 { SkPathRef_verbs ( self ) } # [ inline ] pub unsafe fn verbsMemBegin ( & self ) -> * const u8 { SkPathRef_verbsMemBegin ( self ) } # [ inline ] pub unsafe fn points ( & self ) -> * const SkPoint { SkPathRef_points ( self ) } # [ inline ] pub unsafe fn pointsEnd ( & self ) -> * const SkPoint { SkPathRef_pointsEnd ( self ) } # [ inline ] pub unsafe fn conicWeights ( & self ) -> * const SkScalar { SkPathRef_conicWeights ( self ) } # [ inline ] pub unsafe fn conicWeightsEnd ( & self ) -> * const SkScalar { SkPathRef_conicWeightsEnd ( self ) } # [ inline ] pub unsafe fn atVerb ( & self , index : :: std :: os :: raw :: c_int ) -> u8 { SkPathRef_atVerb ( self , index ) } # [ inline ] pub unsafe fn atPoint ( & self , index : :: std :: os :: raw :: c_int ) -> * const SkPoint { SkPathRef_atPoint ( self , index ) } # [ inline ] pub unsafe fn writeToBuffer ( & self , buffer : * mut SkWBuffer ) { SkPathRef_writeToBuffer ( self , buffer ) } # [ inline ] pub unsafe fn writeSize ( & self ) -> u32 { SkPathRef_writeSize ( self ) } # [ inline ] pub unsafe fn interpolate ( & self , ending : * const SkPathRef , weight : SkScalar , out : * mut SkPathRef ) { SkPathRef_interpolate ( self , ending , weight , out ) } # [ inline ] pub unsafe fn genID ( & self ) -> u32 { SkPathRef_genID ( self ) } # [ inline ] pub unsafe fn addGenIDChangeListener ( & mut self , arg1 : sk_sp < SkPathRef_GenIDChangeListener > ) { SkPathRef_addGenIDChangeListener ( self , arg1 ) } # [ inline ] pub unsafe fn isValid ( & self ) -> bool { SkPathRef_isValid ( self ) } # [ inline ] pub unsafe fn validate ( & self ) { SkPathRef_validate ( self ) } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkPathRef_SkPathRef_destructor ( self ) } } extern "C" { # [ link_name = "\u{1}__ZN9SkPathRef19GenIDChangeListenerD1Ev" ] pub fn SkPathRef_GenIDChangeListener_GenIDChangeListener_destructor ( this : * mut SkPathRef_GenIDChangeListener ) ; } # [ doc = " \\class SkPath" ] # [ doc = "SkPath contain geometry. SkPath may be empty, or contain one or more verbs that" ] # [ doc = "outline a figure. SkPath always starts with a move verb to a Cartesian coordinate," ] # [ doc = "and may be followed by additional verbs that add lines or curves." ] # [ doc = "Adding a close verb makes the geometry into a continuous loop, a closed contour." ] # [ doc = "SkPath may contain any number of contours, each beginning with a move verb." ] # [ doc = "" ] # [ doc = "SkPath contours may contain only a move verb, or may also contain lines," ] # [ doc = "quadratic beziers, conics, and cubic beziers. SkPath contours may be open or" ] # [ doc = "closed." ] # [ doc = "" ] # [ doc = "When used to draw a filled area, SkPath describes whether the fill is inside or" ] # [ doc = "outside the geometry. SkPath also describes the winding rule used to fill" ] # [ doc = "overlapping contours." ] # [ doc = "" ] # [ doc = "Internally, SkPath lazily computes metrics likes bounds and convexity. Call" ] # [ doc = "SkPath::updateBoundsCache to make SkPath thread safe." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPath { pub fPathRef : sk_sp < SkPathRef > , pub fLastMoveToIndex : :: std :: os :: raw :: c_int , pub fConvexity : std_atomic , pub fFirstDirection : std_atomic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub __bindgen_padding_0 : u8 , } # [ doc = "!< contour travels clockwise" ] pub const SkPath_Direction_kCW_Direction : SkPath_Direction = 0 ; # [ doc = "!< contour travels counterclockwise" ] pub const SkPath_Direction_kCCW_Direction : SkPath_Direction = 1 ; # [ doc = " \\enum SkPath::Direction" ] # [ doc = "Direction describes whether contour is clockwise or counterclockwise." ] # [ doc = "When SkPath contains multiple overlapping contours, Direction together with" ] # [ doc = "FillType determines whether overlaps are filled or form holes." ] # [ doc = "" ] # [ doc = "Direction also determines how contour is measured. For instance, dashing" ] # [ doc = "measures along SkPath to determine where to start and stop stroke; Direction" ] # [ doc = "will change dashed results as it steps clockwise or counterclockwise." ] # [ doc = "" ] # [ doc = "Closed contours like SkRect, SkRRect, circle, and oval added with" ] # [ doc = "kCW_Direction travel clockwise; the same added with kCCW_Direction" ] # [ doc = "travel counterclockwise." ] pub type SkPath_Direction = i32 ; # [ doc = "!< is enclosed by a non-zero sum of contour directions" ] pub const SkPath_FillType_kWinding_FillType : SkPath_FillType = 0 ; # [ doc = "!< is enclosed by an odd number of contours" ] pub const SkPath_FillType_kEvenOdd_FillType : SkPath_FillType = 1 ; # [ doc = "!< is enclosed by a zero sum of contour directions" ] pub const SkPath_FillType_kInverseWinding_FillType : SkPath_FillType = 2 ; # [ doc = "!< is enclosed by an even number of contours" ] pub const SkPath_FillType_kInverseEvenOdd_FillType : SkPath_FillType = 3 ; # [ doc = " \\enum SkPath::FillType" ] # [ doc = "FillType selects the rule used to fill SkPath. SkPath set to kWinding_FillType" ] # [ doc = "fills if the sum of contour edges is not zero, where clockwise edges add one, and" ] # [ doc = "counterclockwise edges subtract one. SkPath set to kEvenOdd_FillType fills if the" ] # [ doc = "number of contour edges is odd. Each FillType has an inverse variant that" ] # [ doc = "reverses the rule:" ] # [ doc = "kInverseWinding_FillType fills where the sum of contour edges is zero;" ] # [ doc = "kInverseEvenOdd_FillType fills where the number of contour edges is even." ] pub type SkPath_FillType = u32 ; # [ doc = "!< indicates Convexity has not been determined" ] pub const SkPath_Convexity_kUnknown_Convexity : SkPath_Convexity = 0 ; # [ doc = "!< one contour made of a simple geometry without indentations" ] pub const SkPath_Convexity_kConvex_Convexity : SkPath_Convexity = 1 ; # [ doc = "!< more than one contour, or a geometry with indentations" ] pub const SkPath_Convexity_kConcave_Convexity : SkPath_Convexity = 2 ; # [ doc = " \\enum SkPath::Convexity" ] # [ doc = "SkPath is convex if it contains one contour and contour loops no more than" ] # [ doc = "360 degrees, and contour angles all have same Direction. Convex SkPath" ] # [ doc = "may have better performance and require fewer resources on GPU surface." ] # [ doc = "" ] # [ doc = "SkPath is concave when either at least one Direction change is clockwise and" ] # [ doc = "another is counterclockwise, or the sum of the changes in Direction is not 360" ] # [ doc = "degrees." ] # [ doc = "" ] # [ doc = "Initially SkPath Convexity is kUnknown_Convexity. SkPath Convexity is computed" ] # [ doc = "if needed by destination SkSurface." ] pub type SkPath_Convexity = u8 ; # [ doc = "!< smaller of arc pair" ] pub const SkPath_ArcSize_kSmall_ArcSize : SkPath_ArcSize = 0 ; # [ doc = "!< larger of arc pair" ] pub const SkPath_ArcSize_kLarge_ArcSize : SkPath_ArcSize = 1 ; # [ doc = " \\enum SkPath::ArcSize" ] # [ doc = "Four oval parts with radii (rx, ry) start at last SkPath SkPoint and ends at (x, y)." ] # [ doc = "ArcSize and Direction select one of the four oval parts." ] pub type SkPath_ArcSize = u32 ; # [ doc = "!< appended to destination unaltered" ] pub const SkPath_AddPathMode_kAppend_AddPathMode : SkPath_AddPathMode = 0 ; # [ doc = "!< add line if prior contour is not closed" ] pub const SkPath_AddPathMode_kExtend_AddPathMode : SkPath_AddPathMode = 1 ; # [ doc = " \\enum SkPath::AddPathMode" ] # [ doc = "AddPathMode chooses how addPath() appends. Adding one SkPath to another can extend" ] # [ doc = "the last contour or start a new contour." ] pub type SkPath_AddPathMode = u32 ; # [ doc = "!< contains one or more lines" ] pub const SkPath_SegmentMask_kLine_SegmentMask : SkPath_SegmentMask = 1 ; # [ doc = "!< contains one or more quads" ] pub const SkPath_SegmentMask_kQuad_SegmentMask : SkPath_SegmentMask = 2 ; # [ doc = "!< contains one or more conics" ] pub const SkPath_SegmentMask_kConic_SegmentMask : SkPath_SegmentMask = 4 ; # [ doc = "!< contains one or more cubics" ] pub const SkPath_SegmentMask_kCubic_SegmentMask : SkPath_SegmentMask = 8 ; # [ doc = " \\enum SkPath::SegmentMask" ] # [ doc = "SegmentMask constants correspond to each drawing Verb type in SkPath; for" ] # [ doc = "instance, if SkPath only contains lines, only the kLine_SegmentMask bit is set." ] pub type SkPath_SegmentMask = u32 ; # [ doc = "!< starts new contour at next SkPoint" ] pub const SkPath_Verb_kMove_Verb : SkPath_Verb = 0 ; # [ doc = "!< adds line from last point to next SkPoint" ] pub const SkPath_Verb_kLine_Verb : SkPath_Verb = 1 ; # [ doc = "!< adds quad from last point" ] pub const SkPath_Verb_kQuad_Verb : SkPath_Verb = 2 ; # [ doc = "!< adds conic from last point" ] pub const SkPath_Verb_kConic_Verb : SkPath_Verb = 3 ; # [ doc = "!< adds cubic from last point" ] pub const SkPath_Verb_kCubic_Verb : SkPath_Verb = 4 ; # [ doc = "!< closes contour" ] pub const SkPath_Verb_kClose_Verb : SkPath_Verb = 5 ; # [ doc = "!< terminates SkPath" ] pub const SkPath_Verb_kDone_Verb : SkPath_Verb = 6 ; # [ doc = " \\enum SkPath::Verb" ] # [ doc = "Verb instructs SkPath how to interpret one or more SkPoint and optional conic weight;" ] # [ doc = "manage contour, and terminate SkPath." ] pub type SkPath_Verb = u32 ; # [ doc = " \\class SkPath::Iter" ] # [ doc = "Iterates through verb array, and associated SkPoint array and conic weight." ] # [ doc = "Provides options to treat open contours as closed, and to ignore" ] # [ doc = "degenerate data." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkPath_Iter { pub fPts : * const SkPoint , pub fVerbs : * const u8 , pub fVerbStop : * const u8 , pub fConicWeights : * const SkScalar , pub fMoveTo : SkPoint , pub fLastPt : SkPoint , pub fForceClose : bool , pub fNeedClose : bool , pub fCloseLine : bool , pub fSegmentState : SkPath_Iter_SegmentState , } # [ doc = " The current contour is empty. Starting processing or have just closed a contour." ] pub const SkPath_Iter_SegmentState_kEmptyContour_SegmentState : SkPath_Iter_SegmentState = 0 ; # [ doc = " Have seen a move, but nothing else." ] pub const SkPath_Iter_SegmentState_kAfterMove_SegmentState : SkPath_Iter_SegmentState = 1 ; # [ doc = " Have seen a primitive but not yet closed the path. Also the initial state." ] pub const SkPath_Iter_SegmentState_kAfterPrimitive_SegmentState : SkPath_Iter_SegmentState = 2 ; pub type SkPath_Iter_SegmentState = u8 ; # [ test ] fn bindgen_test_layout_SkPath_Iter ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPath_Iter > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( SkPath_Iter ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPath_Iter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPath_Iter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fPts as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fPts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fVerbs as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fVerbs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fVerbStop as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fVerbStop ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fConicWeights as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fConicWeights ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fMoveTo as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fMoveTo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fLastPt as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fLastPt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fForceClose as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fForceClose ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fNeedClose as * const _ as usize } , 49usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fNeedClose ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fCloseLine as * const _ as usize } , 50usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fCloseLine ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_Iter > ( ) ) ) . fSegmentState as * const _ as usize } , 51usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_Iter ) , "::" , stringify ! ( fSegmentState ) ) ) ; } extern "C" { # [ doc = " Sets SkPath::Iter to return elements of verb array, SkPoint array, and conic weight in" ] # [ doc = "path. If forceClose is true, SkPath::Iter will add kLine_Verb and kClose_Verb after each" ] # [ doc = "open contour. path is not altered." ] # [ doc = "" ] # [ doc = "@param path        SkPath to iterate" ] # [ doc = "@param forceClose  true if open contours generate kClose_Verb" ] # [ link_name = "\u{1}__ZN6SkPath4Iter7setPathERKS_b" ] pub fn SkPath_Iter_setPath ( this : * mut SkPath_Iter , path : * const SkPath , forceClose : bool ) ; } extern "C" { # [ doc = " Returns next SkPath::Verb in verb array, and advances SkPath::Iter." ] # [ doc = "When verb array is exhausted, returns kDone_Verb." ] # [ doc = "" ] # [ doc = "Zero to four SkPoint are stored in pts, depending on the returned SkPath::Verb." ] # [ doc = "" ] # [ doc = "If doConsumeDegenerates is true, skip consecutive kMove_Verb entries, returning" ] # [ doc = "only the last in the series; and skip very small lines, quads, and conics; and" ] # [ doc = "skip kClose_Verb following kMove_Verb." ] # [ doc = "if doConsumeDegenerates is true and exact is true, only skip lines, quads, and" ] # [ doc = "conics with zero lengths." ] # [ doc = "" ] # [ doc = "@param pts                   storage for SkPoint data describing returned SkPath::Verb" ] # [ doc = "@param doConsumeDegenerates  if true, skip degenerate verbs" ] # [ doc = "@param exact                 skip zero length curves" ] # [ doc = "@return                      next SkPath::Verb from verb array" ] # [ link_name = "\u{1}__ZN6SkPath4Iter4nextEP7SkPointbb" ] pub fn SkPath_Iter_next ( this : * mut SkPath_Iter , pts : * mut SkPoint , doConsumeDegenerates : bool , exact : bool ) -> SkPath_Verb ; } extern "C" { # [ doc = " Returns conic weight if next() returned kConic_Verb." ] # [ doc = "" ] # [ doc = "If next() has not been called, or next() did not return kConic_Verb," ] # [ doc = "result is undefined." ] # [ doc = "" ] # [ doc = "@return  conic weight for conic SkPoint returned by next()" ] # [ link_name = "\u{1}__ZNK6SkPath4Iter11conicWeightEv" ] pub fn SkPath_Iter_conicWeight ( this : * const SkPath_Iter ) -> SkScalar ; } extern "C" { # [ doc = " Returns true if last kLine_Verb returned by next() was generated" ] # [ doc = "by kClose_Verb. When true, the end point returned by next() is" ] # [ doc = "also the start point of contour." ] # [ doc = "" ] # [ doc = "If next() has not been called, or next() did not return kLine_Verb," ] # [ doc = "result is undefined." ] # [ doc = "" ] # [ doc = "@return  true if last kLine_Verb was generated by kClose_Verb" ] # [ link_name = "\u{1}__ZNK6SkPath4Iter11isCloseLineEv" ] pub fn SkPath_Iter_isCloseLine ( this : * const SkPath_Iter ) -> bool ; } extern "C" { # [ doc = " Returns true if subsequent calls to next() return kClose_Verb before returning" ] # [ doc = "kMove_Verb. if true, contour SkPath::Iter is processing may end with kClose_Verb, or" ] # [ doc = "SkPath::Iter may have been initialized with force close set to true." ] # [ doc = "" ] # [ doc = "@return  true if contour is closed" ] # [ link_name = "\u{1}__ZNK6SkPath4Iter15isClosedContourEv" ] pub fn SkPath_Iter_isClosedContour ( this : * const SkPath_Iter ) -> bool ; } extern "C" { # [ doc = " Initializes SkPath::Iter with an empty SkPath. next() on SkPath::Iter returns" ] # [ doc = "kDone_Verb." ] # [ doc = "Call setPath to initialize SkPath::Iter at a later time." ] # [ doc = "" ] # [ doc = "@return  SkPath::Iter of empty SkPath" ] # [ link_name = "\u{1}__ZN6SkPath4IterC1Ev" ] pub fn SkPath_Iter_Iter ( this : * mut SkPath_Iter ) ; } extern "C" { # [ doc = " Sets SkPath::Iter to return elements of verb array, SkPoint array, and conic weight in" ] # [ doc = "path. If forceClose is true, SkPath::Iter will add kLine_Verb and kClose_Verb after each" ] # [ doc = "open contour. path is not altered." ] # [ doc = "" ] # [ doc = "@param path        SkPath to iterate" ] # [ doc = "@param forceClose  true if open contours generate kClose_Verb" ] # [ doc = "@return            SkPath::Iter of path" ] # [ link_name = "\u{1}__ZN6SkPath4IterC1ERKS_b" ] pub fn SkPath_Iter_Iter1 ( this : * mut SkPath_Iter , path : * const SkPath , forceClose : bool ) ; } impl SkPath_Iter { # [ inline ] pub unsafe fn setPath ( & mut self , path : * const SkPath , forceClose : bool ) { SkPath_Iter_setPath ( self , path , forceClose ) } # [ inline ] pub unsafe fn next ( & mut self , pts : * mut SkPoint , doConsumeDegenerates : bool , exact : bool ) -> SkPath_Verb { SkPath_Iter_next ( self , pts , doConsumeDegenerates , exact ) } # [ inline ] pub unsafe fn conicWeight ( & self ) -> SkScalar { SkPath_Iter_conicWeight ( self ) } # [ inline ] pub unsafe fn isCloseLine ( & self ) -> bool { SkPath_Iter_isCloseLine ( self ) } # [ inline ] pub unsafe fn isClosedContour ( & self ) -> bool { SkPath_Iter_isClosedContour ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPath_Iter_Iter ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( path : * const SkPath , forceClose : bool ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPath_Iter_Iter1 ( & mut __bindgen_tmp , path , forceClose ) ; __bindgen_tmp } } # [ doc = " \\class SkPath::RawIter" ] # [ doc = "Iterates through verb array, and associated SkPoint array and conic weight." ] # [ doc = "verb array, SkPoint array, and conic weight are returned unaltered." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkPath_RawIter { pub fRawIter : SkPathRef_Iter , } # [ test ] fn bindgen_test_layout_SkPath_RawIter ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPath_RawIter > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SkPath_RawIter ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPath_RawIter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPath_RawIter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath_RawIter > ( ) ) ) . fRawIter as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPath_RawIter ) , "::" , stringify ! ( fRawIter ) ) ) ; } extern "C" { # [ doc = " Sets SkPath::Iter to return elements of verb array, SkPoint array, and conic weight in" ] # [ doc = "path." ] # [ doc = "" ] # [ doc = "@param path  SkPath to iterate" ] # [ link_name = "\u{1}__ZN6SkPath7RawIter7setPathERKS_" ] pub fn SkPath_RawIter_setPath ( this : * mut SkPath_RawIter , path : * const SkPath ) ; } extern "C" { # [ doc = " Returns next SkPath::Verb in verb array, and advances RawIter." ] # [ doc = "When verb array is exhausted, returns kDone_Verb." ] # [ doc = "Zero to four SkPoint are stored in pts, depending on the returned SkPath::Verb." ] # [ doc = "" ] # [ doc = "@param pts  storage for SkPoint data describing returned SkPath::Verb" ] # [ doc = "@return     next SkPath::Verb from verb array" ] # [ link_name = "\u{1}__ZN6SkPath7RawIter4nextEP7SkPoint" ] pub fn SkPath_RawIter_next ( this : * mut SkPath_RawIter , pts : * mut SkPoint ) -> SkPath_Verb ; } extern "C" { # [ doc = " Returns next SkPath::Verb, but does not advance RawIter." ] # [ doc = "" ] # [ doc = "@return  next SkPath::Verb from verb array" ] # [ link_name = "\u{1}__ZNK6SkPath7RawIter4peekEv" ] pub fn SkPath_RawIter_peek ( this : * const SkPath_RawIter ) -> SkPath_Verb ; } extern "C" { # [ doc = " Returns conic weight if next() returned kConic_Verb." ] # [ doc = "" ] # [ doc = "If next() has not been called, or next() did not return kConic_Verb," ] # [ doc = "result is undefined." ] # [ doc = "" ] # [ doc = "@return  conic weight for conic SkPoint returned by next()" ] # [ link_name = "\u{1}__ZNK6SkPath7RawIter11conicWeightEv" ] pub fn SkPath_RawIter_conicWeight ( this : * const SkPath_RawIter ) -> SkScalar ; } extern "C" { # [ doc = " Initializes RawIter with an empty SkPath. next() on RawIter returns kDone_Verb." ] # [ doc = "Call setPath to initialize SkPath::Iter at a later time." ] # [ doc = "" ] # [ doc = "@return  RawIter of empty SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7RawIterC1Ev" ] pub fn SkPath_RawIter_RawIter ( this : * mut SkPath_RawIter ) ; } extern "C" { # [ doc = " Sets RawIter to return elements of verb array, SkPoint array, and conic weight in path." ] # [ doc = "" ] # [ doc = "@param path  SkPath to iterate" ] # [ doc = "@return      RawIter of path" ] # [ link_name = "\u{1}__ZN6SkPath7RawIterC1ERKS_" ] pub fn SkPath_RawIter_RawIter1 ( this : * mut SkPath_RawIter , path : * const SkPath ) ; } impl SkPath_RawIter { # [ inline ] pub unsafe fn setPath ( & mut self , path : * const SkPath ) { SkPath_RawIter_setPath ( self , path ) } # [ inline ] pub unsafe fn next ( & mut self , pts : * mut SkPoint ) -> SkPath_Verb { SkPath_RawIter_next ( self , pts ) } # [ inline ] pub unsafe fn peek ( & self ) -> SkPath_Verb { SkPath_RawIter_peek ( self ) } # [ inline ] pub unsafe fn conicWeight ( & self ) -> SkScalar { SkPath_RawIter_conicWeight ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPath_RawIter_RawIter ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( path : * const SkPath ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPath_RawIter_RawIter1 ( & mut __bindgen_tmp , path ) ; __bindgen_tmp } } # [ test ] fn bindgen_test_layout_SkPath ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPath > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkPath ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPath > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPath ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath > ( ) ) ) . fPathRef as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPath ) , "::" , stringify ! ( fPathRef ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath > ( ) ) ) . fLastMoveToIndex as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkPath ) , "::" , stringify ! ( fLastMoveToIndex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath > ( ) ) ) . fConvexity as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkPath ) , "::" , stringify ! ( fConvexity ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPath > ( ) ) ) . fFirstDirection as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SkPath ) , "::" , stringify ! ( fFirstDirection ) ) ) ; } extern "C" { # [ doc = " Returns true if SkPath contain equal verbs and equal weights." ] # [ doc = "If SkPath contain one or more conics, the weights must match." ] # [ doc = "" ] # [ doc = "conicTo() may add different verbs depending on conic weight, so it is not" ] # [ doc = "trivial to interpolate a pair of SkPath containing conics with different" ] # [ doc = "conic weight values." ] # [ doc = "" ] # [ doc = "@param compare  SkPath to compare" ] # [ doc = "@return         true if SkPath verb array and weights are equivalent" ] # [ link_name = "\u{1}__ZNK6SkPath16isInterpolatableERKS_" ] pub fn SkPath_isInterpolatable ( this : * const SkPath , compare : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Interpolates between SkPath with SkPoint array of equal size." ] # [ doc = "Copy verb array and weights to out, and set out SkPoint array to a weighted" ] # [ doc = "average of this SkPoint array and ending SkPoint array, using the formula:" ] # [ doc = "(Path Point * weight) + ending Point * (1 - weight)." ] # [ doc = "" ] # [ doc = "weight is most useful when between zero (ending SkPoint array) and" ] # [ doc = "one (this Point_Array); will work with values outside of this" ] # [ doc = "range." ] # [ doc = "" ] # [ doc = "interpolate() returns false and leaves out unchanged if SkPoint array is not" ] # [ doc = "the same size as ending SkPoint array. Call isInterpolatable() to check SkPath" ] # [ doc = "compatibility prior to calling interpolate()." ] # [ doc = "" ] # [ doc = "@param ending  SkPoint array averaged with this SkPoint array" ] # [ doc = "@param weight  contribution of this SkPoint array, and" ] # [ doc = "one minus contribution of ending SkPoint array" ] # [ doc = "@param out     SkPath replaced by interpolated averages" ] # [ doc = "@return        true if SkPath contain same number of SkPoint" ] # [ link_name = "\u{1}__ZNK6SkPath11interpolateERKS_fPS_" ] pub fn SkPath_interpolate ( this : * const SkPath , ending : * const SkPath , weight : SkScalar , out : * mut SkPath ) -> bool ; } extern "C" { # [ doc = " Returns FillType, the rule used to fill SkPath. FillType of a new SkPath is" ] # [ doc = "kWinding_FillType." ] # [ doc = "" ] # [ doc = "@return  one of: kWinding_FillType, kEvenOdd_FillType,  kInverseWinding_FillType," ] # [ doc = "kInverseEvenOdd_FillType" ] # [ link_name = "\u{1}__ZNK6SkPath11getFillTypeEv" ] pub fn SkPath_getFillType ( this : * const SkPath ) -> SkPath_FillType ; } extern "C" { # [ doc = " Sets FillType, the rule used to fill SkPath. While there is no check" ] # [ doc = "that ft is legal, values outside of FillType are not supported." ] # [ doc = "" ] # [ doc = "@param ft  one of: kWinding_FillType, kEvenOdd_FillType,  kInverseWinding_FillType," ] # [ doc = "kInverseEvenOdd_FillType" ] # [ link_name = "\u{1}__ZN6SkPath11setFillTypeENS_8FillTypeE" ] pub fn SkPath_setFillType ( this : * mut SkPath , ft : SkPath_FillType ) ; } extern "C" { # [ doc = " Returns if FillType describes area outside SkPath geometry. The inverse fill area" ] # [ doc = "extends indefinitely." ] # [ doc = "" ] # [ doc = "@return  true if FillType is kInverseWinding_FillType or kInverseEvenOdd_FillType" ] # [ link_name = "\u{1}__ZNK6SkPath17isInverseFillTypeEv" ] pub fn SkPath_isInverseFillType ( this : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Replaces FillType with its inverse. The inverse of FillType describes the area" ] # [ doc = "unmodified by the original FillType." ] # [ link_name = "\u{1}__ZN6SkPath21toggleInverseFillTypeEv" ] pub fn SkPath_toggleInverseFillType ( this : * mut SkPath ) ; } extern "C" { # [ doc = " Computes SkPath::Convexity if required, and returns stored value." ] # [ doc = "SkPath::Convexity is computed if stored value is kUnknown_Convexity," ] # [ doc = "or if SkPath has been altered since SkPath::Convexity was computed or set." ] # [ doc = "" ] # [ doc = "@return  computed or stored SkPath::Convexity" ] # [ link_name = "\u{1}__ZNK6SkPath12getConvexityEv" ] pub fn SkPath_getConvexity ( this : * const SkPath ) -> SkPath_Convexity ; } extern "C" { # [ doc = " Returns last computed SkPath::Convexity, or kUnknown_Convexity if" ] # [ doc = "SkPath has been altered since SkPath::Convexity was computed or set." ] # [ doc = "" ] # [ doc = "@return  stored SkPath::Convexity" ] # [ link_name = "\u{1}__ZNK6SkPath21getConvexityOrUnknownEv" ] pub fn SkPath_getConvexityOrUnknown ( this : * const SkPath ) -> SkPath_Convexity ; } extern "C" { # [ doc = " Stores convexity so that it is later returned by getConvexity() or getConvexityOrUnknown()." ] # [ doc = "convexity may differ from getConvexity(), although setting an incorrect value may" ] # [ doc = "cause incorrect or inefficient drawing." ] # [ doc = "" ] # [ doc = "If convexity is kUnknown_Convexity: getConvexity() will" ] # [ doc = "compute SkPath::Convexity, and getConvexityOrUnknown() will return kUnknown_Convexity." ] # [ doc = "" ] # [ doc = "If convexity is kConvex_Convexity or kConcave_Convexity, getConvexity()" ] # [ doc = "and getConvexityOrUnknown() will return convexity until the path is" ] # [ doc = "altered." ] # [ doc = "" ] # [ doc = "@param convexity  one of: kUnknown_Convexity, kConvex_Convexity, or kConcave_Convexity" ] # [ link_name = "\u{1}__ZN6SkPath12setConvexityENS_9ConvexityE" ] pub fn SkPath_setConvexity ( this : * mut SkPath , convexity : SkPath_Convexity ) ; } extern "C" { # [ doc = " Computes SkPath::Convexity if required, and returns true if value is kConvex_Convexity." ] # [ doc = "If setConvexity() was called with kConvex_Convexity or kConcave_Convexity, and" ] # [ doc = "the path has not been altered, SkPath::Convexity is not recomputed." ] # [ doc = "" ] # [ doc = "@return  true if SkPath::Convexity stored or computed is kConvex_Convexity" ] # [ link_name = "\u{1}__ZNK6SkPath8isConvexEv" ] pub fn SkPath_isConvex ( this : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Returns true if this path is recognized as an oval or circle." ] # [ doc = "" ] # [ doc = "bounds receives bounds of oval." ] # [ doc = "" ] # [ doc = "bounds is unmodified if oval is not found." ] # [ doc = "" ] # [ doc = "@param bounds  storage for bounding SkRect of oval; may be nullptr" ] # [ doc = "@return        true if SkPath is recognized as an oval or circle" ] # [ link_name = "\u{1}__ZNK6SkPath6isOvalEP6SkRect" ] pub fn SkPath_isOval ( this : * const SkPath , bounds : * mut SkRect ) -> bool ; } extern "C" { # [ doc = " Returns true if path is representable as SkRRect." ] # [ doc = "Returns false if path is representable as oval, circle, or SkRect." ] # [ doc = "" ] # [ doc = "rrect receives bounds of SkRRect." ] # [ doc = "" ] # [ doc = "rrect is unmodified if SkRRect is not found." ] # [ doc = "" ] # [ doc = "@param rrect  storage for bounding SkRect of SkRRect; may be nullptr" ] # [ doc = "@return       true if SkPath contains only SkRRect" ] # [ link_name = "\u{1}__ZNK6SkPath7isRRectEP7SkRRect" ] pub fn SkPath_isRRect ( this : * const SkPath , rrect : * mut SkRRect ) -> bool ; } extern "C" { # [ doc = " Sets SkPath to its initial state." ] # [ doc = "Removes verb array, SkPoint array, and weights, and sets FillType to kWinding_FillType." ] # [ doc = "Internal storage associated with SkPath is released." ] # [ doc = "" ] # [ doc = "@return  reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath5resetEv" ] pub fn SkPath_reset ( this : * mut SkPath ) -> * mut SkPath ; } extern "C" { # [ doc = " Sets SkPath to its initial state, preserving internal storage." ] # [ doc = "Removes verb array, SkPoint array, and weights, and sets FillType to kWinding_FillType." ] # [ doc = "Internal storage associated with SkPath is retained." ] # [ doc = "" ] # [ doc = "Use rewind() instead of reset() if SkPath storage will be reused and performance" ] # [ doc = "is critical." ] # [ doc = "" ] # [ doc = "@return  reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6rewindEv" ] pub fn SkPath_rewind ( this : * mut SkPath ) -> * mut SkPath ; } extern "C" { # [ doc = " Returns if SkPath is empty." ] # [ doc = "Empty SkPath may have FillType but has no SkPoint, SkPath::Verb, or conic weight." ] # [ doc = "SkPath() constructs empty SkPath; reset() and rewind() make SkPath empty." ] # [ doc = "" ] # [ doc = "@return  true if the path contains no SkPath::Verb array" ] # [ link_name = "\u{1}__ZNK6SkPath7isEmptyEv" ] pub fn SkPath_isEmpty ( this : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Returns if contour is closed." ] # [ doc = "Contour is closed if SkPath SkPath::Verb array was last modified by close(). When stroked," ] # [ doc = "closed contour draws SkPaint::Join instead of SkPaint::Cap at first and last SkPoint." ] # [ doc = "" ] # [ doc = "@return  true if the last contour ends with a kClose_Verb" ] # [ link_name = "\u{1}__ZNK6SkPath19isLastContourClosedEv" ] pub fn SkPath_isLastContourClosed ( this : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Returns true for finite SkPoint array values between negative SK_ScalarMax and" ] # [ doc = "positive SK_ScalarMax. Returns false for any SkPoint array value of" ] # [ doc = "SK_ScalarInfinity, SK_ScalarNegativeInfinity, or SK_ScalarNaN." ] # [ doc = "" ] # [ doc = "@return  true if all SkPoint values are finite" ] # [ link_name = "\u{1}__ZNK6SkPath8isFiniteEv" ] pub fn SkPath_isFinite ( this : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Returns true if the path is volatile; it will not be altered or discarded" ] # [ doc = "by the caller after it is drawn. SkPath by default have volatile set false, allowing" ] # [ doc = "SkSurface to attach a cache of data which speeds repeated drawing. If true, SkSurface" ] # [ doc = "may not speed repeated drawing." ] # [ doc = "" ] # [ doc = "@return  true if caller will alter SkPath after drawing" ] # [ link_name = "\u{1}__ZNK6SkPath10isVolatileEv" ] pub fn SkPath_isVolatile ( this : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Specifies whether SkPath is volatile; whether it will be altered or discarded" ] # [ doc = "by the caller after it is drawn. SkPath by default have volatile set false, allowing" ] # [ doc = "SkBaseDevice to attach a cache of data which speeds repeated drawing." ] # [ doc = "" ] # [ doc = "Mark temporary paths, discarded or modified after use, as volatile" ] # [ doc = "to inform SkBaseDevice that the path need not be cached." ] # [ doc = "" ] # [ doc = "Mark animating SkPath volatile to improve performance." ] # [ doc = "Mark unchanging SkPath non-volatile to improve repeated rendering." ] # [ doc = "" ] # [ doc = "raster surface SkPath draws are affected by volatile for some shadows." ] # [ doc = "GPU surface SkPath draws are affected by volatile for some shadows and concave geometries." ] # [ doc = "" ] # [ doc = "@param isVolatile  true if caller will alter SkPath after drawing" ] # [ link_name = "\u{1}__ZN6SkPath13setIsVolatileEb" ] pub fn SkPath_setIsVolatile ( this : * mut SkPath , isVolatile : bool ) ; } extern "C" { # [ doc = " Tests if line between SkPoint pair is degenerate." ] # [ doc = "Line with no length or that moves a very short distance is degenerate; it is" ] # [ doc = "treated as a point." ] # [ doc = "" ] # [ doc = "exact changes the equality test. If true, returns true only if p1 equals p2." ] # [ doc = "If false, returns true if p1 equals or nearly equals p2." ] # [ doc = "" ] # [ doc = "@param p1     line start point" ] # [ doc = "@param p2     line end point" ] # [ doc = "@param exact  if false, allow nearly equals" ] # [ doc = "@return       true if line is degenerate; its length is effectively zero" ] # [ link_name = "\u{1}__ZN6SkPath16IsLineDegenerateERK7SkPointS2_b" ] pub fn SkPath_IsLineDegenerate ( p1 : * const SkPoint , p2 : * const SkPoint , exact : bool ) -> bool ; } extern "C" { # [ doc = " Tests if quad is degenerate." ] # [ doc = "Quad with no length or that moves a very short distance is degenerate; it is" ] # [ doc = "treated as a point." ] # [ doc = "" ] # [ doc = "@param p1     quad start point" ] # [ doc = "@param p2     quad control point" ] # [ doc = "@param p3     quad end point" ] # [ doc = "@param exact  if true, returns true only if p1, p2, and p3 are equal;" ] # [ doc = "if false, returns true if p1, p2, and p3 are equal or nearly equal" ] # [ doc = "@return       true if quad is degenerate; its length is effectively zero" ] # [ link_name = "\u{1}__ZN6SkPath16IsQuadDegenerateERK7SkPointS2_S2_b" ] pub fn SkPath_IsQuadDegenerate ( p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint , exact : bool ) -> bool ; } extern "C" { # [ doc = " Tests if cubic is degenerate." ] # [ doc = "Cubic with no length or that moves a very short distance is degenerate; it is" ] # [ doc = "treated as a point." ] # [ doc = "" ] # [ doc = "@param p1     cubic start point" ] # [ doc = "@param p2     cubic control point 1" ] # [ doc = "@param p3     cubic control point 2" ] # [ doc = "@param p4     cubic end point" ] # [ doc = "@param exact  if true, returns true only if p1, p2, p3, and p4 are equal;" ] # [ doc = "if false, returns true if p1, p2, p3, and p4 are equal or nearly equal" ] # [ doc = "@return       true if cubic is degenerate; its length is effectively zero" ] # [ link_name = "\u{1}__ZN6SkPath17IsCubicDegenerateERK7SkPointS2_S2_S2_b" ] pub fn SkPath_IsCubicDegenerate ( p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint , p4 : * const SkPoint , exact : bool ) -> bool ; } extern "C" { # [ doc = " Returns true if SkPath contains only one line;" ] # [ doc = "SkPath::Verb array has two entries: kMove_Verb, kLine_Verb." ] # [ doc = "If SkPath contains one line and line is not nullptr, line is set to" ] # [ doc = "line start point and line end point." ] # [ doc = "Returns false if SkPath is not one line; line is unaltered." ] # [ doc = "" ] # [ doc = "@param line  storage for line. May be nullptr" ] # [ doc = "@return      true if SkPath contains exactly one line" ] # [ link_name = "\u{1}__ZNK6SkPath6isLineEP7SkPoint" ] pub fn SkPath_isLine ( this : * const SkPath , line : * mut SkPoint ) -> bool ; } extern "C" { # [ doc = " Returns the number of points in SkPath." ] # [ doc = "SkPoint count is initially zero." ] # [ doc = "" ] # [ doc = "@return  SkPath SkPoint array length" ] # [ link_name = "\u{1}__ZNK6SkPath11countPointsEv" ] pub fn SkPath_countPoints ( this : * const SkPath ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns SkPoint at index in SkPoint array. Valid range for index is" ] # [ doc = "0 to countPoints() - 1." ] # [ doc = "Returns (0, 0) if index is out of range." ] # [ doc = "" ] # [ doc = "@param index  SkPoint array element selector" ] # [ doc = "@return       SkPoint array value or (0, 0)" ] # [ link_name = "\u{1}__ZNK6SkPath8getPointEi" ] pub fn SkPath_getPoint ( this : * const SkPath , index : :: std :: os :: raw :: c_int ) -> SkPoint ; } extern "C" { # [ doc = " Returns number of points in SkPath. Up to max points are copied." ] # [ doc = "points may be nullptr; then, max must be zero." ] # [ doc = "If max is greater than number of points, excess points storage is unaltered." ] # [ doc = "" ] # [ doc = "@param points  storage for SkPath SkPoint array. May be nullptr" ] # [ doc = "@param max     maximum to copy; must be greater than or equal to zero" ] # [ doc = "@return        SkPath SkPoint array length" ] # [ link_name = "\u{1}__ZNK6SkPath9getPointsEP7SkPointi" ] pub fn SkPath_getPoints ( this : * const SkPath , points : * mut SkPoint , max : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns the number of verbs: kMove_Verb, kLine_Verb, kQuad_Verb, kConic_Verb," ] # [ doc = "kCubic_Verb, and kClose_Verb; added to SkPath." ] # [ doc = "" ] # [ doc = "@return  length of verb array" ] # [ link_name = "\u{1}__ZNK6SkPath10countVerbsEv" ] pub fn SkPath_countVerbs ( this : * const SkPath ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns the number of verbs in the path. Up to max verbs are copied. The" ] # [ doc = "verbs are copied as one byte per verb." ] # [ doc = "" ] # [ doc = "@param verbs  storage for verbs, may be nullptr" ] # [ doc = "@param max    maximum number to copy into verbs" ] # [ doc = "@return       the actual number of verbs in the path" ] # [ link_name = "\u{1}__ZNK6SkPath8getVerbsEPhi" ] pub fn SkPath_getVerbs ( this : * const SkPath , verbs : * mut u8 , max : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Exchanges the verb array, SkPoint array, weights, and SkPath::FillType with other." ] # [ doc = "Cached state is also exchanged. swap() internally exchanges pointers, so" ] # [ doc = "it is lightweight and does not allocate memory." ] # [ doc = "" ] # [ doc = "swap() usage has largely been replaced by operator=(const SkPath& path)." ] # [ doc = "SkPath do not copy their content on assignment until they are written to," ] # [ doc = "making assignment as efficient as swap()." ] # [ doc = "" ] # [ doc = "@param other  SkPath exchanged by value" ] # [ link_name = "\u{1}__ZN6SkPath4swapERS_" ] pub fn SkPath_swap ( this : * mut SkPath , other : * mut SkPath ) ; } extern "C" { # [ doc = " Returns minimum and maximum axes values of SkPoint array." ] # [ doc = "Returns (0, 0, 0, 0) if SkPath contains no points. Returned bounds width and height may" ] # [ doc = "be larger or smaller than area affected when SkPath is drawn." ] # [ doc = "" ] # [ doc = "SkRect returned includes all SkPoint added to SkPath, including SkPoint associated with" ] # [ doc = "kMove_Verb that define empty contours." ] # [ doc = "" ] # [ doc = "@return  bounds of all SkPoint in SkPoint array" ] # [ link_name = "\u{1}__ZNK6SkPath9getBoundsEv" ] pub fn SkPath_getBounds ( this : * const SkPath ) -> * const SkRect ; } extern "C" { # [ doc = " Updates internal bounds so that subsequent calls to getBounds() are instantaneous." ] # [ doc = "Unaltered copies of SkPath may also access cached bounds through getBounds()." ] # [ doc = "" ] # [ doc = "For now, identical to calling getBounds() and ignoring the returned value." ] # [ doc = "" ] # [ doc = "Call to prepare SkPath subsequently drawn from multiple threads," ] # [ doc = "to avoid a race condition where each draw separately computes the bounds." ] # [ link_name = "\u{1}__ZNK6SkPath17updateBoundsCacheEv" ] pub fn SkPath_updateBoundsCache ( this : * const SkPath ) ; } extern "C" { # [ doc = " Returns minimum and maximum axes values of the lines and curves in SkPath." ] # [ doc = "Returns (0, 0, 0, 0) if SkPath contains no points." ] # [ doc = "Returned bounds width and height may be larger or smaller than area affected" ] # [ doc = "when SkPath is drawn." ] # [ doc = "" ] # [ doc = "Includes SkPoint associated with kMove_Verb that define empty" ] # [ doc = "contours." ] # [ doc = "" ] # [ doc = "Behaves identically to getBounds() when SkPath contains" ] # [ doc = "only lines. If SkPath contains curves, computed bounds includes" ] # [ doc = "the maximum extent of the quad, conic, or cubic; is slower than getBounds();" ] # [ doc = "and unlike getBounds(), does not cache the result." ] # [ doc = "" ] # [ doc = "@return  tight bounds of curves in SkPath" ] # [ link_name = "\u{1}__ZNK6SkPath18computeTightBoundsEv" ] pub fn SkPath_computeTightBounds ( this : * const SkPath ) -> SkRect ; } extern "C" { # [ doc = " Returns true if rect is contained by SkPath." ] # [ doc = "May return false when rect is contained by SkPath." ] # [ doc = "" ] # [ doc = "For now, only returns true if SkPath has one contour and is convex." ] # [ doc = "rect may share points and edges with SkPath and be contained." ] # [ doc = "Returns true if rect is empty, that is, it has zero width or height; and" ] # [ doc = "the SkPoint or line described by rect is contained by SkPath." ] # [ doc = "" ] # [ doc = "@param rect  SkRect, line, or SkPoint checked for containment" ] # [ doc = "@return      true if rect is contained" ] # [ link_name = "\u{1}__ZNK6SkPath26conservativelyContainsRectERK6SkRect" ] pub fn SkPath_conservativelyContainsRect ( this : * const SkPath , rect : * const SkRect ) -> bool ; } extern "C" { # [ doc = " Grows SkPath verb array and SkPoint array to contain extraPtCount additional SkPoint." ] # [ doc = "May improve performance and use less memory by" ] # [ doc = "reducing the number and size of allocations when creating SkPath." ] # [ doc = "" ] # [ doc = "@param extraPtCount  number of additional SkPoint to allocate" ] # [ link_name = "\u{1}__ZN6SkPath10incReserveEi" ] pub fn SkPath_incReserve ( this : * mut SkPath , extraPtCount : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Shrinks SkPath verb array and SkPoint array storage to discard unused capacity." ] # [ doc = "May reduce the heap overhead for SkPath known to be fully constructed." ] # [ link_name = "\u{1}__ZN6SkPath11shrinkToFitEv" ] pub fn SkPath_shrinkToFit ( this : * mut SkPath ) ; } extern "C" { # [ doc = " Adds beginning of contour at SkPoint (x, y)." ] # [ doc = "" ] # [ doc = "@param x  x-axis value of contour start" ] # [ doc = "@param y  y-axis value of contour start" ] # [ doc = "@return   reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6moveToEff" ] pub fn SkPath_moveTo ( this : * mut SkPath , x : SkScalar , y : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds beginning of contour at SkPoint p." ] # [ doc = "" ] # [ doc = "@param p  contour start" ] # [ doc = "@return   reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6moveToERK7SkPoint" ] pub fn SkPath_moveTo1 ( this : * mut SkPath , p : * const SkPoint ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds beginning of contour relative to last point." ] # [ doc = "If SkPath is empty, starts contour at (dx, dy)." ] # [ doc = "Otherwise, start contour at last point offset by (dx, dy)." ] # [ doc = "Function name stands for \"relative move to\"." ] # [ doc = "" ] # [ doc = "@param dx  offset from last point to contour start on x-axis" ] # [ doc = "@param dy  offset from last point to contour start on y-axis" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7rMoveToEff" ] pub fn SkPath_rMoveTo ( this : * mut SkPath , dx : SkScalar , dy : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds line from last point to (x, y). If SkPath is empty, or last SkPath::Verb is" ] # [ doc = "kClose_Verb, last point is set to (0, 0) before adding line." ] # [ doc = "" ] # [ doc = "lineTo() appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed." ] # [ doc = "lineTo() then appends kLine_Verb to verb array and (x, y) to SkPoint array." ] # [ doc = "" ] # [ doc = "@param x  end of added line on x-axis" ] # [ doc = "@param y  end of added line on y-axis" ] # [ doc = "@return   reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6lineToEff" ] pub fn SkPath_lineTo ( this : * mut SkPath , x : SkScalar , y : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds line from last point to SkPoint p. If SkPath is empty, or last SkPath::Verb is" ] # [ doc = "kClose_Verb, last point is set to (0, 0) before adding line." ] # [ doc = "" ] # [ doc = "lineTo() first appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed." ] # [ doc = "lineTo() then appends kLine_Verb to verb array and SkPoint p to SkPoint array." ] # [ doc = "" ] # [ doc = "@param p  end SkPoint of added line" ] # [ doc = "@return   reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6lineToERK7SkPoint" ] pub fn SkPath_lineTo1 ( this : * mut SkPath , p : * const SkPoint ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds line from last point to vector (dx, dy). If SkPath is empty, or last SkPath::Verb is" ] # [ doc = "kClose_Verb, last point is set to (0, 0) before adding line." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed;" ] # [ doc = "then appends kLine_Verb to verb array and line end to SkPoint array." ] # [ doc = "Line end is last point plus vector (dx, dy)." ] # [ doc = "Function name stands for \"relative line to\"." ] # [ doc = "" ] # [ doc = "@param dx  offset from last point to line end on x-axis" ] # [ doc = "@param dy  offset from last point to line end on y-axis" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7rLineToEff" ] pub fn SkPath_rLineTo ( this : * mut SkPath , dx : SkScalar , dy : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds quad from last point towards (x1, y1), to (x2, y2)." ] # [ doc = "If SkPath is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0)" ] # [ doc = "before adding quad." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed;" ] # [ doc = "then appends kQuad_Verb to verb array; and (x1, y1), (x2, y2)" ] # [ doc = "to SkPoint array." ] # [ doc = "" ] # [ doc = "@param x1  control SkPoint of quad on x-axis" ] # [ doc = "@param y1  control SkPoint of quad on y-axis" ] # [ doc = "@param x2  end SkPoint of quad on x-axis" ] # [ doc = "@param y2  end SkPoint of quad on y-axis" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6quadToEffff" ] pub fn SkPath_quadTo ( this : * mut SkPath , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds quad from last point towards SkPoint p1, to SkPoint p2." ] # [ doc = "If SkPath is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0)" ] # [ doc = "before adding quad." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed;" ] # [ doc = "then appends kQuad_Verb to verb array; and SkPoint p1, p2" ] # [ doc = "to SkPoint array." ] # [ doc = "" ] # [ doc = "@param p1  control SkPoint of added quad" ] # [ doc = "@param p2  end SkPoint of added quad" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6quadToERK7SkPointS2_" ] pub fn SkPath_quadTo1 ( this : * mut SkPath , p1 : * const SkPoint , p2 : * const SkPoint ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds quad from last point towards vector (dx1, dy1), to vector (dx2, dy2)." ] # [ doc = "If SkPath is empty, or last SkPath::Verb" ] # [ doc = "is kClose_Verb, last point is set to (0, 0) before adding quad." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array," ] # [ doc = "if needed; then appends kQuad_Verb to verb array; and appends quad" ] # [ doc = "control and quad end to SkPoint array." ] # [ doc = "Quad control is last point plus vector (dx1, dy1)." ] # [ doc = "Quad end is last point plus vector (dx2, dy2)." ] # [ doc = "Function name stands for \"relative quad to\"." ] # [ doc = "" ] # [ doc = "@param dx1  offset from last point to quad control on x-axis" ] # [ doc = "@param dy1  offset from last point to quad control on y-axis" ] # [ doc = "@param dx2  offset from last point to quad end on x-axis" ] # [ doc = "@param dy2  offset from last point to quad end on y-axis" ] # [ doc = "@return     reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7rQuadToEffff" ] pub fn SkPath_rQuadTo ( this : * mut SkPath , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds conic from last point towards (x1, y1), to (x2, y2), weighted by w." ] # [ doc = "If SkPath is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0)" ] # [ doc = "before adding conic." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed." ] # [ doc = "" ] # [ doc = "If w is finite and not one, appends kConic_Verb to verb array;" ] # [ doc = "and (x1, y1), (x2, y2) to SkPoint array; and w to conic weights." ] # [ doc = "" ] # [ doc = "If w is one, appends kQuad_Verb to verb array, and" ] # [ doc = "(x1, y1), (x2, y2) to SkPoint array." ] # [ doc = "" ] # [ doc = "If w is not finite, appends kLine_Verb twice to verb array, and" ] # [ doc = "(x1, y1), (x2, y2) to SkPoint array." ] # [ doc = "" ] # [ doc = "@param x1  control SkPoint of conic on x-axis" ] # [ doc = "@param y1  control SkPoint of conic on y-axis" ] # [ doc = "@param x2  end SkPoint of conic on x-axis" ] # [ doc = "@param y2  end SkPoint of conic on y-axis" ] # [ doc = "@param w   weight of added conic" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7conicToEfffff" ] pub fn SkPath_conicTo ( this : * mut SkPath , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , w : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds conic from last point towards SkPoint p1, to SkPoint p2, weighted by w." ] # [ doc = "If SkPath is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0)" ] # [ doc = "before adding conic." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed." ] # [ doc = "" ] # [ doc = "If w is finite and not one, appends kConic_Verb to verb array;" ] # [ doc = "and SkPoint p1, p2 to SkPoint array; and w to conic weights." ] # [ doc = "" ] # [ doc = "If w is one, appends kQuad_Verb to verb array, and SkPoint p1, p2" ] # [ doc = "to SkPoint array." ] # [ doc = "" ] # [ doc = "If w is not finite, appends kLine_Verb twice to verb array, and" ] # [ doc = "SkPoint p1, p2 to SkPoint array." ] # [ doc = "" ] # [ doc = "@param p1  control SkPoint of added conic" ] # [ doc = "@param p2  end SkPoint of added conic" ] # [ doc = "@param w   weight of added conic" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7conicToERK7SkPointS2_f" ] pub fn SkPath_conicTo1 ( this : * mut SkPath , p1 : * const SkPoint , p2 : * const SkPoint , w : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds conic from last point towards vector (dx1, dy1), to vector (dx2, dy2)," ] # [ doc = "weighted by w. If SkPath is empty, or last SkPath::Verb" ] # [ doc = "is kClose_Verb, last point is set to (0, 0) before adding conic." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array," ] # [ doc = "if needed." ] # [ doc = "" ] # [ doc = "If w is finite and not one, next appends kConic_Verb to verb array," ] # [ doc = "and w is recorded as conic weight; otherwise, if w is one, appends" ] # [ doc = "kQuad_Verb to verb array; or if w is not finite, appends kLine_Verb" ] # [ doc = "twice to verb array." ] # [ doc = "" ] # [ doc = "In all cases appends SkPoint control and end to SkPoint array." ] # [ doc = "control is last point plus vector (dx1, dy1)." ] # [ doc = "end is last point plus vector (dx2, dy2)." ] # [ doc = "" ] # [ doc = "Function name stands for \"relative conic to\"." ] # [ doc = "" ] # [ doc = "@param dx1  offset from last point to conic control on x-axis" ] # [ doc = "@param dy1  offset from last point to conic control on y-axis" ] # [ doc = "@param dx2  offset from last point to conic end on x-axis" ] # [ doc = "@param dy2  offset from last point to conic end on y-axis" ] # [ doc = "@param w    weight of added conic" ] # [ doc = "@return     reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath8rConicToEfffff" ] pub fn SkPath_rConicTo ( this : * mut SkPath , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar , w : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds cubic from last point towards (x1, y1), then towards (x2, y2), ending at" ] # [ doc = "(x3, y3). If SkPath is empty, or last SkPath::Verb is kClose_Verb, last point is set to" ] # [ doc = "(0, 0) before adding cubic." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed;" ] # [ doc = "then appends kCubic_Verb to verb array; and (x1, y1), (x2, y2), (x3, y3)" ] # [ doc = "to SkPoint array." ] # [ doc = "" ] # [ doc = "@param x1  first control SkPoint of cubic on x-axis" ] # [ doc = "@param y1  first control SkPoint of cubic on y-axis" ] # [ doc = "@param x2  second control SkPoint of cubic on x-axis" ] # [ doc = "@param y2  second control SkPoint of cubic on y-axis" ] # [ doc = "@param x3  end SkPoint of cubic on x-axis" ] # [ doc = "@param y3  end SkPoint of cubic on y-axis" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7cubicToEffffff" ] pub fn SkPath_cubicTo ( this : * mut SkPath , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , x3 : SkScalar , y3 : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds cubic from last point towards SkPoint p1, then towards SkPoint p2, ending at" ] # [ doc = "SkPoint p3. If SkPath is empty, or last SkPath::Verb is kClose_Verb, last point is set to" ] # [ doc = "(0, 0) before adding cubic." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array, if needed;" ] # [ doc = "then appends kCubic_Verb to verb array; and SkPoint p1, p2, p3" ] # [ doc = "to SkPoint array." ] # [ doc = "" ] # [ doc = "@param p1  first control SkPoint of cubic" ] # [ doc = "@param p2  second control SkPoint of cubic" ] # [ doc = "@param p3  end SkPoint of cubic" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7cubicToERK7SkPointS2_S2_" ] pub fn SkPath_cubicTo1 ( this : * mut SkPath , p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds cubic from last point towards vector (dx1, dy1), then towards" ] # [ doc = "vector (dx2, dy2), to vector (dx3, dy3)." ] # [ doc = "If SkPath is empty, or last SkPath::Verb" ] # [ doc = "is kClose_Verb, last point is set to (0, 0) before adding cubic." ] # [ doc = "" ] # [ doc = "Appends kMove_Verb to verb array and (0, 0) to SkPoint array," ] # [ doc = "if needed; then appends kCubic_Verb to verb array; and appends cubic" ] # [ doc = "control and cubic end to SkPoint array." ] # [ doc = "Cubic control is last point plus vector (dx1, dy1)." ] # [ doc = "Cubic end is last point plus vector (dx2, dy2)." ] # [ doc = "Function name stands for \"relative cubic to\"." ] # [ doc = "" ] # [ doc = "@param dx1  offset from last point to first cubic control on x-axis" ] # [ doc = "@param dy1  offset from last point to first cubic control on y-axis" ] # [ doc = "@param dx2  offset from last point to second cubic control on x-axis" ] # [ doc = "@param dy2  offset from last point to second cubic control on y-axis" ] # [ doc = "@param dx3  offset from last point to cubic end on x-axis" ] # [ doc = "@param dy3  offset from last point to cubic end on y-axis" ] # [ doc = "@return    reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath8rCubicToEffffff" ] pub fn SkPath_rCubicTo ( this : * mut SkPath , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar , dx3 : SkScalar , dy3 : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends arc to SkPath. Arc added is part of ellipse" ] # [ doc = "bounded by oval, from startAngle through sweepAngle. Both startAngle and" ] # [ doc = "sweepAngle are measured in degrees, where zero degrees is aligned with the" ] # [ doc = "positive x-axis, and positive sweeps extends arc clockwise." ] # [ doc = "" ] # [ doc = "arcTo() adds line connecting SkPath last SkPoint to initial arc SkPoint if forceMoveTo" ] # [ doc = "is false and SkPath is not empty. Otherwise, added contour begins with first point" ] # [ doc = "of arc. Angles greater than -360 and less than 360 are treated modulo 360." ] # [ doc = "" ] # [ doc = "@param oval         bounds of ellipse containing arc" ] # [ doc = "@param startAngle   starting angle of arc in degrees" ] # [ doc = "@param sweepAngle   sweep, in degrees. Positive is clockwise; treated modulo 360" ] # [ doc = "@param forceMoveTo  true to start a new contour with arc" ] # [ doc = "@return             reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath5arcToERK6SkRectffb" ] pub fn SkPath_arcTo ( this : * mut SkPath , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , forceMoveTo : bool ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends arc to SkPath, after appending line if needed. Arc is implemented by conic" ] # [ doc = "weighted to describe part of circle. Arc is contained by tangent from" ] # [ doc = "last SkPath point to (x1, y1), and tangent from (x1, y1) to (x2, y2). Arc" ] # [ doc = "is part of circle sized to radius, positioned so it touches both tangent lines." ] # [ doc = "" ] # [ doc = "If last Path Point does not start Arc, arcTo appends connecting Line to Path." ] # [ doc = "The length of Vector from (x1, y1) to (x2, y2) does not affect Arc." ] # [ doc = "" ] # [ doc = "Arc sweep is always less than 180 degrees. If radius is zero, or if" ] # [ doc = "tangents are nearly parallel, arcTo appends Line from last Path Point to (x1, y1)." ] # [ doc = "" ] # [ doc = "arcTo appends at most one Line and one conic." ] # [ doc = "arcTo implements the functionality of PostScript arct and HTML Canvas arcTo." ] # [ doc = "" ] # [ doc = "@param x1      x-axis value common to pair of tangents" ] # [ doc = "@param y1      y-axis value common to pair of tangents" ] # [ doc = "@param x2      x-axis value end of second tangent" ] # [ doc = "@param y2      y-axis value end of second tangent" ] # [ doc = "@param radius  distance from arc to circle center" ] # [ doc = "@return        reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath5arcToEfffff" ] pub fn SkPath_arcTo1 ( this : * mut SkPath , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , radius : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends arc to SkPath, after appending line if needed. Arc is implemented by conic" ] # [ doc = "weighted to describe part of circle. Arc is contained by tangent from" ] # [ doc = "last SkPath point to p1, and tangent from p1 to p2. Arc" ] # [ doc = "is part of circle sized to radius, positioned so it touches both tangent lines." ] # [ doc = "" ] # [ doc = "If last SkPath SkPoint does not start arc, arcTo() appends connecting line to SkPath." ] # [ doc = "The length of vector from p1 to p2 does not affect arc." ] # [ doc = "" ] # [ doc = "Arc sweep is always less than 180 degrees. If radius is zero, or if" ] # [ doc = "tangents are nearly parallel, arcTo() appends line from last SkPath SkPoint to p1." ] # [ doc = "" ] # [ doc = "arcTo() appends at most one line and one conic." ] # [ doc = "arcTo() implements the functionality of PostScript arct and HTML Canvas arcTo." ] # [ doc = "" ] # [ doc = "@param p1      SkPoint common to pair of tangents" ] # [ doc = "@param p2      end of second tangent" ] # [ doc = "@param radius  distance from arc to circle center" ] # [ doc = "@return        reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath5arcToE7SkPointS0_f" ] pub fn SkPath_arcTo2 ( this : * mut SkPath , p1 : SkPoint , p2 : SkPoint , radius : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends arc to SkPath. Arc is implemented by one or more conics weighted to" ] # [ doc = "describe part of oval with radii (rx, ry) rotated by xAxisRotate degrees. Arc" ] # [ doc = "curves from last SkPath SkPoint to (x, y), choosing one of four possible routes:" ] # [ doc = "clockwise or counterclockwise, and smaller or larger." ] # [ doc = "" ] # [ doc = "Arc sweep is always less than 360 degrees. arcTo() appends line to (x, y) if" ] # [ doc = "either radii are zero, or if last SkPath SkPoint equals (x, y). arcTo() scales radii" ] # [ doc = "(rx, ry) to fit last SkPath SkPoint and (x, y) if both are greater than zero but" ] # [ doc = "too small." ] # [ doc = "" ] # [ doc = "arcTo() appends up to four conic curves." ] # [ doc = "arcTo() implements the functionality of SVG arc, although SVG sweep-flag value" ] # [ doc = "is opposite the integer value of sweep; SVG sweep-flag uses 1 for clockwise," ] # [ doc = "while kCW_Direction cast to int is zero." ] # [ doc = "" ] # [ doc = "@param rx           radius on x-axis before x-axis rotation" ] # [ doc = "@param ry           radius on y-axis before x-axis rotation" ] # [ doc = "@param xAxisRotate  x-axis rotation in degrees; positive values are clockwise" ] # [ doc = "@param largeArc     chooses smaller or larger arc" ] # [ doc = "@param sweep        chooses clockwise or counterclockwise arc" ] # [ doc = "@param x            end of arc" ] # [ doc = "@param y            end of arc" ] # [ doc = "@return             reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath5arcToEfffNS_7ArcSizeENS_9DirectionEff" ] pub fn SkPath_arcTo3 ( this : * mut SkPath , rx : SkScalar , ry : SkScalar , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPath_Direction , x : SkScalar , y : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends arc to SkPath. Arc is implemented by one or more conic weighted to describe" ] # [ doc = "part of oval with radii (r.fX, r.fY) rotated by xAxisRotate degrees. Arc curves" ] # [ doc = "from last SkPath SkPoint to (xy.fX, xy.fY), choosing one of four possible routes:" ] # [ doc = "clockwise or counterclockwise," ] # [ doc = "and smaller or larger." ] # [ doc = "" ] # [ doc = "Arc sweep is always less than 360 degrees. arcTo() appends line to xy if either" ] # [ doc = "radii are zero, or if last SkPath SkPoint equals (xy.fX, xy.fY). arcTo() scales radii r to" ] # [ doc = "fit last SkPath SkPoint and xy if both are greater than zero but too small to describe" ] # [ doc = "an arc." ] # [ doc = "" ] # [ doc = "arcTo() appends up to four conic curves." ] # [ doc = "arcTo() implements the functionality of SVG arc, although SVG sweep-flag value is" ] # [ doc = "opposite the integer value of sweep; SVG sweep-flag uses 1 for clockwise, while" ] # [ doc = "kCW_Direction cast to int is zero." ] # [ doc = "" ] # [ doc = "@param r            radii on axes before x-axis rotation" ] # [ doc = "@param xAxisRotate  x-axis rotation in degrees; positive values are clockwise" ] # [ doc = "@param largeArc     chooses smaller or larger arc" ] # [ doc = "@param sweep        chooses clockwise or counterclockwise arc" ] # [ doc = "@param xy           end of arc" ] # [ doc = "@return             reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath5arcToE7SkPointfNS_7ArcSizeENS_9DirectionES0_" ] pub fn SkPath_arcTo4 ( this : * mut SkPath , r : SkPoint , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPath_Direction , xy : SkPoint ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends arc to SkPath, relative to last SkPath SkPoint. Arc is implemented by one or" ] # [ doc = "more conic, weighted to describe part of oval with radii (rx, ry) rotated by" ] # [ doc = "xAxisRotate degrees. Arc curves from last SkPath SkPoint to relative end SkPoint:" ] # [ doc = "(dx, dy), choosing one of four possible routes: clockwise or" ] # [ doc = "counterclockwise, and smaller or larger. If SkPath is empty, the start arc SkPoint" ] # [ doc = "is (0, 0)." ] # [ doc = "" ] # [ doc = "Arc sweep is always less than 360 degrees. arcTo() appends line to end SkPoint" ] # [ doc = "if either radii are zero, or if last SkPath SkPoint equals end SkPoint." ] # [ doc = "arcTo() scales radii (rx, ry) to fit last SkPath SkPoint and end SkPoint if both are" ] # [ doc = "greater than zero but too small to describe an arc." ] # [ doc = "" ] # [ doc = "arcTo() appends up to four conic curves." ] # [ doc = "arcTo() implements the functionality of svg arc, although SVG \"sweep-flag\" value is" ] # [ doc = "opposite the integer value of sweep; SVG \"sweep-flag\" uses 1 for clockwise, while" ] # [ doc = "kCW_Direction cast to int is zero." ] # [ doc = "" ] # [ doc = "@param rx           radius before x-axis rotation" ] # [ doc = "@param ry           radius before x-axis rotation" ] # [ doc = "@param xAxisRotate  x-axis rotation in degrees; positive values are clockwise" ] # [ doc = "@param largeArc     chooses smaller or larger arc" ] # [ doc = "@param sweep        chooses clockwise or counterclockwise arc" ] # [ doc = "@param dx           x-axis offset end of arc from last SkPath SkPoint" ] # [ doc = "@param dy           y-axis offset end of arc from last SkPath SkPoint" ] # [ doc = "@return             reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6rArcToEfffNS_7ArcSizeENS_9DirectionEff" ] pub fn SkPath_rArcTo ( this : * mut SkPath , rx : SkScalar , ry : SkScalar , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPath_Direction , dx : SkScalar , dy : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends kClose_Verb to SkPath. A closed contour connects the first and last SkPoint" ] # [ doc = "with line, forming a continuous loop. Open and closed contour draw the same" ] # [ doc = "with SkPaint::kFill_Style. With SkPaint::kStroke_Style, open contour draws" ] # [ doc = "SkPaint::Cap at contour start and end; closed contour draws" ] # [ doc = "SkPaint::Join at contour start and end." ] # [ doc = "" ] # [ doc = "close() has no effect if SkPath is empty or last SkPath SkPath::Verb is kClose_Verb." ] # [ doc = "" ] # [ doc = "@return  reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath5closeEv" ] pub fn SkPath_close ( this : * mut SkPath ) -> * mut SkPath ; } extern "C" { # [ doc = " Returns true if fill is inverted and SkPath with fill represents area outside" ] # [ doc = "of its geometric bounds." ] # [ doc = "" ] # [ doc = "@param fill  one of: kWinding_FillType, kEvenOdd_FillType," ] # [ doc = "kInverseWinding_FillType, kInverseEvenOdd_FillType" ] # [ doc = "@return      true if SkPath fills outside its bounds" ] # [ link_name = "\u{1}__ZN6SkPath17IsInverseFillTypeENS_8FillTypeE" ] pub fn SkPath_IsInverseFillType ( fill : SkPath_FillType ) -> bool ; } extern "C" { # [ doc = " Returns equivalent SkPath::FillType representing SkPath fill inside its bounds." ] # [ doc = "." ] # [ doc = "" ] # [ doc = "@param fill  one of: kWinding_FillType, kEvenOdd_FillType," ] # [ doc = "kInverseWinding_FillType, kInverseEvenOdd_FillType" ] # [ doc = "@return      fill, or kWinding_FillType or kEvenOdd_FillType if fill is inverted" ] # [ link_name = "\u{1}__ZN6SkPath27ConvertToNonInverseFillTypeENS_8FillTypeE" ] pub fn SkPath_ConvertToNonInverseFillType ( fill : SkPath_FillType ) -> SkPath_FillType ; } extern "C" { # [ doc = " Approximates conic with quad array. Conic is constructed from start SkPoint p0," ] # [ doc = "control SkPoint p1, end SkPoint p2, and weight w." ] # [ doc = "Quad array is stored in pts; this storage is supplied by caller." ] # [ doc = "Maximum quad count is 2 to the pow2." ] # [ doc = "Every third point in array shares last SkPoint of previous quad and first SkPoint of" ] # [ doc = "next quad. Maximum pts storage size is given by:" ] # [ doc = "(1 + 2 * (1 << pow2)) * sizeof(SkPoint)." ] # [ doc = "" ] # [ doc = "Returns quad count used the approximation, which may be smaller" ] # [ doc = "than the number requested." ] # [ doc = "" ] # [ doc = "conic weight determines the amount of influence conic control point has on the curve." ] # [ doc = "w less than one represents an elliptical section. w greater than one represents" ] # [ doc = "a hyperbolic section. w equal to one represents a parabolic section." ] # [ doc = "" ] # [ doc = "Two quad curves are sufficient to approximate an elliptical conic with a sweep" ] # [ doc = "of up to 90 degrees; in this case, set pow2 to one." ] # [ doc = "" ] # [ doc = "@param p0    conic start SkPoint" ] # [ doc = "@param p1    conic control SkPoint" ] # [ doc = "@param p2    conic end SkPoint" ] # [ doc = "@param w     conic weight" ] # [ doc = "@param pts   storage for quad array" ] # [ doc = "@param pow2  quad count, as power of two, normally 0 to 5 (1 to 32 quad curves)" ] # [ doc = "@return      number of quad curves written to pts" ] # [ link_name = "\u{1}__ZN6SkPath19ConvertConicToQuadsERK7SkPointS2_S2_fPS0_i" ] pub fn SkPath_ConvertConicToQuads ( p0 : * const SkPoint , p1 : * const SkPoint , p2 : * const SkPoint , w : SkScalar , pts : * mut SkPoint , pow2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns true if SkPath is equivalent to SkRect when filled." ] # [ doc = "If false: rect, isClosed, and direction are unchanged." ] # [ doc = "If true: rect, isClosed, and direction are written to if not nullptr." ] # [ doc = "" ] # [ doc = "rect may be smaller than the SkPath bounds. SkPath bounds may include kMove_Verb points" ] # [ doc = "that do not alter the area drawn by the returned rect." ] # [ doc = "" ] # [ doc = "@param rect       storage for bounds of SkRect; may be nullptr" ] # [ doc = "@param isClosed   storage set to true if SkPath is closed; may be nullptr" ] # [ doc = "@param direction  storage set to SkRect direction; may be nullptr" ] # [ doc = "@return           true if SkPath contains SkRect" ] # [ link_name = "\u{1}__ZNK6SkPath6isRectEP6SkRectPbPNS_9DirectionE" ] pub fn SkPath_isRect ( this : * const SkPath , rect : * mut SkRect , isClosed : * mut bool , direction : * mut SkPath_Direction ) -> bool ; } extern "C" { # [ doc = " Returns true if SkPath is equivalent to nested SkRect pair when filled." ] # [ doc = "If false, rect and dirs are unchanged." ] # [ doc = "If true, rect and dirs are written to if not nullptr:" ] # [ doc = "setting rect[0] to outer SkRect, and rect[1] to inner SkRect;" ] # [ doc = "setting dirs[0] to SkPath::Direction of outer SkRect, and dirs[1] to SkPath::Direction of" ] # [ doc = "inner SkRect." ] # [ doc = "" ] # [ doc = "@param rect  storage for SkRect pair; may be nullptr" ] # [ doc = "@param dirs  storage for SkPath::Direction pair; may be nullptr" ] # [ doc = "@return      true if SkPath contains nested SkRect pair" ] # [ link_name = "\u{1}__ZNK6SkPath17isNestedFillRectsEP6SkRectPNS_9DirectionE" ] pub fn SkPath_isNestedFillRects ( this : * const SkPath , rect : * mut SkRect , dirs : * mut SkPath_Direction ) -> bool ; } extern "C" { # [ doc = " Adds SkRect to SkPath, appending kMove_Verb, three kLine_Verb, and kClose_Verb," ] # [ doc = "starting with top-left corner of SkRect; followed by top-right, bottom-right," ] # [ doc = "and bottom-left if dir is kCW_Direction; or followed by bottom-left," ] # [ doc = "bottom-right, and top-right if dir is kCCW_Direction." ] # [ doc = "" ] # [ doc = "@param rect  SkRect to add as a closed contour" ] # [ doc = "@param dir   SkPath::Direction to wind added contour" ] # [ doc = "@return      reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addRectERK6SkRectNS_9DirectionE" ] pub fn SkPath_addRect ( this : * mut SkPath , rect : * const SkRect , dir : SkPath_Direction ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds SkRect to SkPath, appending kMove_Verb, three kLine_Verb, and kClose_Verb." ] # [ doc = "If dir is kCW_Direction, SkRect corners are added clockwise; if dir is" ] # [ doc = "kCCW_Direction, SkRect corners are added counterclockwise." ] # [ doc = "start determines the first corner added." ] # [ doc = "" ] # [ doc = "@param rect   SkRect to add as a closed contour" ] # [ doc = "@param dir    SkPath::Direction to wind added contour" ] # [ doc = "@param start  initial corner of SkRect to add" ] # [ doc = "@return       reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addRectERK6SkRectNS_9DirectionEj" ] pub fn SkPath_addRect1 ( this : * mut SkPath , rect : * const SkRect , dir : SkPath_Direction , start : :: std :: os :: raw :: c_uint ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds SkRect (left, top, right, bottom) to SkPath," ] # [ doc = "appending kMove_Verb, three kLine_Verb, and kClose_Verb," ] # [ doc = "starting with top-left corner of SkRect; followed by top-right, bottom-right," ] # [ doc = "and bottom-left if dir is kCW_Direction; or followed by bottom-left," ] # [ doc = "bottom-right, and top-right if dir is kCCW_Direction." ] # [ doc = "" ] # [ doc = "@param left    smaller x-axis value of SkRect" ] # [ doc = "@param top     smaller y-axis value of SkRect" ] # [ doc = "@param right   larger x-axis value of SkRect" ] # [ doc = "@param bottom  larger y-axis value of SkRect" ] # [ doc = "@param dir     SkPath::Direction to wind added contour" ] # [ doc = "@return        reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addRectEffffNS_9DirectionE" ] pub fn SkPath_addRect2 ( this : * mut SkPath , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar , dir : SkPath_Direction ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds oval to path, appending kMove_Verb, four kConic_Verb, and kClose_Verb." ] # [ doc = "Oval is upright ellipse bounded by SkRect oval with radii equal to half oval width" ] # [ doc = "and half oval height. Oval begins at (oval.fRight, oval.centerY()) and continues" ] # [ doc = "clockwise if dir is kCW_Direction, counterclockwise if dir is kCCW_Direction." ] # [ doc = "" ] # [ doc = "@param oval  bounds of ellipse added" ] # [ doc = "@param dir   SkPath::Direction to wind ellipse" ] # [ doc = "@return      reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addOvalERK6SkRectNS_9DirectionE" ] pub fn SkPath_addOval ( this : * mut SkPath , oval : * const SkRect , dir : SkPath_Direction ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds oval to SkPath, appending kMove_Verb, four kConic_Verb, and kClose_Verb." ] # [ doc = "Oval is upright ellipse bounded by SkRect oval with radii equal to half oval width" ] # [ doc = "and half oval height. Oval begins at start and continues" ] # [ doc = "clockwise if dir is kCW_Direction, counterclockwise if dir is kCCW_Direction." ] # [ doc = "" ] # [ doc = "@param oval   bounds of ellipse added" ] # [ doc = "@param dir    SkPath::Direction to wind ellipse" ] # [ doc = "@param start  index of initial point of ellipse" ] # [ doc = "@return       reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addOvalERK6SkRectNS_9DirectionEj" ] pub fn SkPath_addOval1 ( this : * mut SkPath , oval : * const SkRect , dir : SkPath_Direction , start : :: std :: os :: raw :: c_uint ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds circle centered at (x, y) of size radius to SkPath, appending kMove_Verb," ] # [ doc = "four kConic_Verb, and kClose_Verb. Circle begins at: (x + radius, y), continuing" ] # [ doc = "clockwise if dir is kCW_Direction, and counterclockwise if dir is kCCW_Direction." ] # [ doc = "" ] # [ doc = "Has no effect if radius is zero or negative." ] # [ doc = "" ] # [ doc = "@param x       center of circle" ] # [ doc = "@param y       center of circle" ] # [ doc = "@param radius  distance from center to edge" ] # [ doc = "@param dir     SkPath::Direction to wind circle" ] # [ doc = "@return        reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath9addCircleEfffNS_9DirectionE" ] pub fn SkPath_addCircle ( this : * mut SkPath , x : SkScalar , y : SkScalar , radius : SkScalar , dir : SkPath_Direction ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends arc to SkPath, as the start of new contour. Arc added is part of ellipse" ] # [ doc = "bounded by oval, from startAngle through sweepAngle. Both startAngle and" ] # [ doc = "sweepAngle are measured in degrees, where zero degrees is aligned with the" ] # [ doc = "positive x-axis, and positive sweeps extends arc clockwise." ] # [ doc = "" ] # [ doc = "If sweepAngle <= -360, or sweepAngle >= 360; and startAngle modulo 90 is nearly" ] # [ doc = "zero, append oval instead of arc. Otherwise, sweepAngle values are treated" ] # [ doc = "modulo 360, and arc may or may not draw depending on numeric rounding." ] # [ doc = "" ] # [ doc = "@param oval        bounds of ellipse containing arc" ] # [ doc = "@param startAngle  starting angle of arc in degrees" ] # [ doc = "@param sweepAngle  sweep, in degrees. Positive is clockwise; treated modulo 360" ] # [ doc = "@return            reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath6addArcERK6SkRectff" ] pub fn SkPath_addArc ( this : * mut SkPath , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends SkRRect to SkPath, creating a new closed contour. SkRRect has bounds" ] # [ doc = "equal to rect; each corner is 90 degrees of an ellipse with radii (rx, ry). If" ] # [ doc = "dir is kCW_Direction, SkRRect starts at top-left of the lower-left corner and" ] # [ doc = "winds clockwise. If dir is kCCW_Direction, SkRRect starts at the bottom-left" ] # [ doc = "of the upper-left corner and winds counterclockwise." ] # [ doc = "" ] # [ doc = "If either rx or ry is too large, rx and ry are scaled uniformly until the" ] # [ doc = "corners fit. If rx or ry is less than or equal to zero, addRoundRect() appends" ] # [ doc = "SkRect rect to SkPath." ] # [ doc = "" ] # [ doc = "After appending, SkPath may be empty, or may contain: SkRect, oval, or SkRRect." ] # [ doc = "" ] # [ doc = "@param rect  bounds of SkRRect" ] # [ doc = "@param rx    x-axis radius of rounded corners on the SkRRect" ] # [ doc = "@param ry    y-axis radius of rounded corners on the SkRRect" ] # [ doc = "@param dir   SkPath::Direction to wind SkRRect" ] # [ doc = "@return      reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath12addRoundRectERK6SkRectffNS_9DirectionE" ] pub fn SkPath_addRoundRect ( this : * mut SkPath , rect : * const SkRect , rx : SkScalar , ry : SkScalar , dir : SkPath_Direction ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends SkRRect to SkPath, creating a new closed contour. SkRRect has bounds" ] # [ doc = "equal to rect; each corner is 90 degrees of an ellipse with radii from the" ] # [ doc = "array." ] # [ doc = "" ] # [ doc = "@param rect   bounds of SkRRect" ] # [ doc = "@param radii  array of 8 SkScalar values, a radius pair for each corner" ] # [ doc = "@param dir    SkPath::Direction to wind SkRRect" ] # [ doc = "@return       reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath12addRoundRectERK6SkRectPKfNS_9DirectionE" ] pub fn SkPath_addRoundRect1 ( this : * mut SkPath , rect : * const SkRect , radii : * const SkScalar , dir : SkPath_Direction ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds rrect to SkPath, creating a new closed contour. If" ] # [ doc = "dir is kCW_Direction, rrect starts at top-left of the lower-left corner and" ] # [ doc = "winds clockwise. If dir is kCCW_Direction, rrect starts at the bottom-left" ] # [ doc = "of the upper-left corner and winds counterclockwise." ] # [ doc = "" ] # [ doc = "After appending, SkPath may be empty, or may contain: SkRect, oval, or SkRRect." ] # [ doc = "" ] # [ doc = "@param rrect  bounds and radii of rounded rectangle" ] # [ doc = "@param dir    SkPath::Direction to wind SkRRect" ] # [ doc = "@return       reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath8addRRectERK7SkRRectNS_9DirectionE" ] pub fn SkPath_addRRect ( this : * mut SkPath , rrect : * const SkRRect , dir : SkPath_Direction ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds rrect to SkPath, creating a new closed contour. If dir is kCW_Direction, rrect" ] # [ doc = "winds clockwise; if dir is kCCW_Direction, rrect winds counterclockwise." ] # [ doc = "start determines the first point of rrect to add." ] # [ doc = "" ] # [ doc = "@param rrect  bounds and radii of rounded rectangle" ] # [ doc = "@param dir    SkPath::Direction to wind SkRRect" ] # [ doc = "@param start  index of initial point of SkRRect" ] # [ doc = "@return       reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath8addRRectERK7SkRRectNS_9DirectionEj" ] pub fn SkPath_addRRect1 ( this : * mut SkPath , rrect : * const SkRRect , dir : SkPath_Direction , start : :: std :: os :: raw :: c_uint ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds contour created from line array, adding (count - 1) line segments." ] # [ doc = "Contour added starts at pts[0], then adds a line for every additional SkPoint" ] # [ doc = "in pts array. If close is true, appends kClose_Verb to SkPath, connecting" ] # [ doc = "pts[count - 1] and pts[0]." ] # [ doc = "" ] # [ doc = "If count is zero, append kMove_Verb to path." ] # [ doc = "Has no effect if count is less than one." ] # [ doc = "" ] # [ doc = "@param pts    array of line sharing end and start SkPoint" ] # [ doc = "@param count  length of SkPoint array" ] # [ doc = "@param close  true to add line connecting contour end and start" ] # [ doc = "@return       reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addPolyEPK7SkPointib" ] pub fn SkPath_addPoly ( this : * mut SkPath , pts : * const SkPoint , count : :: std :: os :: raw :: c_int , close : bool ) -> * mut SkPath ; } extern "C" { # [ doc = " Adds contour created from list. Contour added starts at list[0], then adds a line" ] # [ doc = "for every additional SkPoint in list. If close is true, appends kClose_Verb to SkPath," ] # [ doc = "connecting last and first SkPoint in list." ] # [ doc = "" ] # [ doc = "If list is empty, append kMove_Verb to path." ] # [ doc = "" ] # [ doc = "@param list   array of SkPoint" ] # [ doc = "@param close  true to add line connecting contour end and start" ] # [ doc = "@return       reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addPolyERKSt16initializer_listI7SkPointEb" ] pub fn SkPath_addPoly1 ( this : * mut SkPath , list : * const std_initializer_list < SkPoint > , close : bool ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends src to SkPath, offset by (dx, dy)." ] # [ doc = "" ] # [ doc = "If mode is kAppend_AddPathMode, src verb array, SkPoint array, and conic weights are" ] # [ doc = "added unaltered. If mode is kExtend_AddPathMode, add line before appending" ] # [ doc = "verbs, SkPoint, and conic weights." ] # [ doc = "" ] # [ doc = "@param src   SkPath verbs, SkPoint, and conic weights to add" ] # [ doc = "@param dx    offset added to src SkPoint array x-axis coordinates" ] # [ doc = "@param dy    offset added to src SkPoint array y-axis coordinates" ] # [ doc = "@param mode  kAppend_AddPathMode or kExtend_AddPathMode" ] # [ doc = "@return      reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addPathERKS_ffNS_11AddPathModeE" ] pub fn SkPath_addPath ( this : * mut SkPath , src : * const SkPath , dx : SkScalar , dy : SkScalar , mode : SkPath_AddPathMode ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends src to SkPath." ] # [ doc = "" ] # [ doc = "If mode is kAppend_AddPathMode, src verb array, SkPoint array, and conic weights are" ] # [ doc = "added unaltered. If mode is kExtend_AddPathMode, add line before appending" ] # [ doc = "verbs, SkPoint, and conic weights." ] # [ doc = "" ] # [ doc = "@param src   SkPath verbs, SkPoint, and conic weights to add" ] # [ doc = "@param mode  kAppend_AddPathMode or kExtend_AddPathMode" ] # [ doc = "@return      reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addPathERKS_NS_11AddPathModeE" ] pub fn SkPath_addPath1 ( this : * mut SkPath , src : * const SkPath , mode : SkPath_AddPathMode ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends src to SkPath, transformed by matrix. Transformed curves may have different" ] # [ doc = "verbs, SkPoint, and conic weights." ] # [ doc = "" ] # [ doc = "If mode is kAppend_AddPathMode, src verb array, SkPoint array, and conic weights are" ] # [ doc = "added unaltered. If mode is kExtend_AddPathMode, add line before appending" ] # [ doc = "verbs, SkPoint, and conic weights." ] # [ doc = "" ] # [ doc = "@param src     SkPath verbs, SkPoint, and conic weights to add" ] # [ doc = "@param matrix  transform applied to src" ] # [ doc = "@param mode    kAppend_AddPathMode or kExtend_AddPathMode" ] # [ doc = "@return        reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath7addPathERKS_RK8SkMatrixNS_11AddPathModeE" ] pub fn SkPath_addPath2 ( this : * mut SkPath , src : * const SkPath , matrix : * const SkMatrix , mode : SkPath_AddPathMode ) -> * mut SkPath ; } extern "C" { # [ doc = " Appends src to SkPath, from back to front." ] # [ doc = "Reversed src always appends a new contour to SkPath." ] # [ doc = "" ] # [ doc = "@param src  SkPath verbs, SkPoint, and conic weights to add" ] # [ doc = "@return     reference to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath14reverseAddPathERKS_" ] pub fn SkPath_reverseAddPath ( this : * mut SkPath , src : * const SkPath ) -> * mut SkPath ; } extern "C" { # [ doc = " Offsets SkPoint array by (dx, dy). Offset SkPath replaces dst." ] # [ doc = "If dst is nullptr, SkPath is replaced by offset data." ] # [ doc = "" ] # [ doc = "@param dx   offset added to SkPoint array x-axis coordinates" ] # [ doc = "@param dy   offset added to SkPoint array y-axis coordinates" ] # [ doc = "@param dst  overwritten, translated copy of SkPath; may be nullptr" ] # [ link_name = "\u{1}__ZNK6SkPath6offsetEffPS_" ] pub fn SkPath_offset ( this : * const SkPath , dx : SkScalar , dy : SkScalar , dst : * mut SkPath ) ; } extern "C" { # [ doc = " Offsets SkPoint array by (dx, dy). SkPath is replaced by offset data." ] # [ doc = "" ] # [ doc = "@param dx  offset added to SkPoint array x-axis coordinates" ] # [ doc = "@param dy  offset added to SkPoint array y-axis coordinates" ] # [ link_name = "\u{1}__ZN6SkPath6offsetEff" ] pub fn SkPath_offset1 ( this : * mut SkPath , dx : SkScalar , dy : SkScalar ) ; } extern "C" { # [ doc = " Transforms verb array, SkPoint array, and weight by matrix." ] # [ doc = "transform may change verbs and increase their number." ] # [ doc = "Transformed SkPath replaces dst; if dst is nullptr, original data" ] # [ doc = "is replaced." ] # [ doc = "" ] # [ doc = "@param matrix  SkMatrix to apply to SkPath" ] # [ doc = "@param dst     overwritten, transformed copy of SkPath; may be nullptr" ] # [ link_name = "\u{1}__ZNK6SkPath9transformERK8SkMatrixPS_" ] pub fn SkPath_transform ( this : * const SkPath , matrix : * const SkMatrix , dst : * mut SkPath ) ; } extern "C" { # [ doc = " Transforms verb array, SkPoint array, and weight by matrix." ] # [ doc = "transform may change verbs and increase their number." ] # [ doc = "SkPath is replaced by transformed data." ] # [ doc = "" ] # [ doc = "@param matrix  SkMatrix to apply to SkPath" ] # [ link_name = "\u{1}__ZN6SkPath9transformERK8SkMatrix" ] pub fn SkPath_transform1 ( this : * mut SkPath , matrix : * const SkMatrix ) ; } extern "C" { # [ doc = " Returns last point on SkPath in lastPt. Returns false if SkPoint array is empty," ] # [ doc = "storing (0, 0) if lastPt is not nullptr." ] # [ doc = "" ] # [ doc = "@param lastPt  storage for final SkPoint in SkPoint array; may be nullptr" ] # [ doc = "@return        true if SkPoint array contains one or more SkPoint" ] # [ link_name = "\u{1}__ZNK6SkPath9getLastPtEP7SkPoint" ] pub fn SkPath_getLastPt ( this : * const SkPath , lastPt : * mut SkPoint ) -> bool ; } extern "C" { # [ doc = " Sets last point to (x, y). If SkPoint array is empty, append kMove_Verb to" ] # [ doc = "verb array and append (x, y) to SkPoint array." ] # [ doc = "" ] # [ doc = "@param x  set x-axis value of last point" ] # [ doc = "@param y  set y-axis value of last point" ] # [ link_name = "\u{1}__ZN6SkPath9setLastPtEff" ] pub fn SkPath_setLastPt ( this : * mut SkPath , x : SkScalar , y : SkScalar ) ; } extern "C" { # [ doc = " Sets the last point on the path. If SkPoint array is empty, append kMove_Verb to" ] # [ doc = "verb array and append p to SkPoint array." ] # [ doc = "" ] # [ doc = "@param p  set value of last point" ] # [ link_name = "\u{1}__ZN6SkPath9setLastPtERK7SkPoint" ] pub fn SkPath_setLastPt1 ( this : * mut SkPath , p : * const SkPoint ) ; } extern "C" { # [ doc = " Returns a mask, where each set bit corresponds to a SegmentMask constant" ] # [ doc = "if SkPath contains one or more verbs of that type." ] # [ doc = "Returns zero if SkPath contains no lines, or curves: quads, conics, or cubics." ] # [ doc = "" ] # [ doc = "getSegmentMasks() returns a cached result; it is very fast." ] # [ doc = "" ] # [ doc = "@return  SegmentMask bits or zero" ] # [ link_name = "\u{1}__ZNK6SkPath15getSegmentMasksEv" ] pub fn SkPath_getSegmentMasks ( this : * const SkPath ) -> u32 ; } extern "C" { # [ doc = " Returns true if the point (x, y) is contained by SkPath, taking into" ] # [ doc = "account FillType." ] # [ doc = "" ] # [ doc = "@param x  x-axis value of containment test" ] # [ doc = "@param y  y-axis value of containment test" ] # [ doc = "@return   true if SkPoint is in SkPath" ] # [ link_name = "\u{1}__ZNK6SkPath8containsEff" ] pub fn SkPath_contains ( this : * const SkPath , x : SkScalar , y : SkScalar ) -> bool ; } extern "C" { # [ doc = " Writes text representation of SkPath to stream. If stream is nullptr, writes to" ] # [ doc = "standard output. Set forceClose to true to get edges used to fill SkPath." ] # [ doc = "Set dumpAsHex true to generate exact binary representations" ] # [ doc = "of floating point numbers used in SkPoint array and conic weights." ] # [ doc = "" ] # [ doc = "@param stream      writable SkWStream receiving SkPath text representation; may be nullptr" ] # [ doc = "@param forceClose  true if missing kClose_Verb is output" ] # [ doc = "@param dumpAsHex   true if SkScalar values are written as hexadecimal" ] # [ link_name = "\u{1}__ZNK6SkPath4dumpEP9SkWStreambb" ] pub fn SkPath_dump ( this : * const SkPath , stream : * mut SkWStream , forceClose : bool , dumpAsHex : bool ) ; } extern "C" { # [ doc = " Writes text representation of SkPath to standard output. The representation may be" ] # [ doc = "directly compiled as C++ code. Floating point values are written" ] # [ doc = "with limited precision; it may not be possible to reconstruct original SkPath" ] # [ doc = "from output." ] # [ link_name = "\u{1}__ZNK6SkPath4dumpEv" ] pub fn SkPath_dump1 ( this : * const SkPath ) ; } extern "C" { # [ doc = " Writes text representation of SkPath to standard output. The representation may be" ] # [ doc = "directly compiled as C++ code. Floating point values are written" ] # [ doc = "in hexadecimal to preserve their exact bit pattern. The output reconstructs the" ] # [ doc = "original SkPath." ] # [ doc = "" ] # [ doc = "Use instead of dump() when submitting" ] # [ link_name = "\u{1}__ZNK6SkPath7dumpHexEv" ] pub fn SkPath_dumpHex ( this : * const SkPath ) ; } extern "C" { # [ doc = " Writes SkPath to buffer, returning the number of bytes written." ] # [ doc = "Pass nullptr to obtain the storage size." ] # [ doc = "" ] # [ doc = "Writes SkPath::FillType, verb array, SkPoint array, conic weight, and" ] # [ doc = "additionally writes computed information like SkPath::Convexity and bounds." ] # [ doc = "" ] # [ doc = "Use only be used in concert with readFromMemory();" ] # [ doc = "the format used for SkPath in memory is not guaranteed." ] # [ doc = "" ] # [ doc = "@param buffer  storage for SkPath; may be nullptr" ] # [ doc = "@return        size of storage required for SkPath; always a multiple of 4" ] # [ link_name = "\u{1}__ZNK6SkPath13writeToMemoryEPv" ] pub fn SkPath_writeToMemory ( this : * const SkPath , buffer : * mut :: std :: os :: raw :: c_void ) -> usize ; } extern "C" { # [ doc = " Writes SkPath to buffer, returning the buffer written to, wrapped in SkData." ] # [ doc = "" ] # [ doc = "serialize() writes SkPath::FillType, verb array, SkPoint array, conic weight, and" ] # [ doc = "additionally writes computed information like SkPath::Convexity and bounds." ] # [ doc = "" ] # [ doc = "serialize() should only be used in concert with readFromMemory()." ] # [ doc = "The format used for SkPath in memory is not guaranteed." ] # [ doc = "" ] # [ doc = "@return  SkPath data wrapped in SkData buffer" ] # [ link_name = "\u{1}__ZNK6SkPath9serializeEv" ] pub fn SkPath_serialize ( this : * const SkPath ) -> sk_sp < SkData > ; } extern "C" { # [ doc = " Initializes SkPath from buffer of size length. Returns zero if the buffer is" ] # [ doc = "data is inconsistent, or the length is too small." ] # [ doc = "" ] # [ doc = "Reads SkPath::FillType, verb array, SkPoint array, conic weight, and" ] # [ doc = "additionally reads computed information like SkPath::Convexity and bounds." ] # [ doc = "" ] # [ doc = "Used only in concert with writeToMemory();" ] # [ doc = "the format used for SkPath in memory is not guaranteed." ] # [ doc = "" ] # [ doc = "@param buffer  storage for SkPath" ] # [ doc = "@param length  buffer size in bytes; must be multiple of 4" ] # [ doc = "@return        number of bytes read, or zero on failure" ] # [ link_name = "\u{1}__ZN6SkPath14readFromMemoryEPKvm" ] pub fn SkPath_readFromMemory ( this : * mut SkPath , buffer : * const :: std :: os :: raw :: c_void , length : usize ) -> usize ; } extern "C" { # [ doc = " (See Skia bug 1762.)" ] # [ doc = "Returns a non-zero, globally unique value. A different value is returned" ] # [ doc = "if verb array, SkPoint array, or conic weight changes." ] # [ doc = "" ] # [ doc = "Setting SkPath::FillType does not change generation identifier." ] # [ doc = "" ] # [ doc = "Each time the path is modified, a different generation identifier will be returned." ] # [ doc = "SkPath::FillType does affect generation identifier on Android framework." ] # [ doc = "" ] # [ doc = "@return  non-zero, globally unique value" ] # [ link_name = "\u{1}__ZNK6SkPath15getGenerationIDEv" ] pub fn SkPath_getGenerationID ( this : * const SkPath ) -> u32 ; } extern "C" { # [ doc = " Returns if SkPath data is consistent. Corrupt SkPath data is detected if" ] # [ doc = "internal values are out of range or internal storage does not match" ] # [ doc = "array dimensions." ] # [ doc = "" ] # [ doc = "@return  true if SkPath data is consistent" ] # [ link_name = "\u{1}__ZNK6SkPath7isValidEv" ] pub fn SkPath_isValid ( this : * const SkPath ) -> bool ; } extern "C" { # [ doc = " Constructs an empty SkPath. By default, SkPath has no verbs, no SkPoint, and no weights." ] # [ doc = "SkPath::FillType is set to kWinding_FillType." ] # [ doc = "" ] # [ doc = "@return  empty SkPath" ] # [ link_name = "\u{1}__ZN6SkPathC1Ev" ] pub fn SkPath_SkPath ( this : * mut SkPath ) ; } extern "C" { # [ doc = " Constructs a copy of an existing path." ] # [ doc = "Copy constructor makes two paths identical by value. Internally, path and" ] # [ doc = "the returned result share pointer values. The underlying verb array, SkPoint array" ] # [ doc = "and weights are copied when modified." ] # [ doc = "" ] # [ doc = "Creating a SkPath copy is very efficient and never allocates memory." ] # [ doc = "SkPath are always copied by value from the interface; the underlying shared" ] # [ doc = "pointers are not exposed." ] # [ doc = "" ] # [ doc = "@param path  SkPath to copy by value" ] # [ doc = "@return      copy of SkPath" ] # [ link_name = "\u{1}__ZN6SkPathC1ERKS_" ] pub fn SkPath_SkPath1 ( this : * mut SkPath , path : * const SkPath ) ; } extern "C" { # [ doc = " Releases ownership of any shared data and deletes data if SkPath is sole owner." ] # [ link_name = "\u{1}__ZN6SkPathD1Ev" ] pub fn SkPath_SkPath_destructor ( this : * mut SkPath ) ; } impl SkPath { # [ inline ] pub fn fFillType ( & self ) -> u8 { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_fFillType ( & mut self , val : u8 ) { unsafe { let val : u8 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn fIsVolatile ( & self ) -> u8 { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_fIsVolatile ( & mut self , val : u8 ) { unsafe { let val : u8 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fIsBadForDAA ( & self ) -> u8 { unsafe { :: core :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_fIsBadForDAA ( & mut self , val : u8 ) { unsafe { let val : u8 = :: core :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( fFillType : u8 , fIsVolatile : u8 , fIsBadForDAA : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let fFillType : u8 = unsafe { :: core :: mem :: transmute ( fFillType ) } ; fFillType as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let fIsVolatile : u8 = unsafe { :: core :: mem :: transmute ( fIsVolatile ) } ; fIsVolatile as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let fIsBadForDAA : u8 = unsafe { :: core :: mem :: transmute ( fIsBadForDAA ) } ; fIsBadForDAA as u64 } ) ; __bindgen_bitfield_unit } # [ inline ] pub unsafe fn isInterpolatable ( & self , compare : * const SkPath ) -> bool { SkPath_isInterpolatable ( self , compare ) } # [ inline ] pub unsafe fn interpolate ( & self , ending : * const SkPath , weight : SkScalar , out : * mut SkPath ) -> bool { SkPath_interpolate ( self , ending , weight , out ) } # [ inline ] pub unsafe fn getFillType ( & self ) -> SkPath_FillType { SkPath_getFillType ( self ) } # [ inline ] pub unsafe fn setFillType ( & mut self , ft : SkPath_FillType ) { SkPath_setFillType ( self , ft ) } # [ inline ] pub unsafe fn isInverseFillType ( & self ) -> bool { SkPath_isInverseFillType ( self ) } # [ inline ] pub unsafe fn toggleInverseFillType ( & mut self ) { SkPath_toggleInverseFillType ( self ) } # [ inline ] pub unsafe fn getConvexity ( & self ) -> SkPath_Convexity { SkPath_getConvexity ( self ) } # [ inline ] pub unsafe fn getConvexityOrUnknown ( & self ) -> SkPath_Convexity { SkPath_getConvexityOrUnknown ( self ) } # [ inline ] pub unsafe fn setConvexity ( & mut self , convexity : SkPath_Convexity ) { SkPath_setConvexity ( self , convexity ) } # [ inline ] pub unsafe fn isConvex ( & self ) -> bool { SkPath_isConvex ( self ) } # [ inline ] pub unsafe fn isOval ( & self , bounds : * mut SkRect ) -> bool { SkPath_isOval ( self , bounds ) } # [ inline ] pub unsafe fn isRRect ( & self , rrect : * mut SkRRect ) -> bool { SkPath_isRRect ( self , rrect ) } # [ inline ] pub unsafe fn reset ( & mut self ) -> * mut SkPath { SkPath_reset ( self ) } # [ inline ] pub unsafe fn rewind ( & mut self ) -> * mut SkPath { SkPath_rewind ( self ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkPath_isEmpty ( self ) } # [ inline ] pub unsafe fn isLastContourClosed ( & self ) -> bool { SkPath_isLastContourClosed ( self ) } # [ inline ] pub unsafe fn isFinite ( & self ) -> bool { SkPath_isFinite ( self ) } # [ inline ] pub unsafe fn isVolatile ( & self ) -> bool { SkPath_isVolatile ( self ) } # [ inline ] pub unsafe fn setIsVolatile ( & mut self , isVolatile : bool ) { SkPath_setIsVolatile ( self , isVolatile ) } # [ inline ] pub unsafe fn IsLineDegenerate ( p1 : * const SkPoint , p2 : * const SkPoint , exact : bool ) -> bool { SkPath_IsLineDegenerate ( p1 , p2 , exact ) } # [ inline ] pub unsafe fn IsQuadDegenerate ( p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint , exact : bool ) -> bool { SkPath_IsQuadDegenerate ( p1 , p2 , p3 , exact ) } # [ inline ] pub unsafe fn IsCubicDegenerate ( p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint , p4 : * const SkPoint , exact : bool ) -> bool { SkPath_IsCubicDegenerate ( p1 , p2 , p3 , p4 , exact ) } # [ inline ] pub unsafe fn isLine ( & self , line : * mut SkPoint ) -> bool { SkPath_isLine ( self , line ) } # [ inline ] pub unsafe fn countPoints ( & self ) -> :: std :: os :: raw :: c_int { SkPath_countPoints ( self ) } # [ inline ] pub unsafe fn getPoint ( & self , index : :: std :: os :: raw :: c_int ) -> SkPoint { SkPath_getPoint ( self , index ) } # [ inline ] pub unsafe fn getPoints ( & self , points : * mut SkPoint , max : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int { SkPath_getPoints ( self , points , max ) } # [ inline ] pub unsafe fn countVerbs ( & self ) -> :: std :: os :: raw :: c_int { SkPath_countVerbs ( self ) } # [ inline ] pub unsafe fn getVerbs ( & self , verbs : * mut u8 , max : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int { SkPath_getVerbs ( self , verbs , max ) } # [ inline ] pub unsafe fn swap ( & mut self , other : * mut SkPath ) { SkPath_swap ( self , other ) } # [ inline ] pub unsafe fn getBounds ( & self ) -> * const SkRect { SkPath_getBounds ( self ) } # [ inline ] pub unsafe fn updateBoundsCache ( & self ) { SkPath_updateBoundsCache ( self ) } # [ inline ] pub unsafe fn computeTightBounds ( & self ) -> SkRect { SkPath_computeTightBounds ( self ) } # [ inline ] pub unsafe fn conservativelyContainsRect ( & self , rect : * const SkRect ) -> bool { SkPath_conservativelyContainsRect ( self , rect ) } # [ inline ] pub unsafe fn incReserve ( & mut self , extraPtCount : :: std :: os :: raw :: c_int ) { SkPath_incReserve ( self , extraPtCount ) } # [ inline ] pub unsafe fn shrinkToFit ( & mut self ) { SkPath_shrinkToFit ( self ) } # [ inline ] pub unsafe fn moveTo ( & mut self , x : SkScalar , y : SkScalar ) -> * mut SkPath { SkPath_moveTo ( self , x , y ) } # [ inline ] pub unsafe fn moveTo1 ( & mut self , p : * const SkPoint ) -> * mut SkPath { SkPath_moveTo1 ( self , p ) } # [ inline ] pub unsafe fn rMoveTo ( & mut self , dx : SkScalar , dy : SkScalar ) -> * mut SkPath { SkPath_rMoveTo ( self , dx , dy ) } # [ inline ] pub unsafe fn lineTo ( & mut self , x : SkScalar , y : SkScalar ) -> * mut SkPath { SkPath_lineTo ( self , x , y ) } # [ inline ] pub unsafe fn lineTo1 ( & mut self , p : * const SkPoint ) -> * mut SkPath { SkPath_lineTo1 ( self , p ) } # [ inline ] pub unsafe fn rLineTo ( & mut self , dx : SkScalar , dy : SkScalar ) -> * mut SkPath { SkPath_rLineTo ( self , dx , dy ) } # [ inline ] pub unsafe fn quadTo ( & mut self , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar ) -> * mut SkPath { SkPath_quadTo ( self , x1 , y1 , x2 , y2 ) } # [ inline ] pub unsafe fn quadTo1 ( & mut self , p1 : * const SkPoint , p2 : * const SkPoint ) -> * mut SkPath { SkPath_quadTo1 ( self , p1 , p2 ) } # [ inline ] pub unsafe fn rQuadTo ( & mut self , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar ) -> * mut SkPath { SkPath_rQuadTo ( self , dx1 , dy1 , dx2 , dy2 ) } # [ inline ] pub unsafe fn conicTo ( & mut self , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , w : SkScalar ) -> * mut SkPath { SkPath_conicTo ( self , x1 , y1 , x2 , y2 , w ) } # [ inline ] pub unsafe fn conicTo1 ( & mut self , p1 : * const SkPoint , p2 : * const SkPoint , w : SkScalar ) -> * mut SkPath { SkPath_conicTo1 ( self , p1 , p2 , w ) } # [ inline ] pub unsafe fn rConicTo ( & mut self , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar , w : SkScalar ) -> * mut SkPath { SkPath_rConicTo ( self , dx1 , dy1 , dx2 , dy2 , w ) } # [ inline ] pub unsafe fn cubicTo ( & mut self , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , x3 : SkScalar , y3 : SkScalar ) -> * mut SkPath { SkPath_cubicTo ( self , x1 , y1 , x2 , y2 , x3 , y3 ) } # [ inline ] pub unsafe fn cubicTo1 ( & mut self , p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint ) -> * mut SkPath { SkPath_cubicTo1 ( self , p1 , p2 , p3 ) } # [ inline ] pub unsafe fn rCubicTo ( & mut self , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar , dx3 : SkScalar , dy3 : SkScalar ) -> * mut SkPath { SkPath_rCubicTo ( self , dx1 , dy1 , dx2 , dy2 , dx3 , dy3 ) } # [ inline ] pub unsafe fn arcTo ( & mut self , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , forceMoveTo : bool ) -> * mut SkPath { SkPath_arcTo ( self , oval , startAngle , sweepAngle , forceMoveTo ) } # [ inline ] pub unsafe fn arcTo1 ( & mut self , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , radius : SkScalar ) -> * mut SkPath { SkPath_arcTo1 ( self , x1 , y1 , x2 , y2 , radius ) } # [ inline ] pub unsafe fn arcTo2 ( & mut self , p1 : SkPoint , p2 : SkPoint , radius : SkScalar ) -> * mut SkPath { SkPath_arcTo2 ( self , p1 , p2 , radius ) } # [ inline ] pub unsafe fn arcTo3 ( & mut self , rx : SkScalar , ry : SkScalar , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPath_Direction , x : SkScalar , y : SkScalar ) -> * mut SkPath { SkPath_arcTo3 ( self , rx , ry , xAxisRotate , largeArc , sweep , x , y ) } # [ inline ] pub unsafe fn arcTo4 ( & mut self , r : SkPoint , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPath_Direction , xy : SkPoint ) -> * mut SkPath { SkPath_arcTo4 ( self , r , xAxisRotate , largeArc , sweep , xy ) } # [ inline ] pub unsafe fn rArcTo ( & mut self , rx : SkScalar , ry : SkScalar , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPath_Direction , dx : SkScalar , dy : SkScalar ) -> * mut SkPath { SkPath_rArcTo ( self , rx , ry , xAxisRotate , largeArc , sweep , dx , dy ) } # [ inline ] pub unsafe fn close ( & mut self ) -> * mut SkPath { SkPath_close ( self ) } # [ inline ] pub unsafe fn IsInverseFillType ( fill : SkPath_FillType ) -> bool { SkPath_IsInverseFillType ( fill ) } # [ inline ] pub unsafe fn ConvertToNonInverseFillType ( fill : SkPath_FillType ) -> SkPath_FillType { SkPath_ConvertToNonInverseFillType ( fill ) } # [ inline ] pub unsafe fn ConvertConicToQuads ( p0 : * const SkPoint , p1 : * const SkPoint , p2 : * const SkPoint , w : SkScalar , pts : * mut SkPoint , pow2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int { SkPath_ConvertConicToQuads ( p0 , p1 , p2 , w , pts , pow2 ) } # [ inline ] pub unsafe fn isRect ( & self , rect : * mut SkRect , isClosed : * mut bool , direction : * mut SkPath_Direction ) -> bool { SkPath_isRect ( self , rect , isClosed , direction ) } # [ inline ] pub unsafe fn isNestedFillRects ( & self , rect : * mut SkRect , dirs : * mut SkPath_Direction ) -> bool { SkPath_isNestedFillRects ( self , rect , dirs ) } # [ inline ] pub unsafe fn addRect ( & mut self , rect : * const SkRect , dir : SkPath_Direction ) -> * mut SkPath { SkPath_addRect ( self , rect , dir ) } # [ inline ] pub unsafe fn addRect1 ( & mut self , rect : * const SkRect , dir : SkPath_Direction , start : :: std :: os :: raw :: c_uint ) -> * mut SkPath { SkPath_addRect1 ( self , rect , dir , start ) } # [ inline ] pub unsafe fn addRect2 ( & mut self , left : SkScalar , top : SkScalar , right : SkScalar , bottom : SkScalar , dir : SkPath_Direction ) -> * mut SkPath { SkPath_addRect2 ( self , left , top , right , bottom , dir ) } # [ inline ] pub unsafe fn addOval ( & mut self , oval : * const SkRect , dir : SkPath_Direction ) -> * mut SkPath { SkPath_addOval ( self , oval , dir ) } # [ inline ] pub unsafe fn addOval1 ( & mut self , oval : * const SkRect , dir : SkPath_Direction , start : :: std :: os :: raw :: c_uint ) -> * mut SkPath { SkPath_addOval1 ( self , oval , dir , start ) } # [ inline ] pub unsafe fn addCircle ( & mut self , x : SkScalar , y : SkScalar , radius : SkScalar , dir : SkPath_Direction ) -> * mut SkPath { SkPath_addCircle ( self , x , y , radius , dir ) } # [ inline ] pub unsafe fn addArc ( & mut self , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar ) -> * mut SkPath { SkPath_addArc ( self , oval , startAngle , sweepAngle ) } # [ inline ] pub unsafe fn addRoundRect ( & mut self , rect : * const SkRect , rx : SkScalar , ry : SkScalar , dir : SkPath_Direction ) -> * mut SkPath { SkPath_addRoundRect ( self , rect , rx , ry , dir ) } # [ inline ] pub unsafe fn addRoundRect1 ( & mut self , rect : * const SkRect , radii : * const SkScalar , dir : SkPath_Direction ) -> * mut SkPath { SkPath_addRoundRect1 ( self , rect , radii , dir ) } # [ inline ] pub unsafe fn addRRect ( & mut self , rrect : * const SkRRect , dir : SkPath_Direction ) -> * mut SkPath { SkPath_addRRect ( self , rrect , dir ) } # [ inline ] pub unsafe fn addRRect1 ( & mut self , rrect : * const SkRRect , dir : SkPath_Direction , start : :: std :: os :: raw :: c_uint ) -> * mut SkPath { SkPath_addRRect1 ( self , rrect , dir , start ) } # [ inline ] pub unsafe fn addPoly ( & mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int , close : bool ) -> * mut SkPath { SkPath_addPoly ( self , pts , count , close ) } # [ inline ] pub unsafe fn addPoly1 ( & mut self , list : * const std_initializer_list < SkPoint > , close : bool ) -> * mut SkPath { SkPath_addPoly1 ( self , list , close ) } # [ inline ] pub unsafe fn addPath ( & mut self , src : * const SkPath , dx : SkScalar , dy : SkScalar , mode : SkPath_AddPathMode ) -> * mut SkPath { SkPath_addPath ( self , src , dx , dy , mode ) } # [ inline ] pub unsafe fn addPath1 ( & mut self , src : * const SkPath , mode : SkPath_AddPathMode ) -> * mut SkPath { SkPath_addPath1 ( self , src , mode ) } # [ inline ] pub unsafe fn addPath2 ( & mut self , src : * const SkPath , matrix : * const SkMatrix , mode : SkPath_AddPathMode ) -> * mut SkPath { SkPath_addPath2 ( self , src , matrix , mode ) } # [ inline ] pub unsafe fn reverseAddPath ( & mut self , src : * const SkPath ) -> * mut SkPath { SkPath_reverseAddPath ( self , src ) } # [ inline ] pub unsafe fn offset ( & self , dx : SkScalar , dy : SkScalar , dst : * mut SkPath ) { SkPath_offset ( self , dx , dy , dst ) } # [ inline ] pub unsafe fn offset1 ( & mut self , dx : SkScalar , dy : SkScalar ) { SkPath_offset1 ( self , dx , dy ) } # [ inline ] pub unsafe fn transform ( & self , matrix : * const SkMatrix , dst : * mut SkPath ) { SkPath_transform ( self , matrix , dst ) } # [ inline ] pub unsafe fn transform1 ( & mut self , matrix : * const SkMatrix ) { SkPath_transform1 ( self , matrix ) } # [ inline ] pub unsafe fn getLastPt ( & self , lastPt : * mut SkPoint ) -> bool { SkPath_getLastPt ( self , lastPt ) } # [ inline ] pub unsafe fn setLastPt ( & mut self , x : SkScalar , y : SkScalar ) { SkPath_setLastPt ( self , x , y ) } # [ inline ] pub unsafe fn setLastPt1 ( & mut self , p : * const SkPoint ) { SkPath_setLastPt1 ( self , p ) } # [ inline ] pub unsafe fn getSegmentMasks ( & self ) -> u32 { SkPath_getSegmentMasks ( self ) } # [ inline ] pub unsafe fn contains ( & self , x : SkScalar , y : SkScalar ) -> bool { SkPath_contains ( self , x , y ) } # [ inline ] pub unsafe fn dump ( & self , stream : * mut SkWStream , forceClose : bool , dumpAsHex : bool ) { SkPath_dump ( self , stream , forceClose , dumpAsHex ) } # [ inline ] pub unsafe fn dump1 ( & self ) { SkPath_dump1 ( self ) } # [ inline ] pub unsafe fn dumpHex ( & self ) { SkPath_dumpHex ( self ) } # [ inline ] pub unsafe fn writeToMemory ( & self , buffer : * mut :: std :: os :: raw :: c_void ) -> usize { SkPath_writeToMemory ( self , buffer ) } # [ inline ] pub unsafe fn serialize ( & self ) -> sk_sp < SkData > { SkPath_serialize ( self ) } # [ inline ] pub unsafe fn readFromMemory ( & mut self , buffer : * const :: std :: os :: raw :: c_void , length : usize ) -> usize { SkPath_readFromMemory ( self , buffer , length ) } # [ inline ] pub unsafe fn getGenerationID ( & self ) -> u32 { SkPath_getGenerationID ( self ) } # [ inline ] pub unsafe fn isValid ( & self ) -> bool { SkPath_isValid ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPath_SkPath ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( path : * const SkPath ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPath_SkPath1 ( & mut __bindgen_tmp , path ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkPath_SkPath_destructor ( self ) } } pub const GrBackendApi_kMetal : GrBackendApi = 0 ; pub const GrBackendApi_kOpenGL : GrBackendApi = 1 ; pub const GrBackendApi_kVulkan : GrBackendApi = 2 ; # [ doc = " Mock is a backend that does not draw anything. It is used for unit tests" ] # [ doc = " and to measure CPU overhead." ] pub const GrBackendApi_kMock : GrBackendApi = 3 ; # [ doc = " Added here to support the legacy GrBackend enum value and clients who referenced it using" ] # [ doc = " GrBackend::kOpenGL_GrBackend." ] pub const GrBackendApi_kOpenGL_GrBackend : GrBackendApi = 1 ; # [ doc = " Possible 3D APIs that may be used by Ganesh." ] pub type GrBackendApi = u32 ; # [ repr ( u8 ) ] # [ doc = " Used to say whether a texture has mip levels allocated or not." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum GrMipMapped { kNo = 0 , kYes = 1 , } # [ repr ( i32 ) ] # [ doc = " GPU SkImage and SkSurfaces can be stored such that (0, 0) in texture space may correspond to" ] # [ doc = " either the top-left or bottom-left content pixel." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum GrSurfaceOrigin { kTopLeft_GrSurfaceOrigin = 0 , kBottomLeft_GrSurfaceOrigin = 1 , } pub const GrSemaphoresSubmitted_kNo : GrSemaphoresSubmitted = 0 ; pub const GrSemaphoresSubmitted_kYes : GrSemaphoresSubmitted = 1 ; # [ doc = " Enum used as return value when flush with semaphores so the client knows whether the semaphores" ] # [ doc = " were submitted to GPU or not." ] pub type GrSemaphoresSubmitted = u8 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkMask { _unused : [ u8 ; 0 ] , } # [ doc = " \\class SkPixmap" ] # [ doc = "SkPixmap provides a utility to pair SkImageInfo with pixels and row bytes." ] # [ doc = "SkPixmap is a low level class which provides convenience functions to access" ] # [ doc = "raster destinations. SkCanvas can not draw SkPixmap, nor does SkPixmap provide" ] # [ doc = "a direct drawing destination." ] # [ doc = "" ] # [ doc = "Use SkBitmap to draw pixels referenced by SkPixmap; use SkSurface to draw into" ] # [ doc = "pixels referenced by SkPixmap." ] # [ doc = "" ] # [ doc = "SkPixmap does not try to manage the lifetime of the pixel memory. Use SkPixelRef" ] # [ doc = "to manage pixel memory; SkPixelRef is safe across threads." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPixmap { pub fPixels : * const :: std :: os :: raw :: c_void , pub fRowBytes : usize , pub fInfo : SkImageInfo , } # [ test ] fn bindgen_test_layout_SkPixmap ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPixmap > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( SkPixmap ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPixmap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPixmap ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPixmap > ( ) ) ) . fPixels as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPixmap ) , "::" , stringify ! ( fPixels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPixmap > ( ) ) ) . fRowBytes as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkPixmap ) , "::" , stringify ! ( fRowBytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPixmap > ( ) ) ) . fInfo as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkPixmap ) , "::" , stringify ! ( fInfo ) ) ) ; } extern "C" { # [ doc = " Sets width, height, row bytes to zero; pixel address to nullptr; SkColorType to" ] # [ doc = "kUnknown_SkColorType; and SkAlphaType to kUnknown_SkAlphaType." ] # [ doc = "" ] # [ doc = "The prior pixels are unaffected; it is up to the caller to release pixels" ] # [ doc = "memory if desired." ] # [ link_name = "\u{1}__ZN8SkPixmap5resetEv" ] pub fn SkPixmap_reset ( this : * mut SkPixmap ) ; } extern "C" { # [ doc = " Sets width, height, SkAlphaType, and SkColorType from info." ] # [ doc = "Sets pixel address from addr, which may be nullptr." ] # [ doc = "Sets row bytes from rowBytes, which should be info.width() times" ] # [ doc = "info.bytesPerPixel(), or larger." ] # [ doc = "" ] # [ doc = "Does not check addr. Asserts if built with SK_DEBUG defined and if rowBytes is" ] # [ doc = "too small to hold one row of pixels." ] # [ doc = "" ] # [ doc = "The memory lifetime pixels are managed by the caller. When SkPixmap goes" ] # [ doc = "out of scope, addr is unaffected." ] # [ doc = "" ] # [ doc = "@param info      width, height, SkAlphaType, SkColorType of SkImageInfo" ] # [ doc = "@param addr      pointer to pixels allocated by caller; may be nullptr" ] # [ doc = "@param rowBytes  size of one row of addr; width times pixel size, or larger" ] # [ link_name = "\u{1}__ZN8SkPixmap5resetERK11SkImageInfoPKvm" ] pub fn SkPixmap_reset1 ( this : * mut SkPixmap , info : * const SkImageInfo , addr : * const :: std :: os :: raw :: c_void , rowBytes : usize ) ; } extern "C" { # [ doc = " Changes SkColorSpace in SkImageInfo; preserves width, height, SkAlphaType, and" ] # [ doc = "SkColorType in SkImage, and leaves pixel address and row bytes unchanged." ] # [ doc = "SkColorSpace reference count is incremented." ] # [ doc = "" ] # [ doc = "@param colorSpace  SkColorSpace moved to SkImageInfo" ] # [ link_name = "\u{1}__ZN8SkPixmap13setColorSpaceE5sk_spI12SkColorSpaceE" ] pub fn SkPixmap_setColorSpace ( this : * mut SkPixmap , colorSpace : sk_sp < SkColorSpace > ) ; } extern "C" { # [ doc = " Deprecated." ] # [ link_name = "\u{1}__ZN8SkPixmap5resetERK6SkMask" ] pub fn SkPixmap_reset2 ( this : * mut SkPixmap , mask : * const SkMask ) -> bool ; } extern "C" { # [ doc = " Sets subset width, height, pixel address to intersection of SkPixmap with area," ] # [ doc = "if intersection is not empty; and return true. Otherwise, leave subset unchanged" ] # [ doc = "and return false." ] # [ doc = "" ] # [ doc = "Failing to read the return value generates a compile time warning." ] # [ doc = "" ] # [ doc = "@param subset  storage for width, height, pixel address of intersection" ] # [ doc = "@param area    bounds to intersect with SkPixmap" ] # [ doc = "@return        true if intersection of SkPixmap and area is not empty" ] # [ link_name = "\u{1}__ZNK8SkPixmap13extractSubsetEPS_RK7SkIRect" ] pub fn SkPixmap_extractSubset ( this : * const SkPixmap , subset : * mut SkPixmap , area : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns width, height, SkAlphaType, SkColorType, and SkColorSpace." ] # [ doc = "" ] # [ doc = "@return  reference to SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkPixmap4infoEv" ] pub fn SkPixmap_info ( this : * const SkPixmap ) -> * const SkImageInfo ; } extern "C" { # [ doc = " Returns row bytes, the interval from one pixel row to the next. Row bytes" ] # [ doc = "is at least as large as: width() * info().bytesPerPixel()." ] # [ doc = "" ] # [ doc = "Returns zero if colorType() is kUnknown_SkColorType." ] # [ doc = "It is up to the SkBitmap creator to ensure that row bytes is a useful value." ] # [ doc = "" ] # [ doc = "@return  byte length of pixel row" ] # [ link_name = "\u{1}__ZNK8SkPixmap8rowBytesEv" ] pub fn SkPixmap_rowBytes ( this : * const SkPixmap ) -> usize ; } extern "C" { # [ doc = " Returns pixel address, the base address corresponding to the pixel origin." ] # [ doc = "" ] # [ doc = "It is up to the SkPixmap creator to ensure that pixel address is a useful value." ] # [ doc = "" ] # [ doc = "@return  pixel address" ] # [ link_name = "\u{1}__ZNK8SkPixmap4addrEv" ] pub fn SkPixmap_addr ( this : * const SkPixmap ) -> * const :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " Returns pixel count in each pixel row. Should be equal or less than:" ] # [ doc = "rowBytes() / info().bytesPerPixel()." ] # [ doc = "" ] # [ doc = "@return  pixel width in SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkPixmap5widthEv" ] pub fn SkPixmap_width ( this : * const SkPixmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns pixel row count." ] # [ doc = "" ] # [ doc = "@return  pixel height in SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkPixmap6heightEv" ] pub fn SkPixmap_height ( this : * const SkPixmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns SkColorType, one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType." ] # [ doc = "" ] # [ doc = "@return  SkColorType in SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkPixmap9colorTypeEv" ] pub fn SkPixmap_colorType ( this : * const SkPixmap ) -> SkColorType ; } extern "C" { # [ doc = " Returns SkAlphaType, one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType." ] # [ doc = "" ] # [ doc = "@return  SkAlphaType in SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkPixmap9alphaTypeEv" ] pub fn SkPixmap_alphaType ( this : * const SkPixmap ) -> SkAlphaType ; } extern "C" { # [ doc = " Returns SkColorSpace, the range of colors, associated with SkImageInfo. The" ] # [ doc = "reference count of SkColorSpace is unchanged. The returned SkColorSpace is" ] # [ doc = "immutable." ] # [ doc = "" ] # [ doc = "@return  SkColorSpace in SkImageInfo, or nullptr" ] # [ link_name = "\u{1}__ZNK8SkPixmap10colorSpaceEv" ] pub fn SkPixmap_colorSpace ( this : * const SkPixmap ) -> * mut SkColorSpace ; } extern "C" { # [ doc = " Returns smart pointer to SkColorSpace, the range of colors, associated with" ] # [ doc = "SkImageInfo. The smart pointer tracks the number of objects sharing this" ] # [ doc = "SkColorSpace reference so the memory is released when the owners destruct." ] # [ doc = "" ] # [ doc = "The returned SkColorSpace is immutable." ] # [ doc = "" ] # [ doc = "@return  SkColorSpace in SkImageInfo wrapped in a smart pointer" ] # [ link_name = "\u{1}__ZNK8SkPixmap13refColorSpaceEv" ] pub fn SkPixmap_refColorSpace ( this : * const SkPixmap ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = " Returns true if SkAlphaType is kOpaque_SkAlphaType." ] # [ doc = "Does not check if SkColorType allows alpha, or if any pixel value has" ] # [ doc = "transparency." ] # [ doc = "" ] # [ doc = "@return  true if SkImageInfo has opaque SkAlphaType" ] # [ link_name = "\u{1}__ZNK8SkPixmap8isOpaqueEv" ] pub fn SkPixmap_isOpaque ( this : * const SkPixmap ) -> bool ; } extern "C" { # [ doc = " Returns SkIRect { 0, 0, width(), height() }." ] # [ doc = "" ] # [ doc = "@return  integral rectangle from origin to width() and height()" ] # [ link_name = "\u{1}__ZNK8SkPixmap6boundsEv" ] pub fn SkPixmap_bounds ( this : * const SkPixmap ) -> SkIRect ; } extern "C" { # [ doc = " Returns number of pixels that fit on row. Should be greater than or equal to" ] # [ doc = "width()." ] # [ doc = "" ] # [ doc = "@return  maximum pixels per row" ] # [ link_name = "\u{1}__ZNK8SkPixmap16rowBytesAsPixelsEv" ] pub fn SkPixmap_rowBytesAsPixels ( this : * const SkPixmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns bit shift converting row bytes to row pixels." ] # [ doc = "Returns zero for kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  one of: 0, 1, 2, 3; left shift to convert pixels to bytes" ] # [ link_name = "\u{1}__ZNK8SkPixmap13shiftPerPixelEv" ] pub fn SkPixmap_shiftPerPixel ( this : * const SkPixmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns minimum memory required for pixel storage." ] # [ doc = "Does not include unused memory on last row when rowBytesAsPixels() exceeds width()." ] # [ doc = "Returns zero if result does not fit in size_t." ] # [ doc = "Returns zero if height() or width() is 0." ] # [ doc = "Returns height() times rowBytes() if colorType() is kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  size in bytes of image buffer" ] # [ link_name = "\u{1}__ZNK8SkPixmap15computeByteSizeEv" ] pub fn SkPixmap_computeByteSize ( this : * const SkPixmap ) -> usize ; } extern "C" { # [ doc = " Returns true if all pixels are opaque. SkColorType determines how pixels" ] # [ doc = "are encoded, and whether pixel describes alpha. Returns true for SkColorType" ] # [ doc = "without alpha in each pixel; for other SkColorType, returns true if all" ] # [ doc = "pixels have alpha values equivalent to 1.0 or greater." ] # [ doc = "" ] # [ doc = "For SkColorType kRGB_565_SkColorType or kGray_8_SkColorType: always" ] # [ doc = "returns true. For SkColorType kAlpha_8_SkColorType, kBGRA_8888_SkColorType," ] # [ doc = "kRGBA_8888_SkColorType: returns true if all pixel alpha values are 255." ] # [ doc = "For SkColorType kARGB_4444_SkColorType: returns true if all pixel alpha values are 15." ] # [ doc = "For kRGBA_F16_SkColorType: returns true if all pixel alpha values are 1.0 or" ] # [ doc = "greater." ] # [ doc = "" ] # [ doc = "Returns false for kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  true if all pixels have opaque values or SkColorType is opaque" ] # [ link_name = "\u{1}__ZNK8SkPixmap15computeIsOpaqueEv" ] pub fn SkPixmap_computeIsOpaque ( this : * const SkPixmap ) -> bool ; } extern "C" { # [ doc = " Returns pixel at (x, y) as unpremultiplied color." ] # [ doc = "Returns black with alpha if SkColorType is kAlpha_8_SkColorType." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined; and returns undefined values or may crash if" ] # [ doc = "SK_RELEASE is defined. Fails if SkColorType is kUnknown_SkColorType or" ] # [ doc = "pixel address is nullptr." ] # [ doc = "" ] # [ doc = "SkColorSpace in SkImageInfo is ignored. Some color precision may be lost in the" ] # [ doc = "conversion to unpremultiplied color; original pixel data may have additional" ] # [ doc = "precision." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   pixel converted to unpremultiplied color" ] # [ link_name = "\u{1}__ZNK8SkPixmap8getColorEii" ] pub fn SkPixmap_getColor ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> SkColor ; } extern "C" { # [ doc = " Look up the pixel at (x,y) and return its alpha component, normalized to [0..1]." ] # [ doc = "This is roughly equivalent to SkGetColorA(getColor()), but can be more efficent" ] # [ doc = "(and more precise if the pixels store more than 8 bits per component)." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   alpha converted to normalized float" ] # [ link_name = "\u{1}__ZNK8SkPixmap9getAlphafEii" ] pub fn SkPixmap_getAlphaf ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> f32 ; } extern "C" { # [ doc = " Returns readable pixel address at (x, y). Returns nullptr if SkPixelRef is nullptr." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined. Returns nullptr if SkColorType is kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "Performs a lookup of pixel size; for better performance, call" ] # [ doc = "one of: addr8, addr16, addr32, addr64, or addrF16()." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   readable generic pointer to pixel" ] # [ link_name = "\u{1}__ZNK8SkPixmap4addrEii" ] pub fn SkPixmap_addr1 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " Returns readable base pixel address. Result is addressable as unsigned 8-bit bytes." ] # [ doc = "Will trigger an assert() if SkColorType is not kAlpha_8_SkColorType or" ] # [ doc = "kGray_8_SkColorType, and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "One byte corresponds to one pixel." ] # [ doc = "" ] # [ doc = "@return  readable unsigned 8-bit pointer to pixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap5addr8Ev" ] pub fn SkPixmap_addr8 ( this : * const SkPixmap ) -> * const u8 ; } extern "C" { # [ doc = " Returns readable base pixel address. Result is addressable as unsigned 16-bit words." ] # [ doc = "Will trigger an assert() if SkColorType is not kRGB_565_SkColorType or" ] # [ doc = "kARGB_4444_SkColorType, and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "One word corresponds to one pixel." ] # [ doc = "" ] # [ doc = "@return  readable unsigned 16-bit pointer to pixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap6addr16Ev" ] pub fn SkPixmap_addr16 ( this : * const SkPixmap ) -> * const u16 ; } extern "C" { # [ doc = " Returns readable base pixel address. Result is addressable as unsigned 32-bit words." ] # [ doc = "Will trigger an assert() if SkColorType is not kRGBA_8888_SkColorType or" ] # [ doc = "kBGRA_8888_SkColorType, and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "One word corresponds to one pixel." ] # [ doc = "" ] # [ doc = "@return  readable unsigned 32-bit pointer to pixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap6addr32Ev" ] pub fn SkPixmap_addr32 ( this : * const SkPixmap ) -> * const u32 ; } extern "C" { # [ doc = " Returns readable base pixel address. Result is addressable as unsigned 64-bit words." ] # [ doc = "Will trigger an assert() if SkColorType is not kRGBA_F16_SkColorType and is built" ] # [ doc = "with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "One word corresponds to one pixel." ] # [ doc = "" ] # [ doc = "@return  readable unsigned 64-bit pointer to pixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap6addr64Ev" ] pub fn SkPixmap_addr64 ( this : * const SkPixmap ) -> * const u64 ; } extern "C" { # [ doc = " Returns readable base pixel address. Result is addressable as unsigned 16-bit words." ] # [ doc = "Will trigger an assert() if SkColorType is not kRGBA_F16_SkColorType and is built" ] # [ doc = "with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "Each word represents one color component encoded as a half float." ] # [ doc = "Four words correspond to one pixel." ] # [ doc = "" ] # [ doc = "@return  readable unsigned 16-bit pointer to first component of pixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap7addrF16Ev" ] pub fn SkPixmap_addrF16 ( this : * const SkPixmap ) -> * const u16 ; } extern "C" { # [ doc = " Returns readable pixel address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "Will trigger an assert() if SkColorType is not kAlpha_8_SkColorType or" ] # [ doc = "kGray_8_SkColorType, and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   readable unsigned 8-bit pointer to pixel at (x, y)" ] # [ link_name = "\u{1}__ZNK8SkPixmap5addr8Eii" ] pub fn SkPixmap_addr81 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u8 ; } extern "C" { # [ doc = " Returns readable pixel address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "Will trigger an assert() if SkColorType is not kRGB_565_SkColorType or" ] # [ doc = "kARGB_4444_SkColorType, and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   readable unsigned 16-bit pointer to pixel at (x, y)" ] # [ link_name = "\u{1}__ZNK8SkPixmap6addr16Eii" ] pub fn SkPixmap_addr161 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u16 ; } extern "C" { # [ doc = " Returns readable pixel address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "Will trigger an assert() if SkColorType is not kRGBA_8888_SkColorType or" ] # [ doc = "kBGRA_8888_SkColorType, and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   readable unsigned 32-bit pointer to pixel at (x, y)" ] # [ link_name = "\u{1}__ZNK8SkPixmap6addr32Eii" ] pub fn SkPixmap_addr321 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u32 ; } extern "C" { # [ doc = " Returns readable pixel address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "Will trigger an assert() if SkColorType is not kRGBA_F16_SkColorType and is built" ] # [ doc = "with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   readable unsigned 64-bit pointer to pixel at (x, y)" ] # [ link_name = "\u{1}__ZNK8SkPixmap6addr64Eii" ] pub fn SkPixmap_addr641 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u64 ; } extern "C" { # [ doc = " Returns readable pixel address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "Will trigger an assert() if SkColorType is not kRGBA_F16_SkColorType and is built" ] # [ doc = "with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "Each unsigned 16-bit word represents one color component encoded as a half float." ] # [ doc = "Four words correspond to one pixel." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   readable unsigned 16-bit pointer to pixel component at (x, y)" ] # [ link_name = "\u{1}__ZNK8SkPixmap7addrF16Eii" ] pub fn SkPixmap_addrF161 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u16 ; } extern "C" { # [ doc = " Returns writable base pixel address." ] # [ doc = "" ] # [ doc = "@return  writable generic base pointer to pixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap13writable_addrEv" ] pub fn SkPixmap_writable_addr ( this : * const SkPixmap ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " Returns writable pixel address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined. Returns zero if SkColorType is kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   writable generic pointer to pixel" ] # [ link_name = "\u{1}__ZNK8SkPixmap13writable_addrEii" ] pub fn SkPixmap_writable_addr1 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " Returns writable pixel address at (x, y). Result is addressable as unsigned" ] # [ doc = "8-bit bytes. Will trigger an assert() if SkColorType is not kAlpha_8_SkColorType" ] # [ doc = "or kGray_8_SkColorType, and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "One byte corresponds to one pixel." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   writable unsigned 8-bit pointer to pixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap14writable_addr8Eii" ] pub fn SkPixmap_writable_addr8 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u8 ; } extern "C" { # [ doc = " Returns writable_addr pixel address at (x, y). Result is addressable as unsigned" ] # [ doc = "16-bit words. Will trigger an assert() if SkColorType is not kRGB_565_SkColorType" ] # [ doc = "or kARGB_4444_SkColorType, and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "One word corresponds to one pixel." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   writable unsigned 16-bit pointer to pixel" ] # [ link_name = "\u{1}__ZNK8SkPixmap15writable_addr16Eii" ] pub fn SkPixmap_writable_addr16 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u16 ; } extern "C" { # [ doc = " Returns writable pixel address at (x, y). Result is addressable as unsigned" ] # [ doc = "32-bit words. Will trigger an assert() if SkColorType is not" ] # [ doc = "kRGBA_8888_SkColorType or kBGRA_8888_SkColorType, and is built with SK_DEBUG" ] # [ doc = "defined." ] # [ doc = "" ] # [ doc = "One word corresponds to one pixel." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   writable unsigned 32-bit pointer to pixel" ] # [ link_name = "\u{1}__ZNK8SkPixmap15writable_addr32Eii" ] pub fn SkPixmap_writable_addr32 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u32 ; } extern "C" { # [ doc = " Returns writable pixel address at (x, y). Result is addressable as unsigned" ] # [ doc = "64-bit words. Will trigger an assert() if SkColorType is not" ] # [ doc = "kRGBA_F16_SkColorType and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "One word corresponds to one pixel." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   writable unsigned 64-bit pointer to pixel" ] # [ link_name = "\u{1}__ZNK8SkPixmap15writable_addr64Eii" ] pub fn SkPixmap_writable_addr64 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u64 ; } extern "C" { # [ doc = " Returns writable pixel address at (x, y). Result is addressable as unsigned" ] # [ doc = "16-bit words. Will trigger an assert() if SkColorType is not" ] # [ doc = "kRGBA_F16_SkColorType and is built with SK_DEBUG defined." ] # [ doc = "" ] # [ doc = "Each word represents one color component encoded as a half float." ] # [ doc = "Four words correspond to one pixel." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   writable unsigned 16-bit pointer to first component of pixel" ] # [ link_name = "\u{1}__ZNK8SkPixmap16writable_addrF16Eii" ] pub fn SkPixmap_writable_addrF16 ( this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u16 ; } extern "C" { # [ doc = " Copies a SkRect of pixels to dstPixels. Copy starts at (0, 0), and does not" ] # [ doc = "exceed SkPixmap (width(), height())." ] # [ doc = "" ] # [ doc = "dstInfo specifies width, height, SkColorType, SkAlphaType, and" ] # [ doc = "SkColorSpace of destination. dstRowBytes specifics the gap from one destination" ] # [ doc = "row to the next. Returns true if pixels are copied. Returns false if" ] # [ doc = "dstInfo address equals nullptr, or dstRowBytes is less than dstInfo.minRowBytes()." ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkPixmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dstInfo.colorType() must match." ] # [ doc = "If SkPixmap colorType() is kGray_8_SkColorType, dstInfo.colorSpace() must match." ] # [ doc = "If SkPixmap alphaType() is kOpaque_SkAlphaType, dstInfo.alphaType() must" ] # [ doc = "match. If SkPixmap colorSpace() is nullptr, dstInfo.colorSpace() must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "Returns false if SkPixmap width() or height() is zero or negative." ] # [ doc = "" ] # [ doc = "@param dstInfo      destination width, height, SkColorType, SkAlphaType, SkColorSpace" ] # [ doc = "@param dstPixels    destination pixel storage" ] # [ doc = "@param dstRowBytes  destination row length" ] # [ doc = "@return             true if pixels are copied to dstPixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap10readPixelsERK11SkImageInfoPvm" ] pub fn SkPixmap_readPixels ( this : * const SkPixmap , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize ) -> bool ; } extern "C" { # [ doc = " Copies a SkRect of pixels to dstPixels. Copy starts at (srcX, srcY), and does not" ] # [ doc = "exceed SkPixmap (width(), height())." ] # [ doc = "" ] # [ doc = "dstInfo specifies width, height, SkColorType, SkAlphaType, and" ] # [ doc = "SkColorSpace of destination. dstRowBytes specifics the gap from one destination" ] # [ doc = "row to the next. Returns true if pixels are copied. Returns false if" ] # [ doc = "dstInfo address equals nullptr, or dstRowBytes is less than dstInfo.minRowBytes()." ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkPixmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dstInfo.colorType() must match." ] # [ doc = "If SkPixmap colorType() is kGray_8_SkColorType, dstInfo.colorSpace() must match." ] # [ doc = "If SkPixmap alphaType() is kOpaque_SkAlphaType, dstInfo.alphaType() must" ] # [ doc = "match. If SkPixmap colorSpace() is nullptr, dstInfo.colorSpace() must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "srcX and srcY may be negative to copy only top or left of source. Returns" ] # [ doc = "false if SkPixmap width() or height() is zero or negative. Returns false if:" ] # [ doc = "abs(srcX) >= Pixmap width(), or if abs(srcY) >= Pixmap height()." ] # [ doc = "" ] # [ doc = "@param dstInfo      destination width, height, SkColorType, SkAlphaType, SkColorSpace" ] # [ doc = "@param dstPixels    destination pixel storage" ] # [ doc = "@param dstRowBytes  destination row length" ] # [ doc = "@param srcX         column index whose absolute value is less than width()" ] # [ doc = "@param srcY         row index whose absolute value is less than height()" ] # [ doc = "@return             true if pixels are copied to dstPixels" ] # [ link_name = "\u{1}__ZNK8SkPixmap10readPixelsERK11SkImageInfoPvmii" ] pub fn SkPixmap_readPixels1 ( this : * const SkPixmap , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies a SkRect of pixels to dst. Copy starts at (srcX, srcY), and does not" ] # [ doc = "exceed SkPixmap (width(), height()). dst specifies width, height, SkColorType," ] # [ doc = "SkAlphaType, and SkColorSpace of destination.  Returns true if pixels are copied." ] # [ doc = "Returns false if dst address equals nullptr, or dst.rowBytes() is less than" ] # [ doc = "dst SkImageInfo::minRowBytes." ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkPixmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dst.info().colorType must match." ] # [ doc = "If SkPixmap colorType() is kGray_8_SkColorType, dst.info().colorSpace must match." ] # [ doc = "If SkPixmap alphaType() is kOpaque_SkAlphaType, dst.info().alphaType must" ] # [ doc = "match. If SkPixmap colorSpace() is nullptr, dst.info().colorSpace must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "srcX and srcY may be negative to copy only top or left of source. Returns" ] # [ doc = "false SkPixmap width() or height() is zero or negative. Returns false if:" ] # [ doc = "abs(srcX) >= Pixmap width(), or if abs(srcY) >= Pixmap height()." ] # [ doc = "" ] # [ doc = "@param dst   SkImageInfo and pixel address to write to" ] # [ doc = "@param srcX  column index whose absolute value is less than width()" ] # [ doc = "@param srcY  row index whose absolute value is less than height()" ] # [ doc = "@return      true if pixels are copied to dst" ] # [ link_name = "\u{1}__ZNK8SkPixmap10readPixelsERKS_ii" ] pub fn SkPixmap_readPixels2 ( this : * const SkPixmap , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies pixels inside bounds() to dst. dst specifies width, height, SkColorType," ] # [ doc = "SkAlphaType, and SkColorSpace of destination.  Returns true if pixels are copied." ] # [ doc = "Returns false if dst address equals nullptr, or dst.rowBytes() is less than" ] # [ doc = "dst SkImageInfo::minRowBytes." ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkPixmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dst SkColorType must match." ] # [ doc = "If SkPixmap colorType() is kGray_8_SkColorType, dst SkColorSpace must match." ] # [ doc = "If SkPixmap alphaType() is kOpaque_SkAlphaType, dst SkAlphaType must" ] # [ doc = "match. If SkPixmap colorSpace() is nullptr, dst SkColorSpace must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "Returns false if SkPixmap width() or height() is zero or negative." ] # [ doc = "" ] # [ doc = "@param dst  SkImageInfo and pixel address to write to" ] # [ doc = "@return     true if pixels are copied to dst" ] # [ link_name = "\u{1}__ZNK8SkPixmap10readPixelsERKS_" ] pub fn SkPixmap_readPixels3 ( this : * const SkPixmap , dst : * const SkPixmap ) -> bool ; } extern "C" { # [ doc = " Copies SkBitmap to dst, scaling pixels to fit dst.width() and dst.height(), and" ] # [ doc = "converting pixels to match dst.colorType() and dst.alphaType(). Returns true if" ] # [ doc = "pixels are copied. Returns false if dst address is nullptr, or dst.rowBytes() is" ] # [ doc = "less than dst SkImageInfo::minRowBytes." ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkPixmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dst SkColorType must match." ] # [ doc = "If SkPixmap colorType() is kGray_8_SkColorType, dst SkColorSpace must match." ] # [ doc = "If SkPixmap alphaType() is kOpaque_SkAlphaType, dst SkAlphaType must" ] # [ doc = "match. If SkPixmap colorSpace() is nullptr, dst SkColorSpace must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "Returns false if SkBitmap width() or height() is zero or negative." ] # [ doc = "" ] # [ doc = "Scales the image, with filterQuality, to match dst.width() and dst.height()." ] # [ doc = "filterQuality kNone_SkFilterQuality is fastest, typically implemented with" ] # [ doc = "nearest neighbor filter. kLow_SkFilterQuality is typically implemented with" ] # [ doc = "bilerp filter. kMedium_SkFilterQuality is typically implemented with" ] # [ doc = "bilerp filter, and mip-map filter when size is reduced." ] # [ doc = "kHigh_SkFilterQuality is slowest, typically implemented with bicubic filter." ] # [ doc = "" ] # [ doc = "@param dst            SkImageInfo and pixel address to write to" ] # [ doc = "@param filterQuality  one of: kNone_SkFilterQuality, kLow_SkFilterQuality," ] # [ doc = "kMedium_SkFilterQuality, kHigh_SkFilterQuality" ] # [ doc = "@return               true if pixels are scaled to fit dst" ] # [ link_name = "\u{1}__ZNK8SkPixmap11scalePixelsERKS_15SkFilterQuality" ] pub fn SkPixmap_scalePixels ( this : * const SkPixmap , dst : * const SkPixmap , filterQuality : SkFilterQuality ) -> bool ; } extern "C" { # [ doc = " Writes color to pixels bounded by subset; returns true on success." ] # [ doc = "Returns false if colorType() is kUnknown_SkColorType, or if subset does" ] # [ doc = "not intersect bounds()." ] # [ doc = "" ] # [ doc = "@param color   unpremultiplied color to write" ] # [ doc = "@param subset  bounding integer SkRect of written pixels" ] # [ doc = "@return        true if pixels are changed" ] # [ link_name = "\u{1}__ZNK8SkPixmap5eraseEjRK7SkIRect" ] pub fn SkPixmap_erase ( this : * const SkPixmap , color : SkColor , subset : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Writes color to pixels inside bounds(); returns true on success." ] # [ doc = "Returns false if colorType() is kUnknown_SkColorType, or if bounds()" ] # [ doc = "is empty." ] # [ doc = "" ] # [ doc = "@param color  unpremultiplied color to write" ] # [ doc = "@return       true if pixels are changed" ] # [ link_name = "\u{1}__ZNK8SkPixmap5eraseEj" ] pub fn SkPixmap_erase1 ( this : * const SkPixmap , color : SkColor ) -> bool ; } extern "C" { # [ doc = " Writes color to pixels bounded by subset; returns true on success." ] # [ doc = "if subset is nullptr, writes colors pixels inside bounds(). Returns false if" ] # [ doc = "colorType() is kUnknown_SkColorType, if subset is not nullptr and does" ] # [ doc = "not intersect bounds(), or if subset is nullptr and bounds() is empty." ] # [ doc = "" ] # [ doc = "@param color   unpremultiplied color to write" ] # [ doc = "@param subset  bounding integer SkRect of pixels to write; may be nullptr" ] # [ doc = "@return        true if pixels are changed" ] # [ link_name = "\u{1}__ZNK8SkPixmap5eraseERK8SkRGBA4fIL11SkAlphaType3EEPK7SkIRect" ] pub fn SkPixmap_erase2 ( this : * const SkPixmap , color : * const SkColor4f , subset : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Creates an empty SkPixmap without pixels, with kUnknown_SkColorType, with" ] # [ doc = "kUnknown_SkAlphaType, and with a width and height of zero. Use" ] # [ doc = "reset() to associate pixels, SkColorType, SkAlphaType, width, and height" ] # [ doc = "after SkPixmap has been created." ] # [ doc = "" ] # [ doc = "@return  empty SkPixmap" ] # [ link_name = "\u{1}__ZN8SkPixmapC1Ev" ] pub fn SkPixmap_SkPixmap ( this : * mut SkPixmap ) ; } extern "C" { # [ doc = " Creates SkPixmap from info width, height, SkAlphaType, and SkColorType." ] # [ doc = "addr points to pixels, or nullptr. rowBytes should be info.width() times" ] # [ doc = "info.bytesPerPixel(), or larger." ] # [ doc = "" ] # [ doc = "No parameter checking is performed; it is up to the caller to ensure that" ] # [ doc = "addr and rowBytes agree with info." ] # [ doc = "" ] # [ doc = "The memory lifetime of pixels is managed by the caller. When SkPixmap goes" ] # [ doc = "out of scope, addr is unaffected." ] # [ doc = "" ] # [ doc = "SkPixmap may be later modified by reset() to change its size, pixel type, or" ] # [ doc = "storage." ] # [ doc = "" ] # [ doc = "@param info      width, height, SkAlphaType, SkColorType of SkImageInfo" ] # [ doc = "@param addr      pointer to pixels allocated by caller; may be nullptr" ] # [ doc = "@param rowBytes  size of one row of addr; width times pixel size, or larger" ] # [ doc = "@return          initialized SkPixmap" ] # [ link_name = "\u{1}__ZN8SkPixmapC1ERK11SkImageInfoPKvm" ] pub fn SkPixmap_SkPixmap1 ( this : * mut SkPixmap , info : * const SkImageInfo , addr : * const :: std :: os :: raw :: c_void , rowBytes : usize ) ; } impl SkPixmap { # [ inline ] pub unsafe fn reset ( & mut self ) { SkPixmap_reset ( self ) } # [ inline ] pub unsafe fn reset1 ( & mut self , info : * const SkImageInfo , addr : * const :: std :: os :: raw :: c_void , rowBytes : usize ) { SkPixmap_reset1 ( self , info , addr , rowBytes ) } # [ inline ] pub unsafe fn setColorSpace ( & mut self , colorSpace : sk_sp < SkColorSpace > ) { SkPixmap_setColorSpace ( self , colorSpace ) } # [ inline ] pub unsafe fn reset2 ( & mut self , mask : * const SkMask ) -> bool { SkPixmap_reset2 ( self , mask ) } # [ inline ] pub unsafe fn extractSubset ( & self , subset : * mut SkPixmap , area : * const SkIRect ) -> bool { SkPixmap_extractSubset ( self , subset , area ) } # [ inline ] pub unsafe fn info ( & self ) -> * const SkImageInfo { SkPixmap_info ( self ) } # [ inline ] pub unsafe fn rowBytes ( & self ) -> usize { SkPixmap_rowBytes ( self ) } # [ inline ] pub unsafe fn addr ( & self ) -> * const :: std :: os :: raw :: c_void { SkPixmap_addr ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { SkPixmap_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { SkPixmap_height ( self ) } # [ inline ] pub unsafe fn colorType ( & self ) -> SkColorType { SkPixmap_colorType ( self ) } # [ inline ] pub unsafe fn alphaType ( & self ) -> SkAlphaType { SkPixmap_alphaType ( self ) } # [ inline ] pub unsafe fn colorSpace ( & self ) -> * mut SkColorSpace { SkPixmap_colorSpace ( self ) } # [ inline ] pub unsafe fn refColorSpace ( & self ) -> sk_sp < SkColorSpace > { SkPixmap_refColorSpace ( self ) } # [ inline ] pub unsafe fn isOpaque ( & self ) -> bool { SkPixmap_isOpaque ( self ) } # [ inline ] pub unsafe fn bounds ( & self ) -> SkIRect { SkPixmap_bounds ( self ) } # [ inline ] pub unsafe fn rowBytesAsPixels ( & self ) -> :: std :: os :: raw :: c_int { SkPixmap_rowBytesAsPixels ( self ) } # [ inline ] pub unsafe fn shiftPerPixel ( & self ) -> :: std :: os :: raw :: c_int { SkPixmap_shiftPerPixel ( self ) } # [ inline ] pub unsafe fn computeByteSize ( & self ) -> usize { SkPixmap_computeByteSize ( self ) } # [ inline ] pub unsafe fn computeIsOpaque ( & self ) -> bool { SkPixmap_computeIsOpaque ( self ) } # [ inline ] pub unsafe fn getColor ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> SkColor { SkPixmap_getColor ( self , x , y ) } # [ inline ] pub unsafe fn getAlphaf ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> f32 { SkPixmap_getAlphaf ( self , x , y ) } # [ inline ] pub unsafe fn addr1 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_void { SkPixmap_addr1 ( self , x , y ) } # [ inline ] pub unsafe fn addr8 ( & self ) -> * const u8 { SkPixmap_addr8 ( self ) } # [ inline ] pub unsafe fn addr16 ( & self ) -> * const u16 { SkPixmap_addr16 ( self ) } # [ inline ] pub unsafe fn addr32 ( & self ) -> * const u32 { SkPixmap_addr32 ( self ) } # [ inline ] pub unsafe fn addr64 ( & self ) -> * const u64 { SkPixmap_addr64 ( self ) } # [ inline ] pub unsafe fn addrF16 ( & self ) -> * const u16 { SkPixmap_addrF16 ( self ) } # [ inline ] pub unsafe fn addr81 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u8 { SkPixmap_addr81 ( self , x , y ) } # [ inline ] pub unsafe fn addr161 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u16 { SkPixmap_addr161 ( self , x , y ) } # [ inline ] pub unsafe fn addr321 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u32 { SkPixmap_addr321 ( self , x , y ) } # [ inline ] pub unsafe fn addr641 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u64 { SkPixmap_addr641 ( self , x , y ) } # [ inline ] pub unsafe fn addrF161 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * const u16 { SkPixmap_addrF161 ( self , x , y ) } # [ inline ] pub unsafe fn writable_addr ( & self ) -> * mut :: std :: os :: raw :: c_void { SkPixmap_writable_addr ( self ) } # [ inline ] pub unsafe fn writable_addr1 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void { SkPixmap_writable_addr1 ( self , x , y ) } # [ inline ] pub unsafe fn writable_addr8 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u8 { SkPixmap_writable_addr8 ( self , x , y ) } # [ inline ] pub unsafe fn writable_addr16 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u16 { SkPixmap_writable_addr16 ( self , x , y ) } # [ inline ] pub unsafe fn writable_addr32 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u32 { SkPixmap_writable_addr32 ( self , x , y ) } # [ inline ] pub unsafe fn writable_addr64 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u64 { SkPixmap_writable_addr64 ( self , x , y ) } # [ inline ] pub unsafe fn writable_addrF16 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u16 { SkPixmap_writable_addrF16 ( self , x , y ) } # [ inline ] pub unsafe fn readPixels ( & self , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize ) -> bool { SkPixmap_readPixels ( self , dstInfo , dstPixels , dstRowBytes ) } # [ inline ] pub unsafe fn readPixels1 ( & self , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkPixmap_readPixels1 ( self , dstInfo , dstPixels , dstRowBytes , srcX , srcY ) } # [ inline ] pub unsafe fn readPixels2 ( & self , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkPixmap_readPixels2 ( self , dst , srcX , srcY ) } # [ inline ] pub unsafe fn readPixels3 ( & self , dst : * const SkPixmap ) -> bool { SkPixmap_readPixels3 ( self , dst ) } # [ inline ] pub unsafe fn scalePixels ( & self , dst : * const SkPixmap , filterQuality : SkFilterQuality ) -> bool { SkPixmap_scalePixels ( self , dst , filterQuality ) } # [ inline ] pub unsafe fn erase ( & self , color : SkColor , subset : * const SkIRect ) -> bool { SkPixmap_erase ( self , color , subset ) } # [ inline ] pub unsafe fn erase1 ( & self , color : SkColor ) -> bool { SkPixmap_erase1 ( self , color ) } # [ inline ] pub unsafe fn erase2 ( & self , color : * const SkColor4f , subset : * const SkIRect ) -> bool { SkPixmap_erase2 ( self , color , subset ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPixmap_SkPixmap ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( info : * const SkImageInfo , addr : * const :: std :: os :: raw :: c_void , rowBytes : usize ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPixmap_SkPixmap1 ( & mut __bindgen_tmp , info , addr , rowBytes ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkPixelRef { _unused : [ u8 ; 0 ] , } # [ doc = " \\class SkBitmap" ] # [ doc = "SkBitmap describes a two-dimensional raster pixel array. SkBitmap is built on" ] # [ doc = "SkImageInfo, containing integer width and height, SkColorType and SkAlphaType" ] # [ doc = "describing the pixel format, and SkColorSpace describing the range of colors." ] # [ doc = "SkBitmap points to SkPixelRef, which describes the physical array of pixels." ] # [ doc = "SkImageInfo bounds may be located anywhere fully inside SkPixelRef bounds." ] # [ doc = "" ] # [ doc = "SkBitmap can be drawn using SkCanvas. SkBitmap can be a drawing destination for SkCanvas" ] # [ doc = "draw member functions. SkBitmap flexibility as a pixel container limits some" ] # [ doc = "optimizations available to the target platform." ] # [ doc = "" ] # [ doc = "If pixel array is primarily read-only, use SkImage for better performance." ] # [ doc = "If pixel array is primarily written to, use SkSurface for better performance." ] # [ doc = "" ] # [ doc = "Declaring SkBitmap const prevents altering SkImageInfo: the SkBitmap height, width," ] # [ doc = "and so on cannot change. It does not affect SkPixelRef: a caller may write its" ] # [ doc = "pixels. Declaring SkBitmap const affects SkBitmap configuration, not its contents." ] # [ doc = "" ] # [ doc = "SkBitmap is not thread safe. Each thread must have its own copy of SkBitmap fields," ] # [ doc = "although threads may share the underlying pixel array." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkBitmap { pub fPixelRef : sk_sp < SkPixelRef > , pub fPixmap : SkPixmap , pub fFlags : u8 , } # [ repr ( u32 ) ] # [ doc = " \\enum SkBitmap::AllocFlags" ] # [ doc = "AllocFlags provides the option to zero pixel memory when allocated." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkBitmap_AllocFlags { # [ doc = "!< zero pixel memory" ] kZeroPixels_AllocFlag = 1 , } # [ doc = " \\class SkBitmap::Allocator" ] # [ doc = "Abstract subclass of HeapAllocator." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkBitmap_Allocator { pub _base : SkRefCnt , } pub type SkBitmap_Allocator_INHERITED = SkRefCnt ; # [ test ] fn bindgen_test_layout_SkBitmap_Allocator ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkBitmap_Allocator > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkBitmap_Allocator ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkBitmap_Allocator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkBitmap_Allocator ) ) ) ; } # [ doc = " \\class SkBitmap::HeapAllocator" ] # [ doc = "Subclass of SkBitmap::Allocator that returns a SkPixelRef that allocates its pixel" ] # [ doc = "memory from the heap. This is the default SkBitmap::Allocator invoked by" ] # [ doc = "allocPixels()." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkBitmap_HeapAllocator { pub _base : SkBitmap_Allocator , } # [ test ] fn bindgen_test_layout_SkBitmap_HeapAllocator ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkBitmap_HeapAllocator > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkBitmap_HeapAllocator ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkBitmap_HeapAllocator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkBitmap_HeapAllocator ) ) ) ; } pub const SkBitmap_Flags_kImageIsVolatile_Flag : SkBitmap_Flags = 2 ; pub type SkBitmap_Flags = u32 ; # [ test ] fn bindgen_test_layout_SkBitmap ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkBitmap > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( SkBitmap ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkBitmap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkBitmap ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkBitmap > ( ) ) ) . fPixelRef as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkBitmap ) , "::" , stringify ! ( fPixelRef ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkBitmap > ( ) ) ) . fPixmap as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkBitmap ) , "::" , stringify ! ( fPixmap ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkBitmap > ( ) ) ) . fFlags as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkBitmap ) , "::" , stringify ! ( fFlags ) ) ) ; } extern "C" { # [ doc = " Swaps the fields of the two bitmaps." ] # [ doc = "" ] # [ doc = "@param other  SkBitmap exchanged with original" ] # [ link_name = "\u{1}__ZN8SkBitmap4swapERS_" ] pub fn SkBitmap_swap ( this : * mut SkBitmap , other : * mut SkBitmap ) ; } extern "C" { # [ doc = " Returns a constant reference to the SkPixmap holding the SkBitmap pixel" ] # [ doc = "address, row bytes, and SkImageInfo." ] # [ doc = "" ] # [ doc = "@return  reference to SkPixmap describing this SkBitmap" ] # [ link_name = "\u{1}__ZNK8SkBitmap6pixmapEv" ] pub fn SkBitmap_pixmap ( this : * const SkBitmap ) -> * const SkPixmap ; } extern "C" { # [ doc = " Returns width, height, SkAlphaType, SkColorType, and SkColorSpace." ] # [ doc = "" ] # [ doc = "@return  reference to SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkBitmap4infoEv" ] pub fn SkBitmap_info ( this : * const SkBitmap ) -> * const SkImageInfo ; } extern "C" { # [ doc = " Returns pixel count in each row. Should be equal or less than" ] # [ doc = "rowBytes() / info().bytesPerPixel()." ] # [ doc = "" ] # [ doc = "May be less than pixelRef().width(). Will not exceed pixelRef().width() less" ] # [ doc = "pixelRefOrigin().fX." ] # [ doc = "" ] # [ doc = "@return  pixel width in SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkBitmap5widthEv" ] pub fn SkBitmap_width ( this : * const SkBitmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns pixel row count." ] # [ doc = "" ] # [ doc = "Maybe be less than pixelRef().height(). Will not exceed pixelRef().height() less" ] # [ doc = "pixelRefOrigin().fY." ] # [ doc = "" ] # [ doc = "@return  pixel height in SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkBitmap6heightEv" ] pub fn SkBitmap_height ( this : * const SkBitmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns SkColorType, one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType." ] # [ doc = "" ] # [ doc = "@return  SkColorType in SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkBitmap9colorTypeEv" ] pub fn SkBitmap_colorType ( this : * const SkBitmap ) -> SkColorType ; } extern "C" { # [ doc = " Returns SkAlphaType, one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType." ] # [ doc = "" ] # [ doc = "@return  SkAlphaType in SkImageInfo" ] # [ link_name = "\u{1}__ZNK8SkBitmap9alphaTypeEv" ] pub fn SkBitmap_alphaType ( this : * const SkBitmap ) -> SkAlphaType ; } extern "C" { # [ doc = " Returns SkColorSpace, the range of colors, associated with SkImageInfo. The" ] # [ doc = "reference count of SkColorSpace is unchanged. The returned SkColorSpace is" ] # [ doc = "immutable." ] # [ doc = "" ] # [ doc = "@return  SkColorSpace in SkImageInfo, or nullptr" ] # [ link_name = "\u{1}__ZNK8SkBitmap10colorSpaceEv" ] pub fn SkBitmap_colorSpace ( this : * const SkBitmap ) -> * mut SkColorSpace ; } extern "C" { # [ doc = " Returns smart pointer to SkColorSpace, the range of colors, associated with" ] # [ doc = "SkImageInfo. The smart pointer tracks the number of objects sharing this" ] # [ doc = "SkColorSpace reference so the memory is released when the owners destruct." ] # [ doc = "" ] # [ doc = "The returned SkColorSpace is immutable." ] # [ doc = "" ] # [ doc = "@return  SkColorSpace in SkImageInfo wrapped in a smart pointer" ] # [ link_name = "\u{1}__ZNK8SkBitmap13refColorSpaceEv" ] pub fn SkBitmap_refColorSpace ( this : * const SkBitmap ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = " Returns number of bytes per pixel required by SkColorType." ] # [ doc = "Returns zero if colorType( is kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  bytes in pixel" ] # [ link_name = "\u{1}__ZNK8SkBitmap13bytesPerPixelEv" ] pub fn SkBitmap_bytesPerPixel ( this : * const SkBitmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns number of pixels that fit on row. Should be greater than or equal to" ] # [ doc = "width()." ] # [ doc = "" ] # [ doc = "@return  maximum pixels per row" ] # [ link_name = "\u{1}__ZNK8SkBitmap16rowBytesAsPixelsEv" ] pub fn SkBitmap_rowBytesAsPixels ( this : * const SkBitmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns bit shift converting row bytes to row pixels." ] # [ doc = "Returns zero for kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  one of: 0, 1, 2, 3; left shift to convert pixels to bytes" ] # [ link_name = "\u{1}__ZNK8SkBitmap13shiftPerPixelEv" ] pub fn SkBitmap_shiftPerPixel ( this : * const SkBitmap ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns true if either width() or height() are zero." ] # [ doc = "" ] # [ doc = "Does not check if SkPixelRef is nullptr; call drawsNothing() to check width()," ] # [ doc = "height(), and SkPixelRef." ] # [ doc = "" ] # [ doc = "@return  true if dimensions do not enclose area" ] # [ link_name = "\u{1}__ZNK8SkBitmap5emptyEv" ] pub fn SkBitmap_empty ( this : * const SkBitmap ) -> bool ; } extern "C" { # [ doc = " Returns true if SkPixelRef is nullptr." ] # [ doc = "" ] # [ doc = "Does not check if width() or height() are zero; call drawsNothing() to check" ] # [ doc = "width(), height(), and SkPixelRef." ] # [ doc = "" ] # [ doc = "@return  true if no SkPixelRef is associated" ] # [ link_name = "\u{1}__ZNK8SkBitmap6isNullEv" ] pub fn SkBitmap_isNull ( this : * const SkBitmap ) -> bool ; } extern "C" { # [ doc = " Returns true if width() or height() are zero, or if SkPixelRef is nullptr." ] # [ doc = "If true, SkBitmap has no effect when drawn or drawn into." ] # [ doc = "" ] # [ doc = "@return  true if drawing has no effect" ] # [ link_name = "\u{1}__ZNK8SkBitmap12drawsNothingEv" ] pub fn SkBitmap_drawsNothing ( this : * const SkBitmap ) -> bool ; } extern "C" { # [ doc = " Returns row bytes, the interval from one pixel row to the next. Row bytes" ] # [ doc = "is at least as large as: width() * info().bytesPerPixel()." ] # [ doc = "" ] # [ doc = "Returns zero if colorType() is kUnknown_SkColorType, or if row bytes supplied to" ] # [ doc = "setInfo() is not large enough to hold a row of pixels." ] # [ doc = "" ] # [ doc = "@return  byte length of pixel row" ] # [ link_name = "\u{1}__ZNK8SkBitmap8rowBytesEv" ] pub fn SkBitmap_rowBytes ( this : * const SkBitmap ) -> usize ; } extern "C" { # [ doc = " Sets SkAlphaType, if alphaType is compatible with SkColorType." ] # [ doc = "Returns true unless alphaType is kUnknown_SkAlphaType and current SkAlphaType" ] # [ doc = "is not kUnknown_SkAlphaType." ] # [ doc = "" ] # [ doc = "Returns true if SkColorType is kUnknown_SkColorType. alphaType is ignored, and" ] # [ doc = "SkAlphaType remains kUnknown_SkAlphaType." ] # [ doc = "" ] # [ doc = "Returns true if SkColorType is kRGB_565_SkColorType or kGray_8_SkColorType." ] # [ doc = "alphaType is ignored, and SkAlphaType remains kOpaque_SkAlphaType." ] # [ doc = "" ] # [ doc = "If SkColorType is kARGB_4444_SkColorType, kRGBA_8888_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, or kRGBA_F16_SkColorType: returns true unless" ] # [ doc = "alphaType is kUnknown_SkAlphaType and SkAlphaType is not kUnknown_SkAlphaType." ] # [ doc = "If SkAlphaType is kUnknown_SkAlphaType, alphaType is ignored." ] # [ doc = "" ] # [ doc = "If SkColorType is kAlpha_8_SkColorType, returns true unless" ] # [ doc = "alphaType is kUnknown_SkAlphaType and SkAlphaType is not kUnknown_SkAlphaType." ] # [ doc = "If SkAlphaType is kUnknown_SkAlphaType, alphaType is ignored. If alphaType is" ] # [ doc = "kUnpremul_SkAlphaType, it is treated as kPremul_SkAlphaType." ] # [ doc = "" ] # [ doc = "This changes SkAlphaType in SkPixelRef; all bitmaps sharing SkPixelRef" ] # [ doc = "are affected." ] # [ doc = "" ] # [ doc = "@param alphaType  one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@return           true if SkAlphaType is set" ] # [ link_name = "\u{1}__ZN8SkBitmap12setAlphaTypeE11SkAlphaType" ] pub fn SkBitmap_setAlphaType ( this : * mut SkBitmap , alphaType : SkAlphaType ) -> bool ; } extern "C" { # [ doc = " Returns pixel address, the base address corresponding to the pixel origin." ] # [ doc = "" ] # [ doc = "@return  pixel address" ] # [ link_name = "\u{1}__ZNK8SkBitmap9getPixelsEv" ] pub fn SkBitmap_getPixels ( this : * const SkBitmap ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " Returns minimum memory required for pixel storage." ] # [ doc = "Does not include unused memory on last row when rowBytesAsPixels() exceeds width()." ] # [ doc = "Returns zero if result does not fit in size_t." ] # [ doc = "Returns zero if height() or width() is 0." ] # [ doc = "Returns height() times rowBytes() if colorType() is kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  size in bytes of image buffer" ] # [ link_name = "\u{1}__ZNK8SkBitmap15computeByteSizeEv" ] pub fn SkBitmap_computeByteSize ( this : * const SkBitmap ) -> usize ; } extern "C" { # [ doc = " Returns true if pixels can not change." ] # [ doc = "" ] # [ doc = "Most immutable SkBitmap checks trigger an assert only on debug builds." ] # [ doc = "" ] # [ doc = "@return  true if pixels are immutable" ] # [ link_name = "\u{1}__ZNK8SkBitmap11isImmutableEv" ] pub fn SkBitmap_isImmutable ( this : * const SkBitmap ) -> bool ; } extern "C" { # [ doc = " Sets internal flag to mark SkBitmap as immutable. Once set, pixels can not change." ] # [ doc = "Any other bitmap sharing the same SkPixelRef are also marked as immutable." ] # [ doc = "Once SkPixelRef is marked immutable, the setting cannot be cleared." ] # [ doc = "" ] # [ doc = "Writing to immutable SkBitmap pixels triggers an assert on debug builds." ] # [ link_name = "\u{1}__ZN8SkBitmap12setImmutableEv" ] pub fn SkBitmap_setImmutable ( this : * mut SkBitmap ) ; } extern "C" { # [ doc = " Returns true if SkAlphaType is set to hint that all pixels are opaque; their" ] # [ doc = "alpha value is implicitly or explicitly 1.0. If true, and all pixels are" ] # [ doc = "not opaque, Skia may draw incorrectly." ] # [ doc = "" ] # [ doc = "Does not check if SkColorType allows alpha, or if any pixel value has" ] # [ doc = "transparency." ] # [ doc = "" ] # [ doc = "@return  true if SkImageInfo SkAlphaType is kOpaque_SkAlphaType" ] # [ link_name = "\u{1}__ZNK8SkBitmap8isOpaqueEv" ] pub fn SkBitmap_isOpaque ( this : * const SkBitmap ) -> bool ; } extern "C" { # [ doc = " Provides a hint to caller that pixels should not be cached. Only true if" ] # [ doc = "setIsVolatile() has been called to mark as volatile." ] # [ doc = "" ] # [ doc = "Volatile state is not shared by other bitmaps sharing the same SkPixelRef." ] # [ doc = "" ] # [ doc = "@return  true if marked volatile" ] # [ link_name = "\u{1}__ZNK8SkBitmap10isVolatileEv" ] pub fn SkBitmap_isVolatile ( this : * const SkBitmap ) -> bool ; } extern "C" { # [ doc = " Sets if pixels should be read from SkPixelRef on every access. SkBitmap are not" ] # [ doc = "volatile by default; a GPU back end may upload pixel values expecting them to be" ] # [ doc = "accessed repeatedly. Marking temporary SkBitmap as volatile provides a hint to" ] # [ doc = "SkBaseDevice that the SkBitmap pixels should not be cached. This can" ] # [ doc = "improve performance by avoiding overhead and reducing resource" ] # [ doc = "consumption on SkBaseDevice." ] # [ doc = "" ] # [ doc = "@param isVolatile  true if backing pixels are temporary" ] # [ link_name = "\u{1}__ZN8SkBitmap13setIsVolatileEb" ] pub fn SkBitmap_setIsVolatile ( this : * mut SkBitmap , isVolatile : bool ) ; } extern "C" { # [ doc = " Resets to its initial state; all fields are set to zero, as if SkBitmap had" ] # [ doc = "been initialized by SkBitmap()." ] # [ doc = "" ] # [ doc = "Sets width, height, row bytes to zero; pixel address to nullptr; SkColorType to" ] # [ doc = "kUnknown_SkColorType; and SkAlphaType to kUnknown_SkAlphaType." ] # [ doc = "" ] # [ doc = "If SkPixelRef is allocated, its reference count is decreased by one, releasing" ] # [ doc = "its memory if SkBitmap is the sole owner." ] # [ link_name = "\u{1}__ZN8SkBitmap5resetEv" ] pub fn SkBitmap_reset ( this : * mut SkBitmap ) ; } extern "C" { # [ doc = " Returns true if all pixels are opaque. SkColorType determines how pixels" ] # [ doc = "are encoded, and whether pixel describes alpha. Returns true for SkColorType" ] # [ doc = "without alpha in each pixel; for other SkColorType, returns true if all" ] # [ doc = "pixels have alpha values equivalent to 1.0 or greater." ] # [ doc = "" ] # [ doc = "For SkColorType kRGB_565_SkColorType or kGray_8_SkColorType: always" ] # [ doc = "returns true. For SkColorType kAlpha_8_SkColorType, kBGRA_8888_SkColorType," ] # [ doc = "kRGBA_8888_SkColorType: returns true if all pixel alpha values are 255." ] # [ doc = "For SkColorType kARGB_4444_SkColorType: returns true if all pixel alpha values are 15." ] # [ doc = "For kRGBA_F16_SkColorType: returns true if all pixel alpha values are 1.0 or" ] # [ doc = "greater." ] # [ doc = "" ] # [ doc = "Returns false for kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@param bm  SkBitmap to check" ] # [ doc = "@return    true if all pixels have opaque values or SkColorType is opaque" ] # [ link_name = "\u{1}__ZN8SkBitmap15ComputeIsOpaqueERKS_" ] pub fn SkBitmap_ComputeIsOpaque ( bm : * const SkBitmap ) -> bool ; } extern "C" { # [ doc = " Returns SkRect { 0, 0, width(), height() }." ] # [ doc = "" ] # [ doc = "@param bounds  container for floating point rectangle" ] # [ link_name = "\u{1}__ZNK8SkBitmap9getBoundsEP6SkRect" ] pub fn SkBitmap_getBounds ( this : * const SkBitmap , bounds : * mut SkRect ) ; } extern "C" { # [ doc = " Returns SkIRect { 0, 0, width(), height() }." ] # [ doc = "" ] # [ doc = "@param bounds  container for integral rectangle" ] # [ link_name = "\u{1}__ZNK8SkBitmap9getBoundsEP7SkIRect" ] pub fn SkBitmap_getBounds1 ( this : * const SkBitmap , bounds : * mut SkIRect ) ; } extern "C" { # [ doc = " Returns SkIRect { 0, 0, width(), height() }." ] # [ doc = "" ] # [ doc = "@return  integral rectangle from origin to width() and height()" ] # [ link_name = "\u{1}__ZNK8SkBitmap6boundsEv" ] pub fn SkBitmap_bounds ( this : * const SkBitmap ) -> SkIRect ; } extern "C" { # [ doc = " Returns SkISize { width(), height() }." ] # [ doc = "" ] # [ doc = "@return  integral size of width() and height()" ] # [ link_name = "\u{1}__ZNK8SkBitmap10dimensionsEv" ] pub fn SkBitmap_dimensions ( this : * const SkBitmap ) -> SkISize ; } extern "C" { # [ doc = " Returns the bounds of this bitmap, offset by its SkPixelRef origin." ] # [ doc = "" ] # [ doc = "@return  bounds within SkPixelRef bounds" ] # [ link_name = "\u{1}__ZNK8SkBitmap9getSubsetEv" ] pub fn SkBitmap_getSubset ( this : * const SkBitmap ) -> SkIRect ; } extern "C" { # [ doc = " Sets width, height, SkAlphaType, SkColorType, SkColorSpace, and optional" ] # [ doc = "rowBytes. Frees pixels, and returns true if successful." ] # [ doc = "" ] # [ doc = "imageInfo.alphaType() may be altered to a value permitted by imageInfo.colorSpace()." ] # [ doc = "If imageInfo.colorType() is kUnknown_SkColorType, imageInfo.alphaType() is" ] # [ doc = "set to kUnknown_SkAlphaType." ] # [ doc = "If imageInfo.colorType() is kAlpha_8_SkColorType and imageInfo.alphaType() is" ] # [ doc = "kUnpremul_SkAlphaType, imageInfo.alphaType() is replaced by kPremul_SkAlphaType." ] # [ doc = "If imageInfo.colorType() is kRGB_565_SkColorType or kGray_8_SkColorType," ] # [ doc = "imageInfo.alphaType() is set to kOpaque_SkAlphaType." ] # [ doc = "If imageInfo.colorType() is kARGB_4444_SkColorType, kRGBA_8888_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, or kRGBA_F16_SkColorType: imageInfo.alphaType() remains" ] # [ doc = "unchanged." ] # [ doc = "" ] # [ doc = "rowBytes must equal or exceed imageInfo.minRowBytes(). If imageInfo.colorSpace() is" ] # [ doc = "kUnknown_SkColorType, rowBytes is ignored and treated as zero; for all other" ] # [ doc = "SkColorSpace values, rowBytes of zero is treated as imageInfo.minRowBytes()." ] # [ doc = "" ] # [ doc = "Calls reset() and returns false if:" ] # [ doc = "- rowBytes exceeds 31 bits" ] # [ doc = "- imageInfo.width() is negative" ] # [ doc = "- imageInfo.height() is negative" ] # [ doc = "- rowBytes is positive and less than imageInfo.width() times imageInfo.bytesPerPixel()" ] # [ doc = "" ] # [ doc = "@param imageInfo  contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@param rowBytes   imageInfo.minRowBytes() or larger; or zero" ] # [ doc = "@return           true if SkImageInfo set successfully" ] # [ link_name = "\u{1}__ZN8SkBitmap7setInfoERK11SkImageInfom" ] pub fn SkBitmap_setInfo ( this : * mut SkBitmap , imageInfo : * const SkImageInfo , rowBytes : usize ) -> bool ; } extern "C" { # [ doc = " Sets SkImageInfo to info following the rules in setInfo() and allocates pixel" ] # [ doc = "memory. If flags is kZeroPixels_AllocFlag, memory is zeroed." ] # [ doc = "" ] # [ doc = "Returns false and calls reset() if SkImageInfo could not be set, or memory could" ] # [ doc = "not be allocated, or memory could not optionally be zeroed." ] # [ doc = "" ] # [ doc = "On most platforms, allocating pixel memory may succeed even though there is" ] # [ doc = "not sufficient memory to hold pixels; allocation does not take place" ] # [ doc = "until the pixels are written to. The actual behavior depends on the platform" ] # [ doc = "implementation of malloc(), if flags is zero, and calloc(), if flags is" ] # [ doc = "kZeroPixels_AllocFlag." ] # [ doc = "" ] # [ doc = "flags set to kZeroPixels_AllocFlag offers equal or better performance than" ] # [ doc = "subsequently calling eraseColor() with SK_ColorTRANSPARENT." ] # [ doc = "" ] # [ doc = "@param info   contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@param flags  kZeroPixels_AllocFlag, or zero" ] # [ doc = "@return       true if pixels allocation is successful" ] # [ link_name = "\u{1}__ZN8SkBitmap19tryAllocPixelsFlagsERK11SkImageInfoj" ] pub fn SkBitmap_tryAllocPixelsFlags ( this : * mut SkBitmap , info : * const SkImageInfo , flags : u32 ) -> bool ; } extern "C" { # [ doc = " Sets SkImageInfo to info following the rules in setInfo() and allocates pixel" ] # [ doc = "memory. If flags is kZeroPixels_AllocFlag, memory is zeroed." ] # [ doc = "" ] # [ doc = "Aborts execution if SkImageInfo could not be set, or memory could" ] # [ doc = "not be allocated, or memory could not optionally" ] # [ doc = "be zeroed. Abort steps may be provided by the user at compile time by defining" ] # [ doc = "SK_ABORT." ] # [ doc = "" ] # [ doc = "On most platforms, allocating pixel memory may succeed even though there is" ] # [ doc = "not sufficient memory to hold pixels; allocation does not take place" ] # [ doc = "until the pixels are written to. The actual behavior depends on the platform" ] # [ doc = "implementation of malloc(), if flags is zero, and calloc(), if flags is" ] # [ doc = "kZeroPixels_AllocFlag." ] # [ doc = "" ] # [ doc = "flags set to kZeroPixels_AllocFlag offers equal or better performance than" ] # [ doc = "subsequently calling eraseColor() with SK_ColorTRANSPARENT." ] # [ doc = "" ] # [ doc = "@param info   contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@param flags  kZeroPixels_AllocFlag, or zero" ] # [ link_name = "\u{1}__ZN8SkBitmap16allocPixelsFlagsERK11SkImageInfoj" ] pub fn SkBitmap_allocPixelsFlags ( this : * mut SkBitmap , info : * const SkImageInfo , flags : u32 ) ; } extern "C" { # [ doc = " Sets SkImageInfo to info following the rules in setInfo() and allocates pixel" ] # [ doc = "memory. rowBytes must equal or exceed info.width() times info.bytesPerPixel()," ] # [ doc = "or equal zero. Pass in zero for rowBytes to compute the minimum valid value." ] # [ doc = "" ] # [ doc = "Returns false and calls reset() if SkImageInfo could not be set, or memory could" ] # [ doc = "not be allocated." ] # [ doc = "" ] # [ doc = "On most platforms, allocating pixel memory may succeed even though there is" ] # [ doc = "not sufficient memory to hold pixels; allocation does not take place" ] # [ doc = "until the pixels are written to. The actual behavior depends on the platform" ] # [ doc = "implementation of malloc()." ] # [ doc = "" ] # [ doc = "@param info      contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@param rowBytes  size of pixel row or larger; may be zero" ] # [ doc = "@return          true if pixel storage is allocated" ] # [ link_name = "\u{1}__ZN8SkBitmap14tryAllocPixelsERK11SkImageInfom" ] pub fn SkBitmap_tryAllocPixels ( this : * mut SkBitmap , info : * const SkImageInfo , rowBytes : usize ) -> bool ; } extern "C" { # [ doc = " Sets SkImageInfo to info following the rules in setInfo() and allocates pixel" ] # [ doc = "memory. rowBytes must equal or exceed info.width() times info.bytesPerPixel()," ] # [ doc = "or equal zero. Pass in zero for rowBytes to compute the minimum valid value." ] # [ doc = "" ] # [ doc = "Aborts execution if SkImageInfo could not be set, or memory could" ] # [ doc = "not be allocated. Abort steps may be provided by" ] # [ doc = "the user at compile time by defining SK_ABORT." ] # [ doc = "" ] # [ doc = "On most platforms, allocating pixel memory may succeed even though there is" ] # [ doc = "not sufficient memory to hold pixels; allocation does not take place" ] # [ doc = "until the pixels are written to. The actual behavior depends on the platform" ] # [ doc = "implementation of malloc()." ] # [ doc = "" ] # [ doc = "@param info      contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@param rowBytes  size of pixel row or larger; may be zero" ] # [ link_name = "\u{1}__ZN8SkBitmap11allocPixelsERK11SkImageInfom" ] pub fn SkBitmap_allocPixels ( this : * mut SkBitmap , info : * const SkImageInfo , rowBytes : usize ) ; } extern "C" { # [ doc = " Sets SkImageInfo to info following the rules in setInfo() and allocates pixel" ] # [ doc = "memory." ] # [ doc = "" ] # [ doc = "Returns false and calls reset() if SkImageInfo could not be set, or memory could" ] # [ doc = "not be allocated." ] # [ doc = "" ] # [ doc = "On most platforms, allocating pixel memory may succeed even though there is" ] # [ doc = "not sufficient memory to hold pixels; allocation does not take place" ] # [ doc = "until the pixels are written to. The actual behavior depends on the platform" ] # [ doc = "implementation of malloc()." ] # [ doc = "" ] # [ doc = "@param info  contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@return      true if pixel storage is allocated" ] # [ link_name = "\u{1}__ZN8SkBitmap14tryAllocPixelsERK11SkImageInfo" ] pub fn SkBitmap_tryAllocPixels1 ( this : * mut SkBitmap , info : * const SkImageInfo ) -> bool ; } extern "C" { # [ doc = " Sets SkImageInfo to info following the rules in setInfo() and allocates pixel" ] # [ doc = "memory." ] # [ doc = "" ] # [ doc = "Aborts execution if SkImageInfo could not be set, or memory could" ] # [ doc = "not be allocated. Abort steps may be provided by" ] # [ doc = "the user at compile time by defining SK_ABORT." ] # [ doc = "" ] # [ doc = "On most platforms, allocating pixel memory may succeed even though there is" ] # [ doc = "not sufficient memory to hold pixels; allocation does not take place" ] # [ doc = "until the pixels are written to. The actual behavior depends on the platform" ] # [ doc = "implementation of malloc()." ] # [ doc = "" ] # [ doc = "@param info  contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ link_name = "\u{1}__ZN8SkBitmap11allocPixelsERK11SkImageInfo" ] pub fn SkBitmap_allocPixels1 ( this : * mut SkBitmap , info : * const SkImageInfo ) ; } extern "C" { # [ doc = " Sets SkImageInfo to width, height, and native color type; and allocates" ] # [ doc = "pixel memory. If isOpaque is true, sets SkImageInfo to kOpaque_SkAlphaType;" ] # [ doc = "otherwise, sets to kPremul_SkAlphaType." ] # [ doc = "" ] # [ doc = "Calls reset() and returns false if width exceeds 29 bits or is negative," ] # [ doc = "or height is negative." ] # [ doc = "" ] # [ doc = "Returns false if allocation fails." ] # [ doc = "" ] # [ doc = "Use to create SkBitmap that matches SkPMColor, the native pixel arrangement on" ] # [ doc = "the platform. SkBitmap drawn to output device skips converting its pixel format." ] # [ doc = "" ] # [ doc = "@param width     pixel column count; must be zero or greater" ] # [ doc = "@param height    pixel row count; must be zero or greater" ] # [ doc = "@param isOpaque  true if pixels do not have transparency" ] # [ doc = "@return          true if pixel storage is allocated" ] # [ link_name = "\u{1}__ZN8SkBitmap17tryAllocN32PixelsEiib" ] pub fn SkBitmap_tryAllocN32Pixels ( this : * mut SkBitmap , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool ) -> bool ; } extern "C" { # [ doc = " Sets SkImageInfo to width, height, and the native color type; and allocates" ] # [ doc = "pixel memory. If isOpaque is true, sets SkImageInfo to kPremul_SkAlphaType;" ] # [ doc = "otherwise, sets to kOpaque_SkAlphaType." ] # [ doc = "" ] # [ doc = "Aborts if width exceeds 29 bits or is negative, or height is negative, or" ] # [ doc = "allocation fails. Abort steps may be provided by the user at compile time by" ] # [ doc = "defining SK_ABORT." ] # [ doc = "" ] # [ doc = "Use to create SkBitmap that matches SkPMColor, the native pixel arrangement on" ] # [ doc = "the platform. SkBitmap drawn to output device skips converting its pixel format." ] # [ doc = "" ] # [ doc = "@param width     pixel column count; must be zero or greater" ] # [ doc = "@param height    pixel row count; must be zero or greater" ] # [ doc = "@param isOpaque  true if pixels do not have transparency" ] # [ link_name = "\u{1}__ZN8SkBitmap14allocN32PixelsEiib" ] pub fn SkBitmap_allocN32Pixels ( this : * mut SkBitmap , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool ) ; } extern "C" { # [ doc = " Sets SkImageInfo to info following the rules in setInfo(), and creates SkPixelRef" ] # [ doc = "containing pixels and rowBytes. releaseProc, if not nullptr, is called" ] # [ doc = "immediately on failure or when pixels are no longer referenced. context may be" ] # [ doc = "nullptr." ] # [ doc = "" ] # [ doc = "If SkImageInfo could not be set, or rowBytes is less than info.minRowBytes():" ] # [ doc = "calls releaseProc if present, calls reset(), and returns false." ] # [ doc = "" ] # [ doc = "Otherwise, if pixels equals nullptr: sets SkImageInfo, calls releaseProc if" ] # [ doc = "present, returns true." ] # [ doc = "" ] # [ doc = "If SkImageInfo is set, pixels is not nullptr, and releaseProc is not nullptr:" ] # [ doc = "when pixels are no longer referenced, calls releaseProc with pixels and context" ] # [ doc = "as parameters." ] # [ doc = "" ] # [ doc = "@param info         contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@param pixels       address or pixel storage; may be nullptr" ] # [ doc = "@param rowBytes     size of pixel row or larger" ] # [ doc = "@param releaseProc  function called when pixels can be deleted; may be nullptr" ] # [ doc = "@param context      caller state passed to releaseProc; may be nullptr" ] # [ doc = "@return             true if SkImageInfo is set to info" ] # [ link_name = "\u{1}__ZN8SkBitmap13installPixelsERK11SkImageInfoPvmPFvS3_S3_ES3_" ] pub fn SkBitmap_installPixels ( this : * mut SkBitmap , info : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize , releaseProc : :: core :: option :: Option < unsafe extern "C" fn ( this : * mut SkBitmap , info : * mut :: std :: os :: raw :: c_void , pixels : * mut :: std :: os :: raw :: c_void ) > , context : * mut :: std :: os :: raw :: c_void ) -> bool ; } extern "C" { # [ doc = " Sets SkImageInfo to info following the rules in setInfo(), and creates SkPixelRef" ] # [ doc = "containing pixels and rowBytes." ] # [ doc = "" ] # [ doc = "If SkImageInfo could not be set, or rowBytes is less than info.minRowBytes():" ] # [ doc = "calls reset(), and returns false." ] # [ doc = "" ] # [ doc = "Otherwise, if pixels equals nullptr: sets SkImageInfo, returns true." ] # [ doc = "" ] # [ doc = "Caller must ensure that pixels are valid for the lifetime of SkBitmap and SkPixelRef." ] # [ doc = "" ] # [ doc = "@param info      contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@param pixels    address or pixel storage; may be nullptr" ] # [ doc = "@param rowBytes  size of pixel row or larger" ] # [ doc = "@return          true if SkImageInfo is set to info" ] # [ link_name = "\u{1}__ZN8SkBitmap13installPixelsERK11SkImageInfoPvm" ] pub fn SkBitmap_installPixels1 ( this : * mut SkBitmap , info : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize ) -> bool ; } extern "C" { # [ doc = " Sets SkImageInfo to pixmap.info() following the rules in setInfo(), and creates" ] # [ doc = "SkPixelRef containing pixmap.addr() and pixmap.rowBytes()." ] # [ doc = "" ] # [ doc = "If SkImageInfo could not be set, or pixmap.rowBytes() is less than" ] # [ doc = "SkImageInfo::minRowBytes(): calls reset(), and returns false." ] # [ doc = "" ] # [ doc = "Otherwise, if pixmap.addr() equals nullptr: sets SkImageInfo, returns true." ] # [ doc = "" ] # [ doc = "Caller must ensure that pixmap is valid for the lifetime of SkBitmap and SkPixelRef." ] # [ doc = "" ] # [ doc = "@param pixmap  SkImageInfo, pixel address, and rowBytes()" ] # [ doc = "@return        true if SkImageInfo was set to pixmap.info()" ] # [ link_name = "\u{1}__ZN8SkBitmap13installPixelsERK8SkPixmap" ] pub fn SkBitmap_installPixels2 ( this : * mut SkBitmap , pixmap : * const SkPixmap ) -> bool ; } extern "C" { # [ doc = " Deprecated." ] # [ link_name = "\u{1}__ZN8SkBitmap17installMaskPixelsERK6SkMask" ] pub fn SkBitmap_installMaskPixels ( this : * mut SkBitmap , mask : * const SkMask ) -> bool ; } extern "C" { # [ doc = " Replaces SkPixelRef with pixels, preserving SkImageInfo and rowBytes()." ] # [ doc = "Sets SkPixelRef origin to (0, 0)." ] # [ doc = "" ] # [ doc = "If pixels is nullptr, or if info().colorType() equals kUnknown_SkColorType;" ] # [ doc = "release reference to SkPixelRef, and set SkPixelRef to nullptr." ] # [ doc = "" ] # [ doc = "Caller is responsible for handling ownership pixel memory for the lifetime" ] # [ doc = "of SkBitmap and SkPixelRef." ] # [ doc = "" ] # [ doc = "@param pixels  address of pixel storage, managed by caller" ] # [ link_name = "\u{1}__ZN8SkBitmap9setPixelsEPv" ] pub fn SkBitmap_setPixels ( this : * mut SkBitmap , pixels : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ doc = " Allocates pixel memory with HeapAllocator, and replaces existing SkPixelRef." ] # [ doc = "The allocation size is determined by SkImageInfo width, height, and SkColorType." ] # [ doc = "" ] # [ doc = "Returns false if info().colorType() is kUnknown_SkColorType, or allocation fails." ] # [ doc = "" ] # [ doc = "@return  true if the allocation succeeds" ] # [ link_name = "\u{1}__ZN8SkBitmap14tryAllocPixelsEv" ] pub fn SkBitmap_tryAllocPixels2 ( this : * mut SkBitmap ) -> bool ; } extern "C" { # [ doc = " Allocates pixel memory with HeapAllocator, and replaces existing SkPixelRef." ] # [ doc = "The allocation size is determined by SkImageInfo width, height, and SkColorType." ] # [ doc = "" ] # [ doc = "Aborts if info().colorType() is kUnknown_SkColorType, or allocation fails." ] # [ doc = "Abort steps may be provided by the user at compile" ] # [ doc = "time by defining SK_ABORT." ] # [ link_name = "\u{1}__ZN8SkBitmap11allocPixelsEv" ] pub fn SkBitmap_allocPixels2 ( this : * mut SkBitmap ) ; } extern "C" { # [ doc = " Allocates pixel memory with allocator, and replaces existing SkPixelRef." ] # [ doc = "The allocation size is determined by SkImageInfo width, height, and SkColorType." ] # [ doc = "If allocator is nullptr, use HeapAllocator instead." ] # [ doc = "" ] # [ doc = "Returns false if Allocator::allocPixelRef return false." ] # [ doc = "" ] # [ doc = "@param allocator  instance of SkBitmap::Allocator instantiation" ] # [ doc = "@return           true if custom allocator reports success" ] # [ link_name = "\u{1}__ZN8SkBitmap14tryAllocPixelsEPNS_9AllocatorE" ] pub fn SkBitmap_tryAllocPixels3 ( this : * mut SkBitmap , allocator : * mut SkBitmap_Allocator ) -> bool ; } extern "C" { # [ doc = " Allocates pixel memory with allocator, and replaces existing SkPixelRef." ] # [ doc = "The allocation size is determined by SkImageInfo width, height, and SkColorType." ] # [ doc = "If allocator is nullptr, use HeapAllocator instead." ] # [ doc = "" ] # [ doc = "Aborts if Allocator::allocPixelRef return false. Abort steps may be provided by" ] # [ doc = "the user at compile time by defining SK_ABORT." ] # [ doc = "" ] # [ doc = "@param allocator  instance of SkBitmap::Allocator instantiation" ] # [ link_name = "\u{1}__ZN8SkBitmap11allocPixelsEPNS_9AllocatorE" ] pub fn SkBitmap_allocPixels3 ( this : * mut SkBitmap , allocator : * mut SkBitmap_Allocator ) ; } extern "C" { # [ doc = " Returns SkPixelRef, which contains: pixel base address; its dimensions; and" ] # [ doc = "rowBytes(), the interval from one row to the next. Does not change SkPixelRef" ] # [ doc = "reference count. SkPixelRef may be shared by multiple bitmaps." ] # [ doc = "If SkPixelRef has not been set, returns nullptr." ] # [ doc = "" ] # [ doc = "@return  SkPixelRef, or nullptr" ] # [ link_name = "\u{1}__ZNK8SkBitmap8pixelRefEv" ] pub fn SkBitmap_pixelRef ( this : * const SkBitmap ) -> * mut SkPixelRef ; } extern "C" { # [ doc = " Returns origin of pixels within SkPixelRef. SkBitmap bounds is always contained" ] # [ doc = "by SkPixelRef bounds, which may be the same size or larger. Multiple SkBitmap" ] # [ doc = "can share the same SkPixelRef, where each SkBitmap has different bounds." ] # [ doc = "" ] # [ doc = "The returned origin added to SkBitmap dimensions equals or is smaller than the" ] # [ doc = "SkPixelRef dimensions." ] # [ doc = "" ] # [ doc = "Returns (0, 0) if SkPixelRef is nullptr." ] # [ doc = "" ] # [ doc = "@return  pixel origin within SkPixelRef" ] # [ link_name = "\u{1}__ZNK8SkBitmap14pixelRefOriginEv" ] pub fn SkBitmap_pixelRefOrigin ( this : * const SkBitmap ) -> SkIPoint ; } extern "C" { # [ doc = " Replaces pixelRef and origin in SkBitmap.  dx and dy specify the offset" ] # [ doc = "within the SkPixelRef pixels for the top-left corner of the bitmap." ] # [ doc = "" ] # [ doc = "Asserts in debug builds if dx or dy are out of range. Pins dx and dy" ] # [ doc = "to legal range in release builds." ] # [ doc = "" ] # [ doc = "The caller is responsible for ensuring that the pixels match the" ] # [ doc = "SkColorType and SkAlphaType in SkImageInfo." ] # [ doc = "" ] # [ doc = "@param pixelRef  SkPixelRef describing pixel address and rowBytes()" ] # [ doc = "@param dx        column offset in SkPixelRef for bitmap origin" ] # [ doc = "@param dy        row offset in SkPixelRef for bitmap origin" ] # [ link_name = "\u{1}__ZN8SkBitmap11setPixelRefE5sk_spI10SkPixelRefEii" ] pub fn SkBitmap_setPixelRef ( this : * mut SkBitmap , pixelRef : sk_sp < SkPixelRef > , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Returns true if SkBitmap is can be drawn." ] # [ doc = "" ] # [ doc = "@return  true if getPixels() is not nullptr" ] # [ link_name = "\u{1}__ZNK8SkBitmap11readyToDrawEv" ] pub fn SkBitmap_readyToDraw ( this : * const SkBitmap ) -> bool ; } extern "C" { # [ doc = " Returns a unique value corresponding to the pixels in SkPixelRef." ] # [ doc = "Returns a different value after notifyPixelsChanged() has been called." ] # [ doc = "Returns zero if SkPixelRef is nullptr." ] # [ doc = "" ] # [ doc = "Determines if pixels have changed since last examined." ] # [ doc = "" ] # [ doc = "@return  unique value for pixels in SkPixelRef" ] # [ link_name = "\u{1}__ZNK8SkBitmap15getGenerationIDEv" ] pub fn SkBitmap_getGenerationID ( this : * const SkBitmap ) -> u32 ; } extern "C" { # [ doc = " Marks that pixels in SkPixelRef have changed. Subsequent calls to" ] # [ doc = "getGenerationID() return a different value." ] # [ link_name = "\u{1}__ZNK8SkBitmap19notifyPixelsChangedEv" ] pub fn SkBitmap_notifyPixelsChanged ( this : * const SkBitmap ) ; } extern "C" { # [ doc = " Replaces pixel values with c. All pixels contained by bounds() are affected." ] # [ doc = "If the colorType() is kGray_8_SkColorType or kRGB_565_SkColorType, then alpha" ] # [ doc = "is ignored; RGB is treated as opaque. If colorType() is kAlpha_8_SkColorType," ] # [ doc = "then RGB is ignored." ] # [ doc = "" ] # [ doc = "@param c  unpremultiplied color" ] # [ link_name = "\u{1}__ZNK8SkBitmap10eraseColorEj" ] pub fn SkBitmap_eraseColor ( this : * const SkBitmap , c : SkColor ) ; } extern "C" { # [ doc = " Replaces pixel values with unpremultiplied color built from a, r, g, and b." ] # [ doc = "All pixels contained by bounds() are affected." ] # [ doc = "If the colorType() is kGray_8_SkColorType or kRGB_565_SkColorType, then a" ] # [ doc = "is ignored; r, g, and b are treated as opaque. If colorType() is kAlpha_8_SkColorType," ] # [ doc = "then r, g, and b are ignored." ] # [ doc = "" ] # [ doc = "@param a  amount of alpha, from fully transparent (0) to fully opaque (255)" ] # [ doc = "@param r  amount of red, from no red (0) to full red (255)" ] # [ doc = "@param g  amount of green, from no green (0) to full green (255)" ] # [ doc = "@param b  amount of blue, from no blue (0) to full blue (255)" ] # [ link_name = "\u{1}__ZNK8SkBitmap9eraseARGBEjjjj" ] pub fn SkBitmap_eraseARGB ( this : * const SkBitmap , a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU ) ; } extern "C" { # [ doc = " Replaces pixel values inside area with c. If area does not intersect bounds()," ] # [ doc = "call has no effect." ] # [ doc = "" ] # [ doc = "If the colorType() is kGray_8_SkColorType or kRGB_565_SkColorType, then alpha" ] # [ doc = "is ignored; RGB is treated as opaque. If colorType() is kAlpha_8_SkColorType," ] # [ doc = "then RGB is ignored." ] # [ doc = "" ] # [ doc = "@param c     unpremultiplied color" ] # [ doc = "@param area  rectangle to fill" ] # [ link_name = "\u{1}__ZNK8SkBitmap5eraseEjRK7SkIRect" ] pub fn SkBitmap_erase ( this : * const SkBitmap , c : SkColor , area : * const SkIRect ) ; } extern "C" { # [ doc = " Deprecated." ] # [ link_name = "\u{1}__ZNK8SkBitmap9eraseAreaERK7SkIRectj" ] pub fn SkBitmap_eraseArea ( this : * const SkBitmap , area : * const SkIRect , c : SkColor ) ; } extern "C" { # [ doc = " Returns pixel at (x, y) as unpremultiplied color." ] # [ doc = "Returns black with alpha if SkColorType is kAlpha_8_SkColorType." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y trigger an assert() if" ] # [ doc = "built with SK_DEBUG defined; and returns undefined values or may crash if" ] # [ doc = "SK_RELEASE is defined. Fails if SkColorType is kUnknown_SkColorType or" ] # [ doc = "pixel address is nullptr." ] # [ doc = "" ] # [ doc = "SkColorSpace in SkImageInfo is ignored. Some color precision may be lost in the" ] # [ doc = "conversion to unpremultiplied color; original pixel data may have additional" ] # [ doc = "precision." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   pixel converted to unpremultiplied color" ] # [ link_name = "\u{1}__ZNK8SkBitmap8getColorEii" ] pub fn SkBitmap_getColor ( this : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> SkColor ; } extern "C" { # [ doc = " Look up the pixel at (x,y) and return its alpha component, normalized to [0..1]." ] # [ doc = "This is roughly equivalent to SkGetColorA(getColor()), but can be more efficent" ] # [ doc = "(and more precise if the pixels store more than 8 bits per component)." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   alpha converted to normalized float" ] # [ link_name = "\u{1}__ZNK8SkBitmap9getAlphafEii" ] pub fn SkBitmap_getAlphaf ( this : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> f32 ; } extern "C" { # [ doc = " Returns pixel address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated: out of bounds values of x or y, or kUnknown_SkColorType," ] # [ doc = "trigger an assert() if built with SK_DEBUG defined. Returns nullptr if" ] # [ doc = "SkColorType is kUnknown_SkColorType, or SkPixelRef is nullptr." ] # [ doc = "" ] # [ doc = "Performs a lookup of pixel size; for better performance, call" ] # [ doc = "one of: getAddr8(), getAddr16(), or getAddr32()." ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   generic pointer to pixel" ] # [ link_name = "\u{1}__ZNK8SkBitmap7getAddrEii" ] pub fn SkBitmap_getAddr ( this : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ doc = " Returns address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated. Triggers an assert() if built with SK_DEBUG defined and:" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "- bytesPerPixel() is not four" ] # [ doc = "- x is negative, or not less than width()" ] # [ doc = "- y is negative, or not less than height()" ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   unsigned 32-bit pointer to pixel at (x, y)" ] # [ link_name = "\u{1}__ZNK8SkBitmap9getAddr32Eii" ] pub fn SkBitmap_getAddr32 ( this : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u32 ; } extern "C" { # [ doc = " Returns address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated. Triggers an assert() if built with SK_DEBUG defined and:" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "- bytesPerPixel() is not two" ] # [ doc = "- x is negative, or not less than width()" ] # [ doc = "- y is negative, or not less than height()" ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   unsigned 16-bit pointer to pixel at (x, y)" ] # [ link_name = "\u{1}__ZNK8SkBitmap9getAddr16Eii" ] pub fn SkBitmap_getAddr16 ( this : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u16 ; } extern "C" { # [ doc = " Returns address at (x, y)." ] # [ doc = "" ] # [ doc = "Input is not validated. Triggers an assert() if built with SK_DEBUG defined and:" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "- bytesPerPixel() is not one" ] # [ doc = "- x is negative, or not less than width()" ] # [ doc = "- y is negative, or not less than height()" ] # [ doc = "" ] # [ doc = "@param x  column index, zero or greater, and less than width()" ] # [ doc = "@param y  row index, zero or greater, and less than height()" ] # [ doc = "@return   unsigned 8-bit pointer to pixel at (x, y)" ] # [ link_name = "\u{1}__ZNK8SkBitmap8getAddr8Eii" ] pub fn SkBitmap_getAddr8 ( this : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u8 ; } extern "C" { # [ doc = " Shares SkPixelRef with dst. Pixels are not copied; SkBitmap and dst point" ] # [ doc = "to the same pixels; dst bounds() are set to the intersection of subset" ] # [ doc = "and the original bounds()." ] # [ doc = "" ] # [ doc = "subset may be larger than bounds(). Any area outside of bounds() is ignored." ] # [ doc = "" ] # [ doc = "Any contents of dst are discarded. isVolatile() setting is copied to dst." ] # [ doc = "dst is set to colorType(), alphaType(), and colorSpace()." ] # [ doc = "" ] # [ doc = "Return false if:" ] # [ doc = "- dst is nullptr" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "- subset does not intersect bounds()" ] # [ doc = "" ] # [ doc = "@param dst     SkBitmap set to subset" ] # [ doc = "@param subset  rectangle of pixels to reference" ] # [ doc = "@return        true if dst is replaced by subset" ] # [ link_name = "\u{1}__ZNK8SkBitmap13extractSubsetEPS_RK7SkIRect" ] pub fn SkBitmap_extractSubset ( this : * const SkBitmap , dst : * mut SkBitmap , subset : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Copies a SkRect of pixels from SkBitmap to dstPixels. Copy starts at (srcX, srcY)," ] # [ doc = "and does not exceed SkBitmap (width(), height())." ] # [ doc = "" ] # [ doc = "dstInfo specifies width, height, SkColorType, SkAlphaType, and SkColorSpace of" ] # [ doc = "destination. dstRowBytes specifics the gap from one destination row to the next." ] # [ doc = "Returns true if pixels are copied. Returns false if:" ] # [ doc = "- dstInfo has no address" ] # [ doc = "- dstRowBytes is less than dstInfo.minRowBytes()" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkBitmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dstInfo.colorType() must match." ] # [ doc = "If SkBitmap colorType() is kGray_8_SkColorType, dstInfo.colorSpace() must match." ] # [ doc = "If SkBitmap alphaType() is kOpaque_SkAlphaType, dstInfo.alphaType() must" ] # [ doc = "match. If SkBitmap colorSpace() is nullptr, dstInfo.colorSpace() must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "srcX and srcY may be negative to copy only top or left of source. Returns" ] # [ doc = "false if width() or height() is zero or negative." ] # [ doc = "Returns false if abs(srcX) >= Bitmap width(), or if abs(srcY) >= Bitmap height()." ] # [ doc = "" ] # [ doc = "@param dstInfo      destination width, height, SkColorType, SkAlphaType, SkColorSpace" ] # [ doc = "@param dstPixels    destination pixel storage" ] # [ doc = "@param dstRowBytes  destination row length" ] # [ doc = "@param srcX         column index whose absolute value is less than width()" ] # [ doc = "@param srcY         row index whose absolute value is less than height()" ] # [ doc = "@return             true if pixels are copied to dstPixels" ] # [ link_name = "\u{1}__ZNK8SkBitmap10readPixelsERK11SkImageInfoPvmii" ] pub fn SkBitmap_readPixels ( this : * const SkBitmap , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies a SkRect of pixels from SkBitmap to dst. Copy starts at (srcX, srcY), and" ] # [ doc = "does not exceed SkBitmap (width(), height())." ] # [ doc = "" ] # [ doc = "dst specifies width, height, SkColorType, SkAlphaType, SkColorSpace, pixel storage," ] # [ doc = "and row bytes of destination. dst.rowBytes() specifics the gap from one destination" ] # [ doc = "row to the next. Returns true if pixels are copied. Returns false if:" ] # [ doc = "- dst pixel storage equals nullptr" ] # [ doc = "- dst.rowBytes is less than SkImageInfo::minRowBytes()" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkBitmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dst SkColorType must match." ] # [ doc = "If SkBitmap colorType() is kGray_8_SkColorType, dst SkColorSpace must match." ] # [ doc = "If SkBitmap alphaType() is kOpaque_SkAlphaType, dst SkAlphaType must" ] # [ doc = "match. If SkBitmap colorSpace() is nullptr, dst SkColorSpace must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "srcX and srcY may be negative to copy only top or left of source. Returns" ] # [ doc = "false if width() or height() is zero or negative." ] # [ doc = "Returns false if abs(srcX) >= Bitmap width(), or if abs(srcY) >= Bitmap height()." ] # [ doc = "" ] # [ doc = "@param dst   destination SkPixmap: SkImageInfo, pixels, row bytes" ] # [ doc = "@param srcX  column index whose absolute value is less than width()" ] # [ doc = "@param srcY  row index whose absolute value is less than height()" ] # [ doc = "@return      true if pixels are copied to dst" ] # [ link_name = "\u{1}__ZNK8SkBitmap10readPixelsERK8SkPixmapii" ] pub fn SkBitmap_readPixels1 ( this : * const SkBitmap , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies a SkRect of pixels from SkBitmap to dst. Copy starts at (0, 0), and" ] # [ doc = "does not exceed SkBitmap (width(), height())." ] # [ doc = "" ] # [ doc = "dst specifies width, height, SkColorType, SkAlphaType, SkColorSpace, pixel storage," ] # [ doc = "and row bytes of destination. dst.rowBytes() specifics the gap from one destination" ] # [ doc = "row to the next. Returns true if pixels are copied. Returns false if:" ] # [ doc = "- dst pixel storage equals nullptr" ] # [ doc = "- dst.rowBytes is less than SkImageInfo::minRowBytes()" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkBitmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dst SkColorType must match." ] # [ doc = "If SkBitmap colorType() is kGray_8_SkColorType, dst SkColorSpace must match." ] # [ doc = "If SkBitmap alphaType() is kOpaque_SkAlphaType, dst SkAlphaType must" ] # [ doc = "match. If SkBitmap colorSpace() is nullptr, dst SkColorSpace must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "@param dst  destination SkPixmap: SkImageInfo, pixels, row bytes" ] # [ doc = "@return     true if pixels are copied to dst" ] # [ link_name = "\u{1}__ZNK8SkBitmap10readPixelsERK8SkPixmap" ] pub fn SkBitmap_readPixels2 ( this : * const SkBitmap , dst : * const SkPixmap ) -> bool ; } extern "C" { # [ doc = " Copies a SkRect of pixels from src. Copy starts at (dstX, dstY), and does not exceed" ] # [ doc = "(src.width(), src.height())." ] # [ doc = "" ] # [ doc = "src specifies width, height, SkColorType, SkAlphaType, SkColorSpace, pixel storage," ] # [ doc = "and row bytes of source. src.rowBytes() specifics the gap from one source" ] # [ doc = "row to the next. Returns true if pixels are copied. Returns false if:" ] # [ doc = "- src pixel storage equals nullptr" ] # [ doc = "- src.rowBytes is less than SkImageInfo::minRowBytes()" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkBitmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; src SkColorType must match." ] # [ doc = "If SkBitmap colorType() is kGray_8_SkColorType, src SkColorSpace must match." ] # [ doc = "If SkBitmap alphaType() is kOpaque_SkAlphaType, src SkAlphaType must" ] # [ doc = "match. If SkBitmap colorSpace() is nullptr, src SkColorSpace must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "dstX and dstY may be negative to copy only top or left of source. Returns" ] # [ doc = "false if width() or height() is zero or negative." ] # [ doc = "Returns false if abs(dstX) >= Bitmap width(), or if abs(dstY) >= Bitmap height()." ] # [ doc = "" ] # [ doc = "@param src   source SkPixmap: SkImageInfo, pixels, row bytes" ] # [ doc = "@param dstX  column index whose absolute value is less than width()" ] # [ doc = "@param dstY  row index whose absolute value is less than height()" ] # [ doc = "@return      true if src pixels are copied to SkBitmap" ] # [ link_name = "\u{1}__ZN8SkBitmap11writePixelsERK8SkPixmapii" ] pub fn SkBitmap_writePixels ( this : * mut SkBitmap , src : * const SkPixmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies a SkRect of pixels from src. Copy starts at (0, 0), and does not exceed" ] # [ doc = "(src.width(), src.height())." ] # [ doc = "" ] # [ doc = "src specifies width, height, SkColorType, SkAlphaType, SkColorSpace, pixel storage," ] # [ doc = "and row bytes of source. src.rowBytes() specifics the gap from one source" ] # [ doc = "row to the next. Returns true if pixels are copied. Returns false if:" ] # [ doc = "- src pixel storage equals nullptr" ] # [ doc = "- src.rowBytes is less than SkImageInfo::minRowBytes()" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkBitmap colorType() is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; src SkColorType must match." ] # [ doc = "If SkBitmap colorType() is kGray_8_SkColorType, src SkColorSpace must match." ] # [ doc = "If SkBitmap alphaType() is kOpaque_SkAlphaType, src SkAlphaType must" ] # [ doc = "match. If SkBitmap colorSpace() is nullptr, src SkColorSpace must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "@param src  source SkPixmap: SkImageInfo, pixels, row bytes" ] # [ doc = "@return     true if src pixels are copied to SkBitmap" ] # [ link_name = "\u{1}__ZN8SkBitmap11writePixelsERK8SkPixmap" ] pub fn SkBitmap_writePixels1 ( this : * mut SkBitmap , src : * const SkPixmap ) -> bool ; } extern "C" { # [ doc = " Sets dst to alpha described by pixels. Returns false if dst cannot be written to" ] # [ doc = "or dst pixels cannot be allocated." ] # [ doc = "" ] # [ doc = "Uses HeapAllocator to reserve memory for dst SkPixelRef." ] # [ doc = "" ] # [ doc = "@param dst  holds SkPixelRef to fill with alpha layer" ] # [ doc = "@return     true if alpha layer was constructed in dst SkPixelRef" ] # [ link_name = "\u{1}__ZNK8SkBitmap12extractAlphaEPS_" ] pub fn SkBitmap_extractAlpha ( this : * const SkBitmap , dst : * mut SkBitmap ) -> bool ; } extern "C" { # [ doc = " Sets dst to alpha described by pixels. Returns false if dst cannot be written to" ] # [ doc = "or dst pixels cannot be allocated." ] # [ doc = "" ] # [ doc = "If paint is not nullptr and contains SkMaskFilter, SkMaskFilter" ] # [ doc = "generates mask alpha from SkBitmap. Uses HeapAllocator to reserve memory for dst" ] # [ doc = "SkPixelRef. Sets offset to top-left position for dst for alignment with SkBitmap;" ] # [ doc = "(0, 0) unless SkMaskFilter generates mask." ] # [ doc = "" ] # [ doc = "@param dst     holds SkPixelRef to fill with alpha layer" ] # [ doc = "@param paint   holds optional SkMaskFilter; may be nullptr" ] # [ doc = "@param offset  top-left position for dst; may be nullptr" ] # [ doc = "@return        true if alpha layer was constructed in dst SkPixelRef" ] # [ link_name = "\u{1}__ZNK8SkBitmap12extractAlphaEPS_PK7SkPaintP8SkIPoint" ] pub fn SkBitmap_extractAlpha1 ( this : * const SkBitmap , dst : * mut SkBitmap , paint : * const SkPaint , offset : * mut SkIPoint ) -> bool ; } extern "C" { # [ doc = " Sets dst to alpha described by pixels. Returns false if dst cannot be written to" ] # [ doc = "or dst pixels cannot be allocated." ] # [ doc = "" ] # [ doc = "If paint is not nullptr and contains SkMaskFilter, SkMaskFilter" ] # [ doc = "generates mask alpha from SkBitmap. allocator may reference a custom allocation" ] # [ doc = "class or be set to nullptr to use HeapAllocator. Sets offset to top-left" ] # [ doc = "position for dst for alignment with SkBitmap; (0, 0) unless SkMaskFilter generates" ] # [ doc = "mask." ] # [ doc = "" ] # [ doc = "@param dst        holds SkPixelRef to fill with alpha layer" ] # [ doc = "@param paint      holds optional SkMaskFilter; may be nullptr" ] # [ doc = "@param allocator  function to reserve memory for SkPixelRef; may be nullptr" ] # [ doc = "@param offset     top-left position for dst; may be nullptr" ] # [ doc = "@return           true if alpha layer was constructed in dst SkPixelRef" ] # [ link_name = "\u{1}__ZNK8SkBitmap12extractAlphaEPS_PK7SkPaintPNS_9AllocatorEP8SkIPoint" ] pub fn SkBitmap_extractAlpha2 ( this : * const SkBitmap , dst : * mut SkBitmap , paint : * const SkPaint , allocator : * mut SkBitmap_Allocator , offset : * mut SkIPoint ) -> bool ; } extern "C" { # [ doc = " Copies SkBitmap pixel address, row bytes, and SkImageInfo to pixmap, if address" ] # [ doc = "is available, and returns true. If pixel address is not available, return" ] # [ doc = "false and leave pixmap unchanged." ] # [ doc = "" ] # [ doc = "pixmap contents become invalid on any future change to SkBitmap." ] # [ doc = "" ] # [ doc = "@param pixmap  storage for pixel state if pixels are readable; otherwise, ignored" ] # [ doc = "@return        true if SkBitmap has direct access to pixels" ] # [ link_name = "\u{1}__ZNK8SkBitmap10peekPixelsEP8SkPixmap" ] pub fn SkBitmap_peekPixels ( this : * const SkBitmap , pixmap : * mut SkPixmap ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkBitmap8validateEv" ] pub fn SkBitmap_validate ( this : * const SkBitmap ) ; } extern "C" { # [ doc = " Creates an empty SkBitmap without pixels, with kUnknown_SkColorType," ] # [ doc = "kUnknown_SkAlphaType, and with a width and height of zero. SkPixelRef origin is" ] # [ doc = "set to (0, 0). SkBitmap is not volatile." ] # [ doc = "" ] # [ doc = "Use setInfo() to associate SkColorType, SkAlphaType, width, and height" ] # [ doc = "after SkBitmap has been created." ] # [ doc = "" ] # [ doc = "@return  empty SkBitmap" ] # [ link_name = "\u{1}__ZN8SkBitmapC1Ev" ] pub fn SkBitmap_SkBitmap ( this : * mut SkBitmap ) ; } extern "C" { # [ doc = " Copies settings from src to returned SkBitmap. Shares pixels if src has pixels" ] # [ doc = "allocated, so both bitmaps reference the same pixels." ] # [ doc = "" ] # [ doc = "@param src  SkBitmap to copy SkImageInfo, and share SkPixelRef" ] # [ doc = "@return     copy of src" ] # [ link_name = "\u{1}__ZN8SkBitmapC1ERKS_" ] pub fn SkBitmap_SkBitmap1 ( this : * mut SkBitmap , src : * const SkBitmap ) ; } extern "C" { # [ doc = " Copies settings from src to returned SkBitmap. Moves ownership of src pixels to" ] # [ doc = "SkBitmap." ] # [ doc = "" ] # [ doc = "@param src  SkBitmap to copy SkImageInfo, and reassign SkPixelRef" ] # [ doc = "@return     copy of src" ] # [ link_name = "\u{1}__ZN8SkBitmapC1EOS_" ] pub fn SkBitmap_SkBitmap2 ( this : * mut SkBitmap , src : * mut SkBitmap ) ; } extern "C" { # [ doc = " Decrements SkPixelRef reference count, if SkPixelRef is not nullptr." ] # [ link_name = "\u{1}__ZN8SkBitmapD1Ev" ] pub fn SkBitmap_SkBitmap_destructor ( this : * mut SkBitmap ) ; } impl SkBitmap { # [ inline ] pub unsafe fn swap ( & mut self , other : * mut SkBitmap ) { SkBitmap_swap ( self , other ) } # [ inline ] pub unsafe fn pixmap ( & self ) -> * const SkPixmap { SkBitmap_pixmap ( self ) } # [ inline ] pub unsafe fn info ( & self ) -> * const SkImageInfo { SkBitmap_info ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { SkBitmap_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { SkBitmap_height ( self ) } # [ inline ] pub unsafe fn colorType ( & self ) -> SkColorType { SkBitmap_colorType ( self ) } # [ inline ] pub unsafe fn alphaType ( & self ) -> SkAlphaType { SkBitmap_alphaType ( self ) } # [ inline ] pub unsafe fn colorSpace ( & self ) -> * mut SkColorSpace { SkBitmap_colorSpace ( self ) } # [ inline ] pub unsafe fn refColorSpace ( & self ) -> sk_sp < SkColorSpace > { SkBitmap_refColorSpace ( self ) } # [ inline ] pub unsafe fn bytesPerPixel ( & self ) -> :: std :: os :: raw :: c_int { SkBitmap_bytesPerPixel ( self ) } # [ inline ] pub unsafe fn rowBytesAsPixels ( & self ) -> :: std :: os :: raw :: c_int { SkBitmap_rowBytesAsPixels ( self ) } # [ inline ] pub unsafe fn shiftPerPixel ( & self ) -> :: std :: os :: raw :: c_int { SkBitmap_shiftPerPixel ( self ) } # [ inline ] pub unsafe fn empty ( & self ) -> bool { SkBitmap_empty ( self ) } # [ inline ] pub unsafe fn isNull ( & self ) -> bool { SkBitmap_isNull ( self ) } # [ inline ] pub unsafe fn drawsNothing ( & self ) -> bool { SkBitmap_drawsNothing ( self ) } # [ inline ] pub unsafe fn rowBytes ( & self ) -> usize { SkBitmap_rowBytes ( self ) } # [ inline ] pub unsafe fn setAlphaType ( & mut self , alphaType : SkAlphaType ) -> bool { SkBitmap_setAlphaType ( self , alphaType ) } # [ inline ] pub unsafe fn getPixels ( & self ) -> * mut :: std :: os :: raw :: c_void { SkBitmap_getPixels ( self ) } # [ inline ] pub unsafe fn computeByteSize ( & self ) -> usize { SkBitmap_computeByteSize ( self ) } # [ inline ] pub unsafe fn isImmutable ( & self ) -> bool { SkBitmap_isImmutable ( self ) } # [ inline ] pub unsafe fn setImmutable ( & mut self ) { SkBitmap_setImmutable ( self ) } # [ inline ] pub unsafe fn isOpaque ( & self ) -> bool { SkBitmap_isOpaque ( self ) } # [ inline ] pub unsafe fn isVolatile ( & self ) -> bool { SkBitmap_isVolatile ( self ) } # [ inline ] pub unsafe fn setIsVolatile ( & mut self , isVolatile : bool ) { SkBitmap_setIsVolatile ( self , isVolatile ) } # [ inline ] pub unsafe fn reset ( & mut self ) { SkBitmap_reset ( self ) } # [ inline ] pub unsafe fn ComputeIsOpaque ( bm : * const SkBitmap ) -> bool { SkBitmap_ComputeIsOpaque ( bm ) } # [ inline ] pub unsafe fn getBounds ( & self , bounds : * mut SkRect ) { SkBitmap_getBounds ( self , bounds ) } # [ inline ] pub unsafe fn getBounds1 ( & self , bounds : * mut SkIRect ) { SkBitmap_getBounds1 ( self , bounds ) } # [ inline ] pub unsafe fn bounds ( & self ) -> SkIRect { SkBitmap_bounds ( self ) } # [ inline ] pub unsafe fn dimensions ( & self ) -> SkISize { SkBitmap_dimensions ( self ) } # [ inline ] pub unsafe fn getSubset ( & self ) -> SkIRect { SkBitmap_getSubset ( self ) } # [ inline ] pub unsafe fn setInfo ( & mut self , imageInfo : * const SkImageInfo , rowBytes : usize ) -> bool { SkBitmap_setInfo ( self , imageInfo , rowBytes ) } # [ inline ] pub unsafe fn tryAllocPixelsFlags ( & mut self , info : * const SkImageInfo , flags : u32 ) -> bool { SkBitmap_tryAllocPixelsFlags ( self , info , flags ) } # [ inline ] pub unsafe fn allocPixelsFlags ( & mut self , info : * const SkImageInfo , flags : u32 ) { SkBitmap_allocPixelsFlags ( self , info , flags ) } # [ inline ] pub unsafe fn tryAllocPixels ( & mut self , info : * const SkImageInfo , rowBytes : usize ) -> bool { SkBitmap_tryAllocPixels ( self , info , rowBytes ) } # [ inline ] pub unsafe fn allocPixels ( & mut self , info : * const SkImageInfo , rowBytes : usize ) { SkBitmap_allocPixels ( self , info , rowBytes ) } # [ inline ] pub unsafe fn tryAllocPixels1 ( & mut self , info : * const SkImageInfo ) -> bool { SkBitmap_tryAllocPixels1 ( self , info ) } # [ inline ] pub unsafe fn allocPixels1 ( & mut self , info : * const SkImageInfo ) { SkBitmap_allocPixels1 ( self , info ) } # [ inline ] pub unsafe fn tryAllocN32Pixels ( & mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool ) -> bool { SkBitmap_tryAllocN32Pixels ( self , width , height , isOpaque ) } # [ inline ] pub unsafe fn allocN32Pixels ( & mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool ) { SkBitmap_allocN32Pixels ( self , width , height , isOpaque ) } # [ inline ] pub unsafe fn installPixels ( & mut self , info : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize , releaseProc : :: core :: option :: Option < unsafe extern "C" fn ( this : * mut SkBitmap , info : * mut :: std :: os :: raw :: c_void , pixels : * mut :: std :: os :: raw :: c_void ) > , context : * mut :: std :: os :: raw :: c_void ) -> bool { SkBitmap_installPixels ( self , info , pixels , rowBytes , releaseProc , context ) } # [ inline ] pub unsafe fn installPixels1 ( & mut self , info : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize ) -> bool { SkBitmap_installPixels1 ( self , info , pixels , rowBytes ) } # [ inline ] pub unsafe fn installPixels2 ( & mut self , pixmap : * const SkPixmap ) -> bool { SkBitmap_installPixels2 ( self , pixmap ) } # [ inline ] pub unsafe fn installMaskPixels ( & mut self , mask : * const SkMask ) -> bool { SkBitmap_installMaskPixels ( self , mask ) } # [ inline ] pub unsafe fn setPixels ( & mut self , pixels : * mut :: std :: os :: raw :: c_void ) { SkBitmap_setPixels ( self , pixels ) } # [ inline ] pub unsafe fn tryAllocPixels2 ( & mut self ) -> bool { SkBitmap_tryAllocPixels2 ( self ) } # [ inline ] pub unsafe fn allocPixels2 ( & mut self ) { SkBitmap_allocPixels2 ( self ) } # [ inline ] pub unsafe fn tryAllocPixels3 ( & mut self , allocator : * mut SkBitmap_Allocator ) -> bool { SkBitmap_tryAllocPixels3 ( self , allocator ) } # [ inline ] pub unsafe fn allocPixels3 ( & mut self , allocator : * mut SkBitmap_Allocator ) { SkBitmap_allocPixels3 ( self , allocator ) } # [ inline ] pub unsafe fn pixelRef ( & self ) -> * mut SkPixelRef { SkBitmap_pixelRef ( self ) } # [ inline ] pub unsafe fn pixelRefOrigin ( & self ) -> SkIPoint { SkBitmap_pixelRefOrigin ( self ) } # [ inline ] pub unsafe fn setPixelRef ( & mut self , pixelRef : sk_sp < SkPixelRef > , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int ) { SkBitmap_setPixelRef ( self , pixelRef , dx , dy ) } # [ inline ] pub unsafe fn readyToDraw ( & self ) -> bool { SkBitmap_readyToDraw ( self ) } # [ inline ] pub unsafe fn getGenerationID ( & self ) -> u32 { SkBitmap_getGenerationID ( self ) } # [ inline ] pub unsafe fn notifyPixelsChanged ( & self ) { SkBitmap_notifyPixelsChanged ( self ) } # [ inline ] pub unsafe fn eraseColor ( & self , c : SkColor ) { SkBitmap_eraseColor ( self , c ) } # [ inline ] pub unsafe fn eraseARGB ( & self , a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU ) { SkBitmap_eraseARGB ( self , a , r , g , b ) } # [ inline ] pub unsafe fn erase ( & self , c : SkColor , area : * const SkIRect ) { SkBitmap_erase ( self , c , area ) } # [ inline ] pub unsafe fn eraseArea ( & self , area : * const SkIRect , c : SkColor ) { SkBitmap_eraseArea ( self , area , c ) } # [ inline ] pub unsafe fn getColor ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> SkColor { SkBitmap_getColor ( self , x , y ) } # [ inline ] pub unsafe fn getAlphaf ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> f32 { SkBitmap_getAlphaf ( self , x , y ) } # [ inline ] pub unsafe fn getAddr ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void { SkBitmap_getAddr ( self , x , y ) } # [ inline ] pub unsafe fn getAddr32 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u32 { SkBitmap_getAddr32 ( self , x , y ) } # [ inline ] pub unsafe fn getAddr16 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u16 { SkBitmap_getAddr16 ( self , x , y ) } # [ inline ] pub unsafe fn getAddr8 ( & self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> * mut u8 { SkBitmap_getAddr8 ( self , x , y ) } # [ inline ] pub unsafe fn extractSubset ( & self , dst : * mut SkBitmap , subset : * const SkIRect ) -> bool { SkBitmap_extractSubset ( self , dst , subset ) } # [ inline ] pub unsafe fn readPixels ( & self , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkBitmap_readPixels ( self , dstInfo , dstPixels , dstRowBytes , srcX , srcY ) } # [ inline ] pub unsafe fn readPixels1 ( & self , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkBitmap_readPixels1 ( self , dst , srcX , srcY ) } # [ inline ] pub unsafe fn readPixels2 ( & self , dst : * const SkPixmap ) -> bool { SkBitmap_readPixels2 ( self , dst ) } # [ inline ] pub unsafe fn writePixels ( & mut self , src : * const SkPixmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int ) -> bool { SkBitmap_writePixels ( self , src , dstX , dstY ) } # [ inline ] pub unsafe fn writePixels1 ( & mut self , src : * const SkPixmap ) -> bool { SkBitmap_writePixels1 ( self , src ) } # [ inline ] pub unsafe fn extractAlpha ( & self , dst : * mut SkBitmap ) -> bool { SkBitmap_extractAlpha ( self , dst ) } # [ inline ] pub unsafe fn extractAlpha1 ( & self , dst : * mut SkBitmap , paint : * const SkPaint , offset : * mut SkIPoint ) -> bool { SkBitmap_extractAlpha1 ( self , dst , paint , offset ) } # [ inline ] pub unsafe fn extractAlpha2 ( & self , dst : * mut SkBitmap , paint : * const SkPaint , allocator : * mut SkBitmap_Allocator , offset : * mut SkIPoint ) -> bool { SkBitmap_extractAlpha2 ( self , dst , paint , allocator , offset ) } # [ inline ] pub unsafe fn peekPixels ( & self , pixmap : * mut SkPixmap ) -> bool { SkBitmap_peekPixels ( self , pixmap ) } # [ inline ] pub unsafe fn validate ( & self ) { SkBitmap_validate ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkBitmap_SkBitmap ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( src : * const SkBitmap ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkBitmap_SkBitmap1 ( & mut __bindgen_tmp , src ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( src : * mut SkBitmap ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkBitmap_SkBitmap2 ( & mut __bindgen_tmp , src ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkBitmap_SkBitmap_destructor ( self ) } } extern "C" { # [ doc = " Allocates the pixel memory for the bitmap, given its dimensions and" ] # [ doc = "SkColorType. Returns true on success, where success means either setPixels()" ] # [ doc = "or setPixelRef() was called." ] # [ doc = "" ] # [ doc = "@param bitmap  SkBitmap containing SkImageInfo as input, and SkPixelRef as output" ] # [ doc = "@return        true if pixels are allocated" ] # [ link_name = "\u{1}__ZN8SkBitmap13HeapAllocator13allocPixelRefEPS_" ] pub fn SkBitmap_HeapAllocator_allocPixelRef ( this : * mut :: std :: os :: raw :: c_void , bitmap : * mut SkBitmap ) -> bool ; } # [ repr ( i32 ) ] # [ doc = "  Enum describing format of encoded data." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkEncodedImageFormat { kBMP = 0 , kGIF = 1 , kICO = 2 , kJPEG = 3 , kPNG = 4 , kWBMP = 5 , kWEBP = 6 , kPKM = 7 , kKTX = 8 , kASTC = 9 , kDNG = 10 , kHEIF = 11 , } # [ repr ( C ) ] pub struct SkStream__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ doc = "  SkStream -- abstraction for a source of bytes. Subclasses can be backed by" ] # [ doc = "  memory, or a file, or something else." ] # [ doc = "" ] # [ doc = "  NOTE:" ] # [ doc = "" ] # [ doc = "  Classic \"streams\" APIs are sort of async, in that on a request for N" ] # [ doc = "  bytes, they may return fewer than N bytes on a given call, in which case" ] # [ doc = "  the caller can \"try again\" to get more bytes, eventually (modulo an error)" ] # [ doc = "  receiving their total N bytes." ] # [ doc = "" ] # [ doc = "  Skia streams behave differently. They are effectively synchronous, and will" ] # [ doc = "  always return all N bytes of the request if possible. If they return fewer" ] # [ doc = "  (the read() call returns the number of bytes read) then that means there is" ] # [ doc = "  no more data (at EOF or hit an error). The caller should *not* call again" ] # [ doc = "  in hopes of fulfilling more of the request." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkStream { pub vtable_ : * const SkStream__bindgen_vtable , } # [ test ] fn bindgen_test_layout_SkStream ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkStream > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkStream ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkStream > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkStream ) ) ) ; } extern "C" { # [ doc = "  Attempts to open the specified file as a stream, returns nullptr on failure." ] # [ link_name = "\u{1}__ZN8SkStream12MakeFromFileEPKc" ] pub fn SkStream_MakeFromFile ( path : * const :: std :: os :: raw :: c_char ) -> std_unique_ptr ; } extern "C" { # [ doc = " Skip size number of bytes." ] # [ doc = "  @return the actual number bytes that could be skipped." ] # [ link_name = "\u{1}__ZN8SkStream4skipEm" ] pub fn SkStream_skip ( this : * mut SkStream , size : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream6readS8EPa" ] pub fn SkStream_readS8 ( this : * mut SkStream , arg1 : * mut i8 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream7readS16EPs" ] pub fn SkStream_readS16 ( this : * mut SkStream , arg1 : * mut i16 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream7readS32EPi" ] pub fn SkStream_readS32 ( this : * mut SkStream , arg1 : * mut i32 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream6readU8EPh" ] pub fn SkStream_readU8 ( this : * mut SkStream , i : * mut u8 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream7readU16EPt" ] pub fn SkStream_readU16 ( this : * mut SkStream , i : * mut u16 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream7readU32EPj" ] pub fn SkStream_readU32 ( this : * mut SkStream , i : * mut u32 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream8readBoolEPb" ] pub fn SkStream_readBool ( this : * mut SkStream , b : * mut bool ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream10readScalarEPf" ] pub fn SkStream_readScalar ( this : * mut SkStream , arg1 : * mut SkScalar ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStream14readPackedUIntEPm" ] pub fn SkStream_readPackedUInt ( this : * mut SkStream , arg1 : * mut usize ) -> bool ; } extern "C" { # [ doc = " Duplicates this stream. If this cannot be done, returns NULL." ] # [ doc = "  The returned stream will be positioned at the beginning of its data." ] # [ link_name = "\u{1}__ZNK8SkStream9duplicateEv" ] pub fn SkStream_duplicate ( this : * const SkStream ) -> std_unique_ptr ; } extern "C" { # [ doc = " Duplicates this stream. If this cannot be done, returns NULL." ] # [ doc = "  The returned stream will be positioned the same as this stream." ] # [ link_name = "\u{1}__ZNK8SkStream4forkEv" ] pub fn SkStream_fork ( this : * const SkStream ) -> std_unique_ptr ; } extern "C" { # [ link_name = "\u{1}__ZN8SkStreamC2Ev" ] pub fn SkStream_SkStream ( this : * mut SkStream ) ; } impl SkStream { # [ inline ] pub unsafe fn MakeFromFile ( path : * const :: std :: os :: raw :: c_char ) -> std_unique_ptr { SkStream_MakeFromFile ( path ) } # [ inline ] pub unsafe fn skip ( & mut self , size : usize ) -> usize { SkStream_skip ( self , size ) } # [ inline ] pub unsafe fn readS8 ( & mut self , arg1 : * mut i8 ) -> bool { SkStream_readS8 ( self , arg1 ) } # [ inline ] pub unsafe fn readS16 ( & mut self , arg1 : * mut i16 ) -> bool { SkStream_readS16 ( self , arg1 ) } # [ inline ] pub unsafe fn readS32 ( & mut self , arg1 : * mut i32 ) -> bool { SkStream_readS32 ( self , arg1 ) } # [ inline ] pub unsafe fn readU8 ( & mut self , i : * mut u8 ) -> bool { SkStream_readU8 ( self , i ) } # [ inline ] pub unsafe fn readU16 ( & mut self , i : * mut u16 ) -> bool { SkStream_readU16 ( self , i ) } # [ inline ] pub unsafe fn readU32 ( & mut self , i : * mut u32 ) -> bool { SkStream_readU32 ( self , i ) } # [ inline ] pub unsafe fn readBool ( & mut self , b : * mut bool ) -> bool { SkStream_readBool ( self , b ) } # [ inline ] pub unsafe fn readScalar ( & mut self , arg1 : * mut SkScalar ) -> bool { SkStream_readScalar ( self , arg1 ) } # [ inline ] pub unsafe fn readPackedUInt ( & mut self , arg1 : * mut usize ) -> bool { SkStream_readPackedUInt ( self , arg1 ) } # [ inline ] pub unsafe fn duplicate ( & self ) -> std_unique_ptr { SkStream_duplicate ( self ) } # [ inline ] pub unsafe fn fork ( & self ) -> std_unique_ptr { SkStream_fork ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkStream_SkStream ( & mut __bindgen_tmp ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN8SkStreamD1Ev" ] pub fn SkStream_SkStream_destructor ( this : * mut SkStream ) ; } extern "C" { # [ doc = "  Attempt to peek at size bytes." ] # [ doc = "  If this stream supports peeking, copy min(size, peekable bytes) into" ] # [ doc = "  buffer, and return the number of bytes copied." ] # [ doc = "  If the stream does not support peeking, or cannot peek any bytes," ] # [ doc = "  return 0 and leave buffer unchanged." ] # [ doc = "  The stream is guaranteed to be in the same visible state after this" ] # [ doc = "  call, regardless of success or failure." ] # [ doc = "  @param buffer Must not be NULL, and must be at least size bytes. Destination" ] # [ doc = "      to copy bytes." ] # [ doc = "  @param size Number of bytes to copy." ] # [ doc = "  @return The number of bytes peeked/copied." ] # [ link_name = "\u{1}__ZNK8SkStream4peekEPvm" ] pub fn SkStream_peek ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut :: std :: os :: raw :: c_void , arg2 : usize ) -> usize ; } extern "C" { # [ doc = " Rewinds to the beginning of the stream. Returns true if the stream is known" ] # [ doc = "  to be at the beginning after this call returns." ] # [ link_name = "\u{1}__ZN8SkStream6rewindEv" ] pub fn SkStream_rewind ( this : * mut :: std :: os :: raw :: c_void ) -> bool ; } extern "C" { # [ doc = " Returns true if this stream can report it\'s current position." ] # [ link_name = "\u{1}__ZNK8SkStream11hasPositionEv" ] pub fn SkStream_hasPosition ( this : * mut :: std :: os :: raw :: c_void ) -> bool ; } extern "C" { # [ doc = " Returns the current position in the stream. If this cannot be done, returns 0." ] # [ link_name = "\u{1}__ZNK8SkStream11getPositionEv" ] pub fn SkStream_getPosition ( this : * mut :: std :: os :: raw :: c_void ) -> usize ; } extern "C" { # [ doc = " Seeks to an absolute position in the stream. If this cannot be done, returns false." ] # [ doc = "  If an attempt is made to seek past the end of the stream, the position will be set" ] # [ doc = "  to the end of the stream." ] # [ link_name = "\u{1}__ZN8SkStream4seekEm" ] pub fn SkStream_seek ( this : * mut :: std :: os :: raw :: c_void , arg1 : usize ) -> bool ; } extern "C" { # [ doc = " Seeks to an relative offset in the stream. If this cannot be done, returns false." ] # [ doc = "  If an attempt is made to move to a position outside the stream, the position will be set" ] # [ doc = "  to the closest point within the stream (beginning or end)." ] # [ link_name = "\u{1}__ZN8SkStream4moveEl" ] pub fn SkStream_move ( this : * mut :: std :: os :: raw :: c_void , arg1 : :: std :: os :: raw :: c_long ) -> bool ; } extern "C" { # [ doc = " Returns true if this stream can report it\'s total length." ] # [ link_name = "\u{1}__ZNK8SkStream9hasLengthEv" ] pub fn SkStream_hasLength ( this : * mut :: std :: os :: raw :: c_void ) -> bool ; } extern "C" { # [ doc = " Returns the total length of the stream. If this cannot be done, returns 0." ] # [ link_name = "\u{1}__ZNK8SkStream9getLengthEv" ] pub fn SkStream_getLength ( this : * mut :: std :: os :: raw :: c_void ) -> usize ; } extern "C" { # [ doc = " Returns the starting address for the data. If this cannot be done, returns NULL." ] # [ link_name = "\u{1}__ZN8SkStream13getMemoryBaseEv" ] pub fn SkStream_getMemoryBase ( this : * mut :: std :: os :: raw :: c_void ) -> * const :: std :: os :: raw :: c_void ; } # [ doc = " SkStreamRewindable is a SkStream for which rewind and duplicate are required." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkStreamRewindable { pub _base : SkStream , } # [ test ] fn bindgen_test_layout_SkStreamRewindable ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkStreamRewindable > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkStreamRewindable ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkStreamRewindable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkStreamRewindable ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK18SkStreamRewindable9duplicateEv" ] pub fn SkStreamRewindable_duplicate ( this : * const SkStreamRewindable ) -> std_unique_ptr ; } impl SkStreamRewindable { # [ inline ] pub unsafe fn duplicate ( & self ) -> std_unique_ptr { SkStreamRewindable_duplicate ( self ) } } # [ doc = " SkStreamSeekable is a SkStreamRewindable for which position, seek, move, and fork are required." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkStreamSeekable { pub _base : SkStreamRewindable , } # [ test ] fn bindgen_test_layout_SkStreamSeekable ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkStreamSeekable > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkStreamSeekable ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkStreamSeekable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkStreamSeekable ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK16SkStreamSeekable9duplicateEv" ] pub fn SkStreamSeekable_duplicate ( this : * const SkStreamSeekable ) -> std_unique_ptr ; } extern "C" { # [ link_name = "\u{1}__ZNK16SkStreamSeekable4forkEv" ] pub fn SkStreamSeekable_fork ( this : * const SkStreamSeekable ) -> std_unique_ptr ; } impl SkStreamSeekable { # [ inline ] pub unsafe fn duplicate ( & self ) -> std_unique_ptr { SkStreamSeekable_duplicate ( self ) } # [ inline ] pub unsafe fn fork ( & self ) -> std_unique_ptr { SkStreamSeekable_fork ( self ) } } extern "C" { # [ link_name = "\u{1}__ZNK16SkStreamSeekable11hasPositionEv" ] pub fn SkStreamSeekable_hasPosition ( this : * mut :: std :: os :: raw :: c_void ) -> bool ; } # [ doc = " SkStreamAsset is a SkStreamSeekable for which getLength is required." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkStreamAsset { pub _base : SkStreamSeekable , } # [ test ] fn bindgen_test_layout_SkStreamAsset ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkStreamAsset > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkStreamAsset ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkStreamAsset > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkStreamAsset ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK13SkStreamAsset9duplicateEv" ] pub fn SkStreamAsset_duplicate ( this : * const SkStreamAsset ) -> std_unique_ptr ; } extern "C" { # [ link_name = "\u{1}__ZNK13SkStreamAsset4forkEv" ] pub fn SkStreamAsset_fork ( this : * const SkStreamAsset ) -> std_unique_ptr ; } impl SkStreamAsset { # [ inline ] pub unsafe fn duplicate ( & self ) -> std_unique_ptr { SkStreamAsset_duplicate ( self ) } # [ inline ] pub unsafe fn fork ( & self ) -> std_unique_ptr { SkStreamAsset_fork ( self ) } } extern "C" { # [ link_name = "\u{1}__ZNK13SkStreamAsset9hasLengthEv" ] pub fn SkStreamAsset_hasLength ( this : * mut :: std :: os :: raw :: c_void ) -> bool ; } # [ repr ( C ) ] pub struct SkWStream__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkWStream { pub vtable_ : * const SkWStream__bindgen_vtable , } # [ test ] fn bindgen_test_layout_SkWStream ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkWStream > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkWStream ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkWStream > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkWStream ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream6write8Ej" ] pub fn SkWStream_write8 ( this : * mut SkWStream , value : U8CPU ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream7write16Ej" ] pub fn SkWStream_write16 ( this : * mut SkWStream , value : U16CPU ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream7write32Ej" ] pub fn SkWStream_write32 ( this : * mut SkWStream , v : u32 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream9writeTextEPKc" ] pub fn SkWStream_writeText ( this : * mut SkWStream , text : * const :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream7newlineEv" ] pub fn SkWStream_newline ( this : * mut SkWStream ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream14writeDecAsTextEi" ] pub fn SkWStream_writeDecAsText ( this : * mut SkWStream , arg1 : i32 ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream17writeBigDecAsTextExi" ] pub fn SkWStream_writeBigDecAsText ( this : * mut SkWStream , arg1 : i64 , minDigits : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream14writeHexAsTextEji" ] pub fn SkWStream_writeHexAsText ( this : * mut SkWStream , arg1 : u32 , minDigits : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream17writeScalarAsTextEf" ] pub fn SkWStream_writeScalarAsText ( this : * mut SkWStream , arg1 : SkScalar ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream9writeBoolEb" ] pub fn SkWStream_writeBool ( this : * mut SkWStream , v : bool ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream11writeScalarEf" ] pub fn SkWStream_writeScalar ( this : * mut SkWStream , arg1 : SkScalar ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream15writePackedUIntEm" ] pub fn SkWStream_writePackedUInt ( this : * mut SkWStream , arg1 : usize ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream11writeStreamEP8SkStreamm" ] pub fn SkWStream_writeStream ( this : * mut SkWStream , input : * mut SkStream , length : usize ) -> bool ; } extern "C" { # [ doc = " This returns the number of bytes in the stream required to store" ] # [ doc = " \'value\'." ] # [ link_name = "\u{1}__ZN9SkWStream16SizeOfPackedUIntEm" ] pub fn SkWStream_SizeOfPackedUInt ( value : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStreamC2Ev" ] pub fn SkWStream_SkWStream ( this : * mut SkWStream ) ; } impl SkWStream { # [ inline ] pub unsafe fn write8 ( & mut self , value : U8CPU ) -> bool { SkWStream_write8 ( self , value ) } # [ inline ] pub unsafe fn write16 ( & mut self , value : U16CPU ) -> bool { SkWStream_write16 ( self , value ) } # [ inline ] pub unsafe fn write32 ( & mut self , v : u32 ) -> bool { SkWStream_write32 ( self , v ) } # [ inline ] pub unsafe fn writeText ( & mut self , text : * const :: std :: os :: raw :: c_char ) -> bool { SkWStream_writeText ( self , text ) } # [ inline ] pub unsafe fn newline ( & mut self ) -> bool { SkWStream_newline ( self ) } # [ inline ] pub unsafe fn writeDecAsText ( & mut self , arg1 : i32 ) -> bool { SkWStream_writeDecAsText ( self , arg1 ) } # [ inline ] pub unsafe fn writeBigDecAsText ( & mut self , arg1 : i64 , minDigits : :: std :: os :: raw :: c_int ) -> bool { SkWStream_writeBigDecAsText ( self , arg1 , minDigits ) } # [ inline ] pub unsafe fn writeHexAsText ( & mut self , arg1 : u32 , minDigits : :: std :: os :: raw :: c_int ) -> bool { SkWStream_writeHexAsText ( self , arg1 , minDigits ) } # [ inline ] pub unsafe fn writeScalarAsText ( & mut self , arg1 : SkScalar ) -> bool { SkWStream_writeScalarAsText ( self , arg1 ) } # [ inline ] pub unsafe fn writeBool ( & mut self , v : bool ) -> bool { SkWStream_writeBool ( self , v ) } # [ inline ] pub unsafe fn writeScalar ( & mut self , arg1 : SkScalar ) -> bool { SkWStream_writeScalar ( self , arg1 ) } # [ inline ] pub unsafe fn writePackedUInt ( & mut self , arg1 : usize ) -> bool { SkWStream_writePackedUInt ( self , arg1 ) } # [ inline ] pub unsafe fn writeStream ( & mut self , input : * mut SkStream , length : usize ) -> bool { SkWStream_writeStream ( self , input , length ) } # [ inline ] pub unsafe fn SizeOfPackedUInt ( value : usize ) -> :: std :: os :: raw :: c_int { SkWStream_SizeOfPackedUInt ( value ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkWStream_SkWStream ( & mut __bindgen_tmp ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN9SkWStreamD1Ev" ] pub fn SkWStream_SkWStream_destructor ( this : * mut SkWStream ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkWStream5flushEv" ] pub fn SkWStream_flush ( this : * mut :: std :: os :: raw :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkSerialProcs { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDeserialProcs { _unused : [ u8 ; 0 ] , } # [ doc = " \\class SkFlattenable" ] # [ doc = "" ] # [ doc = "SkFlattenable is the base class for objects that need to be flattened" ] # [ doc = "into a data stream for either transport or as part of the key to the" ] # [ doc = "font cache." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkFlattenable { pub _base : SkRefCnt , } pub const SkFlattenable_Type_kSkColorFilter_Type : SkFlattenable_Type = 0 ; pub const SkFlattenable_Type_kSkDrawable_Type : SkFlattenable_Type = 1 ; pub const SkFlattenable_Type_kSkDrawLooper_Type : SkFlattenable_Type = 2 ; pub const SkFlattenable_Type_kSkImageFilter_Type : SkFlattenable_Type = 3 ; pub const SkFlattenable_Type_kSkMaskFilter_Type : SkFlattenable_Type = 4 ; pub const SkFlattenable_Type_kSkPathEffect_Type : SkFlattenable_Type = 5 ; pub const SkFlattenable_Type_kSkPixelRef_Type : SkFlattenable_Type = 6 ; pub const SkFlattenable_Type_kSkUnused_Type4 : SkFlattenable_Type = 7 ; pub const SkFlattenable_Type_kSkShaderBase_Type : SkFlattenable_Type = 8 ; pub const SkFlattenable_Type_kSkUnused_Type : SkFlattenable_Type = 9 ; pub const SkFlattenable_Type_kSkUnused_Type2 : SkFlattenable_Type = 10 ; pub const SkFlattenable_Type_kSkNormalSource_Type : SkFlattenable_Type = 11 ; pub type SkFlattenable_Type = u32 ; pub type SkFlattenable_Factory = :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut SkReadBuffer ) -> sk_sp < SkFlattenable > > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFlattenable_PrivateInitializer { pub _address : u8 , } # [ test ] fn bindgen_test_layout_SkFlattenable_PrivateInitializer ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFlattenable_PrivateInitializer > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( SkFlattenable_PrivateInitializer ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFlattenable_PrivateInitializer > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SkFlattenable_PrivateInitializer ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13SkFlattenable18PrivateInitializer11InitEffectsEv" ] pub fn SkFlattenable_PrivateInitializer_InitEffects ( ) ; } extern "C" { # [ link_name = "\u{1}__ZN13SkFlattenable18PrivateInitializer16InitImageFiltersEv" ] pub fn SkFlattenable_PrivateInitializer_InitImageFilters ( ) ; } impl SkFlattenable_PrivateInitializer { # [ inline ] pub unsafe fn InitEffects ( ) { SkFlattenable_PrivateInitializer_InitEffects ( ) } # [ inline ] pub unsafe fn InitImageFilters ( ) { SkFlattenable_PrivateInitializer_InitImageFilters ( ) } } pub type SkFlattenable_INHERITED = SkRefCnt ; # [ test ] fn bindgen_test_layout_SkFlattenable ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFlattenable > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkFlattenable ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFlattenable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkFlattenable ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13SkFlattenable13NameToFactoryEPKc" ] pub fn SkFlattenable_NameToFactory ( name : * const :: std :: os :: raw :: c_char ) -> SkFlattenable_Factory ; } extern "C" { # [ link_name = "\u{1}__ZN13SkFlattenable13FactoryToNameEPF5sk_spIS_ER12SkReadBufferE" ] pub fn SkFlattenable_FactoryToName ( arg1 : SkFlattenable_Factory ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__ZN13SkFlattenable8RegisterEPKcPF5sk_spIS_ER12SkReadBufferE" ] pub fn SkFlattenable_Register ( name : * const :: std :: os :: raw :: c_char , arg1 : SkFlattenable_Factory ) ; } extern "C" { # [ link_name = "\u{1}__ZNK13SkFlattenable9serializeEPK13SkSerialProcs" ] pub fn SkFlattenable_serialize ( this : * const SkFlattenable , arg1 : * const SkSerialProcs ) -> sk_sp < SkData > ; } extern "C" { # [ link_name = "\u{1}__ZNK13SkFlattenable9serializeEPvmPK13SkSerialProcs" ] pub fn SkFlattenable_serialize1 ( this : * const SkFlattenable , memory : * mut :: std :: os :: raw :: c_void , memory_size : usize , arg1 : * const SkSerialProcs ) -> usize ; } extern "C" { # [ link_name = "\u{1}__ZN13SkFlattenable11DeserializeENS_4TypeEPKvmPK15SkDeserialProcs" ] pub fn SkFlattenable_Deserialize ( arg1 : SkFlattenable_Type , data : * const :: std :: os :: raw :: c_void , length : usize , procs : * const SkDeserialProcs ) -> sk_sp < SkFlattenable > ; } extern "C" { # [ link_name = "\u{1}__ZN13SkFlattenableC2Ev" ] pub fn SkFlattenable_SkFlattenable ( this : * mut SkFlattenable ) ; } impl SkFlattenable { # [ inline ] pub unsafe fn NameToFactory ( name : * const :: std :: os :: raw :: c_char ) -> SkFlattenable_Factory { SkFlattenable_NameToFactory ( name ) } # [ inline ] pub unsafe fn FactoryToName ( arg1 : SkFlattenable_Factory ) -> * const :: std :: os :: raw :: c_char { SkFlattenable_FactoryToName ( arg1 ) } # [ inline ] pub unsafe fn Register ( name : * const :: std :: os :: raw :: c_char , arg1 : SkFlattenable_Factory ) { SkFlattenable_Register ( name , arg1 ) } # [ inline ] pub unsafe fn serialize ( & self , arg1 : * const SkSerialProcs ) -> sk_sp < SkData > { SkFlattenable_serialize ( self , arg1 ) } # [ inline ] pub unsafe fn serialize1 ( & self , memory : * mut :: std :: os :: raw :: c_void , memory_size : usize , arg1 : * const SkSerialProcs ) -> usize { SkFlattenable_serialize1 ( self , memory , memory_size , arg1 ) } # [ inline ] pub unsafe fn Deserialize ( arg1 : SkFlattenable_Type , data : * const :: std :: os :: raw :: c_void , length : usize , procs : * const SkDeserialProcs ) -> sk_sp < SkFlattenable > { SkFlattenable_Deserialize ( arg1 , data , length , procs ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkFlattenable_SkFlattenable ( & mut __bindgen_tmp ) ; __bindgen_tmp } } extern "C" { # [ doc = "  Override this if your subclass needs to record data that it will need to recreate itself" ] # [ doc = "  from its CreateProc (returned by getFactory())." ] # [ doc = "" ] # [ doc = "  DEPRECATED public : will move to protected ... use serialize() instead" ] # [ link_name = "\u{1}__ZNK13SkFlattenable7flattenER13SkWriteBuffer" ] pub fn SkFlattenable_flatten ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut SkWriteBuffer ) ; } # [ doc = " \\class SkShader" ] # [ doc = "" ] # [ doc = "  Shaders specify the source color(s) for what is being drawn. If a paint" ] # [ doc = "  has no shader, then the paint\'s color is used. If the paint has a" ] # [ doc = "  shader, then the shader\'s color(s) are use instead, but they are" ] # [ doc = "  modulated by the paint\'s alpha. This makes it easy to create a shader" ] # [ doc = "  once (e.g. bitmap tiling or gradient) and then change its transparency" ] # [ doc = "  w/o having to modify the original shader... only the paint\'s alpha needs" ] # [ doc = "  to be modified." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkShader { pub _base : SkFlattenable , } # [ doc = "  Replicate the edge color if the shader draws outside of its" ] # [ doc = "  original bounds." ] pub const SkShader_TileMode_kClamp_TileMode : SkShader_TileMode = 0 ; # [ doc = "  Repeat the shader\'s image horizontally and vertically." ] pub const SkShader_TileMode_kRepeat_TileMode : SkShader_TileMode = 1 ; # [ doc = "  Repeat the shader\'s image horizontally and vertically, alternating" ] # [ doc = "  mirror images so that adjacent images always seam." ] pub const SkShader_TileMode_kMirror_TileMode : SkShader_TileMode = 2 ; # [ doc = "  Only draw within the original domain, return transparent-black everywhere else." ] pub const SkShader_TileMode_kDecal_TileMode : SkShader_TileMode = 3 ; # [ doc = "  Only draw within the original domain, return transparent-black everywhere else." ] pub const SkShader_TileMode_kLast_TileMode : SkShader_TileMode = 3 ; pub type SkShader_TileMode = u32 ; pub const SkShader_GradientType_kNone_GradientType : SkShader_GradientType = 0 ; pub const SkShader_GradientType_kColor_GradientType : SkShader_GradientType = 1 ; pub const SkShader_GradientType_kLinear_GradientType : SkShader_GradientType = 2 ; pub const SkShader_GradientType_kRadial_GradientType : SkShader_GradientType = 3 ; pub const SkShader_GradientType_kSweep_GradientType : SkShader_GradientType = 4 ; pub const SkShader_GradientType_kConical_GradientType : SkShader_GradientType = 5 ; pub const SkShader_GradientType_kLast_GradientType : SkShader_GradientType = 5 ; # [ doc = "  If the shader subclass can be represented as a gradient, asAGradient" ] # [ doc = "  returns the matching GradientType enum (or kNone_GradientType if it" ] # [ doc = "  cannot). Also, if info is not null, asAGradient populates info with" ] # [ doc = "  the relevant (see below) parameters for the gradient.  fColorCount" ] # [ doc = "  is both an input and output parameter.  On input, it indicates how" ] # [ doc = "  many entries in fColors and fColorOffsets can be used, if they are" ] # [ doc = "  non-NULL.  After asAGradient has run, fColorCount indicates how" ] # [ doc = "  many color-offset pairs there are in the gradient.  If there is" ] # [ doc = "  insufficient space to store all of the color-offset pairs, fColors" ] # [ doc = "  and fColorOffsets will not be altered.  fColorOffsets specifies" ] # [ doc = "  where on the range of 0 to 1 to transition to the given color." ] # [ doc = "  The meaning of fPoint and fRadius is dependant on the type of gradient." ] # [ doc = "" ] # [ doc = "  None:" ] # [ doc = "      info is ignored." ] # [ doc = "  Color:" ] # [ doc = "      fColorOffsets[0] is meaningless." ] # [ doc = "  Linear:" ] # [ doc = "      fPoint[0] and fPoint[1] are the end-points of the gradient" ] # [ doc = "  Radial:" ] # [ doc = "      fPoint[0] and fRadius[0] are the center and radius" ] # [ doc = "  Conical:" ] # [ doc = "      fPoint[0] and fRadius[0] are the center and radius of the 1st circle" ] # [ doc = "      fPoint[1] and fRadius[1] are the center and radius of the 2nd circle" ] # [ doc = "  Sweep:" ] # [ doc = "      fPoint[0] is the center of the sweep." ] pub type SkShader_GradientType = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkShader_GradientInfo { # [ doc = "!< In-out parameter, specifies passed size" ] pub fColorCount : :: std :: os :: raw :: c_int , # [ doc = "!< The colors in the gradient." ] pub fColors : * mut SkColor , # [ doc = "!< The unit offset for color transitions." ] pub fColorOffsets : * mut SkScalar , # [ doc = "!< Type specific, see above." ] pub fPoint : [ SkPoint ; 2usize ] , # [ doc = "!< Type specific, see above." ] pub fRadius : [ SkScalar ; 2usize ] , # [ doc = "!< The tile mode used." ] pub fTileMode : SkShader_TileMode , # [ doc = "!< see SkGradientShader::Flags" ] pub fGradientFlags : u32 , } # [ test ] fn bindgen_test_layout_SkShader_GradientInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkShader_GradientInfo > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( SkShader_GradientInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkShader_GradientInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkShader_GradientInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkShader_GradientInfo > ( ) ) ) . fColorCount as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkShader_GradientInfo ) , "::" , stringify ! ( fColorCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkShader_GradientInfo > ( ) ) ) . fColors as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkShader_GradientInfo ) , "::" , stringify ! ( fColors ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkShader_GradientInfo > ( ) ) ) . fColorOffsets as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkShader_GradientInfo ) , "::" , stringify ! ( fColorOffsets ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkShader_GradientInfo > ( ) ) ) . fPoint as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkShader_GradientInfo ) , "::" , stringify ! ( fPoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkShader_GradientInfo > ( ) ) ) . fRadius as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkShader_GradientInfo ) , "::" , stringify ! ( fRadius ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkShader_GradientInfo > ( ) ) ) . fTileMode as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkShader_GradientInfo ) , "::" , stringify ! ( fTileMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkShader_GradientInfo > ( ) ) ) . fGradientFlags as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( SkShader_GradientInfo ) , "::" , stringify ! ( fGradientFlags ) ) ) ; } pub type SkShader_INHERITED = SkFlattenable ; pub const SkShader_kTileModeCount : :: std :: os :: raw :: c_int = 4 ; # [ test ] fn bindgen_test_layout_SkShader ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkShader > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkShader ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkShader > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkShader ) ) ) ; } extern "C" { # [ doc = "  Returns the local matrix." ] # [ doc = "" ] # [ doc = "  FIXME: This can be incorrect for a Shader with its own local matrix" ] # [ doc = "  that is also wrapped via CreateLocalMatrixShader." ] # [ link_name = "\u{1}__ZNK8SkShader14getLocalMatrixEv" ] pub fn SkShader_getLocalMatrix ( this : * const SkShader ) -> * const SkMatrix ; } extern "C" { # [ doc = "  Iff this shader is backed by a single SkImage, return its ptr (the caller must ref this" ] # [ doc = "  if they want to keep it longer than the lifetime of the shader). If not, return nullptr." ] # [ link_name = "\u{1}__ZNK8SkShader8isAImageEP8SkMatrixPNS_8TileModeE" ] pub fn SkShader_isAImage ( this : * const SkShader , localMatrix : * mut SkMatrix , xy : * mut SkShader_TileMode ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkShader8isAImageEv" ] pub fn SkShader_isAImage1 ( this : * const SkShader ) -> bool ; } extern "C" { # [ doc = "  Return a shader that will apply the specified localMatrix to this shader." ] # [ doc = "  The specified matrix will be applied before any matrix associated with this shader." ] # [ link_name = "\u{1}__ZNK8SkShader19makeWithLocalMatrixERK8SkMatrix" ] pub fn SkShader_makeWithLocalMatrix ( this : * const SkShader , arg1 : * const SkMatrix ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = "  Create a new shader that produces the same colors as invoking this shader and then applying" ] # [ doc = "  the colorfilter." ] # [ link_name = "\u{1}__ZNK8SkShader19makeWithColorFilterE5sk_spI13SkColorFilterE" ] pub fn SkShader_makeWithColorFilter ( this : * const SkShader , arg1 : sk_sp < SkColorFilter > ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = "  Call this to create a new \"empty\" shader, that will not draw anything." ] # [ link_name = "\u{1}__ZN8SkShader15MakeEmptyShaderEv" ] pub fn SkShader_MakeEmptyShader ( ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = "  Call this to create a new shader that just draws the specified color. This should always" ] # [ doc = "  draw the same as a paint with this color (and no shader)." ] # [ link_name = "\u{1}__ZN8SkShader15MakeColorShaderEj" ] pub fn SkShader_MakeColorShader ( arg1 : SkColor ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = "  Create a shader that draws the specified color (in the specified colorspace)." ] # [ doc = "" ] # [ doc = "  This works around the limitation that SkPaint::setColor() only takes byte values, and does" ] # [ doc = "  not support specific colorspaces." ] # [ link_name = "\u{1}__ZN8SkShader15MakeColorShaderERK8SkRGBA4fIL11SkAlphaType3EE5sk_spI12SkColorSpaceE" ] pub fn SkShader_MakeColorShader1 ( arg1 : * const SkColor4f , arg2 : sk_sp < SkColorSpace > ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = "  Compose two shaders together, using two operators: mode and lerp. The resulting colors" ] # [ doc = "  are computed by first combining the src and dst shaders using mode, and then linearly" ] # [ doc = "  interpolating between the dst and result colors using lerp." ] # [ doc = "" ] # [ doc = "      result = dst * (1 - lerp) + (src (mode) dst) * lerp" ] # [ doc = "" ] # [ doc = "  If either shader is nullptr, then this returns nullptr." ] # [ doc = "  If lerp is NaN then this returns nullptr, otherwise lerp is clamped to [0..1]." ] # [ link_name = "\u{1}__ZN8SkShader11MakeComposeE5sk_spIS_ES1_11SkBlendModef" ] pub fn SkShader_MakeCompose ( dst : sk_sp < SkShader > , src : sk_sp < SkShader > , mode : SkBlendMode , lerp : f32 ) -> sk_sp < SkShader > ; } extern "C" { # [ link_name = "\u{1}__ZN8SkShader17MakeComposeShaderE5sk_spIS_ES1_11SkBlendMode" ] pub fn SkShader_MakeComposeShader ( dst : sk_sp < SkShader > , src : sk_sp < SkShader > , mode : SkBlendMode ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = "  Compose two shaders together using a weighted average." ] # [ doc = "" ] # [ doc = "  result = dst * (1 - lerp) + src * lerp" ] # [ doc = "" ] # [ doc = "  If either shader is nullptr, then this returns nullptr." ] # [ doc = "  If lerp is NaN then this returns nullptr, otherwise lerp is clamped to [0..1]." ] # [ link_name = "\u{1}__ZN8SkShader9MakeMixerE5sk_spIS_ES1_f" ] pub fn SkShader_MakeMixer ( dst : sk_sp < SkShader > , src : sk_sp < SkShader > , lerp : f32 ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = " Call this to create a new shader that will draw with the specified bitmap." ] # [ doc = "" ] # [ doc = "  If the bitmap cannot be used (e.g. has no pixels, or its dimensions" ] # [ doc = "  exceed implementation limits (currently at 64K - 1)) then SkEmptyShader" ] # [ doc = "  may be returned." ] # [ doc = "" ] # [ doc = "  If the src is kA8_Config then that mask will be colorized using the color on" ] # [ doc = "  the paint." ] # [ doc = "" ] # [ doc = "  @param src  The bitmap to use inside the shader" ] # [ doc = "  @param tmx  The tiling mode to use when sampling the bitmap in the x-direction." ] # [ doc = "  @param tmy  The tiling mode to use when sampling the bitmap in the y-direction." ] # [ doc = "  @return     Returns a new shader object. Note: this function never returns null." ] # [ link_name = "\u{1}__ZN8SkShader16MakeBitmapShaderERK8SkBitmapNS_8TileModeES3_PK8SkMatrix" ] pub fn SkShader_MakeBitmapShader ( src : * const SkBitmap , tmx : SkShader_TileMode , tmy : SkShader_TileMode , localMatrix : * const SkMatrix ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = " Call this to create a new shader that will draw with the specified picture." ] # [ doc = "" ] # [ doc = "  @param src  The picture to use inside the shader (if not NULL, its ref count" ] # [ doc = "              is incremented). The SkPicture must not be changed after" ] # [ doc = "              successfully creating a picture shader." ] # [ doc = "  @param tmx  The tiling mode to use when sampling the bitmap in the x-direction." ] # [ doc = "  @param tmy  The tiling mode to use when sampling the bitmap in the y-direction." ] # [ doc = "  @param tile The tile rectangle in picture coordinates: this represents the subset" ] # [ doc = "              (or superset) of the picture used when building a tile. It is not" ] # [ doc = "              affected by localMatrix and does not imply scaling (only translation" ] # [ doc = "              and cropping). If null, the tile rect is considered equal to the picture" ] # [ doc = "              bounds." ] # [ doc = "  @return     Returns a new shader object. Note: this function never returns null." ] # [ link_name = "\u{1}__ZN8SkShader17MakePictureShaderE5sk_spI9SkPictureENS_8TileModeES3_PK8SkMatrixPK6SkRect" ] pub fn SkShader_MakePictureShader ( src : sk_sp < SkPicture > , tmx : SkShader_TileMode , tmy : SkShader_TileMode , localMatrix : * const SkMatrix , tile : * const SkRect ) -> sk_sp < SkShader > ; } impl SkShader { # [ inline ] pub unsafe fn getLocalMatrix ( & self ) -> * const SkMatrix { SkShader_getLocalMatrix ( self ) } # [ inline ] pub unsafe fn isAImage ( & self , localMatrix : * mut SkMatrix , xy : * mut SkShader_TileMode ) -> * mut SkImage { SkShader_isAImage ( self , localMatrix , xy ) } # [ inline ] pub unsafe fn isAImage1 ( & self ) -> bool { SkShader_isAImage1 ( self ) } # [ inline ] pub unsafe fn makeWithLocalMatrix ( & self , arg1 : * const SkMatrix ) -> sk_sp < SkShader > { SkShader_makeWithLocalMatrix ( self , arg1 ) } # [ inline ] pub unsafe fn makeWithColorFilter ( & self , arg1 : sk_sp < SkColorFilter > ) -> sk_sp < SkShader > { SkShader_makeWithColorFilter ( self , arg1 ) } # [ inline ] pub unsafe fn MakeEmptyShader ( ) -> sk_sp < SkShader > { SkShader_MakeEmptyShader ( ) } # [ inline ] pub unsafe fn MakeColorShader ( arg1 : SkColor ) -> sk_sp < SkShader > { SkShader_MakeColorShader ( arg1 ) } # [ inline ] pub unsafe fn MakeColorShader1 ( arg1 : * const SkColor4f , arg2 : sk_sp < SkColorSpace > ) -> sk_sp < SkShader > { SkShader_MakeColorShader1 ( arg1 , arg2 ) } # [ inline ] pub unsafe fn MakeCompose ( dst : sk_sp < SkShader > , src : sk_sp < SkShader > , mode : SkBlendMode , lerp : f32 ) -> sk_sp < SkShader > { SkShader_MakeCompose ( dst , src , mode , lerp ) } # [ inline ] pub unsafe fn MakeComposeShader ( dst : sk_sp < SkShader > , src : sk_sp < SkShader > , mode : SkBlendMode ) -> sk_sp < SkShader > { SkShader_MakeComposeShader ( dst , src , mode ) } # [ inline ] pub unsafe fn MakeMixer ( dst : sk_sp < SkShader > , src : sk_sp < SkShader > , lerp : f32 ) -> sk_sp < SkShader > { SkShader_MakeMixer ( dst , src , lerp ) } # [ inline ] pub unsafe fn MakeBitmapShader ( src : * const SkBitmap , tmx : SkShader_TileMode , tmy : SkShader_TileMode , localMatrix : * const SkMatrix ) -> sk_sp < SkShader > { SkShader_MakeBitmapShader ( src , tmx , tmy , localMatrix ) } # [ inline ] pub unsafe fn MakePictureShader ( src : sk_sp < SkPicture > , tmx : SkShader_TileMode , tmy : SkShader_TileMode , localMatrix : * const SkMatrix , tile : * const SkRect ) -> sk_sp < SkShader > { SkShader_MakePictureShader ( src , tmx , tmy , localMatrix , tile ) } } extern "C" { # [ doc = "  Returns true if the shader is guaranteed to produce only opaque" ] # [ doc = "  colors, subject to the SkPaint using the shader to apply an opaque" ] # [ doc = "  alpha value. Subclasses should override this to allow some" ] # [ doc = "  optimizations." ] # [ link_name = "\u{1}__ZNK8SkShader8isOpaqueEv" ] pub fn SkShader_isOpaque ( this : * mut :: std :: os :: raw :: c_void ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkShader11asAGradientEPNS_12GradientInfoE" ] pub fn SkShader_asAGradient ( this : * mut :: std :: os :: raw :: c_void , info : * mut SkShader_GradientInfo ) -> SkShader_GradientType ; } extern "C" { # [ doc = "  If this shader can be represented by another shader + a localMatrix, return that shader and" ] # [ doc = "  the localMatrix. If not, return nullptr and ignore the localMatrix parameter." ] # [ link_name = "\u{1}__ZNK8SkShader24makeAsALocalMatrixShaderEP8SkMatrix" ] pub fn SkShader_makeAsALocalMatrixShader ( this : * mut :: std :: os :: raw :: c_void , localMatrix : * mut SkMatrix ) -> sk_sp < SkShader > ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkImageGenerator { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrContextThreadSafeProxy { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrTexture { _unused : [ u8 ; 0 ] , } # [ doc = " \\class SkImage" ] # [ doc = "SkImage describes a two dimensional array of pixels to draw. The pixels may be" ] # [ doc = "decoded in a raster bitmap, encoded in a SkPicture or compressed data stream," ] # [ doc = "or located in GPU memory as a GPU texture." ] # [ doc = "" ] # [ doc = "SkImage cannot be modified after it is created. SkImage may allocate additional" ] # [ doc = "storage as needed; for instance, an encoded SkImage may decode when drawn." ] # [ doc = "" ] # [ doc = "SkImage width and height are greater than zero. Creating an SkImage with zero width" ] # [ doc = "or height returns SkImage equal to nullptr." ] # [ doc = "" ] # [ doc = "SkImage may be created from SkBitmap, SkPixmap, SkSurface, SkPicture, encoded streams," ] # [ doc = "GPU texture, YUV_ColorSpace data, or hardware buffer. Encoded streams supported" ] # [ doc = "include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP. Supported encoding details" ] # [ doc = "vary with platform." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkImage { pub _base : SkRefCnt , pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fUniqueID : u32 , } # [ doc = " Caller data passed to RasterReleaseProc; may be nullptr." ] pub type SkImage_ReleaseContext = * mut :: std :: os :: raw :: c_void ; # [ doc = " Function called when SkImage no longer shares pixels. ReleaseContext is" ] # [ doc = "provided by caller when SkImage is created, and may be nullptr." ] pub type SkImage_RasterReleaseProc = :: core :: option :: Option < unsafe extern "C" fn ( pixels : * const :: std :: os :: raw :: c_void , arg1 : SkImage_ReleaseContext ) > ; pub const SkImage_CompressionType_kETC1_CompressionType : SkImage_CompressionType = 0 ; pub const SkImage_CompressionType_kLast_CompressionType : SkImage_CompressionType = 0 ; pub type SkImage_CompressionType = u32 ; # [ doc = " User function called when supplied texture may be deleted." ] pub type SkImage_TextureReleaseProc = :: core :: option :: Option < unsafe extern "C" fn ( releaseContext : SkImage_ReleaseContext ) > ; # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkImage_BitDepth { # [ doc = "!< uses 8-bit unsigned int per color component" ] kU8 = 0 , # [ doc = "!< uses 16-bit float per color component" ] kF16 = 1 , } # [ repr ( u32 ) ] # [ doc = " \\enum SkImage::CachingHint" ] # [ doc = "CachingHint selects whether Skia may internally cache SkBitmap generated by" ] # [ doc = "decoding SkImage, or by copying SkImage from GPU to CPU. The default behavior" ] # [ doc = "allows caching SkBitmap." ] # [ doc = "" ] # [ doc = "Choose kDisallow_CachingHint if SkImage pixels are to be used only once, or" ] # [ doc = "if SkImage pixels reside in a cache outside of Skia, or to reduce memory pressure." ] # [ doc = "" ] # [ doc = "Choosing kAllow_CachingHint does not ensure that pixels will be cached." ] # [ doc = "SkImage pixels may not be cached if memory requirements are too large or" ] # [ doc = "pixels are not accessible." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkImage_CachingHint { # [ doc = "!< allows internally caching decoded and copied pixels" ] kAllow_CachingHint = 0 , # [ doc = "!< disallows internally caching decoded and copied pixels" ] kDisallow_CachingHint = 1 , } # [ doc = " Defines a callback function, taking one parameter of type GrBackendTexture with" ] # [ doc = "no return value. Function is called when back-end texture is to be released." ] pub type SkImage_BackendTextureReleaseProc = std_function ; # [ doc = "!< returned bitmap is read-only and immutable" ] pub const SkImage_LegacyBitmapMode_kRO_LegacyBitmapMode : SkImage_LegacyBitmapMode = 0 ; # [ doc = " Deprecated." ] pub type SkImage_LegacyBitmapMode = u32 ; pub type SkImage_INHERITED = SkRefCnt ; # [ test ] fn bindgen_test_layout_SkImage ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkImage > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkImage ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkImage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkImage > ( ) ) ) . fWidth as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkImage ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkImage > ( ) ) ) . fHeight as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkImage ) , "::" , stringify ! ( fHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkImage > ( ) ) ) . fUniqueID as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SkImage ) , "::" , stringify ! ( fUniqueID ) ) ) ; } extern "C" { # [ doc = " Creates SkImage from SkPixmap and copy of pixels. Since pixels are copied, SkPixmap" ] # [ doc = "pixels may be modified or deleted without affecting SkImage." ] # [ doc = "" ] # [ doc = "SkImage is returned if SkPixmap is valid. Valid SkPixmap parameters include:" ] # [ doc = "dimensions are greater than zero;" ] # [ doc = "each dimension fits in 29 bits;" ] # [ doc = "SkColorType and SkAlphaType are valid, and SkColorType is not kUnknown_SkColorType;" ] # [ doc = "row bytes are large enough to hold one row of pixels;" ] # [ doc = "pixel address is not nullptr." ] # [ doc = "" ] # [ doc = "@param pixmap  SkImageInfo, pixel address, and row bytes" ] # [ doc = "@return        copy of SkPixmap pixels, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage14MakeRasterCopyERK8SkPixmap" ] pub fn SkImage_MakeRasterCopy ( pixmap : * const SkPixmap ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from SkImageInfo, sharing pixels." ] # [ doc = "" ] # [ doc = "SkImage is returned if SkImageInfo is valid. Valid SkImageInfo parameters include:" ] # [ doc = "dimensions are greater than zero;" ] # [ doc = "each dimension fits in 29 bits;" ] # [ doc = "SkColorType and SkAlphaType are valid, and SkColorType is not kUnknown_SkColorType;" ] # [ doc = "rowBytes are large enough to hold one row of pixels;" ] # [ doc = "pixels is not nullptr, and contains enough data for SkImage." ] # [ doc = "" ] # [ doc = "@param info      contains width, height, SkAlphaType, SkColorType, SkColorSpace" ] # [ doc = "@param pixels    address or pixel storage" ] # [ doc = "@param rowBytes  size of pixel row or larger" ] # [ doc = "@return          SkImage sharing pixels, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage14MakeRasterDataERK11SkImageInfo5sk_spI6SkDataEm" ] pub fn SkImage_MakeRasterData ( info : * const SkImageInfo , pixels : sk_sp < SkData > , rowBytes : usize ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from pixmap, sharing SkPixmap pixels. Pixels must remain valid and" ] # [ doc = "unchanged until rasterReleaseProc is called. rasterReleaseProc is passed" ] # [ doc = "releaseContext when SkImage is deleted or no longer refers to pixmap pixels." ] # [ doc = "" ] # [ doc = "Pass nullptr for rasterReleaseProc to share SkPixmap without requiring a callback" ] # [ doc = "when SkImage is released. Pass nullptr for releaseContext if rasterReleaseProc" ] # [ doc = "does not require state." ] # [ doc = "" ] # [ doc = "SkImage is returned if pixmap is valid. Valid SkPixmap parameters include:" ] # [ doc = "dimensions are greater than zero;" ] # [ doc = "each dimension fits in 29 bits;" ] # [ doc = "SkColorType and SkAlphaType are valid, and SkColorType is not kUnknown_SkColorType;" ] # [ doc = "row bytes are large enough to hold one row of pixels;" ] # [ doc = "pixel address is not nullptr." ] # [ doc = "" ] # [ doc = "@param pixmap             SkImageInfo, pixel address, and row bytes" ] # [ doc = "@param rasterReleaseProc  function called when pixels can be released; or nullptr" ] # [ doc = "@param releaseContext     state passed to rasterReleaseProc; or nullptr" ] # [ doc = "@return                   SkImage sharing pixmap" ] # [ link_name = "\u{1}__ZN7SkImage14MakeFromRasterERK8SkPixmapPFvPKvPvES5_" ] pub fn SkImage_MakeFromRaster ( pixmap : * const SkPixmap , rasterReleaseProc : SkImage_RasterReleaseProc , releaseContext : SkImage_ReleaseContext ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from bitmap, sharing or copying bitmap pixels. If the bitmap" ] # [ doc = "is marked immutable, and its pixel memory is shareable, it may be shared" ] # [ doc = "instead of copied." ] # [ doc = "" ] # [ doc = "SkImage is returned if bitmap is valid. Valid SkBitmap parameters include:" ] # [ doc = "dimensions are greater than zero;" ] # [ doc = "each dimension fits in 29 bits;" ] # [ doc = "SkColorType and SkAlphaType are valid, and SkColorType is not kUnknown_SkColorType;" ] # [ doc = "row bytes are large enough to hold one row of pixels;" ] # [ doc = "pixel address is not nullptr." ] # [ doc = "" ] # [ doc = "@param bitmap  SkImageInfo, row bytes, and pixels" ] # [ doc = "@return        created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage14MakeFromBitmapERK8SkBitmap" ] pub fn SkImage_MakeFromBitmap ( bitmap : * const SkBitmap ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from data returned by imageGenerator. Generated data is owned by SkImage and" ] # [ doc = "may not be shared or accessed." ] # [ doc = "" ] # [ doc = "subset allows selecting a portion of the full image. Pass nullptr to select the entire" ] # [ doc = "image; otherwise, subset must be contained by image bounds." ] # [ doc = "" ] # [ doc = "SkImage is returned if generator data is valid. Valid data parameters vary by type of data" ] # [ doc = "and platform." ] # [ doc = "" ] # [ doc = "imageGenerator may wrap SkPicture data, codec data, or custom data." ] # [ doc = "" ] # [ doc = "@param imageGenerator  stock or custom routines to retrieve SkImage" ] # [ doc = "@param subset          bounds of returned SkImage; may be nullptr" ] # [ doc = "@return                created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage17MakeFromGeneratorENSt3__110unique_ptrI16SkImageGeneratorNS0_14default_deleteIS2_EEEEPK7SkIRect" ] pub fn SkImage_MakeFromGenerator ( imageGenerator : std_unique_ptr , subset : * const SkIRect ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from encoded data." ] # [ doc = "subset allows selecting a portion of the full image. Pass nullptr to select the entire" ] # [ doc = "image; otherwise, subset must be contained by image bounds." ] # [ doc = "" ] # [ doc = "SkImage is returned if format of the encoded data is recognized and supported." ] # [ doc = "Recognized formats vary by platform." ] # [ doc = "" ] # [ doc = "@param encoded  data of SkImage to decode" ] # [ doc = "@param subset   bounds of returned SkImage; may be nullptr" ] # [ doc = "@return         created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage15MakeFromEncodedE5sk_spI6SkDataEPK7SkIRect" ] pub fn SkImage_MakeFromEncoded ( encoded : sk_sp < SkData > , subset : * const SkIRect ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates a GPU-backed SkImage from compressed data." ] # [ doc = "" ] # [ doc = "SkImage is returned if format of the compressed data is supported." ] # [ doc = "Supported formats vary by platform." ] # [ doc = "" ] # [ doc = "@param context  GPU context" ] # [ doc = "@param data     compressed data to store in SkImage" ] # [ doc = "@param width    width of full SkImage" ] # [ doc = "@param height   height of full SkImage" ] # [ doc = "@param type     type of compression used" ] # [ doc = "@return         created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage18MakeFromCompressedEP9GrContext5sk_spI6SkDataEiiNS_15CompressionTypeE" ] pub fn SkImage_MakeFromCompressed ( context : * mut GrContext , data : sk_sp < SkData > , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , type_ : SkImage_CompressionType ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from GPU texture associated with context. Caller is responsible for" ] # [ doc = "managing the lifetime of GPU texture." ] # [ doc = "" ] # [ doc = "SkImage is returned if format of backendTexture is recognized and supported." ] # [ doc = "Recognized formats vary by GPU back-end." ] # [ doc = "" ] # [ doc = "@param context         GPU context" ] # [ doc = "@param backendTexture  texture residing on GPU" ] # [ doc = "@param origin          one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param colorType       one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType," ] # [ doc = "kRGB_888x_SkColorType, kBGRA_8888_SkColorType," ] # [ doc = "kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@param alphaType       one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@param colorSpace      range of colors; may be nullptr" ] # [ doc = "@return                created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage15MakeFromTextureEP9GrContextRK16GrBackendTexture15GrSurfaceOrigin11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromTexture ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from GPU texture associated with context. GPU texture must stay" ] # [ doc = "valid and unchanged until textureReleaseProc is called. textureReleaseProc is" ] # [ doc = "passed releaseContext when SkImage is deleted or no longer refers to texture." ] # [ doc = "" ] # [ doc = "SkImage is returned if format of backendTexture is recognized and supported." ] # [ doc = "Recognized formats vary by GPU back-end." ] # [ doc = "" ] # [ doc = "@param context             GPU context" ] # [ doc = "@param backendTexture      texture residing on GPU" ] # [ doc = "@param origin              one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param colorType           one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType," ] # [ doc = "kRGB_565_SkColorType, kARGB_4444_SkColorType," ] # [ doc = "kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType," ] # [ doc = "kRGB_101010x_SkColorType, kGray_8_SkColorType," ] # [ doc = "kRGBA_F16_SkColorType" ] # [ doc = "@param alphaType           one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@param colorSpace          range of colors; may be nullptr" ] # [ doc = "@param textureReleaseProc  function called when texture can be released" ] # [ doc = "@param releaseContext      state passed to textureReleaseProc" ] # [ doc = "@return                    created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage15MakeFromTextureEP9GrContextRK16GrBackendTexture15GrSurfaceOrigin11SkColorType11SkAlphaType5sk_spI12SkColorSpaceEPFvPvESB_" ] pub fn SkImage_MakeFromTexture1 ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureReleaseProc : SkImage_TextureReleaseProc , releaseContext : SkImage_ReleaseContext ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from encoded data. SkImage is uploaded to GPU back-end using context." ] # [ doc = "" ] # [ doc = "Created SkImage is available to other GPU contexts, and is available across thread" ] # [ doc = "boundaries. All contexts must be in the same GPU share group, or otherwise" ] # [ doc = "share resources." ] # [ doc = "" ] # [ doc = "When SkImage is no longer referenced, context releases texture memory" ] # [ doc = "asynchronously." ] # [ doc = "" ] # [ doc = "GrBackendTexture decoded from data is uploaded to match SkSurface created with" ] # [ doc = "dstColorSpace. SkColorSpace of SkImage is determined by encoded data." ] # [ doc = "" ] # [ doc = "SkImage is returned if format of data is recognized and supported, and if context" ] # [ doc = "supports moving resources. Recognized formats vary by platform and GPU back-end." ] # [ doc = "" ] # [ doc = "SkImage is returned using MakeFromEncoded() if context is nullptr or does not support" ] # [ doc = "moving resources between contexts." ] # [ doc = "" ] # [ doc = "@param context                GPU context" ] # [ doc = "@param data                   SkImage to decode" ] # [ doc = "@param buildMips              create SkImage as mip map if true" ] # [ doc = "@param dstColorSpace          range of colors of matching SkSurface on GPU" ] # [ doc = "@param limitToMaxTextureSize  downscale image to GPU maximum texture size, if necessary" ] # [ doc = "@return                       created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage27MakeCrossContextFromEncodedEP9GrContext5sk_spI6SkDataEbP12SkColorSpaceb" ] pub fn SkImage_MakeCrossContextFromEncoded ( context : * mut GrContext , data : sk_sp < SkData > , buildMips : bool , dstColorSpace : * mut SkColorSpace , limitToMaxTextureSize : bool ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from pixmap. SkImage is uploaded to GPU back-end using context." ] # [ doc = "" ] # [ doc = "Created SkImage is available to other GPU contexts, and is available across thread" ] # [ doc = "boundaries. All contexts must be in the same GPU share group, or otherwise" ] # [ doc = "share resources." ] # [ doc = "" ] # [ doc = "When SkImage is no longer referenced, context releases texture memory" ] # [ doc = "asynchronously." ] # [ doc = "" ] # [ doc = "GrBackendTexture created from pixmap is uploaded to match SkSurface created with" ] # [ doc = "dstColorSpace. SkColorSpace of SkImage is determined by pixmap.colorSpace()." ] # [ doc = "" ] # [ doc = "SkImage is returned referring to GPU back-end if context is not nullptr," ] # [ doc = "format of data is recognized and supported, and if context supports moving" ] # [ doc = "resources between contexts. Otherwise, pixmap pixel data is copied and SkImage" ] # [ doc = "as returned in raster format if possible; nullptr may be returned." ] # [ doc = "Recognized GPU formats vary by platform and GPU back-end." ] # [ doc = "" ] # [ doc = "@param context                GPU context" ] # [ doc = "@param pixmap                 SkImageInfo, pixel address, and row bytes" ] # [ doc = "@param buildMips              create SkImage as mip map if true" ] # [ doc = "@param dstColorSpace          range of colors of matching SkSurface on GPU" ] # [ doc = "@param limitToMaxTextureSize  downscale image to GPU maximum texture size, if necessary" ] # [ doc = "@return                       created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage26MakeCrossContextFromPixmapEP9GrContextRK8SkPixmapbP12SkColorSpaceb" ] pub fn SkImage_MakeCrossContextFromPixmap ( context : * mut GrContext , pixmap : * const SkPixmap , buildMips : bool , dstColorSpace : * mut SkColorSpace , limitToMaxTextureSize : bool ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from backendTexture associated with context. backendTexture and" ] # [ doc = "returned SkImage are managed internally, and are released when no longer needed." ] # [ doc = "" ] # [ doc = "SkImage is returned if format of backendTexture is recognized and supported." ] # [ doc = "Recognized formats vary by GPU back-end." ] # [ doc = "" ] # [ doc = "@param context         GPU context" ] # [ doc = "@param backendTexture  texture residing on GPU" ] # [ doc = "@param surfaceOrigin   one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param colorType       one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType," ] # [ doc = "kRGB_565_SkColorType, kARGB_4444_SkColorType," ] # [ doc = "kRGBA_8888_SkColorType, kRGB_888x_SkColorType," ] # [ doc = "kBGRA_8888_SkColorType, kRGBA_1010102_SkColorType," ] # [ doc = "kRGB_101010x_SkColorType, kGray_8_SkColorType," ] # [ doc = "kRGBA_F16_SkColorType" ] # [ doc = "@param alphaType       one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType" ] # [ doc = "@param colorSpace      range of colors; may be nullptr" ] # [ doc = "@return                created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage22MakeFromAdoptedTextureEP9GrContextRK16GrBackendTexture15GrSurfaceOrigin11SkColorType11SkAlphaType5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromAdoptedTexture ( context : * mut GrContext , backendTexture : * const GrBackendTexture , surfaceOrigin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates an SkImage by flattening the specified YUVA planes into a single, interleaved RGBA" ] # [ doc = "image." ] # [ doc = "" ] # [ doc = "@param context         GPU context" ] # [ doc = "@param yuvColorSpace   How the YUV values are converted to RGB. One of:" ] # [ doc = "kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace," ] # [ doc = "kRec709_SkYUVColorSpace" ] # [ doc = "@param yuvaTextures    array of (up to four) YUVA textures on GPU which contain the," ] # [ doc = "possibly interleaved, YUVA planes" ] # [ doc = "@param yuvaIndices     array indicating which texture in yuvaTextures, and channel" ] # [ doc = "in that texture, maps to each component of YUVA." ] # [ doc = "@param imageSize       size of the resulting image" ] # [ doc = "@param imageOrigin     origin of the resulting image. One of: kBottomLeft_GrSurfaceOrigin," ] # [ doc = "kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param imageColorSpace range of colors of the resulting image; may be nullptr" ] # [ doc = "@return                created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage24MakeFromYUVATexturesCopyEP9GrContext15SkYUVColorSpacePK16GrBackendTexturePK11SkYUVAIndex7SkISize15GrSurfaceOrigin5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromYUVATexturesCopy ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates an SkImage by flattening the specified YUVA planes into a single, interleaved RGBA" ] # [ doc = "image. \'backendTexture\' is used to store the result of the flattening." ] # [ doc = "" ] # [ doc = "@param context         GPU context" ] # [ doc = "@param yuvColorSpace   How the YUV values are converted to RGB. One of:" ] # [ doc = "kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace," ] # [ doc = "kRec709_SkYUVColorSpace" ] # [ doc = "@param yuvaTextures    array of (up to four) YUVA textures on GPU which contain the," ] # [ doc = "possibly interleaved, YUVA planes" ] # [ doc = "@param yuvaIndices     array indicating which texture in yuvaTextures, and channel" ] # [ doc = "in that texture, maps to each component of YUVA." ] # [ doc = "@param imageSize       size of the resulting image" ] # [ doc = "@param imageOrigin     origin of the resulting image. One of: kBottomLeft_GrSurfaceOrigin," ] # [ doc = "kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param backendTexture  the resource that stores the final pixels" ] # [ doc = "@param imageColorSpace range of colors of the resulting image; may be nullptr" ] # [ doc = "@return                created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage43MakeFromYUVATexturesCopyWithExternalBackendEP9GrContext15SkYUVColorSpacePK16GrBackendTexturePK11SkYUVAIndex7SkISize15GrSurfaceOriginRS4_5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromYUVATexturesCopyWithExternalBackend ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , backendTexture : * const GrBackendTexture , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates an SkImage by storing the specified YUVA planes into an image, to be rendered" ] # [ doc = "via multitexturing." ] # [ doc = "" ] # [ doc = "@param context         GPU context" ] # [ doc = "@param yuvColorSpace   How the YUV values are converted to RGB. One of:" ] # [ doc = "kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace," ] # [ doc = "kRec709_SkYUVColorSpace" ] # [ doc = "@param yuvaTextures    array of (up to four) YUVA textures on GPU which contain the," ] # [ doc = "possibly interleaved, YUVA planes" ] # [ doc = "@param yuvaIndices     array indicating which texture in yuvaTextures, and channel" ] # [ doc = "in that texture, maps to each component of YUVA." ] # [ doc = "@param imageSize       size of the resulting image" ] # [ doc = "@param imageOrigin     origin of the resulting image. One of: kBottomLeft_GrSurfaceOrigin," ] # [ doc = "kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param imageColorSpace range of colors of the resulting image; may be nullptr" ] # [ doc = "@return                created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage20MakeFromYUVATexturesEP9GrContext15SkYUVColorSpacePK16GrBackendTexturePK11SkYUVAIndex7SkISize15GrSurfaceOrigin5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromYUVATextures ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from pixmap array representing YUVA data." ] # [ doc = "SkImage is uploaded to GPU back-end using context." ] # [ doc = "" ] # [ doc = "Each GrBackendTexture created from yuvaPixmaps array is uploaded to match SkSurface" ] # [ doc = "using SkColorSpace of SkPixmap. SkColorSpace of SkImage is determined by imageColorSpace." ] # [ doc = "" ] # [ doc = "SkImage is returned referring to GPU back-end if context is not nullptr and" ] # [ doc = "format of data is recognized and supported. Otherwise, nullptr is returned." ] # [ doc = "Recognized GPU formats vary by platform and GPU back-end." ] # [ doc = "" ] # [ doc = "@param context                GPU context" ] # [ doc = "@param yuvColorSpace          How the YUV values are converted to RGB. One of:" ] # [ doc = "kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace," ] # [ doc = "kRec709_SkYUVColorSpace" ] # [ doc = "@param yuvaPixmaps            array of (up to four) SkPixmap which contain the," ] # [ doc = "possibly interleaved, YUVA planes" ] # [ doc = "@param yuvaIndices            array indicating which pixmap in yuvaPixmaps, and channel" ] # [ doc = "in that pixmap, maps to each component of YUVA." ] # [ doc = "@param imageSize              size of the resulting image" ] # [ doc = "@param imageOrigin            origin of the resulting image. One of:" ] # [ doc = "kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param buildMips              create internal YUVA textures as mip map if true" ] # [ doc = "@param limitToMaxTextureSize  downscale image to GPU maximum texture size, if necessary" ] # [ doc = "@param imageColorSpace        range of colors of the resulting image; may be nullptr" ] # [ doc = "@return                       created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage19MakeFromYUVAPixmapsEP9GrContext15SkYUVColorSpacePK8SkPixmapPK11SkYUVAIndex7SkISize15GrSurfaceOriginbb5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromYUVAPixmaps ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaPixmaps : * const SkPixmap , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , buildMips : bool , limitToMaxTextureSize : bool , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " To be deprecated." ] # [ link_name = "\u{1}__ZN7SkImage23MakeFromYUVTexturesCopyEP9GrContext15SkYUVColorSpacePK16GrBackendTexture15GrSurfaceOrigin5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromYUVTexturesCopy ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvTextures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " To be deprecated." ] # [ link_name = "\u{1}__ZN7SkImage42MakeFromYUVTexturesCopyWithExternalBackendEP9GrContext15SkYUVColorSpacePK16GrBackendTexture15GrSurfaceOriginRS4_5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromYUVTexturesCopyWithExternalBackend ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvTextures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , backendTexture : * const GrBackendTexture , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from copy of nv12Textures, an array of textures on GPU." ] # [ doc = "nv12Textures[0] contains pixels for YUV component y plane." ] # [ doc = "nv12Textures[1] contains pixels for YUV component u plane," ] # [ doc = "followed by pixels for YUV component v plane." ] # [ doc = "Returned SkImage has the dimensions nv12Textures[2]." ] # [ doc = "yuvColorSpace describes how YUV colors convert to RGB colors." ] # [ doc = "" ] # [ doc = "@param context         GPU context" ] # [ doc = "@param yuvColorSpace   one of: kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace," ] # [ doc = "kRec709_SkYUVColorSpace" ] # [ doc = "@param nv12Textures    array of YUV textures on GPU" ] # [ doc = "@param imageOrigin     one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param imageColorSpace range of colors; may be nullptr" ] # [ doc = "@return                created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage24MakeFromNV12TexturesCopyEP9GrContext15SkYUVColorSpacePK16GrBackendTexture15GrSurfaceOrigin5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromNV12TexturesCopy ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , nv12Textures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from copy of nv12Textures, an array of textures on GPU." ] # [ doc = "nv12Textures[0] contains pixels for YUV component y plane." ] # [ doc = "nv12Textures[1] contains pixels for YUV component u plane," ] # [ doc = "followed by pixels for YUV component v plane." ] # [ doc = "Returned SkImage has the dimensions nv12Textures[2] and stores pixels in backendTexture." ] # [ doc = "yuvColorSpace describes how YUV colors convert to RGB colors." ] # [ doc = "" ] # [ doc = "@param context         GPU context" ] # [ doc = "@param yuvColorSpace   one of: kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace," ] # [ doc = "kRec709_SkYUVColorSpace" ] # [ doc = "@param nv12Textures    array of YUV textures on GPU" ] # [ doc = "@param imageOrigin     one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param backendTexture  the resource that stores the final pixels" ] # [ doc = "@param imageColorSpace range of colors; may be nullptr" ] # [ doc = "@return                created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage43MakeFromNV12TexturesCopyWithExternalBackendEP9GrContext15SkYUVColorSpacePK16GrBackendTexture15GrSurfaceOriginRS4_5sk_spI12SkColorSpaceE" ] pub fn SkImage_MakeFromNV12TexturesCopyWithExternalBackend ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , nv12Textures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , backendTexture : * const GrBackendTexture , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates SkImage from picture. Returned SkImage width and height are set by dimensions." ] # [ doc = "SkImage draws picture with matrix and paint, set to bitDepth and colorSpace." ] # [ doc = "" ] # [ doc = "If matrix is nullptr, draws with identity SkMatrix. If paint is nullptr, draws" ] # [ doc = "with default SkPaint. colorSpace may be nullptr." ] # [ doc = "" ] # [ doc = "@param picture     stream of drawing commands" ] # [ doc = "@param dimensions  width and height" ] # [ doc = "@param matrix      SkMatrix to rotate, scale, translate, and so on; may be nullptr" ] # [ doc = "@param paint       SkPaint to apply transparency, filtering, and so on; may be nullptr" ] # [ doc = "@param bitDepth    8-bit integer or 16-bit float: per component" ] # [ doc = "@param colorSpace  range of colors; may be nullptr" ] # [ doc = "@return            created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZN7SkImage15MakeFromPictureE5sk_spI9SkPictureERK7SkISizePK8SkMatrixPK7SkPaintNS_8BitDepthES0_I12SkColorSpaceE" ] pub fn SkImage_MakeFromPicture ( picture : sk_sp < SkPicture > , dimensions : * const SkISize , matrix : * const SkMatrix , paint : * const SkPaint , bitDepth : SkImage_BitDepth , colorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Returns pixel count in each row." ] # [ doc = "" ] # [ doc = "@return  pixel width in SkImage" ] # [ link_name = "\u{1}__ZNK7SkImage5widthEv" ] pub fn SkImage_width ( this : * const SkImage ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns pixel row count." ] # [ doc = "" ] # [ doc = "@return  pixel height in SkImage" ] # [ link_name = "\u{1}__ZNK7SkImage6heightEv" ] pub fn SkImage_height ( this : * const SkImage ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns SkISize { width(), height() }." ] # [ doc = "" ] # [ doc = "@return  integral size of width() and height()" ] # [ link_name = "\u{1}__ZNK7SkImage10dimensionsEv" ] pub fn SkImage_dimensions ( this : * const SkImage ) -> SkISize ; } extern "C" { # [ doc = " Returns SkIRect { 0, 0, width(), height() }." ] # [ doc = "" ] # [ doc = "@return  integral rectangle from origin to width() and height()" ] # [ link_name = "\u{1}__ZNK7SkImage6boundsEv" ] pub fn SkImage_bounds ( this : * const SkImage ) -> SkIRect ; } extern "C" { # [ doc = " Returns value unique to image. SkImage contents cannot change after SkImage is" ] # [ doc = "created. Any operation to create a new SkImage will receive generate a new" ] # [ doc = "unique number." ] # [ doc = "" ] # [ doc = "@return  unique identifier" ] # [ link_name = "\u{1}__ZNK7SkImage8uniqueIDEv" ] pub fn SkImage_uniqueID ( this : * const SkImage ) -> u32 ; } extern "C" { # [ doc = " Returns SkAlphaType, one of:" ] # [ doc = "kUnknown_SkAlphaType, kOpaque_SkAlphaType, kPremul_SkAlphaType," ] # [ doc = "kUnpremul_SkAlphaType." ] # [ doc = "" ] # [ doc = "SkAlphaType returned was a parameter to an SkImage constructor," ] # [ doc = "or was parsed from encoded data." ] # [ doc = "" ] # [ doc = "@return  SkAlphaType in SkImage" ] # [ link_name = "\u{1}__ZNK7SkImage9alphaTypeEv" ] pub fn SkImage_alphaType ( this : * const SkImage ) -> SkAlphaType ; } extern "C" { # [ doc = " Returns SkColorType if known; otherwise, returns kUnknown_SkColorType." ] # [ doc = "" ] # [ doc = "@return  SkColorType of SkImage" ] # [ link_name = "\u{1}__ZNK7SkImage9colorTypeEv" ] pub fn SkImage_colorType ( this : * const SkImage ) -> SkColorType ; } extern "C" { # [ doc = " Returns SkColorSpace, the range of colors, associated with SkImage.  The" ] # [ doc = "reference count of SkColorSpace is unchanged. The returned SkColorSpace is" ] # [ doc = "immutable." ] # [ doc = "" ] # [ doc = "SkColorSpace returned was passed to an SkImage constructor," ] # [ doc = "or was parsed from encoded data. SkColorSpace returned may be ignored when SkImage" ] # [ doc = "is drawn, depending on the capabilities of the SkSurface receiving the drawing." ] # [ doc = "" ] # [ doc = "@return  SkColorSpace in SkImage, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage10colorSpaceEv" ] pub fn SkImage_colorSpace ( this : * const SkImage ) -> * mut SkColorSpace ; } extern "C" { # [ doc = " Returns a smart pointer to SkColorSpace, the range of colors, associated with" ] # [ doc = "SkImage.  The smart pointer tracks the number of objects sharing this" ] # [ doc = "SkColorSpace reference so the memory is released when the owners destruct." ] # [ doc = "" ] # [ doc = "The returned SkColorSpace is immutable." ] # [ doc = "" ] # [ doc = "SkColorSpace returned was passed to an SkImage constructor," ] # [ doc = "or was parsed from encoded data. SkColorSpace returned may be ignored when SkImage" ] # [ doc = "is drawn, depending on the capabilities of the SkSurface receiving the drawing." ] # [ doc = "" ] # [ doc = "@return  SkColorSpace in SkImage, or nullptr, wrapped in a smart pointer" ] # [ link_name = "\u{1}__ZNK7SkImage13refColorSpaceEv" ] pub fn SkImage_refColorSpace ( this : * const SkImage ) -> sk_sp < SkColorSpace > ; } extern "C" { # [ doc = " Returns true if SkImage pixels represent transparency only. If true, each pixel" ] # [ doc = "is packed in 8 bits as defined by kAlpha_8_SkColorType." ] # [ doc = "" ] # [ doc = "@return  true if pixels represent a transparency mask" ] # [ link_name = "\u{1}__ZNK7SkImage11isAlphaOnlyEv" ] pub fn SkImage_isAlphaOnly ( this : * const SkImage ) -> bool ; } extern "C" { # [ doc = " Returns true if pixels ignore their alpha value and are treated as fully opaque." ] # [ doc = "" ] # [ doc = "@return  true if SkAlphaType is kOpaque_SkAlphaType" ] # [ link_name = "\u{1}__ZNK7SkImage8isOpaqueEv" ] pub fn SkImage_isOpaque ( this : * const SkImage ) -> bool ; } extern "C" { # [ doc = " Creates SkShader from SkImage. SkShader dimensions are taken from SkImage. SkShader uses" ] # [ doc = "SkShader::TileMode rules to fill drawn area outside SkImage. localMatrix permits" ] # [ doc = "transforming SkImage before SkCanvas matrix is applied." ] # [ doc = "" ] # [ doc = "@param tileMode1    tiling on x-axis, one of: SkShader::kClamp_TileMode," ] # [ doc = "SkShader::kRepeat_TileMode, SkShader::kMirror_TileMode" ] # [ doc = "@param tileMode2    tiling on y-axis, one of: SkShader::kClamp_TileMode," ] # [ doc = "SkShader::kRepeat_TileMode, SkShader::kMirror_TileMode" ] # [ doc = "@param localMatrix  SkImage transformation, or nullptr" ] # [ doc = "@return             SkShader containing SkImage" ] # [ link_name = "\u{1}__ZNK7SkImage10makeShaderEN8SkShader8TileModeES1_PK8SkMatrix" ] pub fn SkImage_makeShader ( this : * const SkImage , tileMode1 : SkShader_TileMode , tileMode2 : SkShader_TileMode , localMatrix : * const SkMatrix ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = " Creates SkShader from SkImage. SkShader dimensions are taken from SkImage. SkShader uses" ] # [ doc = "SkShader::kClamp_TileMode to fill drawn area outside SkImage. localMatrix permits" ] # [ doc = "transforming SkImage before SkCanvas matrix is applied." ] # [ doc = "" ] # [ doc = "@param localMatrix  SkImage transformation, or nullptr" ] # [ doc = "@return             SkShader containing SkImage" ] # [ link_name = "\u{1}__ZNK7SkImage10makeShaderEPK8SkMatrix" ] pub fn SkImage_makeShader1 ( this : * const SkImage , localMatrix : * const SkMatrix ) -> sk_sp < SkShader > ; } extern "C" { # [ doc = " Copies SkImage pixel address, row bytes, and SkImageInfo to pixmap, if address" ] # [ doc = "is available, and returns true. If pixel address is not available, return" ] # [ doc = "false and leave pixmap unchanged." ] # [ doc = "" ] # [ doc = "@param pixmap  storage for pixel state if pixels are readable; otherwise, ignored" ] # [ doc = "@return        true if SkImage has direct access to pixels" ] # [ link_name = "\u{1}__ZNK7SkImage10peekPixelsEP8SkPixmap" ] pub fn SkImage_peekPixels ( this : * const SkImage , pixmap : * mut SkPixmap ) -> bool ; } extern "C" { # [ doc = " Deprecated." ] # [ link_name = "\u{1}__ZNK7SkImage10getTextureEv" ] pub fn SkImage_getTexture ( this : * const SkImage ) -> * mut GrTexture ; } extern "C" { # [ doc = " Returns true the contents of SkImage was created on or uploaded to GPU memory," ] # [ doc = "and is available as a GPU texture." ] # [ doc = "" ] # [ doc = "@return  true if SkImage is a GPU texture" ] # [ link_name = "\u{1}__ZNK7SkImage15isTextureBackedEv" ] pub fn SkImage_isTextureBacked ( this : * const SkImage ) -> bool ; } extern "C" { # [ doc = " Returns true if SkImage can be drawn on either raster surface or GPU surface." ] # [ doc = "If context is nullptr, tests if SkImage draws on raster surface;" ] # [ doc = "otherwise, tests if SkImage draws on GPU surface associated with context." ] # [ doc = "" ] # [ doc = "SkImage backed by GPU texture may become invalid if associated GrContext is" ] # [ doc = "invalid. lazy image may be invalid and may not draw to raster surface or" ] # [ doc = "GPU surface or both." ] # [ doc = "" ] # [ doc = "@param context  GPU context" ] # [ doc = "@return         true if SkImage can be drawn" ] # [ link_name = "\u{1}__ZNK7SkImage7isValidEP9GrContext" ] pub fn SkImage_isValid ( this : * const SkImage , context : * mut GrContext ) -> bool ; } extern "C" { # [ doc = " Retrieves the back-end texture. If SkImage has no back-end texture, an invalid" ] # [ doc = "object is returned. Call GrBackendTexture::isValid to determine if the result" ] # [ doc = "is valid." ] # [ doc = "" ] # [ doc = "If flushPendingGrContextIO is true, completes deferred I/O operations." ] # [ doc = "" ] # [ doc = "If origin in not nullptr, copies location of content drawn into SkImage." ] # [ doc = "" ] # [ doc = "@param flushPendingGrContextIO  flag to flush outstanding requests" ] # [ doc = "@param origin                   storage for one of: kTopLeft_GrSurfaceOrigin," ] # [ doc = "kBottomLeft_GrSurfaceOrigin; or nullptr" ] # [ doc = "@return                         back-end API texture handle; invalid on failure" ] # [ link_name = "\u{1}__ZNK7SkImage17getBackendTextureEbP15GrSurfaceOrigin" ] pub fn SkImage_getBackendTexture ( this : * const SkImage , flushPendingGrContextIO : bool , origin : * mut GrSurfaceOrigin ) -> GrBackendTexture ; } extern "C" { # [ doc = " Copies SkRect of pixels from SkImage to dstPixels. Copy starts at offset (srcX, srcY)," ] # [ doc = "and does not exceed SkImage (width(), height())." ] # [ doc = "" ] # [ doc = "dstInfo specifies width, height, SkColorType, SkAlphaType, and SkColorSpace of" ] # [ doc = "destination. dstRowBytes specifics the gap from one destination row to the next." ] # [ doc = "Returns true if pixels are copied. Returns false if:" ] # [ doc = "- dstInfo.addr() equals nullptr" ] # [ doc = "- dstRowBytes is less than dstInfo.minRowBytes()" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkImage SkColorType is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dstInfo.colorType() must match." ] # [ doc = "If SkImage SkColorType is kGray_8_SkColorType, dstInfo.colorSpace() must match." ] # [ doc = "If SkImage SkAlphaType is kOpaque_SkAlphaType, dstInfo.alphaType() must" ] # [ doc = "match. If SkImage SkColorSpace is nullptr, dstInfo.colorSpace() must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "srcX and srcY may be negative to copy only top or left of source. Returns" ] # [ doc = "false if width() or height() is zero or negative." ] # [ doc = "Returns false if abs(srcX) >= Image width(), or if abs(srcY) >= Image height()." ] # [ doc = "" ] # [ doc = "If cachingHint is kAllow_CachingHint, pixels may be retained locally." ] # [ doc = "If cachingHint is kDisallow_CachingHint, pixels are not added to the local cache." ] # [ doc = "" ] # [ doc = "@param dstInfo      destination width, height, SkColorType, SkAlphaType, SkColorSpace" ] # [ doc = "@param dstPixels    destination pixel storage" ] # [ doc = "@param dstRowBytes  destination row length" ] # [ doc = "@param srcX         column index whose absolute value is less than width()" ] # [ doc = "@param srcY         row index whose absolute value is less than height()" ] # [ doc = "@param cachingHint  one of: kAllow_CachingHint, kDisallow_CachingHint" ] # [ doc = "@return             true if pixels are copied to dstPixels" ] # [ link_name = "\u{1}__ZNK7SkImage10readPixelsERK11SkImageInfoPvmiiNS_11CachingHintE" ] pub fn SkImage_readPixels ( this : * const SkImage , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint ) -> bool ; } extern "C" { # [ doc = " Copies a SkRect of pixels from SkImage to dst. Copy starts at (srcX, srcY), and" ] # [ doc = "does not exceed SkImage (width(), height())." ] # [ doc = "" ] # [ doc = "dst specifies width, height, SkColorType, SkAlphaType, SkColorSpace, pixel storage," ] # [ doc = "and row bytes of destination. dst.rowBytes() specifics the gap from one destination" ] # [ doc = "row to the next. Returns true if pixels are copied. Returns false if:" ] # [ doc = "- dst pixel storage equals nullptr" ] # [ doc = "- dst.rowBytes is less than SkImageInfo::minRowBytes" ] # [ doc = "- SkPixelRef is nullptr" ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkImage SkColorType is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dst.colorType() must match." ] # [ doc = "If SkImage SkColorType is kGray_8_SkColorType, dst.colorSpace() must match." ] # [ doc = "If SkImage SkAlphaType is kOpaque_SkAlphaType, dst.alphaType() must" ] # [ doc = "match. If SkImage SkColorSpace is nullptr, dst.colorSpace() must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "srcX and srcY may be negative to copy only top or left of source. Returns" ] # [ doc = "false if width() or height() is zero or negative." ] # [ doc = "Returns false if abs(srcX) >= Image width(), or if abs(srcY) >= Image height()." ] # [ doc = "" ] # [ doc = "If cachingHint is kAllow_CachingHint, pixels may be retained locally." ] # [ doc = "If cachingHint is kDisallow_CachingHint, pixels are not added to the local cache." ] # [ doc = "" ] # [ doc = "@param dst          destination SkPixmap: SkImageInfo, pixels, row bytes" ] # [ doc = "@param srcX         column index whose absolute value is less than width()" ] # [ doc = "@param srcY         row index whose absolute value is less than height()" ] # [ doc = "@param cachingHint  one of: kAllow_CachingHint, kDisallow_CachingHint" ] # [ doc = "@return             true if pixels are copied to dst" ] # [ link_name = "\u{1}__ZNK7SkImage10readPixelsERK8SkPixmapiiNS_11CachingHintE" ] pub fn SkImage_readPixels1 ( this : * const SkImage , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint ) -> bool ; } extern "C" { # [ doc = " Copies SkImage to dst, scaling pixels to fit dst.width() and dst.height(), and" ] # [ doc = "converting pixels to match dst.colorType() and dst.alphaType(). Returns true if" ] # [ doc = "pixels are copied. Returns false if dst.addr() is nullptr, or dst.rowBytes() is" ] # [ doc = "less than dst SkImageInfo::minRowBytes." ] # [ doc = "" ] # [ doc = "Pixels are copied only if pixel conversion is possible. If SkImage SkColorType is" ] # [ doc = "kGray_8_SkColorType, or kAlpha_8_SkColorType; dst.colorType() must match." ] # [ doc = "If SkImage SkColorType is kGray_8_SkColorType, dst.colorSpace() must match." ] # [ doc = "If SkImage SkAlphaType is kOpaque_SkAlphaType, dst.alphaType() must" ] # [ doc = "match. If SkImage SkColorSpace is nullptr, dst.colorSpace() must match. Returns" ] # [ doc = "false if pixel conversion is not possible." ] # [ doc = "" ] # [ doc = "Scales the image, with filterQuality, to match dst.width() and dst.height()." ] # [ doc = "filterQuality kNone_SkFilterQuality is fastest, typically implemented with" ] # [ doc = "nearest neighbor filter. kLow_SkFilterQuality is typically implemented with" ] # [ doc = "bilerp filter. kMedium_SkFilterQuality is typically implemented with" ] # [ doc = "bilerp filter, and mip-map filter when size is reduced." ] # [ doc = "kHigh_SkFilterQuality is slowest, typically implemented with bicubic filter." ] # [ doc = "" ] # [ doc = "If cachingHint is kAllow_CachingHint, pixels may be retained locally." ] # [ doc = "If cachingHint is kDisallow_CachingHint, pixels are not added to the local cache." ] # [ doc = "" ] # [ doc = "@param dst            destination SkPixmap: SkImageInfo, pixels, row bytes" ] # [ doc = "@param filterQuality  one of: kNone_SkFilterQuality, kLow_SkFilterQuality," ] # [ doc = "kMedium_SkFilterQuality, kHigh_SkFilterQuality" ] # [ doc = "@param cachingHint    one of: kAllow_CachingHint, kDisallow_CachingHint" ] # [ doc = "@return               true if pixels are scaled to fit dst" ] # [ link_name = "\u{1}__ZNK7SkImage11scalePixelsERK8SkPixmap15SkFilterQualityNS_11CachingHintE" ] pub fn SkImage_scalePixels ( this : * const SkImage , dst : * const SkPixmap , filterQuality : SkFilterQuality , cachingHint : SkImage_CachingHint ) -> bool ; } extern "C" { # [ doc = " Encodes SkImage pixels, returning result as SkData." ] # [ doc = "" ] # [ doc = "Returns nullptr if encoding fails, or if encodedImageFormat is not supported." ] # [ doc = "" ] # [ doc = "SkImage encoding in a format requires both building with one or more of:" ] # [ doc = "SK_HAS_JPEG_LIBRARY, SK_HAS_PNG_LIBRARY, SK_HAS_WEBP_LIBRARY; and platform support" ] # [ doc = "for the encoded format." ] # [ doc = "" ] # [ doc = "If SK_BUILD_FOR_MAC or SK_BUILD_FOR_IOS is defined, encodedImageFormat can" ] # [ doc = "additionally be one of: SkEncodedImageFormat::kICO, SkEncodedImageFormat::kBMP," ] # [ doc = "SkEncodedImageFormat::kGIF." ] # [ doc = "" ] # [ doc = "quality is a platform and format specific metric trading off size and encoding" ] # [ doc = "error. When used, quality equaling 100 encodes with the least error. quality may" ] # [ doc = "be ignored by the encoder." ] # [ doc = "" ] # [ doc = "@param encodedImageFormat  one of: SkEncodedImageFormat::kJPEG, SkEncodedImageFormat::kPNG," ] # [ doc = "SkEncodedImageFormat::kWEBP" ] # [ doc = "@param quality             encoder specific metric with 100 equaling best" ] # [ doc = "@return                    encoded SkImage, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage12encodeToDataE20SkEncodedImageFormati" ] pub fn SkImage_encodeToData ( this : * const SkImage , encodedImageFormat : SkEncodedImageFormat , quality : :: std :: os :: raw :: c_int ) -> sk_sp < SkData > ; } extern "C" { # [ doc = " Encodes SkImage pixels, returning result as SkData. Returns existing encoded data" ] # [ doc = "if present; otherwise, SkImage is encoded with SkEncodedImageFormat::kPNG. Skia" ] # [ doc = "must be built with SK_HAS_PNG_LIBRARY to encode SkImage." ] # [ doc = "" ] # [ doc = "Returns nullptr if existing encoded data is missing or invalid, and" ] # [ doc = "encoding fails." ] # [ doc = "" ] # [ doc = "@return  encoded SkImage, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage12encodeToDataEv" ] pub fn SkImage_encodeToData1 ( this : * const SkImage ) -> sk_sp < SkData > ; } extern "C" { # [ doc = " Returns encoded SkImage pixels as SkData, if SkImage was created from supported" ] # [ doc = "encoded stream format. Platform support for formats vary and may require building" ] # [ doc = "with one or more of: SK_HAS_JPEG_LIBRARY, SK_HAS_PNG_LIBRARY, SK_HAS_WEBP_LIBRARY." ] # [ doc = "" ] # [ doc = "Returns nullptr if SkImage contents are not encoded." ] # [ doc = "" ] # [ doc = "@return  encoded SkImage, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage14refEncodedDataEv" ] pub fn SkImage_refEncodedData ( this : * const SkImage ) -> sk_sp < SkData > ; } extern "C" { # [ doc = " Returns subset of SkImage. subset must be fully contained by SkImage dimensions()." ] # [ doc = "The implementation may share pixels, or may copy them." ] # [ doc = "" ] # [ doc = "Returns nullptr if subset is empty, or subset is not contained by bounds, or" ] # [ doc = "pixels in SkImage could not be read or copied." ] # [ doc = "" ] # [ doc = "@param subset  bounds of returned SkImage" ] # [ doc = "@return        partial or full SkImage, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage10makeSubsetERK7SkIRect" ] pub fn SkImage_makeSubset ( this : * const SkImage , subset : * const SkIRect ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Returns SkImage backed by GPU texture associated with context. Returned SkImage is" ] # [ doc = "compatible with SkSurface created with dstColorSpace. The returned SkImage respects" ] # [ doc = "mipMapped setting; if mipMapped equals GrMipMapped::kYes, the backing texture" ] # [ doc = "allocates mip map levels. Returns original SkImage if context" ] # [ doc = "and dstColorSpace match and mipMapped is compatible with backing GPU texture." ] # [ doc = "" ] # [ doc = "Returns nullptr if context is nullptr, or if SkImage was created with another" ] # [ doc = "GrContext." ] # [ doc = "" ] # [ doc = "@param context        GPU context" ] # [ doc = "@param dstColorSpace  range of colors of matching SkSurface on GPU" ] # [ doc = "@param mipMapped      whether created SkImage texture must allocate mip map levels" ] # [ doc = "@return               created SkImage, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage16makeTextureImageEP9GrContextP12SkColorSpace11GrMipMapped" ] pub fn SkImage_makeTextureImage ( this : * const SkImage , context : * mut GrContext , dstColorSpace : * mut SkColorSpace , mipMapped : GrMipMapped ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Returns raster image or lazy image. Copies SkImage backed by GPU texture into" ] # [ doc = "CPU memory if needed. Returns original SkImage if decoded in raster bitmap," ] # [ doc = "or if encoded in a stream." ] # [ doc = "" ] # [ doc = "Returns nullptr if backed by GPU texture and copy fails." ] # [ doc = "" ] # [ doc = "@return  raster image, lazy image, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage19makeNonTextureImageEv" ] pub fn SkImage_makeNonTextureImage ( this : * const SkImage ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Returns raster image. Copies SkImage backed by GPU texture into CPU memory," ] # [ doc = "or decodes SkImage from lazy image. Returns original SkImage if decoded in" ] # [ doc = "raster bitmap." ] # [ doc = "" ] # [ doc = "Returns nullptr if copy, decode, or pixel read fails." ] # [ doc = "" ] # [ doc = "@return  raster image, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage15makeRasterImageEv" ] pub fn SkImage_makeRasterImage ( this : * const SkImage ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates filtered SkImage. filter processes original SkImage, potentially changing" ] # [ doc = "color, position, and size. subset is the bounds of original SkImage processed" ] # [ doc = "by filter. clipBounds is the expected bounds of the filtered SkImage. outSubset" ] # [ doc = "is required storage for the actual bounds of the filtered SkImage. offset is" ] # [ doc = "required storage for translation of returned SkImage." ] # [ doc = "" ] # [ doc = "Returns nullptr if SkImage could not be created. If nullptr is returned, outSubset" ] # [ doc = "and offset are undefined." ] # [ doc = "" ] # [ doc = "Useful for animation of SkImageFilter that varies size from frame to frame." ] # [ doc = "Returned SkImage is created larger than required by filter so that GPU texture" ] # [ doc = "can be reused with different sized effects. outSubset describes the valid bounds" ] # [ doc = "of GPU texture returned. offset translates the returned SkImage to keep subsequent" ] # [ doc = "animation frames aligned with respect to each other." ] # [ doc = "" ] # [ doc = "@param context     the GrContext in play - if it exists" ] # [ doc = "@param filter      how SkImage is sampled when transformed" ] # [ doc = "@param subset      bounds of SkImage processed by filter" ] # [ doc = "@param clipBounds  expected bounds of filtered SkImage" ] # [ doc = "@param outSubset   storage for returned SkImage bounds" ] # [ doc = "@param offset      storage for returned SkImage translation" ] # [ doc = "@return            filtered SkImage, or nullptr" ] # [ link_name = "\u{1}__ZNK7SkImage14makeWithFilterEP9GrContextPK13SkImageFilterRK7SkIRectS7_PS5_P8SkIPoint" ] pub fn SkImage_makeWithFilter ( this : * const SkImage , context : * mut GrContext , filter : * const SkImageFilter , subset : * const SkIRect , clipBounds : * const SkIRect , outSubset : * mut SkIRect , offset : * mut SkIPoint ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " To be deprecated." ] # [ link_name = "\u{1}__ZNK7SkImage14makeWithFilterEPK13SkImageFilterRK7SkIRectS5_PS3_P8SkIPoint" ] pub fn SkImage_makeWithFilter1 ( this : * const SkImage , filter : * const SkImageFilter , subset : * const SkIRect , clipBounds : * const SkIRect , outSubset : * mut SkIRect , offset : * mut SkIPoint ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Creates a GrBackendTexture from the provided SkImage. Returns true and" ] # [ doc = "stores result in backendTexture and backendTextureReleaseProc if" ] # [ doc = "texture is created; otherwise, returns false and leaves" ] # [ doc = "backendTexture and backendTextureReleaseProc unmodified." ] # [ doc = "" ] # [ doc = "Call backendTextureReleaseProc after deleting backendTexture." ] # [ doc = "backendTextureReleaseProc cleans up auxiliary data related to returned" ] # [ doc = "backendTexture. The caller must delete returned backendTexture after use." ] # [ doc = "" ] # [ doc = "If SkImage is both texture backed and singly referenced, image is returned in" ] # [ doc = "backendTexture without conversion or making a copy. SkImage is singly referenced" ] # [ doc = "if its was transferred solely using std::move()." ] # [ doc = "" ] # [ doc = "If SkImage is not texture backed, returns texture with SkImage contents." ] # [ doc = "" ] # [ doc = "@param context                    GPU context" ] # [ doc = "@param image                      SkImage used for texture" ] # [ doc = "@param backendTexture             storage for back-end texture" ] # [ doc = "@param backendTextureReleaseProc  storage for clean up function" ] # [ doc = "@return                           true if back-end texture was created" ] # [ link_name = "\u{1}__ZN7SkImage29MakeBackendTextureFromSkImageEP9GrContext5sk_spIS_EP16GrBackendTexturePNSt3__18functionIFvS4_EEE" ] pub fn SkImage_MakeBackendTextureFromSkImage ( context : * mut GrContext , image : sk_sp < SkImage > , backendTexture : * mut GrBackendTexture , backendTextureReleaseProc : * mut SkImage_BackendTextureReleaseProc ) -> bool ; } extern "C" { # [ doc = " Deprecated." ] # [ doc = "Creates raster SkBitmap with same pixels as SkImage. If legacyBitmapMode is" ] # [ doc = "kRO_LegacyBitmapMode, returned bitmap is read-only and immutable." ] # [ doc = "Returns true if SkBitmap is stored in bitmap. Returns false and resets bitmap if" ] # [ doc = "SkBitmap write did not succeed." ] # [ doc = "" ] # [ doc = "@param bitmap            storage for legacy SkBitmap" ] # [ doc = "@param legacyBitmapMode  bitmap is read-only and immutable" ] # [ doc = "@return                  true if SkBitmap was created" ] # [ link_name = "\u{1}__ZNK7SkImage14asLegacyBitmapEP8SkBitmapNS_16LegacyBitmapModeE" ] pub fn SkImage_asLegacyBitmap ( this : * const SkImage , bitmap : * mut SkBitmap , legacyBitmapMode : SkImage_LegacyBitmapMode ) -> bool ; } extern "C" { # [ doc = " Returns true if SkImage is backed by an image-generator or other service that creates" ] # [ doc = "and caches its pixels or texture on-demand." ] # [ doc = "" ] # [ doc = "@return  true if SkImage is created as needed" ] # [ link_name = "\u{1}__ZNK7SkImage15isLazyGeneratedEv" ] pub fn SkImage_isLazyGenerated ( this : * const SkImage ) -> bool ; } extern "C" { # [ doc = " Creates SkImage in target SkColorSpace." ] # [ doc = "Returns nullptr if SkImage could not be created." ] # [ doc = "" ] # [ doc = "Returns original SkImage if it is in target SkColorSpace." ] # [ doc = "Otherwise, converts pixels from SkImage SkColorSpace to target SkColorSpace." ] # [ doc = "If SkImage colorSpace() returns nullptr, SkImage SkColorSpace is assumed to be sRGB." ] # [ doc = "" ] # [ doc = "@param target  SkColorSpace describing color range of returned SkImage" ] # [ doc = "@return        created SkImage in target SkColorSpace" ] # [ link_name = "\u{1}__ZNK7SkImage14makeColorSpaceE5sk_spI12SkColorSpaceE" ] pub fn SkImage_makeColorSpace ( this : * const SkImage , target : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Experimental." ] # [ doc = "Creates SkImage in target SkColorType and SkColorSpace." ] # [ doc = "Returns nullptr if SkImage could not be created." ] # [ doc = "" ] # [ doc = "Returns original SkImage if it is in target SkColorType and SkColorSpace." ] # [ doc = "" ] # [ doc = "@param targetColorType  SkColorType of returned SkImage" ] # [ doc = "@param targetColorSpace SkColorSpace of returned SkImage" ] # [ doc = "@return                 created SkImage in target SkColorType and SkColorSpace" ] # [ link_name = "\u{1}__ZNK7SkImage26makeColorTypeAndColorSpaceE11SkColorType5sk_spI12SkColorSpaceE" ] pub fn SkImage_makeColorTypeAndColorSpace ( this : * const SkImage , targetColorType : SkColorType , targetColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > ; } impl SkImage { # [ inline ] pub unsafe fn MakeRasterCopy ( pixmap : * const SkPixmap ) -> sk_sp < SkImage > { SkImage_MakeRasterCopy ( pixmap ) } # [ inline ] pub unsafe fn MakeRasterData ( info : * const SkImageInfo , pixels : sk_sp < SkData > , rowBytes : usize ) -> sk_sp < SkImage > { SkImage_MakeRasterData ( info , pixels , rowBytes ) } # [ inline ] pub unsafe fn MakeFromRaster ( pixmap : * const SkPixmap , rasterReleaseProc : SkImage_RasterReleaseProc , releaseContext : SkImage_ReleaseContext ) -> sk_sp < SkImage > { SkImage_MakeFromRaster ( pixmap , rasterReleaseProc , releaseContext ) } # [ inline ] pub unsafe fn MakeFromBitmap ( bitmap : * const SkBitmap ) -> sk_sp < SkImage > { SkImage_MakeFromBitmap ( bitmap ) } # [ inline ] pub unsafe fn MakeFromGenerator ( imageGenerator : std_unique_ptr , subset : * const SkIRect ) -> sk_sp < SkImage > { SkImage_MakeFromGenerator ( imageGenerator , subset ) } # [ inline ] pub unsafe fn MakeFromEncoded ( encoded : sk_sp < SkData > , subset : * const SkIRect ) -> sk_sp < SkImage > { SkImage_MakeFromEncoded ( encoded , subset ) } # [ inline ] pub unsafe fn MakeFromCompressed ( context : * mut GrContext , data : sk_sp < SkData > , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , type_ : SkImage_CompressionType ) -> sk_sp < SkImage > { SkImage_MakeFromCompressed ( context , data , width , height , type_ ) } # [ inline ] pub unsafe fn MakeFromTexture ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromTexture ( context , backendTexture , origin , colorType , alphaType , colorSpace ) } # [ inline ] pub unsafe fn MakeFromTexture1 ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureReleaseProc : SkImage_TextureReleaseProc , releaseContext : SkImage_ReleaseContext ) -> sk_sp < SkImage > { SkImage_MakeFromTexture1 ( context , backendTexture , origin , colorType , alphaType , colorSpace , textureReleaseProc , releaseContext ) } # [ inline ] pub unsafe fn MakeCrossContextFromEncoded ( context : * mut GrContext , data : sk_sp < SkData > , buildMips : bool , dstColorSpace : * mut SkColorSpace , limitToMaxTextureSize : bool ) -> sk_sp < SkImage > { SkImage_MakeCrossContextFromEncoded ( context , data , buildMips , dstColorSpace , limitToMaxTextureSize ) } # [ inline ] pub unsafe fn MakeCrossContextFromPixmap ( context : * mut GrContext , pixmap : * const SkPixmap , buildMips : bool , dstColorSpace : * mut SkColorSpace , limitToMaxTextureSize : bool ) -> sk_sp < SkImage > { SkImage_MakeCrossContextFromPixmap ( context , pixmap , buildMips , dstColorSpace , limitToMaxTextureSize ) } # [ inline ] pub unsafe fn MakeFromAdoptedTexture ( context : * mut GrContext , backendTexture : * const GrBackendTexture , surfaceOrigin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromAdoptedTexture ( context , backendTexture , surfaceOrigin , colorType , alphaType , colorSpace ) } # [ inline ] pub unsafe fn MakeFromYUVATexturesCopy ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromYUVATexturesCopy ( context , yuvColorSpace , yuvaTextures , yuvaIndices , imageSize , imageOrigin , imageColorSpace ) } # [ inline ] pub unsafe fn MakeFromYUVATexturesCopyWithExternalBackend ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , backendTexture : * const GrBackendTexture , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromYUVATexturesCopyWithExternalBackend ( context , yuvColorSpace , yuvaTextures , yuvaIndices , imageSize , imageOrigin , backendTexture , imageColorSpace ) } # [ inline ] pub unsafe fn MakeFromYUVATextures ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromYUVATextures ( context , yuvColorSpace , yuvaTextures , yuvaIndices , imageSize , imageOrigin , imageColorSpace ) } # [ inline ] pub unsafe fn MakeFromYUVAPixmaps ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaPixmaps : * const SkPixmap , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , buildMips : bool , limitToMaxTextureSize : bool , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromYUVAPixmaps ( context , yuvColorSpace , yuvaPixmaps , yuvaIndices , imageSize , imageOrigin , buildMips , limitToMaxTextureSize , imageColorSpace ) } # [ inline ] pub unsafe fn MakeFromYUVTexturesCopy ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvTextures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromYUVTexturesCopy ( context , yuvColorSpace , yuvTextures , imageOrigin , imageColorSpace ) } # [ inline ] pub unsafe fn MakeFromYUVTexturesCopyWithExternalBackend ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvTextures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , backendTexture : * const GrBackendTexture , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromYUVTexturesCopyWithExternalBackend ( context , yuvColorSpace , yuvTextures , imageOrigin , backendTexture , imageColorSpace ) } # [ inline ] pub unsafe fn MakeFromNV12TexturesCopy ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , nv12Textures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromNV12TexturesCopy ( context , yuvColorSpace , nv12Textures , imageOrigin , imageColorSpace ) } # [ inline ] pub unsafe fn MakeFromNV12TexturesCopyWithExternalBackend ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , nv12Textures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , backendTexture : * const GrBackendTexture , imageColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromNV12TexturesCopyWithExternalBackend ( context , yuvColorSpace , nv12Textures , imageOrigin , backendTexture , imageColorSpace ) } # [ inline ] pub unsafe fn MakeFromPicture ( picture : sk_sp < SkPicture > , dimensions : * const SkISize , matrix : * const SkMatrix , paint : * const SkPaint , bitDepth : SkImage_BitDepth , colorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_MakeFromPicture ( picture , dimensions , matrix , paint , bitDepth , colorSpace ) } # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { SkImage_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { SkImage_height ( self ) } # [ inline ] pub unsafe fn dimensions ( & self ) -> SkISize { SkImage_dimensions ( self ) } # [ inline ] pub unsafe fn bounds ( & self ) -> SkIRect { SkImage_bounds ( self ) } # [ inline ] pub unsafe fn uniqueID ( & self ) -> u32 { SkImage_uniqueID ( self ) } # [ inline ] pub unsafe fn alphaType ( & self ) -> SkAlphaType { SkImage_alphaType ( self ) } # [ inline ] pub unsafe fn colorType ( & self ) -> SkColorType { SkImage_colorType ( self ) } # [ inline ] pub unsafe fn colorSpace ( & self ) -> * mut SkColorSpace { SkImage_colorSpace ( self ) } # [ inline ] pub unsafe fn refColorSpace ( & self ) -> sk_sp < SkColorSpace > { SkImage_refColorSpace ( self ) } # [ inline ] pub unsafe fn isAlphaOnly ( & self ) -> bool { SkImage_isAlphaOnly ( self ) } # [ inline ] pub unsafe fn isOpaque ( & self ) -> bool { SkImage_isOpaque ( self ) } # [ inline ] pub unsafe fn makeShader ( & self , tileMode1 : SkShader_TileMode , tileMode2 : SkShader_TileMode , localMatrix : * const SkMatrix ) -> sk_sp < SkShader > { SkImage_makeShader ( self , tileMode1 , tileMode2 , localMatrix ) } # [ inline ] pub unsafe fn makeShader1 ( & self , localMatrix : * const SkMatrix ) -> sk_sp < SkShader > { SkImage_makeShader1 ( self , localMatrix ) } # [ inline ] pub unsafe fn peekPixels ( & self , pixmap : * mut SkPixmap ) -> bool { SkImage_peekPixels ( self , pixmap ) } # [ inline ] pub unsafe fn getTexture ( & self ) -> * mut GrTexture { SkImage_getTexture ( self ) } # [ inline ] pub unsafe fn isTextureBacked ( & self ) -> bool { SkImage_isTextureBacked ( self ) } # [ inline ] pub unsafe fn isValid ( & self , context : * mut GrContext ) -> bool { SkImage_isValid ( self , context ) } # [ inline ] pub unsafe fn getBackendTexture ( & self , flushPendingGrContextIO : bool , origin : * mut GrSurfaceOrigin ) -> GrBackendTexture { SkImage_getBackendTexture ( self , flushPendingGrContextIO , origin ) } # [ inline ] pub unsafe fn readPixels ( & self , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint ) -> bool { SkImage_readPixels ( self , dstInfo , dstPixels , dstRowBytes , srcX , srcY , cachingHint ) } # [ inline ] pub unsafe fn readPixels1 ( & self , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint ) -> bool { SkImage_readPixels1 ( self , dst , srcX , srcY , cachingHint ) } # [ inline ] pub unsafe fn scalePixels ( & self , dst : * const SkPixmap , filterQuality : SkFilterQuality , cachingHint : SkImage_CachingHint ) -> bool { SkImage_scalePixels ( self , dst , filterQuality , cachingHint ) } # [ inline ] pub unsafe fn encodeToData ( & self , encodedImageFormat : SkEncodedImageFormat , quality : :: std :: os :: raw :: c_int ) -> sk_sp < SkData > { SkImage_encodeToData ( self , encodedImageFormat , quality ) } # [ inline ] pub unsafe fn encodeToData1 ( & self ) -> sk_sp < SkData > { SkImage_encodeToData1 ( self ) } # [ inline ] pub unsafe fn refEncodedData ( & self ) -> sk_sp < SkData > { SkImage_refEncodedData ( self ) } # [ inline ] pub unsafe fn makeSubset ( & self , subset : * const SkIRect ) -> sk_sp < SkImage > { SkImage_makeSubset ( self , subset ) } # [ inline ] pub unsafe fn makeTextureImage ( & self , context : * mut GrContext , dstColorSpace : * mut SkColorSpace , mipMapped : GrMipMapped ) -> sk_sp < SkImage > { SkImage_makeTextureImage ( self , context , dstColorSpace , mipMapped ) } # [ inline ] pub unsafe fn makeNonTextureImage ( & self ) -> sk_sp < SkImage > { SkImage_makeNonTextureImage ( self ) } # [ inline ] pub unsafe fn makeRasterImage ( & self ) -> sk_sp < SkImage > { SkImage_makeRasterImage ( self ) } # [ inline ] pub unsafe fn makeWithFilter ( & self , context : * mut GrContext , filter : * const SkImageFilter , subset : * const SkIRect , clipBounds : * const SkIRect , outSubset : * mut SkIRect , offset : * mut SkIPoint ) -> sk_sp < SkImage > { SkImage_makeWithFilter ( self , context , filter , subset , clipBounds , outSubset , offset ) } # [ inline ] pub unsafe fn makeWithFilter1 ( & self , filter : * const SkImageFilter , subset : * const SkIRect , clipBounds : * const SkIRect , outSubset : * mut SkIRect , offset : * mut SkIPoint ) -> sk_sp < SkImage > { SkImage_makeWithFilter1 ( self , filter , subset , clipBounds , outSubset , offset ) } # [ inline ] pub unsafe fn MakeBackendTextureFromSkImage ( context : * mut GrContext , image : sk_sp < SkImage > , backendTexture : * mut GrBackendTexture , backendTextureReleaseProc : * mut SkImage_BackendTextureReleaseProc ) -> bool { SkImage_MakeBackendTextureFromSkImage ( context , image , backendTexture , backendTextureReleaseProc ) } # [ inline ] pub unsafe fn asLegacyBitmap ( & self , bitmap : * mut SkBitmap , legacyBitmapMode : SkImage_LegacyBitmapMode ) -> bool { SkImage_asLegacyBitmap ( self , bitmap , legacyBitmapMode ) } # [ inline ] pub unsafe fn isLazyGenerated ( & self ) -> bool { SkImage_isLazyGenerated ( self ) } # [ inline ] pub unsafe fn makeColorSpace ( & self , target : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_makeColorSpace ( self , target ) } # [ inline ] pub unsafe fn makeColorTypeAndColorSpace ( & self , targetColorType : SkColorType , targetColorSpace : sk_sp < SkColorSpace > ) -> sk_sp < SkImage > { SkImage_makeColorTypeAndColorSpace ( self , targetColorType , targetColorSpace ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDeferredDisplayList { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkSurfaceCharacterization { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrBackendSemaphore { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrRenderTarget { _unused : [ u8 ; 0 ] , } # [ doc = " \\class SkSurface" ] # [ doc = "SkSurface is responsible for managing the pixels that a canvas draws into. The pixels can be" ] # [ doc = "allocated either in CPU memory (a raster surface) or on the GPU (a GrRenderTarget surface)." ] # [ doc = "SkSurface takes care of allocating a SkCanvas that will draw into the surface. Call" ] # [ doc = "surface->getCanvas() to use that canvas (but don\'t delete it, it is owned by the surface)." ] # [ doc = "SkSurface always has non-zero dimensions. If there is a request for a new surface, and either" ] # [ doc = "of the requested dimensions are zero, then nullptr will be returned." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkSurface { pub _base : SkRefCnt , pub fProps : SkSurfaceProps , pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fGenerationID : u32 , } # [ doc = " Caller data passed to RenderTarget/TextureReleaseProc; may be nullptr." ] pub type SkSurface_ReleaseContext = * mut :: std :: os :: raw :: c_void ; # [ doc = " User function called when supplied render target may be deleted." ] pub type SkSurface_RenderTargetReleaseProc = :: core :: option :: Option < unsafe extern "C" fn ( releaseContext : SkSurface_ReleaseContext ) > ; # [ doc = " User function called when supplied texture may be deleted." ] pub type SkSurface_TextureReleaseProc = :: core :: option :: Option < unsafe extern "C" fn ( releaseContext : SkSurface_ReleaseContext ) > ; # [ doc = "!< discards surface on change" ] pub const SkSurface_ContentChangeMode_kDiscard_ContentChangeMode : SkSurface_ContentChangeMode = 0 ; # [ doc = "!< preserves surface on change" ] pub const SkSurface_ContentChangeMode_kRetain_ContentChangeMode : SkSurface_ContentChangeMode = 1 ; # [ doc = " \\enum SkSurface::ContentChangeMode" ] # [ doc = "ContentChangeMode members are parameters to notifyContentWillChange()." ] pub type SkSurface_ContentChangeMode = u32 ; # [ doc = "!< back-end object is readable" ] pub const SkSurface_BackendHandleAccess_kFlushRead_BackendHandleAccess : SkSurface_BackendHandleAccess = 0 ; # [ doc = "!< back-end object is writable" ] pub const SkSurface_BackendHandleAccess_kFlushWrite_BackendHandleAccess : SkSurface_BackendHandleAccess = 1 ; # [ doc = "!< back-end object must be overwritten" ] pub const SkSurface_BackendHandleAccess_kDiscardWrite_BackendHandleAccess : SkSurface_BackendHandleAccess = 2 ; pub type SkSurface_BackendHandleAccess = u32 ; # [ doc = "!< back-end object will not be used by client" ] pub const SkSurface_BackendSurfaceAccess_kNoAccess : SkSurface_BackendSurfaceAccess = 0 ; # [ doc = "!< back-end surface will be used for presenting to screen" ] pub const SkSurface_BackendSurfaceAccess_kPresent : SkSurface_BackendSurfaceAccess = 1 ; pub type SkSurface_BackendSurfaceAccess = i32 ; pub const SkSurface_FlushFlags_kNone_FlushFlags : SkSurface_FlushFlags = 0 ; pub const SkSurface_FlushFlags_kSyncCpu_FlushFlag : SkSurface_FlushFlags = 1 ; pub type SkSurface_FlushFlags = u32 ; pub type SkSurface_INHERITED = SkRefCnt ; extern "C" { # [ link_name = "\u{1}__ZN9SkSurface30kFlushRead_TextureHandleAccessE" ] pub static SkSurface_kFlushRead_TextureHandleAccess : SkSurface_BackendHandleAccess ; } extern "C" { # [ link_name = "\u{1}__ZN9SkSurface31kFlushWrite_TextureHandleAccessE" ] pub static SkSurface_kFlushWrite_TextureHandleAccess : SkSurface_BackendHandleAccess ; } extern "C" { # [ link_name = "\u{1}__ZN9SkSurface33kDiscardWrite_TextureHandleAccessE" ] pub static SkSurface_kDiscardWrite_TextureHandleAccess : SkSurface_BackendHandleAccess ; } # [ test ] fn bindgen_test_layout_SkSurface ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkSurface > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SkSurface ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkSurface > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkSurface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkSurface > ( ) ) ) . fProps as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkSurface ) , "::" , stringify ! ( fProps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkSurface > ( ) ) ) . fWidth as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SkSurface ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkSurface > ( ) ) ) . fHeight as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkSurface ) , "::" , stringify ! ( fHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkSurface > ( ) ) ) . fGenerationID as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SkSurface ) , "::" , stringify ! ( fGenerationID ) ) ) ; } extern "C" { # [ doc = " Allocates raster SkSurface. SkCanvas returned by SkSurface draws directly into pixels." ] # [ doc = "" ] # [ doc = "SkSurface is returned if all parameters are valid." ] # [ doc = "Valid parameters include:" ] # [ doc = "info dimensions are greater than zero;" ] # [ doc = "info contains SkColorType and SkAlphaType supported by raster surface;" ] # [ doc = "pixels is not nullptr;" ] # [ doc = "rowBytes is large enough to contain info width pixels of SkColorType." ] # [ doc = "" ] # [ doc = "Pixel buffer size should be info height times computed rowBytes." ] # [ doc = "Pixels are not initialized." ] # [ doc = "To access pixels after drawing, call flush() or peekPixels()." ] # [ doc = "" ] # [ doc = "@param imageInfo     width, height, SkColorType, SkAlphaType, SkColorSpace," ] # [ doc = "of raster surface; width and height must be greater than zero" ] # [ doc = "@param pixels        pointer to destination pixels buffer" ] # [ doc = "@param rowBytes      interval from one SkSurface row to the next" ] # [ doc = "@param surfaceProps  LCD striping orientation and setting for device independent fonts;" ] # [ doc = "may be nullptr" ] # [ doc = "@return              SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface16MakeRasterDirectERK11SkImageInfoPvmPK14SkSurfaceProps" ] pub fn SkSurface_MakeRasterDirect ( imageInfo : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Allocates raster SkSurface. SkCanvas returned by SkSurface draws directly into pixels." ] # [ doc = "releaseProc is called with pixels and context when SkSurface is deleted." ] # [ doc = "" ] # [ doc = "SkSurface is returned if all parameters are valid." ] # [ doc = "Valid parameters include:" ] # [ doc = "info dimensions are greater than zero;" ] # [ doc = "info contains SkColorType and SkAlphaType supported by raster surface;" ] # [ doc = "pixels is not nullptr;" ] # [ doc = "rowBytes is large enough to contain info width pixels of SkColorType." ] # [ doc = "" ] # [ doc = "Pixel buffer size should be info height times computed rowBytes." ] # [ doc = "Pixels are not initialized." ] # [ doc = "To access pixels after drawing, call flush() or peekPixels()." ] # [ doc = "" ] # [ doc = "@param imageInfo     width, height, SkColorType, SkAlphaType, SkColorSpace," ] # [ doc = "of raster surface; width and height must be greater than zero" ] # [ doc = "@param pixels        pointer to destination pixels buffer" ] # [ doc = "@param rowBytes      interval from one SkSurface row to the next" ] # [ doc = "@param releaseProc   called when SkSurface is deleted; may be nullptr" ] # [ doc = "@param context       passed to releaseProc; may be nullptr" ] # [ doc = "@param surfaceProps  LCD striping orientation and setting for device independent fonts;" ] # [ doc = "may be nullptr" ] # [ doc = "@return              SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface27MakeRasterDirectReleaseProcERK11SkImageInfoPvmPFvS3_S3_ES3_PK14SkSurfaceProps" ] pub fn SkSurface_MakeRasterDirectReleaseProc ( imageInfo : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize , releaseProc : :: core :: option :: Option < unsafe extern "C" fn ( imageInfo : * mut :: std :: os :: raw :: c_void , pixels : * mut :: std :: os :: raw :: c_void ) > , context : * mut :: std :: os :: raw :: c_void , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Allocates raster SkSurface. SkCanvas returned by SkSurface draws directly into pixels." ] # [ doc = "Allocates and zeroes pixel memory. Pixel memory size is imageInfo.height() times" ] # [ doc = "rowBytes, or times imageInfo.minRowBytes() if rowBytes is zero." ] # [ doc = "Pixel memory is deleted when SkSurface is deleted." ] # [ doc = "" ] # [ doc = "SkSurface is returned if all parameters are valid." ] # [ doc = "Valid parameters include:" ] # [ doc = "info dimensions are greater than zero;" ] # [ doc = "info contains SkColorType and SkAlphaType supported by raster surface;" ] # [ doc = "rowBytes is large enough to contain info width pixels of SkColorType, or is zero." ] # [ doc = "" ] # [ doc = "If rowBytes is not zero, subsequent images returned by makeImageSnapshot()" ] # [ doc = "have the same rowBytes." ] # [ doc = "" ] # [ doc = "@param imageInfo     width, height, SkColorType, SkAlphaType, SkColorSpace," ] # [ doc = "of raster surface; width and height must be greater than zero" ] # [ doc = "@param rowBytes      interval from one SkSurface row to the next; may be zero" ] # [ doc = "@param surfaceProps  LCD striping orientation and setting for device independent fonts;" ] # [ doc = "may be nullptr" ] # [ doc = "@return              SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface10MakeRasterERK11SkImageInfomPK14SkSurfaceProps" ] pub fn SkSurface_MakeRaster ( imageInfo : * const SkImageInfo , rowBytes : usize , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Allocates raster SkSurface. SkCanvas returned by SkSurface draws directly into pixels." ] # [ doc = "Allocates and zeroes pixel memory. Pixel memory size is imageInfo.height() times" ] # [ doc = "imageInfo.minRowBytes()." ] # [ doc = "Pixel memory is deleted when SkSurface is deleted." ] # [ doc = "" ] # [ doc = "SkSurface is returned if all parameters are valid." ] # [ doc = "Valid parameters include:" ] # [ doc = "info dimensions are greater than zero;" ] # [ doc = "info contains SkColorType and SkAlphaType supported by raster surface." ] # [ doc = "" ] # [ doc = "@param imageInfo  width, height, SkColorType, SkAlphaType, SkColorSpace," ] # [ doc = "of raster surface; width and height must be greater than zero" ] # [ doc = "@param props      LCD striping orientation and setting for device independent fonts;" ] # [ doc = "may be nullptr" ] # [ doc = "@return           SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface10MakeRasterERK11SkImageInfoPK14SkSurfaceProps" ] pub fn SkSurface_MakeRaster1 ( imageInfo : * const SkImageInfo , props : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Allocates raster SkSurface. SkCanvas returned by SkSurface draws directly into pixels." ] # [ doc = "Allocates and zeroes pixel memory. Pixel memory size is height times width times" ] # [ doc = "four. Pixel memory is deleted when SkSurface is deleted." ] # [ doc = "" ] # [ doc = "Internally, sets SkImageInfo to width, height, native color type, and" ] # [ doc = "kPremul_SkAlphaType." ] # [ doc = "" ] # [ doc = "SkSurface is returned if width and height are greater than zero." ] # [ doc = "" ] # [ doc = "Use to create SkSurface that matches SkPMColor, the native pixel arrangement on" ] # [ doc = "the platform. SkSurface drawn to output device skips converting its pixel format." ] # [ doc = "" ] # [ doc = "@param width         pixel column count; must be greater than zero" ] # [ doc = "@param height        pixel row count; must be greater than zero" ] # [ doc = "@param surfaceProps  LCD striping orientation and setting for device independent" ] # [ doc = "fonts; may be nullptr" ] # [ doc = "@return              SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface19MakeRasterN32PremulEiiPK14SkSurfaceProps" ] pub fn SkSurface_MakeRasterN32Premul ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Wraps a GPU-backed texture into SkSurface. Caller must ensure the texture is" ] # [ doc = "valid for the lifetime of returned SkSurface. If sampleCnt greater than zero," ] # [ doc = "creates an intermediate MSAA SkSurface which is used for drawing backendTexture." ] # [ doc = "" ] # [ doc = "SkSurface is returned if all parameters are valid. backendTexture is valid if" ] # [ doc = "its pixel configuration agrees with colorSpace and context; for instance, if" ] # [ doc = "backendTexture has an sRGB configuration, then context must support sRGB," ] # [ doc = "and colorSpace must be present. Further, backendTexture width and height must" ] # [ doc = "not exceed context capabilities, and the context must be able to support" ] # [ doc = "back-end textures." ] # [ doc = "" ] # [ doc = "If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr." ] # [ doc = "" ] # [ doc = "@param context             GPU context" ] # [ doc = "@param backendTexture      texture residing on GPU" ] # [ doc = "@param origin              one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param sampleCnt           samples per pixel, or 0 to disable full scene anti-aliasing" ] # [ doc = "@param colorType           one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType," ] # [ doc = "kRGB_888x_SkColorType, kBGRA_8888_SkColorType," ] # [ doc = "kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@param colorSpace          range of colors; may be nullptr" ] # [ doc = "@param surfaceProps        LCD striping orientation and setting for device independent" ] # [ doc = "fonts; may be nullptr" ] # [ doc = "@param textureReleaseProc  function called when texture can be released" ] # [ doc = "@param releaseContext      state passed to textureReleaseProc" ] # [ doc = "@return                    SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface22MakeFromBackendTextureEP9GrContextRK16GrBackendTexture15GrSurfaceOrigini11SkColorType5sk_spI12SkColorSpaceEPK14SkSurfacePropsPFvPvESD_" ] pub fn SkSurface_MakeFromBackendTexture ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , sampleCnt : :: std :: os :: raw :: c_int , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps , textureReleaseProc : SkSurface_TextureReleaseProc , releaseContext : SkSurface_ReleaseContext ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Wraps a GPU-backed buffer into SkSurface. Caller must ensure backendRenderTarget" ] # [ doc = "is valid for the lifetime of returned SkSurface." ] # [ doc = "" ] # [ doc = "SkSurface is returned if all parameters are valid. backendRenderTarget is valid if" ] # [ doc = "its pixel configuration agrees with colorSpace and context; for instance, if" ] # [ doc = "backendRenderTarget has an sRGB configuration, then context must support sRGB," ] # [ doc = "and colorSpace must be present. Further, backendRenderTarget width and height must" ] # [ doc = "not exceed context capabilities, and the context must be able to support" ] # [ doc = "back-end render targets." ] # [ doc = "" ] # [ doc = "If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr." ] # [ doc = "" ] # [ doc = "@param context                  GPU context" ] # [ doc = "@param backendRenderTarget      GPU intermediate memory buffer" ] # [ doc = "@param origin                   one of:" ] # [ doc = "kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param colorType                one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType," ] # [ doc = "kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType," ] # [ doc = "kRGB_888x_SkColorType, kBGRA_8888_SkColorType," ] # [ doc = "kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@param colorSpace               range of colors" ] # [ doc = "@param surfaceProps             LCD striping orientation and setting for device independent" ] # [ doc = "fonts; may be nullptr" ] # [ doc = "@param releaseProc              function called when texture can be released" ] # [ doc = "@param releaseContext           state passed to textureReleaseProc" ] # [ doc = "@return                         SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface27MakeFromBackendRenderTargetEP9GrContextRK21GrBackendRenderTarget15GrSurfaceOrigin11SkColorType5sk_spI12SkColorSpaceEPK14SkSurfacePropsPFvPvESD_" ] pub fn SkSurface_MakeFromBackendRenderTarget ( context : * mut GrContext , backendRenderTarget : * const GrBackendRenderTarget , origin : GrSurfaceOrigin , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps , releaseProc : SkSurface_RenderTargetReleaseProc , releaseContext : SkSurface_ReleaseContext ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Wraps a GPU-backed texture into SkSurface. Caller must ensure backendTexture is" ] # [ doc = "valid for the lifetime of returned SkSurface. If sampleCnt greater than zero," ] # [ doc = "creates an intermediate MSAA SkSurface which is used for drawing backendTexture." ] # [ doc = "" ] # [ doc = "SkSurface is returned if all parameters are valid. backendTexture is valid if" ] # [ doc = "its pixel configuration agrees with colorSpace and context; for instance, if" ] # [ doc = "backendTexture has an sRGB configuration, then context must support sRGB," ] # [ doc = "and colorSpace must be present. Further, backendTexture width and height must" ] # [ doc = "not exceed context capabilities." ] # [ doc = "" ] # [ doc = "Returned SkSurface is available only for drawing into, and cannot generate an" ] # [ doc = "SkImage." ] # [ doc = "" ] # [ doc = "If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr." ] # [ doc = "" ] # [ doc = "@param context         GPU context" ] # [ doc = "@param backendTexture  texture residing on GPU" ] # [ doc = "@param origin          one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param sampleCnt       samples per pixel, or 0 to disable full scene anti-aliasing" ] # [ doc = "@param colorType       one of:" ] # [ doc = "kUnknown_SkColorType, kAlpha_8_SkColorType, kRGB_565_SkColorType," ] # [ doc = "kARGB_4444_SkColorType, kRGBA_8888_SkColorType," ] # [ doc = "kRGB_888x_SkColorType, kBGRA_8888_SkColorType," ] # [ doc = "kRGBA_1010102_SkColorType, kRGB_101010x_SkColorType," ] # [ doc = "kGray_8_SkColorType, kRGBA_F16_SkColorType" ] # [ doc = "@param colorSpace      range of colors; may be nullptr" ] # [ doc = "@param surfaceProps    LCD striping orientation and setting for device independent" ] # [ doc = "fonts; may be nullptr" ] # [ doc = "@return                SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface36MakeFromBackendTextureAsRenderTargetEP9GrContextRK16GrBackendTexture15GrSurfaceOrigini11SkColorType5sk_spI12SkColorSpaceEPK14SkSurfaceProps" ] pub fn SkSurface_MakeFromBackendTextureAsRenderTarget ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , sampleCnt : :: std :: os :: raw :: c_int , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Returns SkSurface on GPU indicated by context. Allocates memory for" ] # [ doc = "pixels, based on the width, height, and SkColorType in SkImageInfo.  budgeted" ] # [ doc = "selects whether allocation for pixels is tracked by context. imageInfo" ] # [ doc = "describes the pixel format in SkColorType, and transparency in" ] # [ doc = "SkAlphaType, and color matching in SkColorSpace." ] # [ doc = "" ] # [ doc = "sampleCount requests the number of samples per pixel." ] # [ doc = "Pass zero to disable multi-sample anti-aliasing.  The request is rounded" ] # [ doc = "up to the next supported count, or rounded down if it is larger than the" ] # [ doc = "maximum supported count." ] # [ doc = "" ] # [ doc = "surfaceOrigin pins either the top-left or the bottom-left corner to the origin." ] # [ doc = "" ] # [ doc = "shouldCreateWithMips hints that SkImage returned by makeImageSnapshot() is mip map." ] # [ doc = "" ] # [ doc = "If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr." ] # [ doc = "" ] # [ doc = "@param context               GPU context" ] # [ doc = "@param budgeted              one of: SkBudgeted::kNo, SkBudgeted::kYes" ] # [ doc = "@param imageInfo             width, height, SkColorType, SkAlphaType, SkColorSpace;" ] # [ doc = "width, or height, or both, may be zero" ] # [ doc = "@param sampleCount           samples per pixel, or 0 to disable full scene anti-aliasing" ] # [ doc = "@param surfaceOrigin         one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin" ] # [ doc = "@param surfaceProps          LCD striping orientation and setting for device independent" ] # [ doc = "fonts; may be nullptr" ] # [ doc = "@param shouldCreateWithMips  hint that SkSurface will host mip map images" ] # [ doc = "@return                      SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface16MakeRenderTargetEP9GrContext10SkBudgetedRK11SkImageInfoi15GrSurfaceOriginPK14SkSurfacePropsb" ] pub fn SkSurface_MakeRenderTarget ( context : * mut GrContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo , sampleCount : :: std :: os :: raw :: c_int , surfaceOrigin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , shouldCreateWithMips : bool ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Returns SkSurface on GPU indicated by context. Allocates memory for" ] # [ doc = "pixels, based on the width, height, and SkColorType in SkImageInfo.  budgeted" ] # [ doc = "selects whether allocation for pixels is tracked by context. imageInfo" ] # [ doc = "describes the pixel format in SkColorType, and transparency in" ] # [ doc = "SkAlphaType, and color matching in SkColorSpace." ] # [ doc = "" ] # [ doc = "sampleCount requests the number of samples per pixel." ] # [ doc = "Pass zero to disable multi-sample anti-aliasing.  The request is rounded" ] # [ doc = "up to the next supported count, or rounded down if it is larger than the" ] # [ doc = "maximum supported count." ] # [ doc = "" ] # [ doc = "SkSurface bottom-left corner is pinned to the origin." ] # [ doc = "" ] # [ doc = "@param context      GPU context" ] # [ doc = "@param budgeted     one of: SkBudgeted::kNo, SkBudgeted::kYes" ] # [ doc = "@param imageInfo    width, height, SkColorType, SkAlphaType, SkColorSpace," ] # [ doc = "of raster surface; width, or height, or both, may be zero" ] # [ doc = "@param sampleCount  samples per pixel, or 0 to disable multi-sample anti-aliasing" ] # [ doc = "@param props        LCD striping orientation and setting for device independent" ] # [ doc = "fonts; may be nullptr" ] # [ doc = "@return             SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface16MakeRenderTargetEP9GrContext10SkBudgetedRK11SkImageInfoiPK14SkSurfaceProps" ] pub fn SkSurface_MakeRenderTarget1 ( context : * mut GrContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo , sampleCount : :: std :: os :: raw :: c_int , props : * const SkSurfaceProps ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Returns SkSurface on GPU indicated by context. Allocates memory for" ] # [ doc = "pixels, based on the width, height, and SkColorType in SkImageInfo.  budgeted" ] # [ doc = "selects whether allocation for pixels is tracked by context. imageInfo" ] # [ doc = "describes the pixel format in SkColorType, and transparency in" ] # [ doc = "SkAlphaType, and color matching in SkColorSpace." ] # [ doc = "" ] # [ doc = "SkSurface bottom-left corner is pinned to the origin." ] # [ doc = "" ] # [ doc = "@param context    GPU context" ] # [ doc = "@param budgeted   one of: SkBudgeted::kNo, SkBudgeted::kYes" ] # [ doc = "@param imageInfo  width, height, SkColorType, SkAlphaType, SkColorSpace," ] # [ doc = "of raster surface; width, or height, or both, may be zero" ] # [ doc = "@return           SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface16MakeRenderTargetEP9GrContext10SkBudgetedRK11SkImageInfo" ] pub fn SkSurface_MakeRenderTarget2 ( context : * mut GrContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Returns SkSurface on GPU indicated by context that is compatible with the provided" ] # [ doc = "characterization. budgeted selects whether allocation for pixels is tracked by context." ] # [ doc = "" ] # [ doc = "@param context           GPU context" ] # [ doc = "@param characterization  description of the desired SkSurface" ] # [ doc = "@param budgeted          one of: SkBudgeted::kNo, SkBudgeted::kYes" ] # [ doc = "@return                  SkSurface if all parameters are valid; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface16MakeRenderTargetEP18GrRecordingContextRK25SkSurfaceCharacterization10SkBudgeted" ] pub fn SkSurface_MakeRenderTarget3 ( context : * mut GrRecordingContext , characterization : * const SkSurfaceCharacterization , budgeted : SkBudgeted ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Returns SkSurface without backing pixels. Drawing to SkCanvas returned from SkSurface" ] # [ doc = "has no effect. Calling makeImageSnapshot() on returned SkSurface returns nullptr." ] # [ doc = "" ] # [ doc = "@param width   one or greater" ] # [ doc = "@param height  one or greater" ] # [ doc = "@return        SkSurface if width and height are positive; otherwise, nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface8MakeNullEii" ] pub fn SkSurface_MakeNull ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Returns pixel count in each row; may be zero or greater." ] # [ doc = "" ] # [ doc = "@return  number of pixel columns" ] # [ link_name = "\u{1}__ZNK9SkSurface5widthEv" ] pub fn SkSurface_width ( this : * const SkSurface ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns pixel row count; may be zero or greater." ] # [ doc = "" ] # [ doc = "@return  number of pixel rows" ] # [ link_name = "\u{1}__ZNK9SkSurface6heightEv" ] pub fn SkSurface_height ( this : * const SkSurface ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns unique value identifying the content of SkSurface. Returned value changes" ] # [ doc = "each time the content changes. Content is changed by drawing, or by calling" ] # [ doc = "notifyContentWillChange()." ] # [ doc = "" ] # [ doc = "@return  unique content identifier" ] # [ link_name = "\u{1}__ZN9SkSurface12generationIDEv" ] pub fn SkSurface_generationID ( this : * mut SkSurface ) -> u32 ; } extern "C" { # [ doc = " Notifies that SkSurface contents will be changed by code outside of Skia." ] # [ doc = "Subsequent calls to generationID() return a different value." ] # [ doc = "" ] # [ doc = "TODO: Can kRetain_ContentChangeMode be deprecated?" ] # [ doc = "" ] # [ doc = "@param mode  one of: kDiscard_ContentChangeMode, kRetain_ContentChangeMode" ] # [ link_name = "\u{1}__ZN9SkSurface23notifyContentWillChangeENS_17ContentChangeModeE" ] pub fn SkSurface_notifyContentWillChange ( this : * mut SkSurface , mode : SkSurface_ContentChangeMode ) ; } extern "C" { # [ doc = " Retrieves the back-end texture. If SkSurface has no back-end texture, an invalid" ] # [ doc = "object is returned. Call GrBackendTexture::isValid to determine if the result" ] # [ doc = "is valid." ] # [ doc = "" ] # [ doc = "The returned GrBackendTexture should be discarded if the SkSurface is drawn to or deleted." ] # [ doc = "" ] # [ doc = "@param backendHandleAccess  one of:  kFlushRead_BackendHandleAccess," ] # [ doc = "kFlushWrite_BackendHandleAccess," ] # [ doc = "kDiscardWrite_BackendHandleAccess" ] # [ doc = "@return                     GPU texture reference; invalid on failure" ] # [ link_name = "\u{1}__ZN9SkSurface17getBackendTextureENS_19BackendHandleAccessE" ] pub fn SkSurface_getBackendTexture ( this : * mut SkSurface , backendHandleAccess : SkSurface_BackendHandleAccess ) -> GrBackendTexture ; } extern "C" { # [ doc = " Retrieves the back-end render target. If SkSurface has no back-end render target, an invalid" ] # [ doc = "object is returned. Call GrBackendRenderTarget::isValid to determine if the result" ] # [ doc = "is valid." ] # [ doc = "" ] # [ doc = "The returned GrBackendRenderTarget should be discarded if the SkSurface is drawn to" ] # [ doc = "or deleted." ] # [ doc = "" ] # [ doc = "@param backendHandleAccess  one of:  kFlushRead_BackendHandleAccess," ] # [ doc = "kFlushWrite_BackendHandleAccess," ] # [ doc = "kDiscardWrite_BackendHandleAccess" ] # [ doc = "@return                     GPU render target reference; invalid on failure" ] # [ link_name = "\u{1}__ZN9SkSurface22getBackendRenderTargetENS_19BackendHandleAccessE" ] pub fn SkSurface_getBackendRenderTarget ( this : * mut SkSurface , backendHandleAccess : SkSurface_BackendHandleAccess ) -> GrBackendRenderTarget ; } extern "C" { # [ doc = " Returns SkCanvas that draws into SkSurface. Subsequent calls return the same SkCanvas." ] # [ doc = "SkCanvas returned is managed and owned by SkSurface, and is deleted when SkSurface" ] # [ doc = "is deleted." ] # [ doc = "" ] # [ doc = "@return  drawing SkCanvas for SkSurface" ] # [ link_name = "\u{1}__ZN9SkSurface9getCanvasEv" ] pub fn SkSurface_getCanvas ( this : * mut SkSurface ) -> * mut SkCanvas ; } extern "C" { # [ doc = " Returns a compatible SkSurface, or nullptr. Returned SkSurface contains" ] # [ doc = "the same raster, GPU, or null properties as the original. Returned SkSurface" ] # [ doc = "does not share the same pixels." ] # [ doc = "" ] # [ doc = "Returns nullptr if imageInfo width or height are zero, or if imageInfo" ] # [ doc = "is incompatible with SkSurface." ] # [ doc = "" ] # [ doc = "@param imageInfo  width, height, SkColorType, SkAlphaType, SkColorSpace," ] # [ doc = "of SkSurface; width and height must be greater than zero" ] # [ doc = "@return           compatible SkSurface or nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface11makeSurfaceERK11SkImageInfo" ] pub fn SkSurface_makeSurface ( this : * mut SkSurface , imageInfo : * const SkImageInfo ) -> sk_sp < SkSurface > ; } extern "C" { # [ doc = " Returns SkImage capturing SkSurface contents. Subsequent drawing to SkSurface contents" ] # [ doc = "are not captured. SkImage allocation is accounted for if SkSurface was created with" ] # [ doc = "SkBudgeted::kYes." ] # [ doc = "" ] # [ doc = "@return  SkImage initialized with SkSurface contents" ] # [ link_name = "\u{1}__ZN9SkSurface17makeImageSnapshotEv" ] pub fn SkSurface_makeImageSnapshot ( this : * mut SkSurface ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = "  Like the no-parameter version, this returns an image of the current surface contents." ] # [ doc = "  This variant takes a rectangle specifying the subset of the surface that is of interest." ] # [ doc = "  These bounds will be sanitized before being used." ] # [ doc = "  - If bounds extends beyond the surface, it will be trimmed to just the intersection of" ] # [ doc = "    it and the surface." ] # [ doc = "  - If bounds does not intersect the surface, then this returns nullptr." ] # [ doc = "  - If bounds == the surface, then this is the same as calling the no-parameter variant." ] # [ link_name = "\u{1}__ZN9SkSurface17makeImageSnapshotERK7SkIRect" ] pub fn SkSurface_makeImageSnapshot1 ( this : * mut SkSurface , bounds : * const SkIRect ) -> sk_sp < SkImage > ; } extern "C" { # [ doc = " Draws SkSurface contents to canvas, with its top-left corner at (x, y)." ] # [ doc = "" ] # [ doc = "If SkPaint paint is not nullptr, apply SkColorFilter, alpha, SkImageFilter," ] # [ doc = "SkBlendMode, and SkDrawLooper." ] # [ doc = "" ] # [ doc = "@param canvas  SkCanvas drawn into" ] # [ doc = "@param x       horizontal offset in SkCanvas" ] # [ doc = "@param y       vertical offset in SkCanvas" ] # [ doc = "@param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter," ] # [ doc = "and so on; or nullptr" ] # [ link_name = "\u{1}__ZN9SkSurface4drawEP8SkCanvasffPK7SkPaint" ] pub fn SkSurface_draw ( this : * mut SkSurface , canvas : * mut SkCanvas , x : SkScalar , y : SkScalar , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Copies SkSurface pixel address, row bytes, and SkImageInfo to SkPixmap, if address" ] # [ doc = "is available, and returns true. If pixel address is not available, return" ] # [ doc = "false and leave SkPixmap unchanged." ] # [ doc = "" ] # [ doc = "pixmap contents become invalid on any future change to SkSurface." ] # [ doc = "" ] # [ doc = "@param pixmap  storage for pixel state if pixels are readable; otherwise, ignored" ] # [ doc = "@return        true if SkSurface has direct access to pixels" ] # [ link_name = "\u{1}__ZN9SkSurface10peekPixelsEP8SkPixmap" ] pub fn SkSurface_peekPixels ( this : * mut SkSurface , pixmap : * mut SkPixmap ) -> bool ; } extern "C" { # [ doc = " Copies SkRect of pixels to dst." ] # [ doc = "" ] # [ doc = "Source SkRect corners are (srcX, srcY) and SkSurface (width(), height())." ] # [ doc = "Destination SkRect corners are (0, 0) and (dst.width(), dst.height())." ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to dst.colorType() and dst.alphaType() if required." ] # [ doc = "" ] # [ doc = "Pixels are readable when SkSurface is raster, or backed by a GPU." ] # [ doc = "" ] # [ doc = "The destination pixel storage must be allocated by the caller." ] # [ doc = "" ] # [ doc = "Pixel values are converted only if SkColorType and SkAlphaType" ] # [ doc = "do not match. Only pixels within both source and destination rectangles" ] # [ doc = "are copied. dst contents outside SkRect intersection are unchanged." ] # [ doc = "" ] # [ doc = "Pass negative values for srcX or srcY to offset pixels across or down destination." ] # [ doc = "" ] # [ doc = "Does not copy, and returns false if:" ] # [ doc = "- Source and destination rectangles do not intersect." ] # [ doc = "- SkPixmap pixels could not be allocated." ] # [ doc = "- dst.rowBytes() is too small to contain one row of pixels." ] # [ doc = "" ] # [ doc = "@param dst   storage for pixels copied from SkSurface" ] # [ doc = "@param srcX  offset into readable pixels on x-axis; may be negative" ] # [ doc = "@param srcY  offset into readable pixels on y-axis; may be negative" ] # [ doc = "@return      true if pixels were copied" ] # [ link_name = "\u{1}__ZN9SkSurface10readPixelsERK8SkPixmapii" ] pub fn SkSurface_readPixels ( this : * mut SkSurface , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies SkRect of pixels from SkCanvas into dstPixels." ] # [ doc = "" ] # [ doc = "Source SkRect corners are (srcX, srcY) and SkSurface (width(), height())." ] # [ doc = "Destination SkRect corners are (0, 0) and (dstInfo.width(), dstInfo.height())." ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to dstInfo.colorType() and dstInfo.alphaType() if required." ] # [ doc = "" ] # [ doc = "Pixels are readable when SkSurface is raster, or backed by a GPU." ] # [ doc = "" ] # [ doc = "The destination pixel storage must be allocated by the caller." ] # [ doc = "" ] # [ doc = "Pixel values are converted only if SkColorType and SkAlphaType" ] # [ doc = "do not match. Only pixels within both source and destination rectangles" ] # [ doc = "are copied. dstPixels contents outside SkRect intersection are unchanged." ] # [ doc = "" ] # [ doc = "Pass negative values for srcX or srcY to offset pixels across or down destination." ] # [ doc = "" ] # [ doc = "Does not copy, and returns false if:" ] # [ doc = "- Source and destination rectangles do not intersect." ] # [ doc = "- SkSurface pixels could not be converted to dstInfo.colorType() or dstInfo.alphaType()." ] # [ doc = "- dstRowBytes is too small to contain one row of pixels." ] # [ doc = "" ] # [ doc = "@param dstInfo      width, height, SkColorType, and SkAlphaType of dstPixels" ] # [ doc = "@param dstPixels    storage for pixels; dstInfo.height() times dstRowBytes, or larger" ] # [ doc = "@param dstRowBytes  size of one destination row; dstInfo.width() times pixel size, or larger" ] # [ doc = "@param srcX         offset into readable pixels on x-axis; may be negative" ] # [ doc = "@param srcY         offset into readable pixels on y-axis; may be negative" ] # [ doc = "@return             true if pixels were copied" ] # [ link_name = "\u{1}__ZN9SkSurface10readPixelsERK11SkImageInfoPvmii" ] pub fn SkSurface_readPixels1 ( this : * mut SkSurface , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies SkRect of pixels from SkSurface into bitmap." ] # [ doc = "" ] # [ doc = "Source SkRect corners are (srcX, srcY) and SkSurface (width(), height())." ] # [ doc = "Destination SkRect corners are (0, 0) and (bitmap.width(), bitmap.height())." ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to bitmap.colorType() and bitmap.alphaType() if required." ] # [ doc = "" ] # [ doc = "Pixels are readable when SkSurface is raster, or backed by a GPU." ] # [ doc = "" ] # [ doc = "The destination pixel storage must be allocated by the caller." ] # [ doc = "" ] # [ doc = "Pixel values are converted only if SkColorType and SkAlphaType" ] # [ doc = "do not match. Only pixels within both source and destination rectangles" ] # [ doc = "are copied. dst contents outside SkRect intersection are unchanged." ] # [ doc = "" ] # [ doc = "Pass negative values for srcX or srcY to offset pixels across or down destination." ] # [ doc = "" ] # [ doc = "Does not copy, and returns false if:" ] # [ doc = "- Source and destination rectangles do not intersect." ] # [ doc = "- SkSurface pixels could not be converted to dst.colorType() or dst.alphaType()." ] # [ doc = "- dst pixels could not be allocated." ] # [ doc = "- dst.rowBytes() is too small to contain one row of pixels." ] # [ doc = "" ] # [ doc = "@param dst   storage for pixels copied from SkSurface" ] # [ doc = "@param srcX  offset into readable pixels on x-axis; may be negative" ] # [ doc = "@param srcY  offset into readable pixels on y-axis; may be negative" ] # [ doc = "@return      true if pixels were copied" ] # [ link_name = "\u{1}__ZN9SkSurface10readPixelsERK8SkBitmapii" ] pub fn SkSurface_readPixels2 ( this : * mut SkSurface , dst : * const SkBitmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Copies SkRect of pixels from the src SkPixmap to the SkSurface." ] # [ doc = "" ] # [ doc = "Source SkRect corners are (0, 0) and (src.width(), src.height())." ] # [ doc = "Destination SkRect corners are (dstX, dstY) and" ] # [ doc = "(dstX + Surface width(), dstY + Surface height())." ] # [ doc = "" ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to SkSurface colorType() and SkSurface alphaType() if required." ] # [ doc = "" ] # [ doc = "@param src   storage for pixels to copy to SkSurface" ] # [ doc = "@param dstX  x-axis position relative to SkSurface to begin copy; may be negative" ] # [ doc = "@param dstY  y-axis position relative to SkSurface to begin copy; may be negative" ] # [ link_name = "\u{1}__ZN9SkSurface11writePixelsERK8SkPixmapii" ] pub fn SkSurface_writePixels ( this : * mut SkSurface , src : * const SkPixmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Copies SkRect of pixels from the src SkBitmap to the SkSurface." ] # [ doc = "" ] # [ doc = "Source SkRect corners are (0, 0) and (src.width(), src.height())." ] # [ doc = "Destination SkRect corners are (dstX, dstY) and" ] # [ doc = "(dstX + Surface width(), dstY + Surface height())." ] # [ doc = "" ] # [ doc = "Copies each readable pixel intersecting both rectangles, without scaling," ] # [ doc = "converting to SkSurface colorType() and SkSurface alphaType() if required." ] # [ doc = "" ] # [ doc = "@param src   storage for pixels to copy to SkSurface" ] # [ doc = "@param dstX  x-axis position relative to SkSurface to begin copy; may be negative" ] # [ doc = "@param dstY  y-axis position relative to SkSurface to begin copy; may be negative" ] # [ link_name = "\u{1}__ZN9SkSurface11writePixelsERK8SkBitmapii" ] pub fn SkSurface_writePixels1 ( this : * mut SkSurface , src : * const SkBitmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Returns SkSurfaceProps for surface." ] # [ doc = "" ] # [ doc = "@return  LCD striping orientation and setting for device independent fonts" ] # [ link_name = "\u{1}__ZNK9SkSurface5propsEv" ] pub fn SkSurface_props ( this : * const SkSurface ) -> * const SkSurfaceProps ; } extern "C" { # [ doc = " Deprecated." ] # [ link_name = "\u{1}__ZN9SkSurface20prepareForExternalIOEv" ] pub fn SkSurface_prepareForExternalIO ( this : * mut SkSurface ) ; } extern "C" { # [ doc = " Issues pending SkSurface commands to the GPU-backed API and resolves any SkSurface MSAA." ] # [ doc = "" ] # [ doc = "Skia flushes as needed, so it is not necessary to call this if Skia manages" ] # [ doc = "drawing and object lifetime. Call when interleaving Skia calls with native" ] # [ doc = "GPU calls." ] # [ link_name = "\u{1}__ZN9SkSurface5flushEv" ] pub fn SkSurface_flush ( this : * mut SkSurface ) ; } extern "C" { # [ doc = " Issues pending SkSurface commands to the GPU-backed API and resolves any SkSurface MSAA." ] # [ doc = "After issuing all commands, signalSemaphores of count numSemaphores are signaled by the GPU." ] # [ doc = "The work that is submitted to the GPU will be dependent on the BackendSurfaceAccess that is" ] # [ doc = "passed in." ] # [ doc = "" ] # [ doc = "If BackendSurfaceAccess::kNoAccess is passed in all commands will be issued to the GPU." ] # [ doc = "" ] # [ doc = "If BackendSurfaceAccess::kPresent is passed in and the backend API is not Vulkan, it is" ] # [ doc = "treated the same as kNoAccess. If the backend API is Vulkan, the VkImage that backs the" ] # [ doc = "SkSurface will be transferred back to its original queue. If the SkSurface was created by" ] # [ doc = "wrapping a VkImage, the queue will be set to the queue which was originally passed in on" ] # [ doc = "the GrVkImageInfo. Additionally, if the original queue was not external or foreign the" ] # [ doc = "layout of the VkImage will be set to VK_IMAGE_LAYOUT_PRESENT_SRC_KHR." ] # [ doc = "" ] # [ doc = "For each GrBackendSemaphore in signalSemaphores:" ] # [ doc = "if GrBackendSemaphore is initialized, the GPU back-end uses the semaphore as is;" ] # [ doc = "otherwise, a new semaphore is created and initializes GrBackendSemaphore." ] # [ doc = "" ] # [ doc = "The caller must delete the semaphores created and returned in signalSemaphores." ] # [ doc = "GrBackendSemaphore can be deleted as soon as this function returns." ] # [ doc = "" ] # [ doc = "If the back-end API is OpenGL only uninitialized backend semaphores are supported." ] # [ doc = "" ] # [ doc = "If the back-end API is Vulkan semaphores may be initialized or uninitialized." ] # [ doc = "If uninitialized, created semaphores are valid only with the VkDevice" ] # [ doc = "with which they were created." ] # [ doc = "" ] # [ doc = "If GrSemaphoresSubmitted::kNo is returned, the GPU back-end did not create or" ] # [ doc = "add any semaphores to signal on the GPU; the caller should not instruct the GPU" ] # [ doc = "to wait on any of the semaphores." ] # [ doc = "" ] # [ doc = "Pending surface commands are flushed regardless of the return result." ] # [ doc = "" ] # [ doc = "@param access            type of access the call will do on the backend object after flush" ] # [ doc = "@param flags             flush options" ] # [ doc = "@param numSemaphores     size of signalSemaphores array" ] # [ doc = "@param signalSemaphores  array of semaphore containers" ] # [ doc = "@return                  one of: GrSemaphoresSubmitted::kYes, GrSemaphoresSubmitted::kNo" ] # [ link_name = "\u{1}__ZN9SkSurface5flushENS_20BackendSurfaceAccessENS_10FlushFlagsEiP18GrBackendSemaphore" ] pub fn SkSurface_flush1 ( this : * mut SkSurface , access : SkSurface_BackendSurfaceAccess , flags : SkSurface_FlushFlags , numSemaphores : :: std :: os :: raw :: c_int , signalSemaphores : * mut GrBackendSemaphore ) -> GrSemaphoresSubmitted ; } extern "C" { # [ doc = " Issues pending SkSurface commands to the GPU-backed API and resolves any SkSurface MSAA." ] # [ doc = "After issuing all commands, signalSemaphores of count numSemaphores semaphores" ] # [ doc = "are signaled by the GPU." ] # [ doc = "" ] # [ doc = "For each GrBackendSemaphore in signalSemaphores:" ] # [ doc = "if GrBackendSemaphore is initialized, the GPU back-end uses the semaphore as is;" ] # [ doc = "otherwise, a new semaphore is created and initializes GrBackendSemaphore." ] # [ doc = "" ] # [ doc = "The caller must delete the semaphores created and returned in signalSemaphores." ] # [ doc = "GrBackendSemaphore can be deleted as soon as this function returns." ] # [ doc = "" ] # [ doc = "If the back-end API is OpenGL only uninitialized backend semaphores are supported." ] # [ doc = "" ] # [ doc = "If the back-end API is Vulkan semaphores may be initialized or uninitialized." ] # [ doc = "If uninitialized, created semaphores are valid only with the VkDevice" ] # [ doc = "with which they were created." ] # [ doc = "" ] # [ doc = "If GrSemaphoresSubmitted::kNo is returned, the GPU back-end did not create or" ] # [ doc = "add any semaphores to signal on the GPU; the caller should not instruct the GPU" ] # [ doc = "to wait on any of the semaphores." ] # [ doc = "" ] # [ doc = "Pending surface commands are flushed regardless of the return result." ] # [ doc = "" ] # [ doc = "@param numSemaphores     size of signalSemaphores array" ] # [ doc = "@param signalSemaphores  array of semaphore containers" ] # [ doc = "@return                  one of: GrSemaphoresSubmitted::kYes, GrSemaphoresSubmitted::kNo" ] # [ link_name = "\u{1}__ZN9SkSurface24flushAndSignalSemaphoresEiP18GrBackendSemaphore" ] pub fn SkSurface_flushAndSignalSemaphores ( this : * mut SkSurface , numSemaphores : :: std :: os :: raw :: c_int , signalSemaphores : * mut GrBackendSemaphore ) -> GrSemaphoresSubmitted ; } extern "C" { # [ doc = " Inserts a list of GPU semaphores that the current GPU-backed API must wait on before" ] # [ doc = "executing any more commands on the GPU for this surface. Skia will take ownership of the" ] # [ doc = "underlying semaphores and delete them once they have been signaled and waited on." ] # [ doc = "If this call returns false, then the GPU back-end will not wait on any passed in semaphores," ] # [ doc = "and the client will still own the semaphores." ] # [ doc = "" ] # [ doc = "@param numSemaphores   size of waitSemaphores array" ] # [ doc = "@param waitSemaphores  array of semaphore containers" ] # [ doc = "@return                true if GPU is waiting on semaphores" ] # [ link_name = "\u{1}__ZN9SkSurface4waitEiPK18GrBackendSemaphore" ] pub fn SkSurface_wait ( this : * mut SkSurface , numSemaphores : :: std :: os :: raw :: c_int , waitSemaphores : * const GrBackendSemaphore ) -> bool ; } extern "C" { # [ doc = " Initializes SkSurfaceCharacterization that can be used to perform GPU back-end" ] # [ doc = "processing in a separate thread. Typically this is used to divide drawing" ] # [ doc = "into multiple tiles. SkDeferredDisplayListRecorder records the drawing commands" ] # [ doc = "for each tile." ] # [ doc = "" ] # [ doc = "Return true if SkSurface supports characterization. raster surface returns false." ] # [ doc = "" ] # [ doc = "@param characterization  properties for parallel drawing" ] # [ doc = "@return                  true if supported" ] # [ link_name = "\u{1}__ZNK9SkSurface12characterizeEP25SkSurfaceCharacterization" ] pub fn SkSurface_characterize ( this : * const SkSurface , characterization : * mut SkSurfaceCharacterization ) -> bool ; } extern "C" { # [ doc = " Draws deferred display list created using SkDeferredDisplayListRecorder." ] # [ doc = "Has no effect and returns false if SkSurfaceCharacterization stored in" ] # [ doc = "deferredDisplayList is not compatible with SkSurface." ] # [ doc = "" ] # [ doc = "raster surface returns false." ] # [ doc = "" ] # [ doc = "@param deferredDisplayList  drawing commands" ] # [ doc = "@return                     false if deferredDisplayList is not compatible" ] # [ link_name = "\u{1}__ZN9SkSurface4drawEP21SkDeferredDisplayList" ] pub fn SkSurface_draw1 ( this : * mut SkSurface , deferredDisplayList : * mut SkDeferredDisplayList ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9SkSurface17dirtyGenerationIDEv" ] pub fn SkSurface_dirtyGenerationID ( this : * mut SkSurface ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkSurfaceC1EiiPK14SkSurfaceProps" ] pub fn SkSurface_SkSurface ( this : * mut SkSurface , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps ) ; } extern "C" { # [ link_name = "\u{1}__ZN9SkSurfaceC1ERK11SkImageInfoPK14SkSurfaceProps" ] pub fn SkSurface_SkSurface1 ( this : * mut SkSurface , imageInfo : * const SkImageInfo , surfaceProps : * const SkSurfaceProps ) ; } impl SkSurface { # [ inline ] pub unsafe fn MakeRasterDirect ( imageInfo : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > { SkSurface_MakeRasterDirect ( imageInfo , pixels , rowBytes , surfaceProps ) } # [ inline ] pub unsafe fn MakeRasterDirectReleaseProc ( imageInfo : * const SkImageInfo , pixels : * mut :: std :: os :: raw :: c_void , rowBytes : usize , releaseProc : :: core :: option :: Option < unsafe extern "C" fn ( imageInfo : * mut :: std :: os :: raw :: c_void , pixels : * mut :: std :: os :: raw :: c_void ) > , context : * mut :: std :: os :: raw :: c_void , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > { SkSurface_MakeRasterDirectReleaseProc ( imageInfo , pixels , rowBytes , releaseProc , context , surfaceProps ) } # [ inline ] pub unsafe fn MakeRaster ( imageInfo : * const SkImageInfo , rowBytes : usize , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > { SkSurface_MakeRaster ( imageInfo , rowBytes , surfaceProps ) } # [ inline ] pub unsafe fn MakeRaster1 ( imageInfo : * const SkImageInfo , props : * const SkSurfaceProps ) -> sk_sp < SkSurface > { SkSurface_MakeRaster1 ( imageInfo , props ) } # [ inline ] pub unsafe fn MakeRasterN32Premul ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > { SkSurface_MakeRasterN32Premul ( width , height , surfaceProps ) } # [ inline ] pub unsafe fn MakeFromBackendTexture ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , sampleCnt : :: std :: os :: raw :: c_int , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps , textureReleaseProc : SkSurface_TextureReleaseProc , releaseContext : SkSurface_ReleaseContext ) -> sk_sp < SkSurface > { SkSurface_MakeFromBackendTexture ( context , backendTexture , origin , sampleCnt , colorType , colorSpace , surfaceProps , textureReleaseProc , releaseContext ) } # [ inline ] pub unsafe fn MakeFromBackendRenderTarget ( context : * mut GrContext , backendRenderTarget : * const GrBackendRenderTarget , origin : GrSurfaceOrigin , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps , releaseProc : SkSurface_RenderTargetReleaseProc , releaseContext : SkSurface_ReleaseContext ) -> sk_sp < SkSurface > { SkSurface_MakeFromBackendRenderTarget ( context , backendRenderTarget , origin , colorType , colorSpace , surfaceProps , releaseProc , releaseContext ) } # [ inline ] pub unsafe fn MakeFromBackendTextureAsRenderTarget ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , sampleCnt : :: std :: os :: raw :: c_int , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps ) -> sk_sp < SkSurface > { SkSurface_MakeFromBackendTextureAsRenderTarget ( context , backendTexture , origin , sampleCnt , colorType , colorSpace , surfaceProps ) } # [ inline ] pub unsafe fn MakeRenderTarget ( context : * mut GrContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo , sampleCount : :: std :: os :: raw :: c_int , surfaceOrigin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , shouldCreateWithMips : bool ) -> sk_sp < SkSurface > { SkSurface_MakeRenderTarget ( context , budgeted , imageInfo , sampleCount , surfaceOrigin , surfaceProps , shouldCreateWithMips ) } # [ inline ] pub unsafe fn MakeRenderTarget1 ( context : * mut GrContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo , sampleCount : :: std :: os :: raw :: c_int , props : * const SkSurfaceProps ) -> sk_sp < SkSurface > { SkSurface_MakeRenderTarget1 ( context , budgeted , imageInfo , sampleCount , props ) } # [ inline ] pub unsafe fn MakeRenderTarget2 ( context : * mut GrContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo ) -> sk_sp < SkSurface > { SkSurface_MakeRenderTarget2 ( context , budgeted , imageInfo ) } # [ inline ] pub unsafe fn MakeRenderTarget3 ( context : * mut GrRecordingContext , characterization : * const SkSurfaceCharacterization , budgeted : SkBudgeted ) -> sk_sp < SkSurface > { SkSurface_MakeRenderTarget3 ( context , characterization , budgeted ) } # [ inline ] pub unsafe fn MakeNull ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> sk_sp < SkSurface > { SkSurface_MakeNull ( width , height ) } # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { SkSurface_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { SkSurface_height ( self ) } # [ inline ] pub unsafe fn generationID ( & mut self ) -> u32 { SkSurface_generationID ( self ) } # [ inline ] pub unsafe fn notifyContentWillChange ( & mut self , mode : SkSurface_ContentChangeMode ) { SkSurface_notifyContentWillChange ( self , mode ) } # [ inline ] pub unsafe fn getBackendTexture ( & mut self , backendHandleAccess : SkSurface_BackendHandleAccess ) -> GrBackendTexture { SkSurface_getBackendTexture ( self , backendHandleAccess ) } # [ inline ] pub unsafe fn getBackendRenderTarget ( & mut self , backendHandleAccess : SkSurface_BackendHandleAccess ) -> GrBackendRenderTarget { SkSurface_getBackendRenderTarget ( self , backendHandleAccess ) } # [ inline ] pub unsafe fn getCanvas ( & mut self ) -> * mut SkCanvas { SkSurface_getCanvas ( self ) } # [ inline ] pub unsafe fn makeSurface ( & mut self , imageInfo : * const SkImageInfo ) -> sk_sp < SkSurface > { SkSurface_makeSurface ( self , imageInfo ) } # [ inline ] pub unsafe fn makeImageSnapshot ( & mut self ) -> sk_sp < SkImage > { SkSurface_makeImageSnapshot ( self ) } # [ inline ] pub unsafe fn makeImageSnapshot1 ( & mut self , bounds : * const SkIRect ) -> sk_sp < SkImage > { SkSurface_makeImageSnapshot1 ( self , bounds ) } # [ inline ] pub unsafe fn draw ( & mut self , canvas : * mut SkCanvas , x : SkScalar , y : SkScalar , paint : * const SkPaint ) { SkSurface_draw ( self , canvas , x , y , paint ) } # [ inline ] pub unsafe fn peekPixels ( & mut self , pixmap : * mut SkPixmap ) -> bool { SkSurface_peekPixels ( self , pixmap ) } # [ inline ] pub unsafe fn readPixels ( & mut self , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkSurface_readPixels ( self , dst , srcX , srcY ) } # [ inline ] pub unsafe fn readPixels1 ( & mut self , dstInfo : * const SkImageInfo , dstPixels : * mut :: std :: os :: raw :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkSurface_readPixels1 ( self , dstInfo , dstPixels , dstRowBytes , srcX , srcY ) } # [ inline ] pub unsafe fn readPixels2 ( & mut self , dst : * const SkBitmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int ) -> bool { SkSurface_readPixels2 ( self , dst , srcX , srcY ) } # [ inline ] pub unsafe fn writePixels ( & mut self , src : * const SkPixmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int ) { SkSurface_writePixels ( self , src , dstX , dstY ) } # [ inline ] pub unsafe fn writePixels1 ( & mut self , src : * const SkBitmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int ) { SkSurface_writePixels1 ( self , src , dstX , dstY ) } # [ inline ] pub unsafe fn props ( & self ) -> * const SkSurfaceProps { SkSurface_props ( self ) } # [ inline ] pub unsafe fn prepareForExternalIO ( & mut self ) { SkSurface_prepareForExternalIO ( self ) } # [ inline ] pub unsafe fn flush ( & mut self ) { SkSurface_flush ( self ) } # [ inline ] pub unsafe fn flush1 ( & mut self , access : SkSurface_BackendSurfaceAccess , flags : SkSurface_FlushFlags , numSemaphores : :: std :: os :: raw :: c_int , signalSemaphores : * mut GrBackendSemaphore ) -> GrSemaphoresSubmitted { SkSurface_flush1 ( self , access , flags , numSemaphores , signalSemaphores ) } # [ inline ] pub unsafe fn flushAndSignalSemaphores ( & mut self , numSemaphores : :: std :: os :: raw :: c_int , signalSemaphores : * mut GrBackendSemaphore ) -> GrSemaphoresSubmitted { SkSurface_flushAndSignalSemaphores ( self , numSemaphores , signalSemaphores ) } # [ inline ] pub unsafe fn wait ( & mut self , numSemaphores : :: std :: os :: raw :: c_int , waitSemaphores : * const GrBackendSemaphore ) -> bool { SkSurface_wait ( self , numSemaphores , waitSemaphores ) } # [ inline ] pub unsafe fn characterize ( & self , characterization : * mut SkSurfaceCharacterization ) -> bool { SkSurface_characterize ( self , characterization ) } # [ inline ] pub unsafe fn draw1 ( & mut self , deferredDisplayList : * mut SkDeferredDisplayList ) -> bool { SkSurface_draw1 ( self , deferredDisplayList ) } # [ inline ] pub unsafe fn dirtyGenerationID ( & mut self ) { SkSurface_dirtyGenerationID ( self ) } # [ inline ] pub unsafe fn new ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkSurface_SkSurface ( & mut __bindgen_tmp , width , height , surfaceProps ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( imageInfo : * const SkImageInfo , surfaceProps : * const SkSurfaceProps ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkSurface_SkSurface1 ( & mut __bindgen_tmp , imageInfo , surfaceProps ) ; __bindgen_tmp } } # [ doc = " \\class SkPicture" ] # [ doc = "SkPicture records drawing commands made to SkCanvas. The command stream may be" ] # [ doc = "played in whole or in part at a later time." ] # [ doc = "" ] # [ doc = "SkPicture is an abstract class. SkPicture may be generated by SkPictureRecorder" ] # [ doc = "or SkDrawable, or from SkPicture previously saved to SkData or SkStream." ] # [ doc = "" ] # [ doc = "SkPicture may contain any SkCanvas drawing command, as well as one or more" ] # [ doc = "SkCanvas matrix or SkCanvas clip. SkPicture has a cull SkRect, which is used as" ] # [ doc = "a bounding box hint. To limit SkPicture bounds, use SkCanvas clip when" ] # [ doc = "recording or drawing SkPicture." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPicture { pub _base : SkRefCnt , pub fUniqueID : u32 , } # [ repr ( C ) ] pub struct SkPicture_AbortCallback__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ doc = " \\class SkPicture::AbortCallback" ] # [ doc = "AbortCallback is an abstract class. An implementation of AbortCallback may" ] # [ doc = "passed as a parameter to SkPicture::playback, to stop it before all drawing" ] # [ doc = "commands have been processed." ] # [ doc = "" ] # [ doc = "If AbortCallback::abort returns true, SkPicture::playback is interrupted." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPicture_AbortCallback { pub vtable_ : * const SkPicture_AbortCallback__bindgen_vtable , } # [ test ] fn bindgen_test_layout_SkPicture_AbortCallback ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPicture_AbortCallback > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkPicture_AbortCallback ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPicture_AbortCallback > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPicture_AbortCallback ) ) ) ; } extern "C" { # [ doc = " Has no effect." ] # [ doc = "" ] # [ doc = "@return  abstract class cannot be instantiated" ] # [ link_name = "\u{1}__ZN9SkPicture13AbortCallbackC2Ev" ] pub fn SkPicture_AbortCallback_AbortCallback ( this : * mut SkPicture_AbortCallback ) ; } impl SkPicture_AbortCallback { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPicture_AbortCallback_AbortCallback ( & mut __bindgen_tmp ) ; __bindgen_tmp } } pub const SkPicture_MIN_PICTURE_VERSION : u32 = 56 ; pub const SkPicture_CURRENT_PICTURE_VERSION : u32 = 68 ; # [ test ] fn bindgen_test_layout_SkPicture ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPicture > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkPicture ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPicture > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPicture ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPicture > ( ) ) ) . fUniqueID as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkPicture ) , "::" , stringify ! ( fUniqueID ) ) ) ; } extern "C" { # [ doc = " Recreates SkPicture that was serialized into a stream. Returns constructed SkPicture" ] # [ doc = "if successful; otherwise, returns nullptr. Fails if data does not permit" ] # [ doc = "constructing valid SkPicture." ] # [ doc = "" ] # [ doc = "procs->fPictureProc permits supplying a custom function to decode SkPicture." ] # [ doc = "If procs->fPictureProc is nullptr, default decoding is used. procs->fPictureCtx" ] # [ doc = "may be used to provide user context to procs->fPictureProc; procs->fPictureProc" ] # [ doc = "is called with a pointer to data, data byte length, and user context." ] # [ doc = "" ] # [ doc = "@param stream  container for serial data" ] # [ doc = "@param procs   custom serial data decoders; may be nullptr" ] # [ doc = "@return        SkPicture constructed from stream data" ] # [ link_name = "\u{1}__ZN9SkPicture14MakeFromStreamEP8SkStreamPK15SkDeserialProcs" ] pub fn SkPicture_MakeFromStream ( stream : * mut SkStream , procs : * const SkDeserialProcs ) -> sk_sp < SkPicture > ; } extern "C" { # [ doc = " Recreates SkPicture that was serialized into data. Returns constructed SkPicture" ] # [ doc = "if successful; otherwise, returns nullptr. Fails if data does not permit" ] # [ doc = "constructing valid SkPicture." ] # [ doc = "" ] # [ doc = "procs->fPictureProc permits supplying a custom function to decode SkPicture." ] # [ doc = "If procs->fPictureProc is nullptr, default decoding is used. procs->fPictureCtx" ] # [ doc = "may be used to provide user context to procs->fPictureProc; procs->fPictureProc" ] # [ doc = "is called with a pointer to data, data byte length, and user context." ] # [ doc = "" ] # [ doc = "@param data   container for serial data" ] # [ doc = "@param procs  custom serial data decoders; may be nullptr" ] # [ doc = "@return       SkPicture constructed from data" ] # [ link_name = "\u{1}__ZN9SkPicture12MakeFromDataEPK6SkDataPK15SkDeserialProcs" ] pub fn SkPicture_MakeFromData ( data : * const SkData , procs : * const SkDeserialProcs ) -> sk_sp < SkPicture > ; } extern "C" { # [ doc = "@param data   pointer to serial data" ] # [ doc = "@param size   size of data" ] # [ doc = "@param procs  custom serial data decoders; may be nullptr" ] # [ doc = "@return       SkPicture constructed from data" ] # [ link_name = "\u{1}__ZN9SkPicture12MakeFromDataEPKvmPK15SkDeserialProcs" ] pub fn SkPicture_MakeFromData1 ( data : * const :: std :: os :: raw :: c_void , size : usize , procs : * const SkDeserialProcs ) -> sk_sp < SkPicture > ; } extern "C" { # [ doc = " Returns a non-zero value unique among SkPicture in Skia process." ] # [ doc = "" ] # [ doc = "@return  identifier for SkPicture" ] # [ link_name = "\u{1}__ZNK9SkPicture8uniqueIDEv" ] pub fn SkPicture_uniqueID ( this : * const SkPicture ) -> u32 ; } extern "C" { # [ doc = " Returns storage containing SkData describing SkPicture, using optional custom" ] # [ doc = "encoders." ] # [ doc = "" ] # [ doc = "procs->fPictureProc permits supplying a custom function to encode SkPicture." ] # [ doc = "If procs->fPictureProc is nullptr, default encoding is used. procs->fPictureCtx" ] # [ doc = "may be used to provide user context to procs->fPictureProc; procs->fPictureProc" ] # [ doc = "is called with a pointer to SkPicture and user context." ] # [ doc = "" ] # [ doc = "@param procs  custom serial data encoders; may be nullptr" ] # [ doc = "@return       storage containing serialized SkPicture" ] # [ link_name = "\u{1}__ZNK9SkPicture9serializeEPK13SkSerialProcs" ] pub fn SkPicture_serialize ( this : * const SkPicture , procs : * const SkSerialProcs ) -> sk_sp < SkData > ; } extern "C" { # [ doc = " Writes picture to stream, using optional custom encoders." ] # [ doc = "" ] # [ doc = "procs->fPictureProc permits supplying a custom function to encode SkPicture." ] # [ doc = "If procs->fPictureProc is nullptr, default encoding is used. procs->fPictureCtx" ] # [ doc = "may be used to provide user context to procs->fPictureProc; procs->fPictureProc" ] # [ doc = "is called with a pointer to SkPicture and user context." ] # [ doc = "" ] # [ doc = "@param stream  writable serial data stream" ] # [ doc = "@param procs   custom serial data encoders; may be nullptr" ] # [ link_name = "\u{1}__ZNK9SkPicture9serializeEP9SkWStreamPK13SkSerialProcs" ] pub fn SkPicture_serialize1 ( this : * const SkPicture , stream : * mut SkWStream , procs : * const SkSerialProcs ) ; } extern "C" { # [ doc = " Returns a placeholder SkPicture. Result does not draw, and contains only" ] # [ doc = "cull SkRect, a hint of its bounds. Result is immutable; it cannot be changed" ] # [ doc = "later. Result identifier is unique." ] # [ doc = "" ] # [ doc = "Returned placeholder can be intercepted during playback to insert other" ] # [ doc = "commands into SkCanvas draw stream." ] # [ doc = "" ] # [ doc = "@param cull  placeholder dimensions" ] # [ doc = "@return      placeholder with unique identifier" ] # [ link_name = "\u{1}__ZN9SkPicture15MakePlaceholderE6SkRect" ] pub fn SkPicture_MakePlaceholder ( cull : SkRect ) -> sk_sp < SkPicture > ; } impl SkPicture { # [ inline ] pub unsafe fn MakeFromStream ( stream : * mut SkStream , procs : * const SkDeserialProcs ) -> sk_sp < SkPicture > { SkPicture_MakeFromStream ( stream , procs ) } # [ inline ] pub unsafe fn MakeFromData ( data : * const SkData , procs : * const SkDeserialProcs ) -> sk_sp < SkPicture > { SkPicture_MakeFromData ( data , procs ) } # [ inline ] pub unsafe fn MakeFromData1 ( data : * const :: std :: os :: raw :: c_void , size : usize , procs : * const SkDeserialProcs ) -> sk_sp < SkPicture > { SkPicture_MakeFromData1 ( data , size , procs ) } # [ inline ] pub unsafe fn uniqueID ( & self ) -> u32 { SkPicture_uniqueID ( self ) } # [ inline ] pub unsafe fn serialize ( & self , procs : * const SkSerialProcs ) -> sk_sp < SkData > { SkPicture_serialize ( self , procs ) } # [ inline ] pub unsafe fn serialize1 ( & self , stream : * mut SkWStream , procs : * const SkSerialProcs ) { SkPicture_serialize1 ( self , stream , procs ) } # [ inline ] pub unsafe fn MakePlaceholder ( cull : SkRect ) -> sk_sp < SkPicture > { SkPicture_MakePlaceholder ( cull ) } } extern "C" { # [ doc = " Has no effect." ] # [ link_name = "\u{1}__ZN9SkPicture13AbortCallbackD1Ev" ] pub fn SkPicture_AbortCallback_AbortCallback_destructor ( this : * mut SkPicture_AbortCallback ) ; } impl SkColorChannel { pub const kLastEnum : SkColorChannel = SkColorChannel :: kA ; } # [ repr ( i32 ) ] # [ doc = " \\enum SkColorChannel" ] # [ doc = "Describes different color channels one can manipulate" ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkColorChannel { kR = 0 , kG = 1 , kB = 2 , kA = 3 , } # [ doc = " \\struct SkYUVAIndex" ] # [ doc = "Describes from which image source and which channel to read each individual YUVA plane." ] # [ doc = "" ] # [ doc = "SkYUVAIndex contains a index for which image source to read from and a enum for which channel" ] # [ doc = "to read from." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkYUVAIndex { # [ doc = " The index is a number between -1..3 which definies which image source to read from, where -1" ] # [ doc = " means the image source doesn\'t exist. The assumption is we will always have image sources for" ] # [ doc = " each of YUV planes, but optionally have image source for A plane." ] pub fIndex : :: std :: os :: raw :: c_int , # [ doc = " The channel describes from which channel to read the info from. Currently we only deal with" ] # [ doc = " YUV and NV12 and channel info is ignored." ] pub fChannel : SkColorChannel , } impl SkYUVAIndex_Index { pub const kLast_Index : SkYUVAIndex_Index = SkYUVAIndex_Index :: kA_Index ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkYUVAIndex_Index { kY_Index = 0 , kU_Index = 1 , kV_Index = 2 , kA_Index = 3 , } pub const SkYUVAIndex_kIndexCount : :: std :: os :: raw :: c_int = 4 ; # [ test ] fn bindgen_test_layout_SkYUVAIndex ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkYUVAIndex > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SkYUVAIndex ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkYUVAIndex > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkYUVAIndex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkYUVAIndex > ( ) ) ) . fIndex as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkYUVAIndex ) , "::" , stringify ! ( fIndex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkYUVAIndex > ( ) ) ) . fChannel as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkYUVAIndex ) , "::" , stringify ! ( fChannel ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN11SkYUVAIndex15AreValidIndicesEPKS_Pi" ] pub fn SkYUVAIndex_AreValidIndices ( yuvaIndices : * const SkYUVAIndex , numPlanes : * mut :: std :: os :: raw :: c_int ) -> bool ; } impl SkYUVAIndex { # [ inline ] pub unsafe fn AreValidIndices ( yuvaIndices : * const SkYUVAIndex , numPlanes : * mut :: std :: os :: raw :: c_int ) -> bool { SkYUVAIndex_AreValidIndices ( yuvaIndices , numPlanes ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkPoint3 { pub fX : SkScalar , pub fY : SkScalar , pub fZ : SkScalar , } # [ test ] fn bindgen_test_layout_SkPoint3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPoint3 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( SkPoint3 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPoint3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkPoint3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPoint3 > ( ) ) ) . fX as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPoint3 ) , "::" , stringify ! ( fX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPoint3 > ( ) ) ) . fY as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkPoint3 ) , "::" , stringify ! ( fY ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPoint3 > ( ) ) ) . fZ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkPoint3 ) , "::" , stringify ! ( fZ ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN8SkPoint34MakeEfff" ] pub fn SkPoint3_Make ( x : SkScalar , y : SkScalar , z : SkScalar ) -> SkPoint3 ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkPoint31xEv" ] pub fn SkPoint3_x ( this : * const SkPoint3 ) -> SkScalar ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkPoint31yEv" ] pub fn SkPoint3_y ( this : * const SkPoint3 ) -> SkScalar ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkPoint31zEv" ] pub fn SkPoint3_z ( this : * const SkPoint3 ) -> SkScalar ; } extern "C" { # [ link_name = "\u{1}__ZN8SkPoint33setEfff" ] pub fn SkPoint3_set ( this : * mut SkPoint3 , x : SkScalar , y : SkScalar , z : SkScalar ) ; } extern "C" { # [ doc = " Returns the Euclidian distance from (0,0,0) to (x,y,z)" ] # [ link_name = "\u{1}__ZN8SkPoint36LengthEfff" ] pub fn SkPoint3_Length ( x : SkScalar , y : SkScalar , z : SkScalar ) -> SkScalar ; } extern "C" { # [ doc = " Return the Euclidian distance from (0,0,0) to the point" ] # [ link_name = "\u{1}__ZNK8SkPoint36lengthEv" ] pub fn SkPoint3_length ( this : * const SkPoint3 ) -> SkScalar ; } extern "C" { # [ doc = " Set the point (vector) to be unit-length in the same direction as it" ] # [ doc = "already points.  If the point has a degenerate length (i.e., nearly 0)" ] # [ doc = "then set it to (0,0,0) and return false; otherwise return true." ] # [ link_name = "\u{1}__ZN8SkPoint39normalizeEv" ] pub fn SkPoint3_normalize ( this : * mut SkPoint3 ) -> bool ; } extern "C" { # [ doc = " Return a new point whose X, Y and Z coordinates are scaled." ] # [ link_name = "\u{1}__ZNK8SkPoint39makeScaleEf" ] pub fn SkPoint3_makeScale ( this : * const SkPoint3 , scale : SkScalar ) -> SkPoint3 ; } extern "C" { # [ doc = " Scale the point\'s coordinates by scale." ] # [ link_name = "\u{1}__ZN8SkPoint35scaleEf" ] pub fn SkPoint3_scale ( this : * mut SkPoint3 , value : SkScalar ) ; } extern "C" { # [ doc = " Returns true if fX, fY, and fZ are measurable values." ] # [ doc = "" ] # [ doc = "@return  true for values other than infinities and NaN" ] # [ link_name = "\u{1}__ZNK8SkPoint38isFiniteEv" ] pub fn SkPoint3_isFinite ( this : * const SkPoint3 ) -> bool ; } extern "C" { # [ doc = " Returns the dot product of a and b, treating them as 3D vectors" ] # [ link_name = "\u{1}__ZN8SkPoint310DotProductERKS_S1_" ] pub fn SkPoint3_DotProduct ( a : * const SkPoint3 , b : * const SkPoint3 ) -> SkScalar ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkPoint33dotERKS_" ] pub fn SkPoint3_dot ( this : * const SkPoint3 , vec : * const SkPoint3 ) -> SkScalar ; } extern "C" { # [ doc = " Returns the cross product of a and b, treating them as 3D vectors" ] # [ link_name = "\u{1}__ZN8SkPoint312CrossProductERKS_S1_" ] pub fn SkPoint3_CrossProduct ( a : * const SkPoint3 , b : * const SkPoint3 ) -> SkPoint3 ; } extern "C" { # [ link_name = "\u{1}__ZNK8SkPoint35crossERKS_" ] pub fn SkPoint3_cross ( this : * const SkPoint3 , vec : * const SkPoint3 ) -> SkPoint3 ; } impl SkPoint3 { # [ inline ] pub unsafe fn Make ( x : SkScalar , y : SkScalar , z : SkScalar ) -> SkPoint3 { SkPoint3_Make ( x , y , z ) } # [ inline ] pub unsafe fn x ( & self ) -> SkScalar { SkPoint3_x ( self ) } # [ inline ] pub unsafe fn y ( & self ) -> SkScalar { SkPoint3_y ( self ) } # [ inline ] pub unsafe fn z ( & self ) -> SkScalar { SkPoint3_z ( self ) } # [ inline ] pub unsafe fn set ( & mut self , x : SkScalar , y : SkScalar , z : SkScalar ) { SkPoint3_set ( self , x , y , z ) } # [ inline ] pub unsafe fn Length ( x : SkScalar , y : SkScalar , z : SkScalar ) -> SkScalar { SkPoint3_Length ( x , y , z ) } # [ inline ] pub unsafe fn length ( & self ) -> SkScalar { SkPoint3_length ( self ) } # [ inline ] pub unsafe fn normalize ( & mut self ) -> bool { SkPoint3_normalize ( self ) } # [ inline ] pub unsafe fn makeScale ( & self , scale : SkScalar ) -> SkPoint3 { SkPoint3_makeScale ( self , scale ) } # [ inline ] pub unsafe fn scale ( & mut self , value : SkScalar ) { SkPoint3_scale ( self , value ) } # [ inline ] pub unsafe fn isFinite ( & self ) -> bool { SkPoint3_isFinite ( self ) } # [ inline ] pub unsafe fn DotProduct ( a : * const SkPoint3 , b : * const SkPoint3 ) -> SkScalar { SkPoint3_DotProduct ( a , b ) } # [ inline ] pub unsafe fn dot ( & self , vec : * const SkPoint3 ) -> SkScalar { SkPoint3_dot ( self , vec ) } # [ inline ] pub unsafe fn CrossProduct ( a : * const SkPoint3 , b : * const SkPoint3 ) -> SkPoint3 { SkPoint3_CrossProduct ( a , b ) } # [ inline ] pub unsafe fn cross ( & self , vec : * const SkPoint3 ) -> SkPoint3 { SkPoint3_cross ( self , vec ) } } # [ doc = " \\class SkRegion" ] # [ doc = "SkRegion describes the set of pixels used to clip SkCanvas. SkRegion is compact," ] # [ doc = "efficiently storing a single integer rectangle, or a run length encoded array" ] # [ doc = "of rectangles. SkRegion may reduce the current SkCanvas clip, or may be drawn as" ] # [ doc = "one or more integer rectangles. SkRegion iterator returns the scan lines or" ] # [ doc = "rectangles contained by it, optionally intersecting a bounding rectangle." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkRegion { pub fBounds : SkIRect , pub fRunHead : * mut SkRegion_RunHead , } pub type SkRegion_RunType = i32 ; impl SkRegion_Op { pub const kLastOp : SkRegion_Op = SkRegion_Op :: kReplace_Op ; } # [ repr ( u32 ) ] # [ doc = " \\enum SkRegion::Op" ] # [ doc = "The logical operations that can be performed when combining two SkRegion." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkRegion_Op { # [ doc = "!< target minus operand" ] kDifference_Op = 0 , # [ doc = "!< target intersected with operand" ] kIntersect_Op = 1 , # [ doc = "!< target unioned with operand" ] kUnion_Op = 2 , # [ doc = "!< target exclusive or with operand" ] kXOR_Op = 3 , # [ doc = "!< operand minus target" ] kReverseDifference_Op = 4 , # [ doc = "!< replace target with operand" ] kReplace_Op = 5 , } # [ doc = " \\class SkRegion::Iterator" ] # [ doc = "Returns sequence of rectangles, sorted along y-axis, then x-axis, that make" ] # [ doc = "up SkRegion." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRegion_Iterator { pub fRgn : * const SkRegion , pub fRuns : * const SkRegion_RunType , pub fRect : SkIRect , pub fDone : bool , } # [ test ] fn bindgen_test_layout_SkRegion_Iterator ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRegion_Iterator > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( SkRegion_Iterator ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRegion_Iterator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkRegion_Iterator ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Iterator > ( ) ) ) . fRgn as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Iterator ) , "::" , stringify ! ( fRgn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Iterator > ( ) ) ) . fRuns as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Iterator ) , "::" , stringify ! ( fRuns ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Iterator > ( ) ) ) . fRect as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Iterator ) , "::" , stringify ! ( fRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Iterator > ( ) ) ) . fDone as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Iterator ) , "::" , stringify ! ( fDone ) ) ) ; } extern "C" { # [ doc = " SkPoint SkRegion::Iterator to start of SkRegion." ] # [ doc = "Returns true if SkRegion was set; otherwise, returns false." ] # [ doc = "" ] # [ doc = "@return  true if SkRegion was set" ] # [ link_name = "\u{1}__ZN8SkRegion8Iterator6rewindEv" ] pub fn SkRegion_Iterator_rewind ( this : * mut SkRegion_Iterator ) -> bool ; } extern "C" { # [ doc = " Resets iterator, using the new SkRegion." ] # [ doc = "" ] # [ doc = "@param region  SkRegion to iterate" ] # [ link_name = "\u{1}__ZN8SkRegion8Iterator5resetERKS_" ] pub fn SkRegion_Iterator_reset ( this : * mut SkRegion_Iterator , region : * const SkRegion ) ; } extern "C" { # [ doc = " Returns true if SkRegion::Iterator is pointing to final SkIRect in SkRegion." ] # [ doc = "" ] # [ doc = "@return  true if data parsing is complete" ] # [ link_name = "\u{1}__ZNK8SkRegion8Iterator4doneEv" ] pub fn SkRegion_Iterator_done ( this : * const SkRegion_Iterator ) -> bool ; } extern "C" { # [ doc = " Advances SkRegion::Iterator to next SkIRect in SkRegion if it is not done." ] # [ link_name = "\u{1}__ZN8SkRegion8Iterator4nextEv" ] pub fn SkRegion_Iterator_next ( this : * mut SkRegion_Iterator ) ; } extern "C" { # [ doc = " Returns SkIRect element in SkRegion. Does not return predictable results if SkRegion" ] # [ doc = "is empty." ] # [ doc = "" ] # [ doc = "@return  part of SkRegion as SkIRect" ] # [ link_name = "\u{1}__ZNK8SkRegion8Iterator4rectEv" ] pub fn SkRegion_Iterator_rect ( this : * const SkRegion_Iterator ) -> * const SkIRect ; } extern "C" { # [ doc = " Returns SkRegion if set; otherwise, returns nullptr." ] # [ doc = "" ] # [ doc = "@return  iterated SkRegion" ] # [ link_name = "\u{1}__ZNK8SkRegion8Iterator3rgnEv" ] pub fn SkRegion_Iterator_rgn ( this : * const SkRegion_Iterator ) -> * const SkRegion ; } extern "C" { # [ doc = " Initializes SkRegion::Iterator with an empty SkRegion. done() on SkRegion::Iterator" ] # [ doc = "returns true." ] # [ doc = "Call reset() to initialized SkRegion::Iterator at a later time." ] # [ doc = "" ] # [ doc = "@return  empty SkRegion iterator" ] # [ link_name = "\u{1}__ZN8SkRegion8IteratorC1Ev" ] pub fn SkRegion_Iterator_Iterator ( this : * mut SkRegion_Iterator ) ; } extern "C" { # [ doc = " Sets SkRegion::Iterator to return elements of SkIRect array in region." ] # [ doc = "" ] # [ doc = "@param region  SkRegion to iterate" ] # [ doc = "@return        SkRegion iterator" ] # [ link_name = "\u{1}__ZN8SkRegion8IteratorC1ERKS_" ] pub fn SkRegion_Iterator_Iterator1 ( this : * mut SkRegion_Iterator , region : * const SkRegion ) ; } impl SkRegion_Iterator { # [ inline ] pub unsafe fn rewind ( & mut self ) -> bool { SkRegion_Iterator_rewind ( self ) } # [ inline ] pub unsafe fn reset ( & mut self , region : * const SkRegion ) { SkRegion_Iterator_reset ( self , region ) } # [ inline ] pub unsafe fn done ( & self ) -> bool { SkRegion_Iterator_done ( self ) } # [ inline ] pub unsafe fn next ( & mut self ) { SkRegion_Iterator_next ( self ) } # [ inline ] pub unsafe fn rect ( & self ) -> * const SkIRect { SkRegion_Iterator_rect ( self ) } # [ inline ] pub unsafe fn rgn ( & self ) -> * const SkRegion { SkRegion_Iterator_rgn ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRegion_Iterator_Iterator ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( region : * const SkRegion ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRegion_Iterator_Iterator1 ( & mut __bindgen_tmp , region ) ; __bindgen_tmp } } # [ doc = " \\class SkRegion::Cliperator" ] # [ doc = "Returns the sequence of rectangles, sorted along y-axis, then x-axis, that make" ] # [ doc = "up SkRegion intersected with the specified clip rectangle." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRegion_Cliperator { pub fIter : SkRegion_Iterator , pub fClip : SkIRect , pub fRect : SkIRect , pub fDone : bool , } # [ test ] fn bindgen_test_layout_SkRegion_Cliperator ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRegion_Cliperator > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( SkRegion_Cliperator ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRegion_Cliperator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkRegion_Cliperator ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Cliperator > ( ) ) ) . fIter as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Cliperator ) , "::" , stringify ! ( fIter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Cliperator > ( ) ) ) . fClip as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Cliperator ) , "::" , stringify ! ( fClip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Cliperator > ( ) ) ) . fRect as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Cliperator ) , "::" , stringify ! ( fRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Cliperator > ( ) ) ) . fDone as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Cliperator ) , "::" , stringify ! ( fDone ) ) ) ; } extern "C" { # [ doc = " Returns true if SkRegion::Cliperator is pointing to final SkIRect in SkRegion." ] # [ doc = "" ] # [ doc = "@return  true if data parsing is complete" ] # [ link_name = "\u{1}__ZN8SkRegion10Cliperator4doneEv" ] pub fn SkRegion_Cliperator_done ( this : * mut SkRegion_Cliperator ) -> bool ; } extern "C" { # [ doc = " Advances iterator to next SkIRect in SkRegion contained by clip." ] # [ link_name = "\u{1}__ZN8SkRegion10Cliperator4nextEv" ] pub fn SkRegion_Cliperator_next ( this : * mut SkRegion_Cliperator ) ; } extern "C" { # [ doc = " Returns SkIRect element in SkRegion, intersected with clip passed to" ] # [ doc = "SkRegion::Cliperator constructor. Does not return predictable results if SkRegion" ] # [ doc = "is empty." ] # [ doc = "" ] # [ doc = "@return  part of SkRegion inside clip as SkIRect" ] # [ link_name = "\u{1}__ZNK8SkRegion10Cliperator4rectEv" ] pub fn SkRegion_Cliperator_rect ( this : * const SkRegion_Cliperator ) -> * const SkIRect ; } extern "C" { # [ doc = " Sets SkRegion::Cliperator to return elements of SkIRect array in SkRegion within clip." ] # [ doc = "" ] # [ doc = "@param region  SkRegion to iterate" ] # [ doc = "@param clip    bounds of iteration" ] # [ doc = "@return        SkRegion iterator" ] # [ link_name = "\u{1}__ZN8SkRegion10CliperatorC1ERKS_RK7SkIRect" ] pub fn SkRegion_Cliperator_Cliperator ( this : * mut SkRegion_Cliperator , region : * const SkRegion , clip : * const SkIRect ) ; } impl SkRegion_Cliperator { # [ inline ] pub unsafe fn done ( & mut self ) -> bool { SkRegion_Cliperator_done ( self ) } # [ inline ] pub unsafe fn next ( & mut self ) { SkRegion_Cliperator_next ( self ) } # [ inline ] pub unsafe fn rect ( & self ) -> * const SkIRect { SkRegion_Cliperator_rect ( self ) } # [ inline ] pub unsafe fn new ( region : * const SkRegion , clip : * const SkIRect ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRegion_Cliperator_Cliperator ( & mut __bindgen_tmp , region , clip ) ; __bindgen_tmp } } # [ doc = " \\class SkRegion::Spanerator" ] # [ doc = "Returns the line segment ends within SkRegion that intersect a horizontal line." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRegion_Spanerator { pub fRuns : * const SkRegion_RunType , pub fLeft : :: std :: os :: raw :: c_int , pub fRight : :: std :: os :: raw :: c_int , pub fDone : bool , } # [ test ] fn bindgen_test_layout_SkRegion_Spanerator ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRegion_Spanerator > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkRegion_Spanerator ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRegion_Spanerator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkRegion_Spanerator ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Spanerator > ( ) ) ) . fRuns as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Spanerator ) , "::" , stringify ! ( fRuns ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Spanerator > ( ) ) ) . fLeft as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Spanerator ) , "::" , stringify ! ( fLeft ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Spanerator > ( ) ) ) . fRight as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Spanerator ) , "::" , stringify ! ( fRight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion_Spanerator > ( ) ) ) . fDone as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion_Spanerator ) , "::" , stringify ! ( fDone ) ) ) ; } extern "C" { # [ doc = " Advances iterator to next span intersecting SkRegion within line segment provided" ] # [ doc = "in constructor. Returns true if interval was found." ] # [ doc = "" ] # [ doc = "@param left   pointer to span start; may be nullptr" ] # [ doc = "@param right  pointer to span end; may be nullptr" ] # [ doc = "@return       true if interval was found" ] # [ link_name = "\u{1}__ZN8SkRegion10Spanerator4nextEPiS1_" ] pub fn SkRegion_Spanerator_next ( this : * mut SkRegion_Spanerator , left : * mut :: std :: os :: raw :: c_int , right : * mut :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Sets SkRegion::Spanerator to return line segments in SkRegion on scan line." ] # [ doc = "" ] # [ doc = "@param region  SkRegion to iterate" ] # [ doc = "@param y       horizontal line to intersect" ] # [ doc = "@param left    bounds of iteration" ] # [ doc = "@param right   bounds of iteration" ] # [ doc = "@return        SkRegion iterator" ] # [ link_name = "\u{1}__ZN8SkRegion10SpaneratorC1ERKS_iii" ] pub fn SkRegion_Spanerator_Spanerator ( this : * mut SkRegion_Spanerator , region : * const SkRegion , y : :: std :: os :: raw :: c_int , left : :: std :: os :: raw :: c_int , right : :: std :: os :: raw :: c_int ) ; } impl SkRegion_Spanerator { # [ inline ] pub unsafe fn next ( & mut self , left : * mut :: std :: os :: raw :: c_int , right : * mut :: std :: os :: raw :: c_int ) -> bool { SkRegion_Spanerator_next ( self , left , right ) } # [ inline ] pub unsafe fn new ( region : * const SkRegion , y : :: std :: os :: raw :: c_int , left : :: std :: os :: raw :: c_int , right : :: std :: os :: raw :: c_int ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRegion_Spanerator_Spanerator ( & mut __bindgen_tmp , region , y , left , right ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkRegion_RunHead { _unused : [ u8 ; 0 ] , } pub const SkRegion_kOpCnt : :: std :: os :: raw :: c_int = 6 ; pub const SkRegion_kOpCount : :: std :: os :: raw :: c_int = 6 ; pub const SkRegion_kRectRegionRuns : :: std :: os :: raw :: c_int = 7 ; extern "C" { # [ link_name = "\u{1}__ZN8SkRegion15kRectRunHeadPtrE" ] pub static SkRegion_kRectRunHeadPtr : * mut SkRegion_RunHead ; } # [ test ] fn bindgen_test_layout_SkRegion ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkRegion > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkRegion ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkRegion > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkRegion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion > ( ) ) ) . fBounds as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkRegion > ( ) ) ) . fRunHead as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkRegion ) , "::" , stringify ! ( fRunHead ) ) ) ; } extern "C" { # [ doc = " Sets SkRegion to src, and returns true if src bounds is not empty." ] # [ doc = "This makes SkRegion and src identical by value. Internally," ] # [ doc = "SkRegion and src share pointer values. The underlying SkRect array is" ] # [ doc = "copied when modified." ] # [ doc = "" ] # [ doc = "Creating a SkRegion copy is very efficient and never allocates memory." ] # [ doc = "SkRegion are always copied by value from the interface; the underlying shared" ] # [ doc = "pointers are not exposed." ] # [ doc = "" ] # [ doc = "@param src  SkRegion to copy" ] # [ doc = "@return     copy of src" ] # [ link_name = "\u{1}__ZN8SkRegion3setERKS_" ] pub fn SkRegion_set ( this : * mut SkRegion , src : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Exchanges SkIRect array of SkRegion and other. swap() internally exchanges pointers," ] # [ doc = "so it is lightweight and does not allocate memory." ] # [ doc = "" ] # [ doc = "swap() usage has largely been replaced by operator=(const SkRegion& region)." ] # [ doc = "SkPath do not copy their content on assignment until they are written to," ] # [ doc = "making assignment as efficient as swap()." ] # [ doc = "" ] # [ doc = "@param other  operator=(const SkRegion& region) set" ] # [ link_name = "\u{1}__ZN8SkRegion4swapERS_" ] pub fn SkRegion_swap ( this : * mut SkRegion , other : * mut SkRegion ) ; } extern "C" { # [ doc = " Returns true if SkRegion is empty." ] # [ doc = "Empty SkRegion has bounds width or height less than or equal to zero." ] # [ doc = "SkRegion() constructs empty SkRegion; setEmpty()" ] # [ doc = "and setRect() with dimensionless data make SkRegion empty." ] # [ doc = "" ] # [ doc = "@return  true if bounds has no width or height" ] # [ link_name = "\u{1}__ZNK8SkRegion7isEmptyEv" ] pub fn SkRegion_isEmpty ( this : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRegion is one SkIRect with positive dimensions." ] # [ doc = "" ] # [ doc = "@return  true if SkRegion contains one SkIRect" ] # [ link_name = "\u{1}__ZNK8SkRegion6isRectEv" ] pub fn SkRegion_isRect ( this : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRegion is described by more than one rectangle." ] # [ doc = "" ] # [ doc = "@return  true if SkRegion contains more than one SkIRect" ] # [ link_name = "\u{1}__ZNK8SkRegion9isComplexEv" ] pub fn SkRegion_isComplex ( this : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Returns minimum and maximum axes values of SkIRect array." ] # [ doc = "Returns (0, 0, 0, 0) if SkRegion is empty." ] # [ doc = "" ] # [ doc = "@return  combined bounds of all SkIRect elements" ] # [ link_name = "\u{1}__ZNK8SkRegion9getBoundsEv" ] pub fn SkRegion_getBounds ( this : * const SkRegion ) -> * const SkIRect ; } extern "C" { # [ doc = " Returns a value that increases with the number of" ] # [ doc = "elements in SkRegion. Returns zero if SkRegion is empty." ] # [ doc = "Returns one if SkRegion equals SkIRect; otherwise, returns" ] # [ doc = "value greater than one indicating that SkRegion is complex." ] # [ doc = "" ] # [ doc = "Call to compare SkRegion for relative complexity." ] # [ doc = "" ] # [ doc = "@return  relative complexity" ] # [ link_name = "\u{1}__ZNK8SkRegion23computeRegionComplexityEv" ] pub fn SkRegion_computeRegionComplexity ( this : * const SkRegion ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Appends outline of SkRegion to path." ] # [ doc = "Returns true if SkRegion is not empty; otherwise, returns false, and leaves path" ] # [ doc = "unmodified." ] # [ doc = "" ] # [ doc = "@param path  SkPath to append to" ] # [ doc = "@return      true if path changed" ] # [ link_name = "\u{1}__ZNK8SkRegion15getBoundaryPathEP6SkPath" ] pub fn SkRegion_getBoundaryPath ( this : * const SkRegion , path : * mut SkPath ) -> bool ; } extern "C" { # [ doc = " Constructs an empty SkRegion. SkRegion is set to empty bounds" ] # [ doc = "at (0, 0) with zero width and height. Always returns false." ] # [ doc = "" ] # [ doc = "@return  false" ] # [ link_name = "\u{1}__ZN8SkRegion8setEmptyEv" ] pub fn SkRegion_setEmpty ( this : * mut SkRegion ) -> bool ; } extern "C" { # [ doc = " Constructs a rectangular SkRegion matching the bounds of rect." ] # [ doc = "If rect is empty, constructs empty and returns false." ] # [ doc = "" ] # [ doc = "@param rect  bounds of constructed SkRegion" ] # [ doc = "@return      true if rect is not empty" ] # [ link_name = "\u{1}__ZN8SkRegion7setRectERK7SkIRect" ] pub fn SkRegion_setRect ( this : * mut SkRegion , rect : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Constructs SkRegion with bounds (left, top, right, bottom)." ] # [ doc = "Returns true if left is less than right and top is less than bottom; otherwise," ] # [ doc = "constructs empty SkRegion and returns false." ] # [ doc = "" ] # [ doc = "@param left    edge of bounds on x-axis" ] # [ doc = "@param top     edge of bounds on y-axis" ] # [ doc = "@param right   edge of bounds on x-axis" ] # [ doc = "@param bottom  edge of bounds on y-axis" ] # [ doc = "@return        rectangular SkRegion" ] # [ link_name = "\u{1}__ZN8SkRegion7setRectEiiii" ] pub fn SkRegion_setRect1 ( this : * mut SkRegion , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool ; } extern "C" { # [ doc = " Constructs SkRegion as the union of SkIRect in rects array. If count is" ] # [ doc = "zero, constructs empty SkRegion. Returns false if constructed SkRegion is empty." ] # [ doc = "" ] # [ doc = "May be faster than repeated calls to op()." ] # [ doc = "" ] # [ doc = "@param rects  array of SkIRect" ] # [ doc = "@param count  array size" ] # [ doc = "@return       true if constructed SkRegion is not empty" ] # [ link_name = "\u{1}__ZN8SkRegion8setRectsEPK7SkIRecti" ] pub fn SkRegion_setRects ( this : * mut SkRegion , rects : * const SkIRect , count : :: std :: os :: raw :: c_int ) -> bool ; } extern "C" { # [ doc = " Constructs a copy of an existing region." ] # [ doc = "Makes two regions identical by value. Internally, region and" ] # [ doc = "the returned result share pointer values. The underlying SkRect array is" ] # [ doc = "copied when modified." ] # [ doc = "" ] # [ doc = "Creating a SkRegion copy is very efficient and never allocates memory." ] # [ doc = "SkRegion are always copied by value from the interface; the underlying shared" ] # [ doc = "pointers are not exposed." ] # [ doc = "" ] # [ doc = "@param region  SkRegion to copy by value" ] # [ doc = "@return        SkRegion to copy by value" ] # [ link_name = "\u{1}__ZN8SkRegion9setRegionERKS_" ] pub fn SkRegion_setRegion ( this : * mut SkRegion , region : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Constructs SkRegion to match outline of path within clip." ] # [ doc = "Returns false if constructed SkRegion is empty." ] # [ doc = "" ] # [ doc = "Constructed SkRegion draws the same pixels as path through clip when" ] # [ doc = "anti-aliasing is disabled." ] # [ doc = "" ] # [ doc = "@param path  SkPath providing outline" ] # [ doc = "@param clip  SkRegion containing path" ] # [ doc = "@return      true if constructed SkRegion is not empty" ] # [ link_name = "\u{1}__ZN8SkRegion7setPathERK6SkPathRKS_" ] pub fn SkRegion_setPath ( this : * mut SkRegion , path : * const SkPath , clip : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRegion intersects rect." ] # [ doc = "Returns false if either rect or SkRegion is empty, or do not intersect." ] # [ doc = "" ] # [ doc = "@param rect  SkIRect to intersect" ] # [ doc = "@return      true if rect and SkRegion have area in common" ] # [ link_name = "\u{1}__ZNK8SkRegion10intersectsERK7SkIRect" ] pub fn SkRegion_intersects ( this : * const SkRegion , rect : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRegion intersects other." ] # [ doc = "Returns false if either other or SkRegion is empty, or do not intersect." ] # [ doc = "" ] # [ doc = "@param other  SkRegion to intersect" ] # [ doc = "@return       true if other and SkRegion have area in common" ] # [ link_name = "\u{1}__ZNK8SkRegion10intersectsERKS_" ] pub fn SkRegion_intersects1 ( this : * const SkRegion , other : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Returns true if SkIPoint (x, y) is inside SkRegion." ] # [ doc = "Returns false if SkRegion is empty." ] # [ doc = "" ] # [ doc = "@param x  test SkIPoint x-coordinate" ] # [ doc = "@param y  test SkIPoint y-coordinate" ] # [ doc = "@return   true if (x, y) is inside SkRegion" ] # [ link_name = "\u{1}__ZNK8SkRegion8containsEii" ] pub fn SkRegion_contains ( this : * const SkRegion , x : i32 , y : i32 ) -> bool ; } extern "C" { # [ doc = " Returns true if other is completely inside SkRegion." ] # [ doc = "Returns false if SkRegion or other is empty." ] # [ doc = "" ] # [ doc = "@param other  SkIRect to contain" ] # [ doc = "@return       true if other is inside SkRegion" ] # [ link_name = "\u{1}__ZNK8SkRegion8containsERK7SkIRect" ] pub fn SkRegion_contains1 ( this : * const SkRegion , other : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if other is completely inside SkRegion." ] # [ doc = "Returns false if SkRegion or other is empty." ] # [ doc = "" ] # [ doc = "@param other  SkRegion to contain" ] # [ doc = "@return       true if other is inside SkRegion" ] # [ link_name = "\u{1}__ZNK8SkRegion8containsERKS_" ] pub fn SkRegion_contains2 ( this : * const SkRegion , other : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRegion is a single rectangle and contains r." ] # [ doc = "May return false even though SkRegion contains r." ] # [ doc = "" ] # [ doc = "@param r  SkIRect to contain" ] # [ doc = "@return   true quickly if r points are equal or inside" ] # [ link_name = "\u{1}__ZNK8SkRegion13quickContainsERK7SkIRect" ] pub fn SkRegion_quickContains ( this : * const SkRegion , r : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRegion is a single rectangle and contains SkIRect" ] # [ doc = "(left, top, right, bottom)." ] # [ doc = "Returns false if SkRegion is empty or SkIRect (left, top, right, bottom) is empty." ] # [ doc = "May return false even though SkRegion contains (left, top, right, bottom)." ] # [ doc = "" ] # [ doc = "@param left    edge of bounds on x-axis" ] # [ doc = "@param top     edge of bounds on y-axis" ] # [ doc = "@param right   edge of bounds on x-axis" ] # [ doc = "@param bottom  edge of bounds on y-axis" ] # [ doc = "@return        true quickly if SkIRect are equal or inside" ] # [ link_name = "\u{1}__ZNK8SkRegion13quickContainsEiiii" ] pub fn SkRegion_quickContains1 ( this : * const SkRegion , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRegion does not intersect rect." ] # [ doc = "Returns true if rect is empty or SkRegion is empty." ] # [ doc = "May return false even though SkRegion does not intersect rect." ] # [ doc = "" ] # [ doc = "@param rect  SkIRect to intersect" ] # [ doc = "@return      true if rect does not intersect" ] # [ link_name = "\u{1}__ZNK8SkRegion11quickRejectERK7SkIRect" ] pub fn SkRegion_quickReject ( this : * const SkRegion , rect : * const SkIRect ) -> bool ; } extern "C" { # [ doc = " Returns true if SkRegion does not intersect rgn." ] # [ doc = "Returns true if rgn is empty or SkRegion is empty." ] # [ doc = "May return false even though SkRegion does not intersect rgn." ] # [ doc = "" ] # [ doc = "@param rgn  SkRegion to intersect" ] # [ doc = "@return     true if rgn does not intersect" ] # [ link_name = "\u{1}__ZNK8SkRegion11quickRejectERKS_" ] pub fn SkRegion_quickReject1 ( this : * const SkRegion , rgn : * const SkRegion ) -> bool ; } extern "C" { # [ doc = " Offsets SkRegion by ivector (dx, dy). Has no effect if SkRegion is empty." ] # [ doc = "" ] # [ doc = "@param dx  x-axis offset" ] # [ doc = "@param dy  y-axis offset" ] # [ link_name = "\u{1}__ZN8SkRegion9translateEii" ] pub fn SkRegion_translate ( this : * mut SkRegion , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ doc = " Offsets SkRegion by ivector (dx, dy), writing result to dst. SkRegion may be passed" ] # [ doc = "as dst parameter, translating SkRegion in place. Has no effect if dst is nullptr." ] # [ doc = "If SkRegion is empty, sets dst to empty." ] # [ doc = "" ] # [ doc = "@param dx   x-axis offset" ] # [ doc = "@param dy   y-axis offset" ] # [ doc = "@param dst  translated result" ] # [ link_name = "\u{1}__ZNK8SkRegion9translateEiiPS_" ] pub fn SkRegion_translate1 ( this : * const SkRegion , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int , dst : * mut SkRegion ) ; } extern "C" { # [ doc = " Replaces SkRegion with the result of SkRegion op rect." ] # [ doc = "Returns true if replaced SkRegion is not empty." ] # [ doc = "" ] # [ doc = "@param rect  SkIRect operand" ] # [ doc = "@param op    operator, one of:" ] # [ doc = "kDifference_Op, kIntersect_Op, kUnion_Op, kXOR_Op, kReverseDifference_Op," ] # [ doc = "kReplace_Op" ] # [ doc = "@return      false if result is empty" ] # [ link_name = "\u{1}__ZN8SkRegion2opERK7SkIRectNS_2OpE" ] pub fn SkRegion_op ( this : * mut SkRegion , rect : * const SkIRect , op : SkRegion_Op ) -> bool ; } extern "C" { # [ doc = " Replaces SkRegion with the result of SkRegion op SkIRect (left, top, right, bottom)." ] # [ doc = "Returns true if replaced SkRegion is not empty." ] # [ doc = "" ] # [ doc = "@param left    edge of bounds on x-axis" ] # [ doc = "@param top     edge of bounds on y-axis" ] # [ doc = "@param right   edge of bounds on x-axis" ] # [ doc = "@param bottom  edge of bounds on y-axis" ] # [ doc = "@param op      operator, one of:" ] # [ doc = "kDifference_Op, kIntersect_Op, kUnion_Op, kXOR_Op, kReverseDifference_Op," ] # [ doc = "kReplace_Op" ] # [ doc = "@return        false if result is empty" ] # [ link_name = "\u{1}__ZN8SkRegion2opEiiiiNS_2OpE" ] pub fn SkRegion_op1 ( this : * mut SkRegion , left : :: std :: os :: raw :: c_int , top : :: std :: os :: raw :: c_int , right : :: std :: os :: raw :: c_int , bottom : :: std :: os :: raw :: c_int , op : SkRegion_Op ) -> bool ; } extern "C" { # [ doc = " Replaces SkRegion with the result of SkRegion op rgn." ] # [ doc = "Returns true if replaced SkRegion is not empty." ] # [ doc = "" ] # [ doc = "@param rgn  SkRegion operand" ] # [ doc = "@param op   operator, one of:" ] # [ doc = "kDifference_Op, kIntersect_Op, kUnion_Op, kXOR_Op, kReverseDifference_Op," ] # [ doc = "kReplace_Op" ] # [ doc = "@return     false if result is empty" ] # [ link_name = "\u{1}__ZN8SkRegion2opERKS_NS_2OpE" ] pub fn SkRegion_op2 ( this : * mut SkRegion , rgn : * const SkRegion , op : SkRegion_Op ) -> bool ; } extern "C" { # [ doc = " Replaces SkRegion with the result of rect op rgn." ] # [ doc = "Returns true if replaced SkRegion is not empty." ] # [ doc = "" ] # [ doc = "@param rect  SkIRect operand" ] # [ doc = "@param rgn   SkRegion operand" ] # [ doc = "@param op    operator, one of:" ] # [ doc = "kDifference_Op, kIntersect_Op, kUnion_Op, kXOR_Op, kReverseDifference_Op," ] # [ doc = "kReplace_Op" ] # [ doc = "@return      false if result is empty" ] # [ link_name = "\u{1}__ZN8SkRegion2opERK7SkIRectRKS_NS_2OpE" ] pub fn SkRegion_op3 ( this : * mut SkRegion , rect : * const SkIRect , rgn : * const SkRegion , op : SkRegion_Op ) -> bool ; } extern "C" { # [ doc = " Replaces SkRegion with the result of rgn op rect." ] # [ doc = "Returns true if replaced SkRegion is not empty." ] # [ doc = "" ] # [ doc = "@param rgn   SkRegion operand" ] # [ doc = "@param rect  SkIRect operand" ] # [ doc = "@param op    operator, one of:" ] # [ doc = "kDifference_Op, kIntersect_Op, kUnion_Op, kXOR_Op, kReverseDifference_Op," ] # [ doc = "kReplace_Op" ] # [ doc = "@return      false if result is empty" ] # [ link_name = "\u{1}__ZN8SkRegion2opERKS_RK7SkIRectNS_2OpE" ] pub fn SkRegion_op4 ( this : * mut SkRegion , rgn : * const SkRegion , rect : * const SkIRect , op : SkRegion_Op ) -> bool ; } extern "C" { # [ doc = " Replaces SkRegion with the result of rgna op rgnb." ] # [ doc = "Returns true if replaced SkRegion is not empty." ] # [ doc = "" ] # [ doc = "@param rgna  SkRegion operand" ] # [ doc = "@param rgnb  SkRegion operand" ] # [ doc = "@param op    operator, one of:" ] # [ doc = "kDifference_Op, kIntersect_Op, kUnion_Op, kXOR_Op, kReverseDifference_Op," ] # [ doc = "kReplace_Op" ] # [ doc = "@return      false if result is empty" ] # [ link_name = "\u{1}__ZN8SkRegion2opERKS_S1_NS_2OpE" ] pub fn SkRegion_op5 ( this : * mut SkRegion , rgna : * const SkRegion , rgnb : * const SkRegion , op : SkRegion_Op ) -> bool ; } extern "C" { # [ doc = " Writes SkRegion to buffer, and returns number of bytes written." ] # [ doc = "If buffer is nullptr, returns number number of bytes that would be written." ] # [ doc = "" ] # [ doc = "@param buffer  storage for binary data" ] # [ doc = "@return        size of SkRegion" ] # [ link_name = "\u{1}__ZNK8SkRegion13writeToMemoryEPv" ] pub fn SkRegion_writeToMemory ( this : * const SkRegion , buffer : * mut :: std :: os :: raw :: c_void ) -> usize ; } extern "C" { # [ doc = " Constructs SkRegion from buffer of size length. Returns bytes read." ] # [ doc = "Returned value will be multiple of four or zero if length was too small." ] # [ doc = "" ] # [ doc = "@param buffer  storage for binary data" ] # [ doc = "@param length  size of buffer" ] # [ doc = "@return        bytes read" ] # [ link_name = "\u{1}__ZN8SkRegion14readFromMemoryEPKvm" ] pub fn SkRegion_readFromMemory ( this : * mut SkRegion , buffer : * const :: std :: os :: raw :: c_void , length : usize ) -> usize ; } extern "C" { # [ doc = " Constructs an empty SkRegion. SkRegion is set to empty bounds" ] # [ doc = "at (0, 0) with zero width and height." ] # [ doc = "" ] # [ doc = "@return  empty SkRegion" ] # [ link_name = "\u{1}__ZN8SkRegionC1Ev" ] pub fn SkRegion_SkRegion ( this : * mut SkRegion ) ; } extern "C" { # [ doc = " Constructs a copy of an existing region." ] # [ doc = "Copy constructor makes two regions identical by value. Internally, region and" ] # [ doc = "the returned result share pointer values. The underlying SkRect array is" ] # [ doc = "copied when modified." ] # [ doc = "" ] # [ doc = "Creating a SkRegion copy is very efficient and never allocates memory." ] # [ doc = "SkRegion are always copied by value from the interface; the underlying shared" ] # [ doc = "pointers are not exposed." ] # [ doc = "" ] # [ doc = "@param region  SkRegion to copy by value" ] # [ doc = "@return        copy of SkRegion" ] # [ link_name = "\u{1}__ZN8SkRegionC1ERKS_" ] pub fn SkRegion_SkRegion1 ( this : * mut SkRegion , region : * const SkRegion ) ; } extern "C" { # [ doc = " Constructs a rectangular SkRegion matching the bounds of rect." ] # [ doc = "" ] # [ doc = "@param rect  bounds of constructed SkRegion" ] # [ doc = "@return      rectangular SkRegion" ] # [ link_name = "\u{1}__ZN8SkRegionC1ERK7SkIRect" ] pub fn SkRegion_SkRegion2 ( this : * mut SkRegion , rect : * const SkIRect ) ; } extern "C" { # [ doc = " Releases ownership of any shared data and deletes data if SkRegion is sole owner." ] # [ link_name = "\u{1}__ZN8SkRegionD1Ev" ] pub fn SkRegion_SkRegion_destructor ( this : * mut SkRegion ) ; } impl SkRegion { # [ inline ] pub unsafe fn set ( & mut self , src : * const SkRegion ) -> bool { SkRegion_set ( self , src ) } # [ inline ] pub unsafe fn swap ( & mut self , other : * mut SkRegion ) { SkRegion_swap ( self , other ) } # [ inline ] pub unsafe fn isEmpty ( & self ) -> bool { SkRegion_isEmpty ( self ) } # [ inline ] pub unsafe fn isRect ( & self ) -> bool { SkRegion_isRect ( self ) } # [ inline ] pub unsafe fn isComplex ( & self ) -> bool { SkRegion_isComplex ( self ) } # [ inline ] pub unsafe fn getBounds ( & self ) -> * const SkIRect { SkRegion_getBounds ( self ) } # [ inline ] pub unsafe fn computeRegionComplexity ( & self ) -> :: std :: os :: raw :: c_int { SkRegion_computeRegionComplexity ( self ) } # [ inline ] pub unsafe fn getBoundaryPath ( & self , path : * mut SkPath ) -> bool { SkRegion_getBoundaryPath ( self , path ) } # [ inline ] pub unsafe fn setEmpty ( & mut self ) -> bool { SkRegion_setEmpty ( self ) } # [ inline ] pub unsafe fn setRect ( & mut self , rect : * const SkIRect ) -> bool { SkRegion_setRect ( self , rect ) } # [ inline ] pub unsafe fn setRect1 ( & mut self , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool { SkRegion_setRect1 ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn setRects ( & mut self , rects : * const SkIRect , count : :: std :: os :: raw :: c_int ) -> bool { SkRegion_setRects ( self , rects , count ) } # [ inline ] pub unsafe fn setRegion ( & mut self , region : * const SkRegion ) -> bool { SkRegion_setRegion ( self , region ) } # [ inline ] pub unsafe fn setPath ( & mut self , path : * const SkPath , clip : * const SkRegion ) -> bool { SkRegion_setPath ( self , path , clip ) } # [ inline ] pub unsafe fn intersects ( & self , rect : * const SkIRect ) -> bool { SkRegion_intersects ( self , rect ) } # [ inline ] pub unsafe fn intersects1 ( & self , other : * const SkRegion ) -> bool { SkRegion_intersects1 ( self , other ) } # [ inline ] pub unsafe fn contains ( & self , x : i32 , y : i32 ) -> bool { SkRegion_contains ( self , x , y ) } # [ inline ] pub unsafe fn contains1 ( & self , other : * const SkIRect ) -> bool { SkRegion_contains1 ( self , other ) } # [ inline ] pub unsafe fn contains2 ( & self , other : * const SkRegion ) -> bool { SkRegion_contains2 ( self , other ) } # [ inline ] pub unsafe fn quickContains ( & self , r : * const SkIRect ) -> bool { SkRegion_quickContains ( self , r ) } # [ inline ] pub unsafe fn quickContains1 ( & self , left : i32 , top : i32 , right : i32 , bottom : i32 ) -> bool { SkRegion_quickContains1 ( self , left , top , right , bottom ) } # [ inline ] pub unsafe fn quickReject ( & self , rect : * const SkIRect ) -> bool { SkRegion_quickReject ( self , rect ) } # [ inline ] pub unsafe fn quickReject1 ( & self , rgn : * const SkRegion ) -> bool { SkRegion_quickReject1 ( self , rgn ) } # [ inline ] pub unsafe fn translate ( & mut self , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int ) { SkRegion_translate ( self , dx , dy ) } # [ inline ] pub unsafe fn translate1 ( & self , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int , dst : * mut SkRegion ) { SkRegion_translate1 ( self , dx , dy , dst ) } # [ inline ] pub unsafe fn op ( & mut self , rect : * const SkIRect , op : SkRegion_Op ) -> bool { SkRegion_op ( self , rect , op ) } # [ inline ] pub unsafe fn op1 ( & mut self , left : :: std :: os :: raw :: c_int , top : :: std :: os :: raw :: c_int , right : :: std :: os :: raw :: c_int , bottom : :: std :: os :: raw :: c_int , op : SkRegion_Op ) -> bool { SkRegion_op1 ( self , left , top , right , bottom , op ) } # [ inline ] pub unsafe fn op2 ( & mut self , rgn : * const SkRegion , op : SkRegion_Op ) -> bool { SkRegion_op2 ( self , rgn , op ) } # [ inline ] pub unsafe fn op3 ( & mut self , rect : * const SkIRect , rgn : * const SkRegion , op : SkRegion_Op ) -> bool { SkRegion_op3 ( self , rect , rgn , op ) } # [ inline ] pub unsafe fn op4 ( & mut self , rgn : * const SkRegion , rect : * const SkIRect , op : SkRegion_Op ) -> bool { SkRegion_op4 ( self , rgn , rect , op ) } # [ inline ] pub unsafe fn op5 ( & mut self , rgna : * const SkRegion , rgnb : * const SkRegion , op : SkRegion_Op ) -> bool { SkRegion_op5 ( self , rgna , rgnb , op ) } # [ inline ] pub unsafe fn writeToMemory ( & self , buffer : * mut :: std :: os :: raw :: c_void ) -> usize { SkRegion_writeToMemory ( self , buffer ) } # [ inline ] pub unsafe fn readFromMemory ( & mut self , buffer : * const :: std :: os :: raw :: c_void , length : usize ) -> usize { SkRegion_readFromMemory ( self , buffer , length ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRegion_SkRegion ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( region : * const SkRegion ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRegion_SkRegion1 ( & mut __bindgen_tmp , region ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( rect : * const SkIRect ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkRegion_SkRegion2 ( & mut __bindgen_tmp , rect ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkRegion_SkRegion_destructor ( self ) } } # [ doc = " \\class SkFont" ] # [ doc = "SkFont controls options applied when drawing and measuring text." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkFont { pub fTypeface : sk_sp < SkTypeface > , pub fSize : SkScalar , pub fScaleX : SkScalar , pub fSkewX : SkScalar , pub fFlags : u8 , pub fEdging : u8 , pub fHinting : u8 , } # [ repr ( i32 ) ] # [ doc = " Whether edge pixels draw opaque or with partial transparency." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkFont_Edging { # [ doc = "!< no transparent pixels on glyph edges" ] kAlias = 0 , # [ doc = "!< may have transparent pixels on glyph edges" ] kAntiAlias = 1 , # [ doc = "!< glyph positioned in pixel using transparency" ] kSubpixelAntiAlias = 2 , } pub const SkFont_PrivFlags_kForceAutoHinting_PrivFlag : SkFont_PrivFlags = 1 ; pub const SkFont_PrivFlags_kEmbeddedBitmaps_PrivFlag : SkFont_PrivFlags = 2 ; pub const SkFont_PrivFlags_kSubpixel_PrivFlag : SkFont_PrivFlags = 4 ; pub const SkFont_PrivFlags_kLinearMetrics_PrivFlag : SkFont_PrivFlags = 8 ; pub const SkFont_PrivFlags_kEmbolden_PrivFlag : SkFont_PrivFlags = 16 ; pub type SkFont_PrivFlags = u32 ; pub const SkFont_kAllFlags : :: std :: os :: raw :: c_uint = 31 ; # [ test ] fn bindgen_test_layout_SkFont ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFont > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SkFont ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFont > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkFont ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFont > ( ) ) ) . fTypeface as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkFont ) , "::" , stringify ! ( fTypeface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFont > ( ) ) ) . fSize as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkFont ) , "::" , stringify ! ( fSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFont > ( ) ) ) . fScaleX as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkFont ) , "::" , stringify ! ( fScaleX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFont > ( ) ) ) . fSkewX as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkFont ) , "::" , stringify ! ( fSkewX ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFont > ( ) ) ) . fFlags as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SkFont ) , "::" , stringify ! ( fFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFont > ( ) ) ) . fEdging as * const _ as usize } , 21usize , concat ! ( "Offset of field: " , stringify ! ( SkFont ) , "::" , stringify ! ( fEdging ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFont > ( ) ) ) . fHinting as * const _ as usize } , 22usize , concat ! ( "Offset of field: " , stringify ! ( SkFont ) , "::" , stringify ! ( fHinting ) ) ) ; } extern "C" { # [ doc = " If true, instructs the font manager to always hint glyphs." ] # [ doc = "Returned value is only meaningful if platform uses FreeType as the font manager." ] # [ doc = "" ] # [ doc = "@return  true if all glyphs are hinted" ] # [ link_name = "\u{1}__ZNK6SkFont18isForceAutoHintingEv" ] pub fn SkFont_isForceAutoHinting ( this : * const SkFont ) -> bool ; } extern "C" { # [ doc = " Returns true if font engine may return glyphs from font bitmaps instead of from outlines." ] # [ doc = "" ] # [ doc = "@return  true if glyphs may be font bitmaps" ] # [ link_name = "\u{1}__ZNK6SkFont17isEmbeddedBitmapsEv" ] pub fn SkFont_isEmbeddedBitmaps ( this : * const SkFont ) -> bool ; } extern "C" { # [ doc = " Returns true if glyphs at different sub-pixel positions may differ on pixel edge coverage." ] # [ doc = "" ] # [ doc = "@return  true if glyph positioned in pixel using transparency" ] # [ link_name = "\u{1}__ZNK6SkFont10isSubpixelEv" ] pub fn SkFont_isSubpixel ( this : * const SkFont ) -> bool ; } extern "C" { # [ doc = " Returns true if text is converted to SkPath before drawing and measuring." ] # [ doc = "" ] # [ doc = "@return  true glyph hints are never applied" ] # [ link_name = "\u{1}__ZNK6SkFont15isLinearMetricsEv" ] pub fn SkFont_isLinearMetrics ( this : * const SkFont ) -> bool ; } extern "C" { # [ doc = " Returns true if bold is approximated by increasing the stroke width when creating glyph" ] # [ doc = "bitmaps from outlines." ] # [ doc = "" ] # [ doc = "@return  bold is approximated through stroke width" ] # [ link_name = "\u{1}__ZNK6SkFont10isEmboldenEv" ] pub fn SkFont_isEmbolden ( this : * const SkFont ) -> bool ; } extern "C" { # [ doc = " Sets whether to always hint glyphs." ] # [ doc = "If forceAutoHinting is set, instructs the font manager to always hint glyphs." ] # [ doc = "" ] # [ doc = "Only affects platforms that use FreeType as the font manager." ] # [ doc = "" ] # [ doc = "@param forceAutoHinting  setting to always hint glyphs" ] # [ link_name = "\u{1}__ZN6SkFont19setForceAutoHintingEb" ] pub fn SkFont_setForceAutoHinting ( this : * mut SkFont , forceAutoHinting : bool ) ; } extern "C" { # [ doc = " Requests, but does not require, to use bitmaps in fonts instead of outlines." ] # [ doc = "" ] # [ doc = "@param embeddedBitmaps  setting to use bitmaps in fonts" ] # [ link_name = "\u{1}__ZN6SkFont18setEmbeddedBitmapsEb" ] pub fn SkFont_setEmbeddedBitmaps ( this : * mut SkFont , embeddedBitmaps : bool ) ; } extern "C" { # [ doc = " Requests, but does not require, that glyphs respect sub-pixel positioning." ] # [ doc = "" ] # [ doc = "@param subpixel  setting for sub-pixel positioning" ] # [ link_name = "\u{1}__ZN6SkFont11setSubpixelEb" ] pub fn SkFont_setSubpixel ( this : * mut SkFont , subpixel : bool ) ; } extern "C" { # [ doc = " Requests, but does not require, that glyphs are converted to SkPath" ] # [ doc = "before drawing and measuring." ] # [ doc = "" ] # [ doc = "@param linearMetrics  setting for converting glyphs to paths" ] # [ link_name = "\u{1}__ZN6SkFont16setLinearMetricsEb" ] pub fn SkFont_setLinearMetrics ( this : * mut SkFont , linearMetrics : bool ) ; } extern "C" { # [ doc = " Increases stroke width when creating glyph bitmaps to approximate a bold typeface." ] # [ doc = "" ] # [ doc = "@param embolden  setting for bold approximation" ] # [ link_name = "\u{1}__ZN6SkFont11setEmboldenEb" ] pub fn SkFont_setEmbolden ( this : * mut SkFont , embolden : bool ) ; } extern "C" { # [ doc = " Whether edge pixels draw opaque or with partial transparency." ] # [ doc = "" ] # [ doc = "@return  one of: Edging::kAlias, Edging::kAntiAlias, Edging::kSubpixelAntiAlias" ] # [ link_name = "\u{1}__ZNK6SkFont9getEdgingEv" ] pub fn SkFont_getEdging ( this : * const SkFont ) -> SkFont_Edging ; } extern "C" { # [ doc = " Requests, but does not require, that edge pixels draw opaque or with" ] # [ doc = "partial transparency." ] # [ doc = "" ] # [ doc = "@param edging  one of: Edging::kAlias, Edging::kAntiAlias, Edging::kSubpixelAntiAlias" ] # [ link_name = "\u{1}__ZN6SkFont9setEdgingENS_6EdgingE" ] pub fn SkFont_setEdging ( this : * mut SkFont , edging : SkFont_Edging ) ; } extern "C" { # [ doc = " Sets level of glyph outline adjustment." ] # [ doc = "Does not check for valid values of hintingLevel." ] # [ doc = "" ] # [ doc = "@param hintingLevel  one of: SkFontHinting::kNone, SkFontHinting::kSlight," ] # [ doc = "SkFontHinting::kNormal, SkFontHinting::kFull" ] # [ link_name = "\u{1}__ZN6SkFont10setHintingE13SkFontHinting" ] pub fn SkFont_setHinting ( this : * mut SkFont , hintingLevel : SkFontHinting ) ; } extern "C" { # [ doc = " Returns level of glyph outline adjustment." ] # [ doc = "" ] # [ doc = "@return  one of: SkFontHinting::kNone, SkFontHinting::kSlight, SkFontHinting::kNormal," ] # [ doc = "SkFontHinting::kFull" ] # [ link_name = "\u{1}__ZNK6SkFont10getHintingEv" ] pub fn SkFont_getHinting ( this : * const SkFont ) -> SkFontHinting ; } extern "C" { # [ doc = " Returns a font with the same attributes of this font, but with the specified size." ] # [ doc = "Returns nullptr if size is less than zero, infinite, or NaN." ] # [ doc = "" ] # [ doc = "@param size  typographic height of text" ] # [ doc = "@return      initialized SkFont" ] # [ link_name = "\u{1}__ZNK6SkFont12makeWithSizeEf" ] pub fn SkFont_makeWithSize ( this : * const SkFont , size : SkScalar ) -> SkFont ; } extern "C" { # [ doc = " Returns SkTypeface if set, or nullptr." ] # [ doc = "Does not alter SkTypeface SkRefCnt." ] # [ doc = "" ] # [ doc = "@return  SkTypeface if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK6SkFont11getTypefaceEv" ] pub fn SkFont_getTypeface ( this : * const SkFont ) -> * mut SkTypeface ; } extern "C" { # [ doc = " Returns SkTypeface if set, or the default typeface." ] # [ doc = "Does not alter SkTypeface SkRefCnt." ] # [ doc = "" ] # [ doc = "@return  SkTypeface if previously set or, a pointer to the default typeface if not" ] # [ doc = "previously set." ] # [ link_name = "\u{1}__ZNK6SkFont20getTypefaceOrDefaultEv" ] pub fn SkFont_getTypefaceOrDefault ( this : * const SkFont ) -> * mut SkTypeface ; } extern "C" { # [ doc = " Returns text size in points." ] # [ doc = "" ] # [ doc = "@return  typographic height of text" ] # [ link_name = "\u{1}__ZNK6SkFont7getSizeEv" ] pub fn SkFont_getSize ( this : * const SkFont ) -> SkScalar ; } extern "C" { # [ doc = " Returns text scale on x-axis." ] # [ doc = "Default value is 1." ] # [ doc = "" ] # [ doc = "@return  text horizontal scale" ] # [ link_name = "\u{1}__ZNK6SkFont9getScaleXEv" ] pub fn SkFont_getScaleX ( this : * const SkFont ) -> SkScalar ; } extern "C" { # [ doc = " Returns text skew on x-axis." ] # [ doc = "Default value is zero." ] # [ doc = "" ] # [ doc = "@return  additional shear on x-axis relative to y-axis" ] # [ link_name = "\u{1}__ZNK6SkFont8getSkewXEv" ] pub fn SkFont_getSkewX ( this : * const SkFont ) -> SkScalar ; } extern "C" { # [ doc = " Increases SkTypeface SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@return  SkTypeface if previously set, nullptr otherwise" ] # [ link_name = "\u{1}__ZNK6SkFont11refTypefaceEv" ] pub fn SkFont_refTypeface ( this : * const SkFont ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Increases SkTypeface SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@return  SkTypeface if previously set or, a pointer to the default typeface if not" ] # [ doc = "previously set." ] # [ link_name = "\u{1}__ZNK6SkFont20refTypefaceOrDefaultEv" ] pub fn SkFont_refTypefaceOrDefault ( this : * const SkFont ) -> sk_sp < SkTypeface > ; } extern "C" { # [ doc = " Sets SkTypeface to typeface, decreasing SkRefCnt of the previous SkTypeface." ] # [ doc = "Pass nullptr to clear SkTypeface and use the default typeface. Increments" ] # [ doc = "tf SkRefCnt by one." ] # [ doc = "" ] # [ doc = "@param tf  font and style used to draw text" ] # [ link_name = "\u{1}__ZN6SkFont11setTypefaceE5sk_spI10SkTypefaceE" ] pub fn SkFont_setTypeface ( this : * mut SkFont , tf : sk_sp < SkTypeface > ) ; } extern "C" { # [ doc = " Sets text size in points." ] # [ doc = "Has no effect if textSize is not greater than or equal to zero." ] # [ doc = "" ] # [ doc = "@param textSize  typographic height of text" ] # [ link_name = "\u{1}__ZN6SkFont7setSizeEf" ] pub fn SkFont_setSize ( this : * mut SkFont , textSize : SkScalar ) ; } extern "C" { # [ doc = " Sets text scale on x-axis." ] # [ doc = "Default value is 1." ] # [ doc = "" ] # [ doc = "@param scaleX  text horizontal scale" ] # [ link_name = "\u{1}__ZN6SkFont9setScaleXEf" ] pub fn SkFont_setScaleX ( this : * mut SkFont , scaleX : SkScalar ) ; } extern "C" { # [ doc = " Sets text skew on x-axis." ] # [ doc = "Default value is zero." ] # [ doc = "" ] # [ doc = "@param skewX  additional shear on x-axis relative to y-axis" ] # [ link_name = "\u{1}__ZN6SkFont8setSkewXEf" ] pub fn SkFont_setSkewX ( this : * mut SkFont , skewX : SkScalar ) ; } extern "C" { # [ doc = " Converts text into glyph indices." ] # [ doc = "Returns the number of glyph indices represented by text." ] # [ doc = "SkTextEncoding specifies how text represents characters or glyphs." ] # [ doc = "glyphs may be nullptr, to compute the glyph count." ] # [ doc = "" ] # [ doc = "Does not check text for valid character codes or valid glyph indices." ] # [ doc = "" ] # [ doc = "If byteLength equals zero, returns zero." ] # [ doc = "If byteLength includes a partial character, the partial character is ignored." ] # [ doc = "" ] # [ doc = "If encoding is kUTF8_SkTextEncoding and text contains an invalid UTF-8 sequence," ] # [ doc = "zero is returned." ] # [ doc = "" ] # [ doc = "When encoding is SkTextEncoding::kUTF8, SkTextEncoding::kUTF16, or" ] # [ doc = "SkTextEncoding::kUTF32; then each Unicode codepoint is mapped to a" ] # [ doc = "single glyph.  This function uses the default character-to-glyph" ] # [ doc = "mapping from the SkTypeface and maps characters not found in the" ] # [ doc = "SkTypeface to zero." ] # [ doc = "" ] # [ doc = "If maxGlyphCount is not sufficient to store all the glyphs, no glyphs are copied." ] # [ doc = "The total glyph count is returned for subsequent buffer reallocation." ] # [ doc = "" ] # [ doc = "@param text          character storage encoded with SkTextEncoding" ] # [ doc = "@param byteLength    length of character storage in bytes" ] # [ doc = "@param encoding      one of: kUTF8_SkTextEncoding, kUTF16_SkTextEncoding," ] # [ doc = "kUTF32_SkTextEncoding, kGlyphID_SkTextEncoding" ] # [ doc = "@param glyphs        storage for glyph indices; may be nullptr" ] # [ doc = "@param maxGlyphCount storage capacity" ] # [ doc = "@return              number of glyphs represented by text of length byteLength" ] # [ link_name = "\u{1}__ZNK6SkFont12textToGlyphsEPKvm14SkTextEncodingPti" ] pub fn SkFont_textToGlyphs ( this : * const SkFont , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding , glyphs : * mut SkGlyphID , maxGlyphCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns glyph index for Unicode character." ] # [ doc = "" ] # [ doc = "If the character is not supported by the SkTypeface, returns 0." ] # [ doc = "" ] # [ doc = "@param uni  Unicode character" ] # [ doc = "@return     glyph index" ] # [ link_name = "\u{1}__ZNK6SkFont14unicharToGlyphEi" ] pub fn SkFont_unicharToGlyph ( this : * const SkFont , uni : SkUnichar ) -> SkGlyphID ; } extern "C" { # [ doc = " Returns number of glyphs represented by text." ] # [ doc = "" ] # [ doc = "If encoding is kUTF8_SkTextEncoding, kUTF16_SkTextEncoding, or" ] # [ doc = "kUTF32_SkTextEncoding; then each Unicode codepoint is mapped to a" ] # [ doc = "single glyph." ] # [ doc = "" ] # [ doc = "@param text          character storage encoded with SkTextEncoding" ] # [ doc = "@param byteLength    length of character storage in bytes" ] # [ doc = "@param encoding      one of: kUTF8_SkTextEncoding, kUTF16_SkTextEncoding," ] # [ doc = "kUTF32_SkTextEncoding, kGlyphID_SkTextEncoding" ] # [ doc = "@return              number of glyphs represented by text of length byteLength" ] # [ link_name = "\u{1}__ZNK6SkFont9countTextEPKvm14SkTextEncoding" ] pub fn SkFont_countText ( this : * const SkFont , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns the advance width of text." ] # [ doc = "The advance is the normal distance to move before drawing additional text." ] # [ doc = "Returns the bounding box of text if bounds is not nullptr." ] # [ doc = "" ] # [ doc = "@param text        character storage encoded with SkTextEncoding" ] # [ doc = "@param byteLength  length of character storage in bytes" ] # [ doc = "@param encoding    one of: kUTF8_SkTextEncoding, kUTF16_SkTextEncoding," ] # [ doc = "kUTF32_SkTextEncoding, kGlyphID_SkTextEncoding" ] # [ doc = "@param bounds      returns bounding box relative to (0, 0) if not nullptr" ] # [ doc = "@return            number of glyphs represented by text of length byteLength" ] # [ link_name = "\u{1}__ZNK6SkFont11measureTextEPKvm14SkTextEncodingP6SkRect" ] pub fn SkFont_measureText ( this : * const SkFont , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding , bounds : * mut SkRect ) -> SkScalar ; } extern "C" { # [ doc = " Returns the advance width of text." ] # [ doc = "The advance is the normal distance to move before drawing additional text." ] # [ doc = "Returns the bounding box of text if bounds is not nullptr. paint" ] # [ doc = "stroke width or SkPathEffect may modify the advance with." ] # [ doc = "" ] # [ doc = "@param text        character storage encoded with SkTextEncoding" ] # [ doc = "@param byteLength  length of character storage in bytes" ] # [ doc = "@param encoding    one of: kUTF8_SkTextEncoding, kUTF16_SkTextEncoding," ] # [ doc = "kUTF32_SkTextEncoding, kGlyphID_SkTextEncoding" ] # [ doc = "@param bounds      returns bounding box relative to (0, 0) if not nullptr" ] # [ doc = "@param paint       optional; may be nullptr" ] # [ doc = "@return            number of glyphs represented by text of length byteLength" ] # [ link_name = "\u{1}__ZNK6SkFont11measureTextEPKvm14SkTextEncodingP6SkRectPK7SkPaint" ] pub fn SkFont_measureText1 ( this : * const SkFont , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding , bounds : * mut SkRect , paint : * const SkPaint ) -> SkScalar ; } extern "C" { # [ doc = " DEPRECATED" ] # [ doc = "Retrieves the advance and bounds for each glyph in glyphs." ] # [ doc = "Both widths and bounds may be nullptr." ] # [ doc = "If widths is not nullptr, widths must be an array of count entries." ] # [ doc = "if bounds is not nullptr, bounds must be an array of count entries." ] # [ doc = "" ] # [ doc = "@param glyphs      array of glyph indices to be measured" ] # [ doc = "@param count       number of glyphs" ] # [ doc = "@param widths      returns text advances for each glyph; may be nullptr" ] # [ doc = "@param bounds      returns bounds for each glyph relative to (0, 0); may be nullptr" ] # [ link_name = "\u{1}__ZNK6SkFont9getWidthsEPKtiPfP6SkRect" ] pub fn SkFont_getWidths ( this : * const SkFont , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar , bounds : * mut SkRect ) ; } extern "C" { # [ link_name = "\u{1}__ZNK6SkFont9getWidthsEPKtiPfDn" ] pub fn SkFont_getWidths1 ( this : * const SkFont , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar , arg1 : std_nullptr_t ) ; } extern "C" { # [ doc = " Retrieves the advance and bounds for each glyph in glyphs." ] # [ doc = "Both widths and bounds may be nullptr." ] # [ doc = "If widths is not nullptr, widths must be an array of count entries." ] # [ doc = "if bounds is not nullptr, bounds must be an array of count entries." ] # [ doc = "" ] # [ doc = "@param glyphs      array of glyph indices to be measured" ] # [ doc = "@param count       number of glyphs" ] # [ doc = "@param widths      returns text advances for each glyph" ] # [ link_name = "\u{1}__ZNK6SkFont9getWidthsEPKtiPf" ] pub fn SkFont_getWidths2 ( this : * const SkFont , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar ) ; } extern "C" { # [ doc = " Retrieves the advance and bounds for each glyph in glyphs." ] # [ doc = "Both widths and bounds may be nullptr." ] # [ doc = "If widths is not nullptr, widths must be an array of count entries." ] # [ doc = "if bounds is not nullptr, bounds must be an array of count entries." ] # [ doc = "" ] # [ doc = "@param glyphs      array of glyph indices to be measured" ] # [ doc = "@param count       number of glyphs" ] # [ doc = "@param widths      returns text advances for each glyph; may be nullptr" ] # [ doc = "@param bounds      returns bounds for each glyph relative to (0, 0); may be nullptr" ] # [ doc = "@param paint       optional, specifies stroking, SkPathEffect and SkMaskFilter" ] # [ link_name = "\u{1}__ZNK6SkFont15getWidthsBoundsEPKtiPfP6SkRectPK7SkPaint" ] pub fn SkFont_getWidthsBounds ( this : * const SkFont , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar , bounds : * mut SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Retrieves the bounds for each glyph in glyphs." ] # [ doc = "bounds must be an array of count entries." ] # [ doc = "If paint is not nullptr, its stroking, SkPathEffect, and SkMaskFilter fields are respected." ] # [ doc = "" ] # [ doc = "@param glyphs      array of glyph indices to be measured" ] # [ doc = "@param count       number of glyphs" ] # [ doc = "@param bounds      returns bounds for each glyph relative to (0, 0); may be nullptr" ] # [ doc = "@param paint       optional, specifies stroking, SkPathEffect, and SkMaskFilter" ] # [ link_name = "\u{1}__ZNK6SkFont9getBoundsEPKtiP6SkRectPK7SkPaint" ] pub fn SkFont_getBounds ( this : * const SkFont , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , bounds : * mut SkRect , paint : * const SkPaint ) ; } extern "C" { # [ doc = " Retrieves the positions for each glyph, beginning at the specified origin. The caller" ] # [ doc = "must allocated at least count number of elements in the pos[] array." ] # [ doc = "" ] # [ doc = "@param glyphs   array of glyph indices to be positioned" ] # [ doc = "@param count    number of glyphs" ] # [ doc = "@param pos      returns glyphs positions" ] # [ doc = "@param origin   location of the first glyph. Defaults to {0, 0}." ] # [ link_name = "\u{1}__ZNK6SkFont6getPosEPKtiP7SkPointS2_" ] pub fn SkFont_getPos ( this : * const SkFont , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , pos : * mut SkPoint , origin : SkPoint ) ; } extern "C" { # [ doc = " Retrieves the x-positions for each glyph, beginning at the specified origin. The caller" ] # [ doc = "must allocated at least count number of elements in the xpos[] array." ] # [ doc = "" ] # [ doc = "@param glyphs   array of glyph indices to be positioned" ] # [ doc = "@param count    number of glyphs" ] # [ doc = "@param xpos     returns glyphs x-positions" ] # [ doc = "@param origin   x-position of the first glyph. Defaults to 0." ] # [ link_name = "\u{1}__ZNK6SkFont7getXPosEPKtiPff" ] pub fn SkFont_getXPos ( this : * const SkFont , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , xpos : * mut SkScalar , origin : SkScalar ) ; } extern "C" { # [ doc = " Returns path corresponding to glyph outline." ] # [ doc = "If glyph has an outline, copies outline to path and returns true." ] # [ doc = "path returned may be empty." ] # [ doc = "If glyph is described by a bitmap, returns false and ignores path parameter." ] # [ doc = "" ] # [ doc = "@param glyphID  index of glyph" ] # [ doc = "@param path     pointer to existing SkPath" ] # [ doc = "@return         true if glyphID is described by path" ] # [ link_name = "\u{1}__ZNK6SkFont7getPathEtP6SkPath" ] pub fn SkFont_getPath ( this : * const SkFont , glyphID : u16 , path : * mut SkPath ) -> bool ; } extern "C" { # [ doc = " Returns path corresponding to glyph array." ] # [ doc = "" ] # [ doc = "@param glyphIDs      array of glyph indices" ] # [ doc = "@param count         number of glyphs" ] # [ doc = "@param glyphPathProc function returning one glyph description as path" ] # [ doc = "@param ctx           function context" ] # [ link_name = "\u{1}__ZNK6SkFont8getPathsEPKtiPFvPK6SkPathRK8SkMatrixPvES8_" ] pub fn SkFont_getPaths ( this : * const SkFont , glyphIDs : * const u16 , count : :: std :: os :: raw :: c_int , glyphPathProc : :: core :: option :: Option < unsafe extern "C" fn ( this : * const SkFont , glyphIDs : * const SkPath , count : * const SkMatrix , glyphPathProc : * mut :: std :: os :: raw :: c_void ) > , ctx : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ doc = " Returns SkFontMetrics associated with SkTypeface." ] # [ doc = "The return value is the recommended spacing between lines: the sum of metrics" ] # [ doc = "descent, ascent, and leading." ] # [ doc = "If metrics is not nullptr, SkFontMetrics is copied to metrics." ] # [ doc = "Results are scaled by text size but does not take into account" ] # [ doc = "dimensions required by text scale, text skew, fake bold," ] # [ doc = "style stroke, and SkPathEffect." ] # [ doc = "" ] # [ doc = "@param metrics  storage for SkFontMetrics; may be nullptr" ] # [ doc = "@return         recommended spacing between lines" ] # [ link_name = "\u{1}__ZNK6SkFont10getMetricsEP13SkFontMetrics" ] pub fn SkFont_getMetrics ( this : * const SkFont , metrics : * mut SkFontMetrics ) -> SkScalar ; } extern "C" { # [ doc = " Returns the recommended spacing between lines: the sum of metrics" ] # [ doc = "descent, ascent, and leading." ] # [ doc = "Result is scaled by text size but does not take into account" ] # [ doc = "dimensions required by stroking and SkPathEffect." ] # [ doc = "Returns the same result as getMetrics()." ] # [ doc = "" ] # [ doc = "@return  recommended spacing between lines" ] # [ link_name = "\u{1}__ZNK6SkFont10getSpacingEv" ] pub fn SkFont_getSpacing ( this : * const SkFont ) -> SkScalar ; } extern "C" { # [ doc = " Experimental." ] # [ doc = "  Dumps fields of the font to SkDebugf. May change its output over time, so clients should" ] # [ doc = "  not rely on this for anything specific. Used to aid in debugging." ] # [ link_name = "\u{1}__ZNK6SkFont4dumpEv" ] pub fn SkFont_dump ( this : * const SkFont ) ; } extern "C" { # [ doc = " Constructs SkFont with default values." ] # [ doc = "" ] # [ doc = "@return  default initialized SkFont" ] # [ link_name = "\u{1}__ZN6SkFontC1Ev" ] pub fn SkFont_SkFont ( this : * mut SkFont ) ; } extern "C" { # [ doc = " Constructs SkFont with default values with SkTypeface and size in points." ] # [ doc = "" ] # [ doc = "@param typeface  font and style used to draw and measure text" ] # [ doc = "@param size      typographic height of text" ] # [ doc = "@return          initialized SkFont" ] # [ link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceEf" ] pub fn SkFont_SkFont1 ( this : * mut SkFont , typeface : sk_sp < SkTypeface > , size : SkScalar ) ; } extern "C" { # [ doc = " Constructs SkFont with default values with SkTypeface." ] # [ doc = "" ] # [ doc = "@param typeface  font and style used to draw and measure text" ] # [ doc = "@return          initialized SkFont" ] # [ link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceE" ] pub fn SkFont_SkFont2 ( this : * mut SkFont , typeface : sk_sp < SkTypeface > ) ; } extern "C" { # [ doc = " Constructs SkFont with default values with SkTypeface and size in points," ] # [ doc = "horizontal scale, and horizontal skew. Horizontal scale emulates condensed" ] # [ doc = "and expanded fonts. Horizontal skew emulates oblique fonts." ] # [ doc = "" ] # [ doc = "@param typeface  font and style used to draw and measure text" ] # [ doc = "@param size      typographic height of text" ] # [ doc = "@param scaleX    text horizontal scale" ] # [ doc = "@param skewX     additional shear on x-axis relative to y-axis" ] # [ doc = "@return          initialized SkFont" ] # [ link_name = "\u{1}__ZN6SkFontC1E5sk_spI10SkTypefaceEfff" ] pub fn SkFont_SkFont3 ( this : * mut SkFont , typeface : sk_sp < SkTypeface > , size : SkScalar , scaleX : SkScalar , skewX : SkScalar ) ; } impl SkFont { # [ inline ] pub unsafe fn isForceAutoHinting ( & self ) -> bool { SkFont_isForceAutoHinting ( self ) } # [ inline ] pub unsafe fn isEmbeddedBitmaps ( & self ) -> bool { SkFont_isEmbeddedBitmaps ( self ) } # [ inline ] pub unsafe fn isSubpixel ( & self ) -> bool { SkFont_isSubpixel ( self ) } # [ inline ] pub unsafe fn isLinearMetrics ( & self ) -> bool { SkFont_isLinearMetrics ( self ) } # [ inline ] pub unsafe fn isEmbolden ( & self ) -> bool { SkFont_isEmbolden ( self ) } # [ inline ] pub unsafe fn setForceAutoHinting ( & mut self , forceAutoHinting : bool ) { SkFont_setForceAutoHinting ( self , forceAutoHinting ) } # [ inline ] pub unsafe fn setEmbeddedBitmaps ( & mut self , embeddedBitmaps : bool ) { SkFont_setEmbeddedBitmaps ( self , embeddedBitmaps ) } # [ inline ] pub unsafe fn setSubpixel ( & mut self , subpixel : bool ) { SkFont_setSubpixel ( self , subpixel ) } # [ inline ] pub unsafe fn setLinearMetrics ( & mut self , linearMetrics : bool ) { SkFont_setLinearMetrics ( self , linearMetrics ) } # [ inline ] pub unsafe fn setEmbolden ( & mut self , embolden : bool ) { SkFont_setEmbolden ( self , embolden ) } # [ inline ] pub unsafe fn getEdging ( & self ) -> SkFont_Edging { SkFont_getEdging ( self ) } # [ inline ] pub unsafe fn setEdging ( & mut self , edging : SkFont_Edging ) { SkFont_setEdging ( self , edging ) } # [ inline ] pub unsafe fn setHinting ( & mut self , hintingLevel : SkFontHinting ) { SkFont_setHinting ( self , hintingLevel ) } # [ inline ] pub unsafe fn getHinting ( & self ) -> SkFontHinting { SkFont_getHinting ( self ) } # [ inline ] pub unsafe fn makeWithSize ( & self , size : SkScalar ) -> SkFont { SkFont_makeWithSize ( self , size ) } # [ inline ] pub unsafe fn getTypeface ( & self ) -> * mut SkTypeface { SkFont_getTypeface ( self ) } # [ inline ] pub unsafe fn getTypefaceOrDefault ( & self ) -> * mut SkTypeface { SkFont_getTypefaceOrDefault ( self ) } # [ inline ] pub unsafe fn getSize ( & self ) -> SkScalar { SkFont_getSize ( self ) } # [ inline ] pub unsafe fn getScaleX ( & self ) -> SkScalar { SkFont_getScaleX ( self ) } # [ inline ] pub unsafe fn getSkewX ( & self ) -> SkScalar { SkFont_getSkewX ( self ) } # [ inline ] pub unsafe fn refTypeface ( & self ) -> sk_sp < SkTypeface > { SkFont_refTypeface ( self ) } # [ inline ] pub unsafe fn refTypefaceOrDefault ( & self ) -> sk_sp < SkTypeface > { SkFont_refTypefaceOrDefault ( self ) } # [ inline ] pub unsafe fn setTypeface ( & mut self , tf : sk_sp < SkTypeface > ) { SkFont_setTypeface ( self , tf ) } # [ inline ] pub unsafe fn setSize ( & mut self , textSize : SkScalar ) { SkFont_setSize ( self , textSize ) } # [ inline ] pub unsafe fn setScaleX ( & mut self , scaleX : SkScalar ) { SkFont_setScaleX ( self , scaleX ) } # [ inline ] pub unsafe fn setSkewX ( & mut self , skewX : SkScalar ) { SkFont_setSkewX ( self , skewX ) } # [ inline ] pub unsafe fn textToGlyphs ( & self , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding , glyphs : * mut SkGlyphID , maxGlyphCount : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int { SkFont_textToGlyphs ( self , text , byteLength , encoding , glyphs , maxGlyphCount ) } # [ inline ] pub unsafe fn unicharToGlyph ( & self , uni : SkUnichar ) -> SkGlyphID { SkFont_unicharToGlyph ( self , uni ) } # [ inline ] pub unsafe fn countText ( & self , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding ) -> :: std :: os :: raw :: c_int { SkFont_countText ( self , text , byteLength , encoding ) } # [ inline ] pub unsafe fn measureText ( & self , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding , bounds : * mut SkRect ) -> SkScalar { SkFont_measureText ( self , text , byteLength , encoding , bounds ) } # [ inline ] pub unsafe fn measureText1 ( & self , text : * const :: std :: os :: raw :: c_void , byteLength : usize , encoding : SkTextEncoding , bounds : * mut SkRect , paint : * const SkPaint ) -> SkScalar { SkFont_measureText1 ( self , text , byteLength , encoding , bounds , paint ) } # [ inline ] pub unsafe fn getWidths ( & self , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar , bounds : * mut SkRect ) { SkFont_getWidths ( self , glyphs , count , widths , bounds ) } # [ inline ] pub unsafe fn getWidths1 ( & self , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar , arg1 : std_nullptr_t ) { SkFont_getWidths1 ( self , glyphs , count , widths , arg1 ) } # [ inline ] pub unsafe fn getWidths2 ( & self , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar ) { SkFont_getWidths2 ( self , glyphs , count , widths ) } # [ inline ] pub unsafe fn getWidthsBounds ( & self , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar , bounds : * mut SkRect , paint : * const SkPaint ) { SkFont_getWidthsBounds ( self , glyphs , count , widths , bounds , paint ) } # [ inline ] pub unsafe fn getBounds ( & self , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , bounds : * mut SkRect , paint : * const SkPaint ) { SkFont_getBounds ( self , glyphs , count , bounds , paint ) } # [ inline ] pub unsafe fn getPos ( & self , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , pos : * mut SkPoint , origin : SkPoint ) { SkFont_getPos ( self , glyphs , count , pos , origin ) } # [ inline ] pub unsafe fn getXPos ( & self , glyphs : * const u16 , count : :: std :: os :: raw :: c_int , xpos : * mut SkScalar , origin : SkScalar ) { SkFont_getXPos ( self , glyphs , count , xpos , origin ) } # [ inline ] pub unsafe fn getPath ( & self , glyphID : u16 , path : * mut SkPath ) -> bool { SkFont_getPath ( self , glyphID , path ) } # [ inline ] pub unsafe fn getPaths ( & self , glyphIDs : * const u16 , count : :: std :: os :: raw :: c_int , glyphPathProc : :: core :: option :: Option < unsafe extern "C" fn ( this : * const SkFont , glyphIDs : * const SkPath , count : * const SkMatrix , glyphPathProc : * mut :: std :: os :: raw :: c_void ) > , ctx : * mut :: std :: os :: raw :: c_void ) { SkFont_getPaths ( self , glyphIDs , count , glyphPathProc , ctx ) } # [ inline ] pub unsafe fn getMetrics ( & self , metrics : * mut SkFontMetrics ) -> SkScalar { SkFont_getMetrics ( self , metrics ) } # [ inline ] pub unsafe fn getSpacing ( & self ) -> SkScalar { SkFont_getSpacing ( self ) } # [ inline ] pub unsafe fn dump ( & self ) { SkFont_dump ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkFont_SkFont ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( typeface : sk_sp < SkTypeface > , size : SkScalar ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkFont_SkFont1 ( & mut __bindgen_tmp , typeface , size ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( typeface : sk_sp < SkTypeface > ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkFont_SkFont2 ( & mut __bindgen_tmp , typeface ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( typeface : sk_sp < SkTypeface > , size : SkScalar , scaleX : SkScalar , skewX : SkScalar ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkFont_SkFont3 ( & mut __bindgen_tmp , typeface , size , scaleX , skewX ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkFontMetrics { # [ doc = "!< is set to FontMetricsFlags when metrics are valid" ] pub fFlags : u32 , # [ doc = "!< extent above baseline" ] pub fTop : SkScalar , # [ doc = "!< distance to reserve above baseline" ] pub fAscent : SkScalar , # [ doc = "!< distance to reserve below baseline" ] pub fDescent : SkScalar , # [ doc = "!< extent below baseline" ] pub fBottom : SkScalar , # [ doc = "!< distance to add between lines" ] pub fLeading : SkScalar , # [ doc = "!< average character width" ] pub fAvgCharWidth : SkScalar , # [ doc = "!< maximum character width" ] pub fMaxCharWidth : SkScalar , # [ doc = "!< minimum x" ] pub fXMin : SkScalar , # [ doc = "!< maximum x" ] pub fXMax : SkScalar , # [ doc = "!< height of lower-case \'x\'" ] pub fXHeight : SkScalar , # [ doc = "!< height of an upper-case letter" ] pub fCapHeight : SkScalar , # [ doc = "!< underline thickness" ] pub fUnderlineThickness : SkScalar , # [ doc = "!< underline position relative to baseline" ] pub fUnderlinePosition : SkScalar , # [ doc = "!< strikeout thickness" ] pub fStrikeoutThickness : SkScalar , # [ doc = "!< strikeout position relative to baseline" ] pub fStrikeoutPosition : SkScalar , } # [ repr ( u32 ) ] # [ doc = " \\enum FontMetricsFlags" ] # [ doc = "FontMetricsFlags are set in fFlags when underline and strikeout metrics are valid;" ] # [ doc = "the underline or strikeout metric may be valid and zero." ] # [ doc = "Fonts with embedded bitmaps may not have valid underline or strikeout metrics." ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum SkFontMetrics_FontMetricsFlags { # [ doc = "!< set if fUnderlineThickness is valid" ] kUnderlineThicknessIsValid_Flag = 1 , # [ doc = "!< set if fUnderlinePosition is valid" ] kUnderlinePositionIsValid_Flag = 2 , # [ doc = "!< set if fStrikeoutThickness is valid" ] kStrikeoutThicknessIsValid_Flag = 4 , # [ doc = "!< set if fStrikeoutPosition is valid" ] kStrikeoutPositionIsValid_Flag = 8 , } # [ test ] fn bindgen_test_layout_SkFontMetrics ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkFontMetrics > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( SkFontMetrics ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkFontMetrics > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SkFontMetrics ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fFlags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fTop as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fTop ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fAscent as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fAscent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fDescent as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fDescent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fBottom as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fBottom ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fLeading as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fLeading ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fAvgCharWidth as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fAvgCharWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fMaxCharWidth as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fMaxCharWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fXMin as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fXMin ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fXMax as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fXMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fXHeight as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fXHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fCapHeight as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fCapHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fUnderlineThickness as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fUnderlineThickness ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fUnderlinePosition as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fUnderlinePosition ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fStrikeoutThickness as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fStrikeoutThickness ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkFontMetrics > ( ) ) ) . fStrikeoutPosition as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( SkFontMetrics ) , "::" , stringify ! ( fStrikeoutPosition ) ) ) ; } extern "C" { # [ doc = " Returns true if SkFontMetrics has a valid underline thickness, and sets" ] # [ doc = "thickness to that value. If the underline thickness is not valid," ] # [ doc = "return false, and ignore thickness." ] # [ doc = "" ] # [ doc = "@param thickness  storage for underline width" ] # [ doc = "@return           true if font specifies underline width" ] # [ link_name = "\u{1}__ZNK13SkFontMetrics21hasUnderlineThicknessEPf" ] pub fn SkFontMetrics_hasUnderlineThickness ( this : * const SkFontMetrics , thickness : * mut SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns true if SkFontMetrics has a valid underline position, and sets" ] # [ doc = "position to that value. If the underline position is not valid," ] # [ doc = "return false, and ignore position." ] # [ doc = "" ] # [ doc = "@param position  storage for underline position" ] # [ doc = "@return          true if font specifies underline position" ] # [ link_name = "\u{1}__ZNK13SkFontMetrics20hasUnderlinePositionEPf" ] pub fn SkFontMetrics_hasUnderlinePosition ( this : * const SkFontMetrics , position : * mut SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns true if SkFontMetrics has a valid strikeout thickness, and sets" ] # [ doc = "thickness to that value. If the underline thickness is not valid," ] # [ doc = "return false, and ignore thickness." ] # [ doc = "" ] # [ doc = "@param thickness  storage for strikeout width" ] # [ doc = "@return           true if font specifies strikeout width" ] # [ link_name = "\u{1}__ZNK13SkFontMetrics21hasStrikeoutThicknessEPf" ] pub fn SkFontMetrics_hasStrikeoutThickness ( this : * const SkFontMetrics , thickness : * mut SkScalar ) -> bool ; } extern "C" { # [ doc = " Returns true if SkFontMetrics has a valid strikeout position, and sets" ] # [ doc = "position to that value. If the underline position is not valid," ] # [ doc = "return false, and ignore position." ] # [ doc = "" ] # [ doc = "@param position  storage for strikeout position" ] # [ doc = "@return          true if font specifies strikeout position" ] # [ link_name = "\u{1}__ZNK13SkFontMetrics20hasStrikeoutPositionEPf" ] pub fn SkFontMetrics_hasStrikeoutPosition ( this : * const SkFontMetrics , position : * mut SkScalar ) -> bool ; } impl SkFontMetrics { # [ inline ] pub unsafe fn hasUnderlineThickness ( & self , thickness : * mut SkScalar ) -> bool { SkFontMetrics_hasUnderlineThickness ( self , thickness ) } # [ inline ] pub unsafe fn hasUnderlinePosition ( & self , position : * mut SkScalar ) -> bool { SkFontMetrics_hasUnderlinePosition ( self , position ) } # [ inline ] pub unsafe fn hasStrikeoutThickness ( & self , thickness : * mut SkScalar ) -> bool { SkFontMetrics_hasStrikeoutThickness ( self , thickness ) } # [ inline ] pub unsafe fn hasStrikeoutPosition ( & self , position : * mut SkScalar ) -> bool { SkFontMetrics_hasStrikeoutPosition ( self , position ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkStrokeRec { _unused : [ u8 ; 0 ] , } # [ doc = " \\class SkPathEffect" ] # [ doc = "" ] # [ doc = "SkPathEffect is the base class for objects in the SkPaint that affect" ] # [ doc = "the geometry of a drawing primitive before it is transformed by the" ] # [ doc = "canvas\' matrix and drawn." ] # [ doc = "" ] # [ doc = "Dashing is implemented as a subclass of SkPathEffect." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPathEffect { pub _base : SkFlattenable , } # [ doc = " \\class PointData" ] # [ doc = "" ] # [ doc = "PointData aggregates all the information needed to draw the point" ] # [ doc = "primitives returned by an \'asPoints\' call." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkPathEffect_PointData { pub fFlags : u32 , pub fPoints : * mut SkPoint , pub fNumPoints : :: std :: os :: raw :: c_int , pub fSize : SkVector , pub fClipRect : SkRect , pub fPath : SkPath , pub fFirst : SkPath , pub fLast : SkPath , } pub const SkPathEffect_PointData_PointFlags_kCircles_PointFlag : SkPathEffect_PointData_PointFlags = 1 ; pub const SkPathEffect_PointData_PointFlags_kUsePath_PointFlag : SkPathEffect_PointData_PointFlags = 2 ; pub const SkPathEffect_PointData_PointFlags_kUseClip_PointFlag : SkPathEffect_PointData_PointFlags = 4 ; pub type SkPathEffect_PointData_PointFlags = u32 ; # [ test ] fn bindgen_test_layout_SkPathEffect_PointData ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPathEffect_PointData > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( SkPathEffect_PointData ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPathEffect_PointData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPathEffect_PointData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_PointData > ( ) ) ) . fFlags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_PointData ) , "::" , stringify ! ( fFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_PointData > ( ) ) ) . fPoints as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_PointData ) , "::" , stringify ! ( fPoints ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_PointData > ( ) ) ) . fNumPoints as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_PointData ) , "::" , stringify ! ( fNumPoints ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_PointData > ( ) ) ) . fSize as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_PointData ) , "::" , stringify ! ( fSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_PointData > ( ) ) ) . fClipRect as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_PointData ) , "::" , stringify ! ( fClipRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_PointData > ( ) ) ) . fPath as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_PointData ) , "::" , stringify ! ( fPath ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_PointData > ( ) ) ) . fFirst as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_PointData ) , "::" , stringify ! ( fFirst ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_PointData > ( ) ) ) . fLast as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_PointData ) , "::" , stringify ! ( fLast ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN12SkPathEffect9PointDataC1Ev" ] pub fn SkPathEffect_PointData_PointData ( this : * mut SkPathEffect_PointData ) ; } extern "C" { # [ link_name = "\u{1}__ZN12SkPathEffect9PointDataD1Ev" ] pub fn SkPathEffect_PointData_PointData_destructor ( this : * mut SkPathEffect_PointData ) ; } impl SkPathEffect_PointData { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPathEffect_PointData_PointData ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { SkPathEffect_PointData_PointData_destructor ( self ) } } # [ doc = "!< ignores the info parameter" ] pub const SkPathEffect_DashType_kNone_DashType : SkPathEffect_DashType = 0 ; # [ doc = "!< fills in all of the info parameter" ] pub const SkPathEffect_DashType_kDash_DashType : SkPathEffect_DashType = 1 ; # [ doc = "  If the PathEffect can be represented as a dash pattern, asADash will return kDash_DashType" ] # [ doc = "  and None otherwise. If a non NULL info is passed in, the various DashInfo will be filled" ] # [ doc = "  in if the PathEffect can be a dash pattern. If passed in info has an fCount equal or" ] # [ doc = "  greater to that of the effect, it will memcpy the values of the dash intervals into the" ] # [ doc = "  info. Thus the general approach will be call asADash once with default info to get DashType" ] # [ doc = "  and fCount. If effect can be represented as a dash pattern, allocate space for the intervals" ] # [ doc = "  in info, then call asADash again with the same info and the intervals will get copied in." ] pub type SkPathEffect_DashType = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkPathEffect_DashInfo { # [ doc = "!< Length of on/off intervals for dashed lines" ] pub fIntervals : * mut SkScalar , # [ doc = "!< Number of intervals in the dash. Should be even number" ] pub fCount : i32 , # [ doc = "!< Offset into the dashed interval pattern" ] pub fPhase : SkScalar , } # [ test ] fn bindgen_test_layout_SkPathEffect_DashInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPathEffect_DashInfo > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkPathEffect_DashInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPathEffect_DashInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPathEffect_DashInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_DashInfo > ( ) ) ) . fIntervals as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_DashInfo ) , "::" , stringify ! ( fIntervals ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_DashInfo > ( ) ) ) . fCount as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_DashInfo ) , "::" , stringify ! ( fCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SkPathEffect_DashInfo > ( ) ) ) . fPhase as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SkPathEffect_DashInfo ) , "::" , stringify ! ( fPhase ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN12SkPathEffect8DashInfoC1Ev" ] pub fn SkPathEffect_DashInfo_DashInfo ( this : * mut SkPathEffect_DashInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN12SkPathEffect8DashInfoC1EPfif" ] pub fn SkPathEffect_DashInfo_DashInfo1 ( this : * mut SkPathEffect_DashInfo , intervals : * mut SkScalar , count : i32 , phase : SkScalar ) ; } impl SkPathEffect_DashInfo { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPathEffect_DashInfo_DashInfo ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( intervals : * mut SkScalar , count : i32 , phase : SkScalar ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPathEffect_DashInfo_DashInfo1 ( & mut __bindgen_tmp , intervals , count , phase ) ; __bindgen_tmp } } pub type SkPathEffect_INHERITED = SkFlattenable ; # [ test ] fn bindgen_test_layout_SkPathEffect ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkPathEffect > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SkPathEffect ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkPathEffect > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SkPathEffect ) ) ) ; } extern "C" { # [ doc = "  Returns a patheffect that apples each effect (first and second) to the original path," ] # [ doc = "  and returns a path with the sum of these." ] # [ doc = "" ] # [ doc = "  result = first(path) + second(path)" ] # [ doc = "" ] # [ link_name = "\u{1}__ZN12SkPathEffect7MakeSumE5sk_spIS_ES1_" ] pub fn SkPathEffect_MakeSum ( first : sk_sp < SkPathEffect > , second : sk_sp < SkPathEffect > ) -> sk_sp < SkPathEffect > ; } extern "C" { # [ doc = "  Returns a patheffect that applies the inner effect to the path, and then applies the" ] # [ doc = "  outer effect to the result of the inner\'s." ] # [ doc = "" ] # [ doc = "  result = outer(inner(path))" ] # [ link_name = "\u{1}__ZN12SkPathEffect11MakeComposeE5sk_spIS_ES1_" ] pub fn SkPathEffect_MakeCompose ( outer : sk_sp < SkPathEffect > , inner : sk_sp < SkPathEffect > ) -> sk_sp < SkPathEffect > ; } extern "C" { # [ doc = "  Given a src path (input) and a stroke-rec (input and output), apply" ] # [ doc = "  this effect to the src path, returning the new path in dst, and return" ] # [ doc = "  true. If this effect cannot be applied, return false and ignore dst" ] # [ doc = "  and stroke-rec." ] # [ doc = "" ] # [ doc = "  The stroke-rec specifies the initial request for stroking (if any)." ] # [ doc = "  The effect can treat this as input only, or it can choose to change" ] # [ doc = "  the rec as well. For example, the effect can decide to change the" ] # [ doc = "  stroke\'s width or join, or the effect can change the rec from stroke" ] # [ doc = "  to fill (or fill to stroke) in addition to returning a new (dst) path." ] # [ doc = "" ] # [ doc = "  If this method returns true, the caller will apply (as needed) the" ] # [ doc = "  resulting stroke-rec to dst and then draw." ] # [ link_name = "\u{1}__ZNK12SkPathEffect10filterPathEP6SkPathRKS0_P11SkStrokeRecPK6SkRect" ] pub fn SkPathEffect_filterPath ( this : * const SkPathEffect , dst : * mut SkPath , src : * const SkPath , arg1 : * mut SkStrokeRec , cullR : * const SkRect ) -> bool ; } extern "C" { # [ doc = "  Compute a conservative bounds for its effect, given the src bounds." ] # [ doc = "  The baseline implementation just assigns src to dst." ] # [ link_name = "\u{1}__ZNK12SkPathEffect17computeFastBoundsEP6SkRectRKS0_" ] pub fn SkPathEffect_computeFastBounds ( this : * const SkPathEffect , dst : * mut SkRect , src : * const SkRect ) ; } extern "C" { # [ doc = "  Does applying this path effect to \'src\' yield a set of points? If so," ] # [ doc = "  optionally return the points in \'results\'." ] # [ link_name = "\u{1}__ZNK12SkPathEffect8asPointsEPNS_9PointDataERK6SkPathRK11SkStrokeRecRK8SkMatrixPK6SkRect" ] pub fn SkPathEffect_asPoints ( this : * const SkPathEffect , results : * mut SkPathEffect_PointData , src : * const SkPath , arg1 : * const SkStrokeRec , arg2 : * const SkMatrix , cullR : * const SkRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkPathEffect7asADashEPNS_8DashInfoE" ] pub fn SkPathEffect_asADash ( this : * const SkPathEffect , info : * mut SkPathEffect_DashInfo ) -> SkPathEffect_DashType ; } extern "C" { # [ link_name = "\u{1}__ZN12SkPathEffect20RegisterFlattenablesEv" ] pub fn SkPathEffect_RegisterFlattenables ( ) ; } extern "C" { # [ link_name = "\u{1}__ZN12SkPathEffect18GetFlattenableTypeEv" ] pub fn SkPathEffect_GetFlattenableType ( ) -> SkFlattenable_Type ; } extern "C" { # [ link_name = "\u{1}__ZN12SkPathEffect11DeserializeEPKvmPK15SkDeserialProcs" ] pub fn SkPathEffect_Deserialize ( data : * const :: std :: os :: raw :: c_void , size : usize , procs : * const SkDeserialProcs ) -> sk_sp < SkPathEffect > ; } extern "C" { # [ link_name = "\u{1}__ZN12SkPathEffectC2Ev" ] pub fn SkPathEffect_SkPathEffect ( this : * mut SkPathEffect ) ; } impl SkPathEffect { # [ inline ] pub unsafe fn MakeSum ( first : sk_sp < SkPathEffect > , second : sk_sp < SkPathEffect > ) -> sk_sp < SkPathEffect > { SkPathEffect_MakeSum ( first , second ) } # [ inline ] pub unsafe fn MakeCompose ( outer : sk_sp < SkPathEffect > , inner : sk_sp < SkPathEffect > ) -> sk_sp < SkPathEffect > { SkPathEffect_MakeCompose ( outer , inner ) } # [ inline ] pub unsafe fn filterPath ( & self , dst : * mut SkPath , src : * const SkPath , arg1 : * mut SkStrokeRec , cullR : * const SkRect ) -> bool { SkPathEffect_filterPath ( self , dst , src , arg1 , cullR ) } # [ inline ] pub unsafe fn computeFastBounds ( & self , dst : * mut SkRect , src : * const SkRect ) { SkPathEffect_computeFastBounds ( self , dst , src ) } # [ inline ] pub unsafe fn asPoints ( & self , results : * mut SkPathEffect_PointData , src : * const SkPath , arg1 : * const SkStrokeRec , arg2 : * const SkMatrix , cullR : * const SkRect ) -> bool { SkPathEffect_asPoints ( self , results , src , arg1 , arg2 , cullR ) } # [ inline ] pub unsafe fn asADash ( & self , info : * mut SkPathEffect_DashInfo ) -> SkPathEffect_DashType { SkPathEffect_asADash ( self , info ) } # [ inline ] pub unsafe fn RegisterFlattenables ( ) { SkPathEffect_RegisterFlattenables ( ) } # [ inline ] pub unsafe fn GetFlattenableType ( ) -> SkFlattenable_Type { SkPathEffect_GetFlattenableType ( ) } # [ inline ] pub unsafe fn Deserialize ( data : * const :: std :: os :: raw :: c_void , size : usize , procs : * const SkDeserialProcs ) -> sk_sp < SkPathEffect > { SkPathEffect_Deserialize ( data , size , procs ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; SkPathEffect_SkPathEffect ( & mut __bindgen_tmp ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZNK12SkPathEffect18getFlattenableTypeEv" ] pub fn SkPathEffect_getFlattenableType ( this : * mut :: std :: os :: raw :: c_void ) -> SkFlattenable_Type ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkPathEffect19onComputeFastBoundsERK6SkRect" ] pub fn SkPathEffect_onComputeFastBounds ( this : * mut :: std :: os :: raw :: c_void , src : * const SkRect ) -> SkRect ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkPathEffect10onAsPointsEPNS_9PointDataERK6SkPathRK11SkStrokeRecRK8SkMatrixPK6SkRect" ] pub fn SkPathEffect_onAsPoints ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut SkPathEffect_PointData , arg2 : * const SkPath , arg3 : * const SkStrokeRec , arg4 : * const SkMatrix , arg5 : * const SkRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK12SkPathEffect9onAsADashEPNS_8DashInfoE" ] pub fn SkPathEffect_onAsADash ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut SkPathEffect_DashInfo ) -> SkPathEffect_DashType ; } # [ doc = " Base class for all GrGpuResource cache keys. There are two types of cache keys. Refer to the" ] # [ doc = " comments for each key type below." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrResourceKey { pub fKey : [ u64 ; 5usize ] , } # [ doc = " Used to initialize a key." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrResourceKey_Builder { pub fKey : * mut GrResourceKey , } # [ test ] fn bindgen_test_layout_GrResourceKey_Builder ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrResourceKey_Builder > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrResourceKey_Builder ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrResourceKey_Builder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrResourceKey_Builder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrResourceKey_Builder > ( ) ) ) . fKey as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrResourceKey_Builder ) , "::" , stringify ! ( fKey ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrResourceKey7Builder6finishEv" ] pub fn GrResourceKey_Builder_finish ( this : * mut GrResourceKey_Builder ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrResourceKey7BuilderC1EPS_ji" ] pub fn GrResourceKey_Builder_Builder ( this : * mut GrResourceKey_Builder , key : * mut GrResourceKey , domain : u32 , data32Count : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrResourceKey7BuilderD1Ev" ] pub fn GrResourceKey_Builder_Builder_destructor ( this : * mut GrResourceKey_Builder ) ; } impl GrResourceKey_Builder { # [ inline ] pub unsafe fn finish ( & mut self ) { GrResourceKey_Builder_finish ( self ) } # [ inline ] pub unsafe fn new ( key : * mut GrResourceKey , domain : u32 , data32Count : :: std :: os :: raw :: c_int ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrResourceKey_Builder_Builder ( & mut __bindgen_tmp , key , domain , data32Count ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { GrResourceKey_Builder_Builder_destructor ( self ) } } pub const GrResourceKey_MetaDataIdx_kHash_MetaDataIdx : GrResourceKey_MetaDataIdx = 0 ; pub const GrResourceKey_MetaDataIdx_kDomainAndSize_MetaDataIdx : GrResourceKey_MetaDataIdx = 1 ; pub const GrResourceKey_MetaDataIdx_kLastMetaDataIdx : GrResourceKey_MetaDataIdx = 1 ; pub type GrResourceKey_MetaDataIdx = u32 ; pub const GrResourceKey_kInvalidDomain : u32 = 0 ; pub const GrResourceKey_kMetaDataCnt : u32 = 2 ; # [ test ] fn bindgen_test_layout_GrResourceKey ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrResourceKey > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( GrResourceKey ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrResourceKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrResourceKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrResourceKey > ( ) ) ) . fKey as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrResourceKey ) , "::" , stringify ! ( fKey ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrResourceKey4hashEv" ] pub fn GrResourceKey_hash ( this : * const GrResourceKey ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrResourceKey4sizeEv" ] pub fn GrResourceKey_size ( this : * const GrResourceKey ) -> usize ; } extern "C" { # [ doc = " Reset to an invalid key." ] # [ link_name = "\u{1}__ZN13GrResourceKey5resetEv" ] pub fn GrResourceKey_reset ( this : * mut GrResourceKey ) ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrResourceKey7isValidEv" ] pub fn GrResourceKey_isValid ( this : * const GrResourceKey ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrResourceKey6domainEv" ] pub fn GrResourceKey_domain ( this : * const GrResourceKey ) -> u32 ; } extern "C" { # [ doc = " size of the key data, excluding meta-data (hash, domain, etc)." ] # [ link_name = "\u{1}__ZNK13GrResourceKey8dataSizeEv" ] pub fn GrResourceKey_dataSize ( this : * const GrResourceKey ) -> usize ; } extern "C" { # [ doc = " ptr to the key data, excluding meta-data (hash, domain, etc)." ] # [ link_name = "\u{1}__ZNK13GrResourceKey4dataEv" ] pub fn GrResourceKey_data ( this : * const GrResourceKey ) -> * const u32 ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrResourceKey4dumpEv" ] pub fn GrResourceKey_dump ( this : * const GrResourceKey ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrResourceKeyC1Ev" ] pub fn GrResourceKey_GrResourceKey ( this : * mut GrResourceKey ) ; } impl GrResourceKey { # [ inline ] pub unsafe fn hash ( & self ) -> u32 { GrResourceKey_hash ( self ) } # [ inline ] pub unsafe fn size ( & self ) -> usize { GrResourceKey_size ( self ) } # [ inline ] pub unsafe fn reset ( & mut self ) { GrResourceKey_reset ( self ) } # [ inline ] pub unsafe fn isValid ( & self ) -> bool { GrResourceKey_isValid ( self ) } # [ inline ] pub unsafe fn domain ( & self ) -> u32 { GrResourceKey_domain ( self ) } # [ inline ] pub unsafe fn dataSize ( & self ) -> usize { GrResourceKey_dataSize ( self ) } # [ inline ] pub unsafe fn data ( & self ) -> * const u32 { GrResourceKey_data ( self ) } # [ inline ] pub unsafe fn dump ( & self ) { GrResourceKey_dump ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrResourceKey_GrResourceKey ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ doc = " A key used for scratch resources. There are three important rules about scratch keys:" ] # [ doc = "        * Multiple resources can share the same scratch key. Therefore resources assigned the same" ] # [ doc = "          scratch key should be interchangeable with respect to the code that uses them." ] # [ doc = "        * A resource can have at most one scratch key and it is set at resource creation by the" ] # [ doc = "          resource itself." ] # [ doc = "        * When a scratch resource is ref\'ed it will not be returned from the" ] # [ doc = "          cache for a subsequent cache request until all refs are released. This facilitates using" ] # [ doc = "          a scratch key for multiple render-to-texture scenarios. An example is a separable blur:" ] # [ doc = "" ] # [ doc = "  GrTexture* texture[2];" ] # [ doc = "  texture[0] = get_scratch_texture(scratchKey);" ] # [ doc = "  texture[1] = get_scratch_texture(scratchKey); // texture[0] is already owned so we will get a" ] # [ doc = "                                                // different one for texture[1]" ] # [ doc = "  draw_mask(texture[0], path);        // draws path mask to texture[0]" ] # [ doc = "  blur_x(texture[0], texture[1]);     // blurs texture[0] in y and stores result in texture[1]" ] # [ doc = "  blur_y(texture[1], texture[0]);     // blurs texture[1] in y and stores result in texture[0]" ] # [ doc = "  texture[1]->unref();  // texture 1 can now be recycled for the next request with scratchKey" ] # [ doc = "  consume_blur(texture[0]);" ] # [ doc = "  texture[0]->unref();  // texture 0 can now be recycled for the next request with scratchKey" ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrScratchKey { pub _base : GrResourceKey , } pub type GrScratchKey_INHERITED = GrResourceKey ; # [ doc = " Uniquely identifies the type of resource that is cached as scratch." ] pub type GrScratchKey_ResourceType = u32 ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrScratchKey_Builder { pub _base : GrResourceKey_Builder , } # [ test ] fn bindgen_test_layout_GrScratchKey_Builder ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrScratchKey_Builder > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrScratchKey_Builder ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrScratchKey_Builder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrScratchKey_Builder ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrScratchKey7BuilderC1EPS_ji" ] pub fn GrScratchKey_Builder_Builder ( this : * mut GrScratchKey_Builder , key : * mut GrScratchKey , type_ : GrScratchKey_ResourceType , data32Count : :: std :: os :: raw :: c_int ) ; } impl GrScratchKey_Builder { # [ inline ] pub unsafe fn new ( key : * mut GrScratchKey , type_ : GrScratchKey_ResourceType , data32Count : :: std :: os :: raw :: c_int ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrScratchKey_Builder_Builder ( & mut __bindgen_tmp , key , type_ , data32Count ) ; __bindgen_tmp } } # [ test ] fn bindgen_test_layout_GrScratchKey ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrScratchKey > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( GrScratchKey ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrScratchKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrScratchKey ) ) ) ; } extern "C" { # [ doc = " Generate a unique ResourceType." ] # [ link_name = "\u{1}__ZN12GrScratchKey20GenerateResourceTypeEv" ] pub fn GrScratchKey_GenerateResourceType ( ) -> GrScratchKey_ResourceType ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrScratchKey12resourceTypeEv" ] pub fn GrScratchKey_resourceType ( this : * const GrScratchKey ) -> GrScratchKey_ResourceType ; } extern "C" { # [ doc = " Creates an invalid scratch key. It must be initialized using a Builder object before use." ] # [ link_name = "\u{1}__ZN12GrScratchKeyC1Ev" ] pub fn GrScratchKey_GrScratchKey ( this : * mut GrScratchKey ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrScratchKeyC1ERKS_" ] pub fn GrScratchKey_GrScratchKey1 ( this : * mut GrScratchKey , that : * const GrScratchKey ) ; } impl GrScratchKey { # [ inline ] pub unsafe fn GenerateResourceType ( ) -> GrScratchKey_ResourceType { GrScratchKey_GenerateResourceType ( ) } # [ inline ] pub unsafe fn resourceType ( & self ) -> GrScratchKey_ResourceType { GrScratchKey_resourceType ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrScratchKey_GrScratchKey ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( that : * const GrScratchKey ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrScratchKey_GrScratchKey1 ( & mut __bindgen_tmp , that ) ; __bindgen_tmp } } # [ doc = " A key that allows for exclusive use of a resource for a use case (AKA \"domain\"). There are three" ] # [ doc = " rules governing the use of unique keys:" ] # [ doc = "        * Only one resource can have a given unique key at a time. Hence, \"unique\"." ] # [ doc = "        * A resource can have at most one unique key at a time." ] # [ doc = "        * Unlike scratch keys, multiple requests for a unique key will return the same" ] # [ doc = "          resource even if the resource already has refs." ] # [ doc = " This key type allows a code path to create cached resources for which it is the exclusive user." ] # [ doc = " The code path creates a domain which it sets on its keys. This guarantees that there are no" ] # [ doc = " cross-domain collisions." ] # [ doc = "" ] # [ doc = " Unique keys preempt scratch keys. While a resource has a unique key it is inaccessible via its" ] # [ doc = " scratch key. It can become scratch again if the unique key is removed." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrUniqueKey { pub _base : GrResourceKey , pub fData : sk_sp < SkData > , pub fTag : * const :: std :: os :: raw :: c_char , } pub type GrUniqueKey_INHERITED = GrResourceKey ; pub type GrUniqueKey_Domain = u32 ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrUniqueKey_Builder { pub _base : GrResourceKey_Builder , } # [ test ] fn bindgen_test_layout_GrUniqueKey_Builder ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrUniqueKey_Builder > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrUniqueKey_Builder ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrUniqueKey_Builder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrUniqueKey_Builder ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN11GrUniqueKey7BuilderC1EPS_jiPKc" ] pub fn GrUniqueKey_Builder_Builder ( this : * mut GrUniqueKey_Builder , key : * mut GrUniqueKey , type_ : GrUniqueKey_Domain , data32Count : :: std :: os :: raw :: c_int , tag : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ doc = " Used to build a key that wraps another key and adds additional data." ] # [ link_name = "\u{1}__ZN11GrUniqueKey7BuilderC1EPS_RKS_jiPKc" ] pub fn GrUniqueKey_Builder_Builder1 ( this : * mut GrUniqueKey_Builder , key : * mut GrUniqueKey , innerKey : * const GrUniqueKey , domain : GrUniqueKey_Domain , extraData32Cnt : :: std :: os :: raw :: c_int , tag : * const :: std :: os :: raw :: c_char ) ; } impl GrUniqueKey_Builder { # [ inline ] pub unsafe fn new ( key : * mut GrUniqueKey , type_ : GrUniqueKey_Domain , data32Count : :: std :: os :: raw :: c_int , tag : * const :: std :: os :: raw :: c_char ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrUniqueKey_Builder_Builder ( & mut __bindgen_tmp , key , type_ , data32Count , tag ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( key : * mut GrUniqueKey , innerKey : * const GrUniqueKey , domain : GrUniqueKey_Domain , extraData32Cnt : :: std :: os :: raw :: c_int , tag : * const :: std :: os :: raw :: c_char ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrUniqueKey_Builder_Builder1 ( & mut __bindgen_tmp , key , innerKey , domain , extraData32Cnt , tag ) ; __bindgen_tmp } } # [ test ] fn bindgen_test_layout_GrUniqueKey ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrUniqueKey > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( GrUniqueKey ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrUniqueKey > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrUniqueKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrUniqueKey > ( ) ) ) . fData as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( GrUniqueKey ) , "::" , stringify ! ( fData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrUniqueKey > ( ) ) ) . fTag as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( GrUniqueKey ) , "::" , stringify ! ( fTag ) ) ) ; } extern "C" { # [ doc = " Generate a Domain for unique keys." ] # [ link_name = "\u{1}__ZN11GrUniqueKey14GenerateDomainEv" ] pub fn GrUniqueKey_GenerateDomain ( ) -> GrUniqueKey_Domain ; } extern "C" { # [ link_name = "\u{1}__ZN11GrUniqueKey13setCustomDataE5sk_spI6SkDataE" ] pub fn GrUniqueKey_setCustomData ( this : * mut GrUniqueKey , data : sk_sp < SkData > ) ; } extern "C" { # [ link_name = "\u{1}__ZNK11GrUniqueKey13getCustomDataEv" ] pub fn GrUniqueKey_getCustomData ( this : * const GrUniqueKey ) -> * mut SkData ; } extern "C" { # [ link_name = "\u{1}__ZNK11GrUniqueKey3tagEv" ] pub fn GrUniqueKey_tag ( this : * const GrUniqueKey ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__ZNK11GrUniqueKey4dumpEPKc" ] pub fn GrUniqueKey_dump ( this : * const GrUniqueKey , label : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ doc = " Creates an invalid unique key. It must be initialized using a Builder object before use." ] # [ link_name = "\u{1}__ZN11GrUniqueKeyC1Ev" ] pub fn GrUniqueKey_GrUniqueKey ( this : * mut GrUniqueKey ) ; } extern "C" { # [ link_name = "\u{1}__ZN11GrUniqueKeyC1ERKS_" ] pub fn GrUniqueKey_GrUniqueKey1 ( this : * mut GrUniqueKey , that : * const GrUniqueKey ) ; } impl GrUniqueKey { # [ inline ] pub unsafe fn GenerateDomain ( ) -> GrUniqueKey_Domain { GrUniqueKey_GenerateDomain ( ) } # [ inline ] pub unsafe fn setCustomData ( & mut self , data : sk_sp < SkData > ) { GrUniqueKey_setCustomData ( self , data ) } # [ inline ] pub unsafe fn getCustomData ( & self ) -> * mut SkData { GrUniqueKey_getCustomData ( self ) } # [ inline ] pub unsafe fn tag ( & self ) -> * const :: std :: os :: raw :: c_char { GrUniqueKey_tag ( self ) } # [ inline ] pub unsafe fn dump ( & self , label : * const :: std :: os :: raw :: c_char ) { GrUniqueKey_dump ( self , label ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrUniqueKey_GrUniqueKey ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( that : * const GrUniqueKey ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrUniqueKey_GrUniqueKey1 ( & mut __bindgen_tmp , that ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrCaps { _unused : [ u8 ; 0 ] , } pub const GrPixelConfig_kUnknown_GrPixelConfig : GrPixelConfig = 0 ; pub const GrPixelConfig_kAlpha_8_GrPixelConfig : GrPixelConfig = 1 ; pub const GrPixelConfig_kAlpha_8_as_Alpha_GrPixelConfig : GrPixelConfig = 2 ; pub const GrPixelConfig_kAlpha_8_as_Red_GrPixelConfig : GrPixelConfig = 3 ; pub const GrPixelConfig_kGray_8_GrPixelConfig : GrPixelConfig = 4 ; pub const GrPixelConfig_kGray_8_as_Lum_GrPixelConfig : GrPixelConfig = 5 ; pub const GrPixelConfig_kGray_8_as_Red_GrPixelConfig : GrPixelConfig = 6 ; pub const GrPixelConfig_kRGB_565_GrPixelConfig : GrPixelConfig = 7 ; pub const GrPixelConfig_kRGBA_4444_GrPixelConfig : GrPixelConfig = 8 ; pub const GrPixelConfig_kRGBA_8888_GrPixelConfig : GrPixelConfig = 9 ; pub const GrPixelConfig_kRGB_888_GrPixelConfig : GrPixelConfig = 10 ; pub const GrPixelConfig_kRGB_888X_GrPixelConfig : GrPixelConfig = 11 ; pub const GrPixelConfig_kRG_88_GrPixelConfig : GrPixelConfig = 12 ; pub const GrPixelConfig_kBGRA_8888_GrPixelConfig : GrPixelConfig = 13 ; pub const GrPixelConfig_kSRGBA_8888_GrPixelConfig : GrPixelConfig = 14 ; pub const GrPixelConfig_kSBGRA_8888_GrPixelConfig : GrPixelConfig = 15 ; pub const GrPixelConfig_kRGBA_1010102_GrPixelConfig : GrPixelConfig = 16 ; pub const GrPixelConfig_kRGBA_float_GrPixelConfig : GrPixelConfig = 17 ; pub const GrPixelConfig_kRG_float_GrPixelConfig : GrPixelConfig = 18 ; pub const GrPixelConfig_kAlpha_half_GrPixelConfig : GrPixelConfig = 19 ; pub const GrPixelConfig_kAlpha_half_as_Red_GrPixelConfig : GrPixelConfig = 20 ; pub const GrPixelConfig_kRGBA_half_GrPixelConfig : GrPixelConfig = 21 ; pub const GrPixelConfig_kRGB_ETC1_GrPixelConfig : GrPixelConfig = 22 ; pub const GrPixelConfig_kLast_GrPixelConfig : GrPixelConfig = 22 ; # [ doc = " Pixel configurations. This type conflates texture formats, CPU pixel formats, and" ] # [ doc = " premultipliedness. We are moving away from it towards SkColorType and backend API (GL, Vulkan)" ] # [ doc = " texture formats in the public API. Right now this mostly refers to texture formats as we\'re" ] # [ doc = " migrating." ] pub type GrPixelConfig = u32 ; pub const GrSurfaceFlags_kNone_GrSurfaceFlags : GrSurfaceFlags = 0 ; # [ doc = " Creates a texture that can be rendered to as a GrRenderTarget. Use" ] # [ doc = " GrTexture::asRenderTarget() to access." ] pub const GrSurfaceFlags_kRenderTarget_GrSurfaceFlag : GrSurfaceFlags = 1 ; # [ doc = " Clears to zero on creation. It will cause creation failure if initial data is supplied to the" ] # [ doc = " texture. This only affects the base level if the texture is created with MIP levels." ] pub const GrSurfaceFlags_kPerformInitialClear_GrSurfaceFlag : GrSurfaceFlags = 2 ; # [ doc = " Optional bitfield flags that can be set on GrSurfaceDesc (below)." ] pub type GrSurfaceFlags = u32 ; pub use self :: GrSurfaceFlags as GrSurfaceDescFlags ; # [ doc = " Describes a surface to be created." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrSurfaceDesc { # [ doc = "!< bitfield of TextureFlags" ] pub fFlags : GrSurfaceDescFlags , # [ doc = "!< Width of the texture" ] pub fWidth : :: std :: os :: raw :: c_int , # [ doc = "!< Height of the texture" ] pub fHeight : :: std :: os :: raw :: c_int , # [ doc = " Format of source data of the texture. Not guaranteed to be the same as" ] # [ doc = " internal format used by 3D API." ] pub fConfig : GrPixelConfig , # [ doc = " The number of samples per pixel. Zero is treated equivalently to 1. This only" ] # [ doc = " applies if the kRenderTarget_GrSurfaceFlag is set. The actual number" ] # [ doc = " of samples may not exactly match the request. The request will be rounded" ] # [ doc = " up to the next supported sample count. A value larger than the largest" ] # [ doc = " supported sample count will fail." ] pub fSampleCnt : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_GrSurfaceDesc ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrSurfaceDesc > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( GrSurfaceDesc ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrSurfaceDesc > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrSurfaceDesc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceDesc > ( ) ) ) . fFlags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceDesc ) , "::" , stringify ! ( fFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceDesc > ( ) ) ) . fWidth as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceDesc ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceDesc > ( ) ) ) . fHeight as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceDesc ) , "::" , stringify ! ( fHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceDesc > ( ) ) ) . fConfig as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceDesc ) , "::" , stringify ! ( fConfig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceDesc > ( ) ) ) . fSampleCnt as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceDesc ) , "::" , stringify ! ( fSampleCnt ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrSurfaceDescC1Ev" ] pub fn GrSurfaceDesc_GrSurfaceDesc ( this : * mut GrSurfaceDesc ) ; } impl GrSurfaceDesc { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSurfaceDesc_GrSurfaceDesc ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ doc = " The wrapped resource will be removed from the cache as soon as it becomes purgeable. It may" ] # [ doc = " still be assigned and found by a unique key, but the presence of the key will not be used to" ] # [ doc = " keep the resource alive when it has no references." ] pub const GrWrapCacheable_kNo : GrWrapCacheable = 0 ; # [ doc = " The wrapped resource is allowed to remain in the GrResourceCache when it has no references" ] # [ doc = " but has a unique key. Such resources should only be given unique keys when it is known that" ] # [ doc = " the key will eventually be removed from the resource or invalidated via the message bus." ] pub const GrWrapCacheable_kYes : GrWrapCacheable = 1 ; pub type GrWrapCacheable = u8 ; # [ doc = " The resource is budgeted and is subject to purging under budget pressure." ] pub const GrBudgetedType_kBudgeted : GrBudgetedType = 0 ; # [ doc = " The resource is unbudgeted and is purged as soon as it has no refs regardless of whether" ] # [ doc = " it has a unique or scratch key." ] pub const GrBudgetedType_kUnbudgetedUncacheable : GrBudgetedType = 1 ; # [ doc = " The resource is unbudgeted and is allowed to remain in the cache with no refs if it" ] # [ doc = " has a unique key. Scratch keys are ignored." ] pub const GrBudgetedType_kUnbudgetedCacheable : GrBudgetedType = 2 ; pub type GrBudgetedType = u8 ; # [ doc = " No FSAA" ] pub const GrFSAAType_kNone : GrFSAAType = 0 ; # [ doc = " Regular MSAA where each attachment has the same sample count." ] pub const GrFSAAType_kUnifiedMSAA : GrFSAAType = 1 ; # [ doc = " One color sample, N stencil samples." ] pub const GrFSAAType_kMixedSamples : GrFSAAType = 2 ; # [ doc = " The type of full scene antialiasing supported by a render target." ] pub type GrFSAAType = i32 ; pub const GrTextureType_k2D : GrTextureType = 0 ; pub const GrTextureType_kRectangle : GrTextureType = 1 ; pub const GrTextureType_kExternal : GrTextureType = 2 ; # [ doc = " The type of texture. Backends other than GL currently only use the 2D value but the type must" ] # [ doc = " still be known at the API-neutral layer as it used to determine whether MIP maps, renderability," ] # [ doc = " and sampling parameters are legal for proxies that will be instantiated with wrapped textures." ] pub type GrTextureType = i32 ; pub const GrInternalSurfaceFlags_kNone : GrInternalSurfaceFlags = 0 ; pub const GrInternalSurfaceFlags_kNoPendingIO : GrInternalSurfaceFlags = 1 ; pub const GrInternalSurfaceFlags_kSurfaceMask : GrInternalSurfaceFlags = 1 ; pub const GrInternalSurfaceFlags_kReadOnly : GrInternalSurfaceFlags = 2 ; pub const GrInternalSurfaceFlags_kTextureMask : GrInternalSurfaceFlags = 2 ; pub const GrInternalSurfaceFlags_kMixedSampled : GrInternalSurfaceFlags = 4 ; pub const GrInternalSurfaceFlags_kGLRTFBOIDIs0 : GrInternalSurfaceFlags = 8 ; pub const GrInternalSurfaceFlags_kRenderTargetMask : GrInternalSurfaceFlags = 12 ; pub type GrInternalSurfaceFlags = i32 ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrReleaseProcHelper { pub _base : SkRefCnt , pub fReleaseProc : GrReleaseProcHelper_ReleaseProc , pub fReleaseCtx : GrReleaseProcHelper_ReleaseCtx , } pub type GrReleaseProcHelper_ReleaseCtx = * mut :: std :: os :: raw :: c_void ; pub type GrReleaseProcHelper_ReleaseProc = :: core :: option :: Option < unsafe extern "C" fn ( arg1 : GrReleaseProcHelper_ReleaseCtx ) > ; # [ test ] fn bindgen_test_layout_GrReleaseProcHelper ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrReleaseProcHelper > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( GrReleaseProcHelper ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrReleaseProcHelper > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrReleaseProcHelper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrReleaseProcHelper > ( ) ) ) . fReleaseProc as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrReleaseProcHelper ) , "::" , stringify ! ( fReleaseProc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrReleaseProcHelper > ( ) ) ) . fReleaseCtx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrReleaseProcHelper ) , "::" , stringify ! ( fReleaseCtx ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN19GrReleaseProcHelperC1EPFvPvES0_" ] pub fn GrReleaseProcHelper_GrReleaseProcHelper ( this : * mut GrReleaseProcHelper , proc_ : GrReleaseProcHelper_ReleaseProc , ctx : GrReleaseProcHelper_ReleaseCtx ) ; } impl GrReleaseProcHelper { # [ inline ] pub unsafe fn new ( proc_ : GrReleaseProcHelper_ReleaseProc , ctx : GrReleaseProcHelper_ReleaseCtx ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrReleaseProcHelper_GrReleaseProcHelper ( & mut __bindgen_tmp , proc_ , ctx ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN19GrReleaseProcHelperD1Ev" ] pub fn GrReleaseProcHelper_GrReleaseProcHelper_destructor ( this : * mut GrReleaseProcHelper ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrGpu { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrResourceCache { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkTraceMemoryDump { _unused : [ u8 ; 0 ] , } # [ doc = " Base class for GrGpuResource. Handles the various types of refs we need. Separated out as a base" ] # [ doc = " class to isolate the ref-cnting behavior and provide friendship without exposing all of" ] # [ doc = " GrGpuResource." ] # [ doc = "" ] # [ doc = " Gpu resources can have three types of refs:" ] # [ doc = "   1) Normal ref (+ by ref(), - by unref()): These are used by code that is issuing draw calls" ] # [ doc = "      that read and write the resource via GrOpList and by any object that must own a" ] # [ doc = "      GrGpuResource and is itself owned (directly or indirectly) by Skia-client code." ] # [ doc = "   2) Pending read (+ by addPendingRead(), - by completedRead()): GrContext has scheduled a read" ] # [ doc = "      of the resource by the GPU as a result of a skia API call but hasn\'t executed it yet." ] # [ doc = "   3) Pending write (+ by addPendingWrite(), - by completedWrite()): GrContext has scheduled a" ] # [ doc = "      write to the resource by the GPU as a result of a skia API call but hasn\'t executed it yet." ] # [ doc = "" ] # [ doc = " The latter two ref types are private and intended only for Gr core code." ] # [ doc = "" ] # [ doc = " PRIOR to the last ref/IO count being removed DERIVED::notifyAllCntsWillBeZero() will be called" ] # [ doc = " (static poly morphism using CRTP). It is legal for additional ref\'s or pending IOs to be added" ] # [ doc = " during this time. AFTER all the ref/io counts reach zero DERIVED::notifyAllCntsAreZero() will be" ] # [ doc = " called. Similarly when the ref (but not necessarily pending read/write) count reaches 0" ] # [ doc = " DERIVED::notifyRefCountIsZero() will be called. In the case when an unref() causes both" ] # [ doc = " the ref cnt to reach zero and the other counts are zero, notifyRefCountIsZero() will be called" ] # [ doc = " before notifyAllCntsAreZero(). Moreover, if notifyRefCountIsZero() returns false then" ] # [ doc = " notifyAllCntsAreZero() won\'t be called at all. notifyRefCountIsZero() must return false if the" ] # [ doc = " object may be deleted after notifyRefCntIsZero() returns." ] # [ doc = "" ] # [ doc = " GrIORef and GrGpuResource are separate classes for organizational reasons and to be" ] # [ doc = " able to give access via friendship to only the functions related to pending IO operations." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrIORef { pub fRefCnt : i32 , pub fPendingReads : i32 , pub fPendingWrites : i32 , } pub const GrIORef_CntType_kRef_CntType : GrIORef_CntType = 0 ; pub const GrIORef_CntType_kPendingRead_CntType : GrIORef_CntType = 0 ; pub const GrIORef_CntType_kPendingWrite_CntType : GrIORef_CntType = 0 ; pub type GrIORef_CntType = i32 ; # [ repr ( C ) ] pub struct GrGpuResource__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ doc = " Base class for objects that can be kept in the GrResourceCache." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrGpuResource { pub vtable_ : * const GrGpuResource__bindgen_vtable , pub _base : GrIORef , pub fCacheArrayIndex : :: std :: os :: raw :: c_int , pub fTimestamp : u32 , pub fTimeWhenBecamePurgeable : std_chrono_steady_clock_time_point , pub fScratchKey : GrScratchKey , pub fUniqueKey : GrUniqueKey , pub fGpu : * mut GrGpu , pub fGpuMemorySize : usize , pub fBudgetedType : GrBudgetedType , pub fRefsWrappedObjects : bool , pub fUniqueID : GrGpuResource_UniqueID , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrGpuResource_UniqueID { pub fID : u32 , } # [ test ] fn bindgen_test_layout_GrGpuResource_UniqueID ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrGpuResource_UniqueID > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( GrGpuResource_UniqueID ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrGpuResource_UniqueID > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrGpuResource_UniqueID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource_UniqueID > ( ) ) ) . fID as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource_UniqueID ) , "::" , stringify ! ( fID ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrGpuResource8UniqueID6asUIntEv" ] pub fn GrGpuResource_UniqueID_asUInt ( this : * const GrGpuResource_UniqueID ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource8UniqueID11makeInvalidEv" ] pub fn GrGpuResource_UniqueID_makeInvalid ( this : * mut GrGpuResource_UniqueID ) ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrGpuResource8UniqueID9isInvalidEv" ] pub fn GrGpuResource_UniqueID_isInvalid ( this : * const GrGpuResource_UniqueID ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource8UniqueIDC1Ev" ] pub fn GrGpuResource_UniqueID_UniqueID ( this : * mut GrGpuResource_UniqueID ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource8UniqueIDC1Ej" ] pub fn GrGpuResource_UniqueID_UniqueID1 ( this : * mut GrGpuResource_UniqueID , id : u32 ) ; } impl GrGpuResource_UniqueID { # [ inline ] pub unsafe fn asUInt ( & self ) -> u32 { GrGpuResource_UniqueID_asUInt ( self ) } # [ inline ] pub unsafe fn makeInvalid ( & mut self ) { GrGpuResource_UniqueID_makeInvalid ( self ) } # [ inline ] pub unsafe fn isInvalid ( & self ) -> bool { GrGpuResource_UniqueID_isInvalid ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrGpuResource_UniqueID_UniqueID ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( id : u32 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrGpuResource_UniqueID_UniqueID1 ( & mut __bindgen_tmp , id ) ; __bindgen_tmp } } # [ doc = " Internal-only helper class used for manipulations of the resource by the cache." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrGpuResource_CacheAccess { _unused : [ u8 ; 0 ] , } # [ doc = " Internal-only helper class used for manipulations of the resource by internal code." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrGpuResource_ResourcePriv { _unused : [ u8 ; 0 ] , } pub type GrGpuResource_INHERITED = GrIORef ; extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource21kInvalidGpuMemorySizeE" ] pub static GrGpuResource_kInvalidGpuMemorySize : usize ; } # [ test ] fn bindgen_test_layout_GrGpuResource ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrGpuResource > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( GrGpuResource ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrGpuResource > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrGpuResource ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fCacheArrayIndex as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fCacheArrayIndex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fTimestamp as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fTimestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fTimeWhenBecamePurgeable as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fTimeWhenBecamePurgeable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fScratchKey as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fScratchKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fUniqueKey as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fUniqueKey ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fGpu as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fGpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fGpuMemorySize as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fGpuMemorySize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fBudgetedType as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fBudgetedType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fRefsWrappedObjects as * const _ as usize } , 153usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fRefsWrappedObjects ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGpuResource > ( ) ) ) . fUniqueID as * const _ as usize } , 156usize , concat ! ( "Offset of field: " , stringify ! ( GrGpuResource ) , "::" , stringify ! ( fUniqueID ) ) ) ; } extern "C" { # [ doc = " Tests whether a object has been abandoned or released. All objects will" ] # [ doc = " be in this state after their creating GrContext is destroyed or has" ] # [ doc = " contextLost called. It\'s up to the client to test wasDestroyed() before" ] # [ doc = " attempting to use an object if it holds refs on objects across" ] # [ doc = " ~GrContext, freeResources with the force flag, or contextLost." ] # [ doc = "" ] # [ doc = " @return true if the object has been released or abandoned," ] # [ doc = "         false otherwise." ] # [ link_name = "\u{1}__ZNK13GrGpuResource12wasDestroyedEv" ] pub fn GrGpuResource_wasDestroyed ( this : * const GrGpuResource ) -> bool ; } extern "C" { # [ doc = " Retrieves the context that owns the object. Note that it is possible for" ] # [ doc = " this to return NULL. When objects have been release()ed or abandon()ed" ] # [ doc = " they no longer have an owning context. Destroying a GrContext" ] # [ doc = " automatically releases all its resources." ] # [ link_name = "\u{1}__ZNK13GrGpuResource10getContextEv" ] pub fn GrGpuResource_getContext ( this : * const GrGpuResource ) -> * const GrContext ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource10getContextEv" ] pub fn GrGpuResource_getContext1 ( this : * mut GrGpuResource ) -> * mut GrContext ; } extern "C" { # [ doc = " Retrieves the amount of GPU memory used by this resource in bytes. It is" ] # [ doc = " approximate since we aren\'t aware of additional padding or copies made" ] # [ doc = " by the driver." ] # [ doc = "" ] # [ doc = " @return the amount of GPU memory used in bytes" ] # [ link_name = "\u{1}__ZNK13GrGpuResource13gpuMemorySizeEv" ] pub fn GrGpuResource_gpuMemorySize ( this : * const GrGpuResource ) -> usize ; } extern "C" { # [ doc = " Gets an id that is unique for this GrGpuResource object. It is static in that it does" ] # [ doc = " not change when the content of the GrGpuResource object changes. This will never return" ] # [ doc = " 0." ] # [ link_name = "\u{1}__ZNK13GrGpuResource8uniqueIDEv" ] pub fn GrGpuResource_uniqueID ( this : * const GrGpuResource ) -> GrGpuResource_UniqueID ; } extern "C" { # [ doc = " Returns the current unique key for the resource. It will be invalid if the resource has no" ] # [ doc = "associated unique key." ] # [ link_name = "\u{1}__ZNK13GrGpuResource12getUniqueKeyEv" ] pub fn GrGpuResource_getUniqueKey ( this : * const GrGpuResource ) -> * const GrUniqueKey ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource11cacheAccessEv" ] pub fn GrGpuResource_cacheAccess ( this : * mut GrGpuResource ) -> GrGpuResource_CacheAccess ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrGpuResource11cacheAccessEv" ] pub fn GrGpuResource_cacheAccess1 ( this : * const GrGpuResource ) -> GrGpuResource_CacheAccess ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource12resourcePrivEv" ] pub fn GrGpuResource_resourcePriv ( this : * mut GrGpuResource ) -> GrGpuResource_ResourcePriv ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrGpuResource12resourcePrivEv" ] pub fn GrGpuResource_resourcePriv1 ( this : * const GrGpuResource ) -> GrGpuResource_ResourcePriv ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource14CreateUniqueIDEv" ] pub fn GrGpuResource_CreateUniqueID ( ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource17registerWithCacheE10SkBudgeted" ] pub fn GrGpuResource_registerWithCache ( this : * mut GrGpuResource , arg1 : SkBudgeted ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResource24registerWithCacheWrappedE15GrWrapCacheable" ] pub fn GrGpuResource_registerWithCacheWrapped ( this : * mut GrGpuResource , arg1 : GrWrapCacheable ) ; } extern "C" { # [ link_name = "\u{1}__ZNK13GrGpuResource6getGpuEv" ] pub fn GrGpuResource_getGpu ( this : * const GrGpuResource ) -> * mut GrGpu ; } extern "C" { # [ doc = " Returns a string that uniquely identifies this resource." ] # [ link_name = "\u{1}__ZNK13GrGpuResource15getResourceNameEv" ] pub fn GrGpuResource_getResourceName ( this : * const GrGpuResource ) -> SkString ; } extern "C" { # [ doc = " A helper for subclasses that override dumpMemoryStatistics(). This method using a format" ] # [ doc = " consistent with the default implementation of dumpMemoryStatistics() but allows the caller" ] # [ doc = " to customize various inputs." ] # [ link_name = "\u{1}__ZNK13GrGpuResource24dumpMemoryStatisticsPrivEP17SkTraceMemoryDumpRK8SkStringPKcm" ] pub fn GrGpuResource_dumpMemoryStatisticsPriv ( this : * const GrGpuResource , traceMemoryDump : * mut SkTraceMemoryDump , resourceName : * const SkString , type_ : * const :: std :: os :: raw :: c_char , size : usize ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResourceC2EP5GrGpu" ] pub fn GrGpuResource_GrGpuResource ( this : * mut GrGpuResource , arg1 : * mut GrGpu ) ; } impl GrGpuResource { # [ inline ] pub unsafe fn wasDestroyed ( & self ) -> bool { GrGpuResource_wasDestroyed ( self ) } # [ inline ] pub unsafe fn getContext ( & self ) -> * const GrContext { GrGpuResource_getContext ( self ) } # [ inline ] pub unsafe fn getContext1 ( & mut self ) -> * mut GrContext { GrGpuResource_getContext1 ( self ) } # [ inline ] pub unsafe fn gpuMemorySize ( & self ) -> usize { GrGpuResource_gpuMemorySize ( self ) } # [ inline ] pub unsafe fn uniqueID ( & self ) -> GrGpuResource_UniqueID { GrGpuResource_uniqueID ( self ) } # [ inline ] pub unsafe fn getUniqueKey ( & self ) -> * const GrUniqueKey { GrGpuResource_getUniqueKey ( self ) } # [ inline ] pub unsafe fn cacheAccess ( & mut self ) -> GrGpuResource_CacheAccess { GrGpuResource_cacheAccess ( self ) } # [ inline ] pub unsafe fn cacheAccess1 ( & self ) -> GrGpuResource_CacheAccess { GrGpuResource_cacheAccess1 ( self ) } # [ inline ] pub unsafe fn resourcePriv ( & mut self ) -> GrGpuResource_ResourcePriv { GrGpuResource_resourcePriv ( self ) } # [ inline ] pub unsafe fn resourcePriv1 ( & self ) -> GrGpuResource_ResourcePriv { GrGpuResource_resourcePriv1 ( self ) } # [ inline ] pub unsafe fn CreateUniqueID ( ) -> u32 { GrGpuResource_CreateUniqueID ( ) } # [ inline ] pub unsafe fn registerWithCache ( & mut self , arg1 : SkBudgeted ) { GrGpuResource_registerWithCache ( self , arg1 ) } # [ inline ] pub unsafe fn registerWithCacheWrapped ( & mut self , arg1 : GrWrapCacheable ) { GrGpuResource_registerWithCacheWrapped ( self , arg1 ) } # [ inline ] pub unsafe fn getGpu ( & self ) -> * mut GrGpu { GrGpuResource_getGpu ( self ) } # [ inline ] pub unsafe fn getResourceName ( & self ) -> SkString { GrGpuResource_getResourceName ( self ) } # [ inline ] pub unsafe fn dumpMemoryStatisticsPriv ( & self , traceMemoryDump : * mut SkTraceMemoryDump , resourceName : * const SkString , type_ : * const :: std :: os :: raw :: c_char , size : usize ) { GrGpuResource_dumpMemoryStatisticsPriv ( self , traceMemoryDump , resourceName , type_ , size ) } # [ inline ] pub unsafe fn new ( arg1 : * mut GrGpu ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrGpuResource_GrGpuResource ( & mut __bindgen_tmp , arg1 ) ; __bindgen_tmp } } extern "C" { # [ doc = " Dumps memory usage information for this GrGpuResource to traceMemoryDump." ] # [ doc = " Typically, subclasses should not need to override this, and should only" ] # [ doc = " need to override setMemoryBacking." ] # [ link_name = "\u{1}__ZNK13GrGpuResource20dumpMemoryStatisticsEP17SkTraceMemoryDump" ] pub fn GrGpuResource_dumpMemoryStatistics ( this : * mut :: std :: os :: raw :: c_void , traceMemoryDump : * mut SkTraceMemoryDump ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrGpuResourceD1Ev" ] pub fn GrGpuResource_GrGpuResource_destructor ( this : * mut GrGpuResource ) ; } extern "C" { # [ doc = " Overridden to free GPU resources in the backend API." ] # [ link_name = "\u{1}__ZN13GrGpuResource9onReleaseEv" ] pub fn GrGpuResource_onRelease ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ doc = " Overridden to abandon any internal handles, ptrs, etc to backend API resources." ] # [ doc = "This may be called when the underlying 3D context is no longer valid and so no" ] # [ doc = "backend API calls should be made." ] # [ link_name = "\u{1}__ZN13GrGpuResource9onAbandonEv" ] pub fn GrGpuResource_onAbandon ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ doc = " Allows subclasses to add additional backing information to the SkTraceMemoryDump." ] # [ link_name = "\u{1}__ZNK13GrGpuResource16setMemoryBackingEP17SkTraceMemoryDumpRK8SkString" ] pub fn GrGpuResource_setMemoryBacking ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut SkTraceMemoryDump , arg2 : * const SkString ) ; } # [ doc = " Declares typedefs for all the GL functions used in GrGLInterface" ] pub type GrGLenum = :: std :: os :: raw :: c_uint ; pub type GrGLuint = :: std :: os :: raw :: c_uint ; # [ doc = "" ] # [ doc = "**" ] # [ doc = "* Types for interacting with GL resources created externally to Skia. GrBackendObjects for GL" ] # [ doc = "* textures are really const GrGLTexture*. The fFormat here should be a sized, internal format" ] # [ doc = "* for the texture. We will try to use the sized format if the GL Context supports it, otherwise" ] # [ doc = "* we will internally fall back to using the base internal formats." ] # [ doc = "*/" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrGLTextureInfo { pub fTarget : GrGLenum , pub fID : GrGLuint , pub fFormat : GrGLenum , } # [ test ] fn bindgen_test_layout_GrGLTextureInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrGLTextureInfo > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( GrGLTextureInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrGLTextureInfo > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrGLTextureInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGLTextureInfo > ( ) ) ) . fTarget as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrGLTextureInfo ) , "::" , stringify ! ( fTarget ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGLTextureInfo > ( ) ) ) . fID as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrGLTextureInfo ) , "::" , stringify ! ( fID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGLTextureInfo > ( ) ) ) . fFormat as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrGLTextureInfo ) , "::" , stringify ! ( fFormat ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrGLFramebufferInfo { pub fFBOID : GrGLuint , pub fFormat : GrGLenum , } # [ test ] fn bindgen_test_layout_GrGLFramebufferInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrGLFramebufferInfo > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrGLFramebufferInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrGLFramebufferInfo > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrGLFramebufferInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGLFramebufferInfo > ( ) ) ) . fFBOID as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrGLFramebufferInfo ) , "::" , stringify ! ( fFBOID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrGLFramebufferInfo > ( ) ) ) . fFormat as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrGLFramebufferInfo ) , "::" , stringify ! ( fFormat ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrMockTextureInfo { pub fConfig : GrPixelConfig , pub fID : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_GrMockTextureInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrMockTextureInfo > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrMockTextureInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrMockTextureInfo > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrMockTextureInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockTextureInfo > ( ) ) ) . fConfig as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrMockTextureInfo ) , "::" , stringify ! ( fConfig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockTextureInfo > ( ) ) ) . fID as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrMockTextureInfo ) , "::" , stringify ! ( fID ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrMockRenderTargetInfo { pub fConfig : GrPixelConfig , pub fID : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_GrMockRenderTargetInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrMockRenderTargetInfo > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrMockRenderTargetInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrMockRenderTargetInfo > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrMockRenderTargetInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockRenderTargetInfo > ( ) ) ) . fConfig as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrMockRenderTargetInfo ) , "::" , stringify ! ( fConfig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockRenderTargetInfo > ( ) ) ) . fID as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrMockRenderTargetInfo ) , "::" , stringify ! ( fID ) ) ) ; } # [ doc = " A pointer to this type is used as the GrBackendContext when creating a Mock GrContext. It can be" ] # [ doc = " used to specify capability options for the mock context. If nullptr is used a default constructed" ] # [ doc = " GrMockOptions is used." ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrMockOptions { pub fInstanceAttribSupport : bool , pub fHalfFloatVertexAttributeSupport : bool , pub fMapBufferFlags : u32 , pub fMaxTextureSize : :: std :: os :: raw :: c_int , pub fMaxRenderTargetSize : :: std :: os :: raw :: c_int , pub fMaxVertexAttributes : :: std :: os :: raw :: c_int , pub fConfigOptions : [ GrMockOptions_ConfigOptions ; 23usize ] , pub fGeometryShaderSupport : bool , pub fIntegerSupport : bool , pub fFlatInterpolationSupport : bool , pub fMaxVertexSamplers : :: std :: os :: raw :: c_int , pub fMaxFragmentSamplers : :: std :: os :: raw :: c_int , pub fShaderDerivativeSupport : bool , pub fFailTextureAllocations : bool , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrMockOptions_ConfigOptions { pub fRenderability : GrMockOptions_ConfigOptions_Renderability , pub fTexturable : bool , } pub const GrMockOptions_ConfigOptions_Renderability_kNo : GrMockOptions_ConfigOptions_Renderability = 0 ; pub const GrMockOptions_ConfigOptions_Renderability_kNonMSAA : GrMockOptions_ConfigOptions_Renderability = 1 ; pub const GrMockOptions_ConfigOptions_Renderability_kMSAA : GrMockOptions_ConfigOptions_Renderability = 2 ; pub type GrMockOptions_ConfigOptions_Renderability = u32 ; # [ test ] fn bindgen_test_layout_GrMockOptions_ConfigOptions ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrMockOptions_ConfigOptions > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrMockOptions_ConfigOptions ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrMockOptions_ConfigOptions > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrMockOptions_ConfigOptions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions_ConfigOptions > ( ) ) ) . fRenderability as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions_ConfigOptions ) , "::" , stringify ! ( fRenderability ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions_ConfigOptions > ( ) ) ) . fTexturable as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions_ConfigOptions ) , "::" , stringify ! ( fTexturable ) ) ) ; } # [ test ] fn bindgen_test_layout_GrMockOptions ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrMockOptions > ( ) , 220usize , concat ! ( "Size of: " , stringify ! ( GrMockOptions ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrMockOptions > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrMockOptions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fInstanceAttribSupport as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fInstanceAttribSupport ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fHalfFloatVertexAttributeSupport as * const _ as usize } , 1usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fHalfFloatVertexAttributeSupport ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fMapBufferFlags as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fMapBufferFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fMaxTextureSize as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fMaxTextureSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fMaxRenderTargetSize as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fMaxRenderTargetSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fMaxVertexAttributes as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fMaxVertexAttributes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fConfigOptions as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fConfigOptions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fGeometryShaderSupport as * const _ as usize } , 204usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fGeometryShaderSupport ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fIntegerSupport as * const _ as usize } , 205usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fIntegerSupport ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fFlatInterpolationSupport as * const _ as usize } , 206usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fFlatInterpolationSupport ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fMaxVertexSamplers as * const _ as usize } , 208usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fMaxVertexSamplers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fMaxFragmentSamplers as * const _ as usize } , 212usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fMaxFragmentSamplers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fShaderDerivativeSupport as * const _ as usize } , 216usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fShaderDerivativeSupport ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrMockOptions > ( ) ) ) . fFailTextureAllocations as * const _ as usize } , 217usize , concat ! ( "Offset of field: " , stringify ! ( GrMockOptions ) , "::" , stringify ! ( fFailTextureAllocations ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrMockOptionsC1Ev" ] pub fn GrMockOptions_GrMockOptions ( this : * mut GrMockOptions ) ; } impl GrMockOptions { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrMockOptions_GrMockOptions ( & mut __bindgen_tmp ) ; __bindgen_tmp } } pub type VkFlags = u32 ; pub type VkBool32 = u32 ; pub type VkDeviceSize = u64 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VkDeviceMemory_T { _unused : [ u8 ; 0 ] , } pub type VkDeviceMemory = * mut VkDeviceMemory_T ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct VkImage_T { _unused : [ u8 ; 0 ] , } pub type VkImage = * mut VkImage_T ; pub const VkFormat_VK_FORMAT_UNDEFINED : VkFormat = 0 ; pub const VkFormat_VK_FORMAT_R4G4_UNORM_PACK8 : VkFormat = 1 ; pub const VkFormat_VK_FORMAT_R4G4B4A4_UNORM_PACK16 : VkFormat = 2 ; pub const VkFormat_VK_FORMAT_B4G4R4A4_UNORM_PACK16 : VkFormat = 3 ; pub const VkFormat_VK_FORMAT_R5G6B5_UNORM_PACK16 : VkFormat = 4 ; pub const VkFormat_VK_FORMAT_B5G6R5_UNORM_PACK16 : VkFormat = 5 ; pub const VkFormat_VK_FORMAT_R5G5B5A1_UNORM_PACK16 : VkFormat = 6 ; pub const VkFormat_VK_FORMAT_B5G5R5A1_UNORM_PACK16 : VkFormat = 7 ; pub const VkFormat_VK_FORMAT_A1R5G5B5_UNORM_PACK16 : VkFormat = 8 ; pub const VkFormat_VK_FORMAT_R8_UNORM : VkFormat = 9 ; pub const VkFormat_VK_FORMAT_R8_SNORM : VkFormat = 10 ; pub const VkFormat_VK_FORMAT_R8_USCALED : VkFormat = 11 ; pub const VkFormat_VK_FORMAT_R8_SSCALED : VkFormat = 12 ; pub const VkFormat_VK_FORMAT_R8_UINT : VkFormat = 13 ; pub const VkFormat_VK_FORMAT_R8_SINT : VkFormat = 14 ; pub const VkFormat_VK_FORMAT_R8_SRGB : VkFormat = 15 ; pub const VkFormat_VK_FORMAT_R8G8_UNORM : VkFormat = 16 ; pub const VkFormat_VK_FORMAT_R8G8_SNORM : VkFormat = 17 ; pub const VkFormat_VK_FORMAT_R8G8_USCALED : VkFormat = 18 ; pub const VkFormat_VK_FORMAT_R8G8_SSCALED : VkFormat = 19 ; pub const VkFormat_VK_FORMAT_R8G8_UINT : VkFormat = 20 ; pub const VkFormat_VK_FORMAT_R8G8_SINT : VkFormat = 21 ; pub const VkFormat_VK_FORMAT_R8G8_SRGB : VkFormat = 22 ; pub const VkFormat_VK_FORMAT_R8G8B8_UNORM : VkFormat = 23 ; pub const VkFormat_VK_FORMAT_R8G8B8_SNORM : VkFormat = 24 ; pub const VkFormat_VK_FORMAT_R8G8B8_USCALED : VkFormat = 25 ; pub const VkFormat_VK_FORMAT_R8G8B8_SSCALED : VkFormat = 26 ; pub const VkFormat_VK_FORMAT_R8G8B8_UINT : VkFormat = 27 ; pub const VkFormat_VK_FORMAT_R8G8B8_SINT : VkFormat = 28 ; pub const VkFormat_VK_FORMAT_R8G8B8_SRGB : VkFormat = 29 ; pub const VkFormat_VK_FORMAT_B8G8R8_UNORM : VkFormat = 30 ; pub const VkFormat_VK_FORMAT_B8G8R8_SNORM : VkFormat = 31 ; pub const VkFormat_VK_FORMAT_B8G8R8_USCALED : VkFormat = 32 ; pub const VkFormat_VK_FORMAT_B8G8R8_SSCALED : VkFormat = 33 ; pub const VkFormat_VK_FORMAT_B8G8R8_UINT : VkFormat = 34 ; pub const VkFormat_VK_FORMAT_B8G8R8_SINT : VkFormat = 35 ; pub const VkFormat_VK_FORMAT_B8G8R8_SRGB : VkFormat = 36 ; pub const VkFormat_VK_FORMAT_R8G8B8A8_UNORM : VkFormat = 37 ; pub const VkFormat_VK_FORMAT_R8G8B8A8_SNORM : VkFormat = 38 ; pub const VkFormat_VK_FORMAT_R8G8B8A8_USCALED : VkFormat = 39 ; pub const VkFormat_VK_FORMAT_R8G8B8A8_SSCALED : VkFormat = 40 ; pub const VkFormat_VK_FORMAT_R8G8B8A8_UINT : VkFormat = 41 ; pub const VkFormat_VK_FORMAT_R8G8B8A8_SINT : VkFormat = 42 ; pub const VkFormat_VK_FORMAT_R8G8B8A8_SRGB : VkFormat = 43 ; pub const VkFormat_VK_FORMAT_B8G8R8A8_UNORM : VkFormat = 44 ; pub const VkFormat_VK_FORMAT_B8G8R8A8_SNORM : VkFormat = 45 ; pub const VkFormat_VK_FORMAT_B8G8R8A8_USCALED : VkFormat = 46 ; pub const VkFormat_VK_FORMAT_B8G8R8A8_SSCALED : VkFormat = 47 ; pub const VkFormat_VK_FORMAT_B8G8R8A8_UINT : VkFormat = 48 ; pub const VkFormat_VK_FORMAT_B8G8R8A8_SINT : VkFormat = 49 ; pub const VkFormat_VK_FORMAT_B8G8R8A8_SRGB : VkFormat = 50 ; pub const VkFormat_VK_FORMAT_A8B8G8R8_UNORM_PACK32 : VkFormat = 51 ; pub const VkFormat_VK_FORMAT_A8B8G8R8_SNORM_PACK32 : VkFormat = 52 ; pub const VkFormat_VK_FORMAT_A8B8G8R8_USCALED_PACK32 : VkFormat = 53 ; pub const VkFormat_VK_FORMAT_A8B8G8R8_SSCALED_PACK32 : VkFormat = 54 ; pub const VkFormat_VK_FORMAT_A8B8G8R8_UINT_PACK32 : VkFormat = 55 ; pub const VkFormat_VK_FORMAT_A8B8G8R8_SINT_PACK32 : VkFormat = 56 ; pub const VkFormat_VK_FORMAT_A8B8G8R8_SRGB_PACK32 : VkFormat = 57 ; pub const VkFormat_VK_FORMAT_A2R10G10B10_UNORM_PACK32 : VkFormat = 58 ; pub const VkFormat_VK_FORMAT_A2R10G10B10_SNORM_PACK32 : VkFormat = 59 ; pub const VkFormat_VK_FORMAT_A2R10G10B10_USCALED_PACK32 : VkFormat = 60 ; pub const VkFormat_VK_FORMAT_A2R10G10B10_SSCALED_PACK32 : VkFormat = 61 ; pub const VkFormat_VK_FORMAT_A2R10G10B10_UINT_PACK32 : VkFormat = 62 ; pub const VkFormat_VK_FORMAT_A2R10G10B10_SINT_PACK32 : VkFormat = 63 ; pub const VkFormat_VK_FORMAT_A2B10G10R10_UNORM_PACK32 : VkFormat = 64 ; pub const VkFormat_VK_FORMAT_A2B10G10R10_SNORM_PACK32 : VkFormat = 65 ; pub const VkFormat_VK_FORMAT_A2B10G10R10_USCALED_PACK32 : VkFormat = 66 ; pub const VkFormat_VK_FORMAT_A2B10G10R10_SSCALED_PACK32 : VkFormat = 67 ; pub const VkFormat_VK_FORMAT_A2B10G10R10_UINT_PACK32 : VkFormat = 68 ; pub const VkFormat_VK_FORMAT_A2B10G10R10_SINT_PACK32 : VkFormat = 69 ; pub const VkFormat_VK_FORMAT_R16_UNORM : VkFormat = 70 ; pub const VkFormat_VK_FORMAT_R16_SNORM : VkFormat = 71 ; pub const VkFormat_VK_FORMAT_R16_USCALED : VkFormat = 72 ; pub const VkFormat_VK_FORMAT_R16_SSCALED : VkFormat = 73 ; pub const VkFormat_VK_FORMAT_R16_UINT : VkFormat = 74 ; pub const VkFormat_VK_FORMAT_R16_SINT : VkFormat = 75 ; pub const VkFormat_VK_FORMAT_R16_SFLOAT : VkFormat = 76 ; pub const VkFormat_VK_FORMAT_R16G16_UNORM : VkFormat = 77 ; pub const VkFormat_VK_FORMAT_R16G16_SNORM : VkFormat = 78 ; pub const VkFormat_VK_FORMAT_R16G16_USCALED : VkFormat = 79 ; pub const VkFormat_VK_FORMAT_R16G16_SSCALED : VkFormat = 80 ; pub const VkFormat_VK_FORMAT_R16G16_UINT : VkFormat = 81 ; pub const VkFormat_VK_FORMAT_R16G16_SINT : VkFormat = 82 ; pub const VkFormat_VK_FORMAT_R16G16_SFLOAT : VkFormat = 83 ; pub const VkFormat_VK_FORMAT_R16G16B16_UNORM : VkFormat = 84 ; pub const VkFormat_VK_FORMAT_R16G16B16_SNORM : VkFormat = 85 ; pub const VkFormat_VK_FORMAT_R16G16B16_USCALED : VkFormat = 86 ; pub const VkFormat_VK_FORMAT_R16G16B16_SSCALED : VkFormat = 87 ; pub const VkFormat_VK_FORMAT_R16G16B16_UINT : VkFormat = 88 ; pub const VkFormat_VK_FORMAT_R16G16B16_SINT : VkFormat = 89 ; pub const VkFormat_VK_FORMAT_R16G16B16_SFLOAT : VkFormat = 90 ; pub const VkFormat_VK_FORMAT_R16G16B16A16_UNORM : VkFormat = 91 ; pub const VkFormat_VK_FORMAT_R16G16B16A16_SNORM : VkFormat = 92 ; pub const VkFormat_VK_FORMAT_R16G16B16A16_USCALED : VkFormat = 93 ; pub const VkFormat_VK_FORMAT_R16G16B16A16_SSCALED : VkFormat = 94 ; pub const VkFormat_VK_FORMAT_R16G16B16A16_UINT : VkFormat = 95 ; pub const VkFormat_VK_FORMAT_R16G16B16A16_SINT : VkFormat = 96 ; pub const VkFormat_VK_FORMAT_R16G16B16A16_SFLOAT : VkFormat = 97 ; pub const VkFormat_VK_FORMAT_R32_UINT : VkFormat = 98 ; pub const VkFormat_VK_FORMAT_R32_SINT : VkFormat = 99 ; pub const VkFormat_VK_FORMAT_R32_SFLOAT : VkFormat = 100 ; pub const VkFormat_VK_FORMAT_R32G32_UINT : VkFormat = 101 ; pub const VkFormat_VK_FORMAT_R32G32_SINT : VkFormat = 102 ; pub const VkFormat_VK_FORMAT_R32G32_SFLOAT : VkFormat = 103 ; pub const VkFormat_VK_FORMAT_R32G32B32_UINT : VkFormat = 104 ; pub const VkFormat_VK_FORMAT_R32G32B32_SINT : VkFormat = 105 ; pub const VkFormat_VK_FORMAT_R32G32B32_SFLOAT : VkFormat = 106 ; pub const VkFormat_VK_FORMAT_R32G32B32A32_UINT : VkFormat = 107 ; pub const VkFormat_VK_FORMAT_R32G32B32A32_SINT : VkFormat = 108 ; pub const VkFormat_VK_FORMAT_R32G32B32A32_SFLOAT : VkFormat = 109 ; pub const VkFormat_VK_FORMAT_R64_UINT : VkFormat = 110 ; pub const VkFormat_VK_FORMAT_R64_SINT : VkFormat = 111 ; pub const VkFormat_VK_FORMAT_R64_SFLOAT : VkFormat = 112 ; pub const VkFormat_VK_FORMAT_R64G64_UINT : VkFormat = 113 ; pub const VkFormat_VK_FORMAT_R64G64_SINT : VkFormat = 114 ; pub const VkFormat_VK_FORMAT_R64G64_SFLOAT : VkFormat = 115 ; pub const VkFormat_VK_FORMAT_R64G64B64_UINT : VkFormat = 116 ; pub const VkFormat_VK_FORMAT_R64G64B64_SINT : VkFormat = 117 ; pub const VkFormat_VK_FORMAT_R64G64B64_SFLOAT : VkFormat = 118 ; pub const VkFormat_VK_FORMAT_R64G64B64A64_UINT : VkFormat = 119 ; pub const VkFormat_VK_FORMAT_R64G64B64A64_SINT : VkFormat = 120 ; pub const VkFormat_VK_FORMAT_R64G64B64A64_SFLOAT : VkFormat = 121 ; pub const VkFormat_VK_FORMAT_B10G11R11_UFLOAT_PACK32 : VkFormat = 122 ; pub const VkFormat_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 : VkFormat = 123 ; pub const VkFormat_VK_FORMAT_D16_UNORM : VkFormat = 124 ; pub const VkFormat_VK_FORMAT_X8_D24_UNORM_PACK32 : VkFormat = 125 ; pub const VkFormat_VK_FORMAT_D32_SFLOAT : VkFormat = 126 ; pub const VkFormat_VK_FORMAT_S8_UINT : VkFormat = 127 ; pub const VkFormat_VK_FORMAT_D16_UNORM_S8_UINT : VkFormat = 128 ; pub const VkFormat_VK_FORMAT_D24_UNORM_S8_UINT : VkFormat = 129 ; pub const VkFormat_VK_FORMAT_D32_SFLOAT_S8_UINT : VkFormat = 130 ; pub const VkFormat_VK_FORMAT_BC1_RGB_UNORM_BLOCK : VkFormat = 131 ; pub const VkFormat_VK_FORMAT_BC1_RGB_SRGB_BLOCK : VkFormat = 132 ; pub const VkFormat_VK_FORMAT_BC1_RGBA_UNORM_BLOCK : VkFormat = 133 ; pub const VkFormat_VK_FORMAT_BC1_RGBA_SRGB_BLOCK : VkFormat = 134 ; pub const VkFormat_VK_FORMAT_BC2_UNORM_BLOCK : VkFormat = 135 ; pub const VkFormat_VK_FORMAT_BC2_SRGB_BLOCK : VkFormat = 136 ; pub const VkFormat_VK_FORMAT_BC3_UNORM_BLOCK : VkFormat = 137 ; pub const VkFormat_VK_FORMAT_BC3_SRGB_BLOCK : VkFormat = 138 ; pub const VkFormat_VK_FORMAT_BC4_UNORM_BLOCK : VkFormat = 139 ; pub const VkFormat_VK_FORMAT_BC4_SNORM_BLOCK : VkFormat = 140 ; pub const VkFormat_VK_FORMAT_BC5_UNORM_BLOCK : VkFormat = 141 ; pub const VkFormat_VK_FORMAT_BC5_SNORM_BLOCK : VkFormat = 142 ; pub const VkFormat_VK_FORMAT_BC6H_UFLOAT_BLOCK : VkFormat = 143 ; pub const VkFormat_VK_FORMAT_BC6H_SFLOAT_BLOCK : VkFormat = 144 ; pub const VkFormat_VK_FORMAT_BC7_UNORM_BLOCK : VkFormat = 145 ; pub const VkFormat_VK_FORMAT_BC7_SRGB_BLOCK : VkFormat = 146 ; pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK : VkFormat = 147 ; pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK : VkFormat = 148 ; pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK : VkFormat = 149 ; pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK : VkFormat = 150 ; pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK : VkFormat = 151 ; pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK : VkFormat = 152 ; pub const VkFormat_VK_FORMAT_EAC_R11_UNORM_BLOCK : VkFormat = 153 ; pub const VkFormat_VK_FORMAT_EAC_R11_SNORM_BLOCK : VkFormat = 154 ; pub const VkFormat_VK_FORMAT_EAC_R11G11_UNORM_BLOCK : VkFormat = 155 ; pub const VkFormat_VK_FORMAT_EAC_R11G11_SNORM_BLOCK : VkFormat = 156 ; pub const VkFormat_VK_FORMAT_ASTC_4x4_UNORM_BLOCK : VkFormat = 157 ; pub const VkFormat_VK_FORMAT_ASTC_4x4_SRGB_BLOCK : VkFormat = 158 ; pub const VkFormat_VK_FORMAT_ASTC_5x4_UNORM_BLOCK : VkFormat = 159 ; pub const VkFormat_VK_FORMAT_ASTC_5x4_SRGB_BLOCK : VkFormat = 160 ; pub const VkFormat_VK_FORMAT_ASTC_5x5_UNORM_BLOCK : VkFormat = 161 ; pub const VkFormat_VK_FORMAT_ASTC_5x5_SRGB_BLOCK : VkFormat = 162 ; pub const VkFormat_VK_FORMAT_ASTC_6x5_UNORM_BLOCK : VkFormat = 163 ; pub const VkFormat_VK_FORMAT_ASTC_6x5_SRGB_BLOCK : VkFormat = 164 ; pub const VkFormat_VK_FORMAT_ASTC_6x6_UNORM_BLOCK : VkFormat = 165 ; pub const VkFormat_VK_FORMAT_ASTC_6x6_SRGB_BLOCK : VkFormat = 166 ; pub const VkFormat_VK_FORMAT_ASTC_8x5_UNORM_BLOCK : VkFormat = 167 ; pub const VkFormat_VK_FORMAT_ASTC_8x5_SRGB_BLOCK : VkFormat = 168 ; pub const VkFormat_VK_FORMAT_ASTC_8x6_UNORM_BLOCK : VkFormat = 169 ; pub const VkFormat_VK_FORMAT_ASTC_8x6_SRGB_BLOCK : VkFormat = 170 ; pub const VkFormat_VK_FORMAT_ASTC_8x8_UNORM_BLOCK : VkFormat = 171 ; pub const VkFormat_VK_FORMAT_ASTC_8x8_SRGB_BLOCK : VkFormat = 172 ; pub const VkFormat_VK_FORMAT_ASTC_10x5_UNORM_BLOCK : VkFormat = 173 ; pub const VkFormat_VK_FORMAT_ASTC_10x5_SRGB_BLOCK : VkFormat = 174 ; pub const VkFormat_VK_FORMAT_ASTC_10x6_UNORM_BLOCK : VkFormat = 175 ; pub const VkFormat_VK_FORMAT_ASTC_10x6_SRGB_BLOCK : VkFormat = 176 ; pub const VkFormat_VK_FORMAT_ASTC_10x8_UNORM_BLOCK : VkFormat = 177 ; pub const VkFormat_VK_FORMAT_ASTC_10x8_SRGB_BLOCK : VkFormat = 178 ; pub const VkFormat_VK_FORMAT_ASTC_10x10_UNORM_BLOCK : VkFormat = 179 ; pub const VkFormat_VK_FORMAT_ASTC_10x10_SRGB_BLOCK : VkFormat = 180 ; pub const VkFormat_VK_FORMAT_ASTC_12x10_UNORM_BLOCK : VkFormat = 181 ; pub const VkFormat_VK_FORMAT_ASTC_12x10_SRGB_BLOCK : VkFormat = 182 ; pub const VkFormat_VK_FORMAT_ASTC_12x12_UNORM_BLOCK : VkFormat = 183 ; pub const VkFormat_VK_FORMAT_ASTC_12x12_SRGB_BLOCK : VkFormat = 184 ; pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM : VkFormat = 1000156000 ; pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM : VkFormat = 1000156001 ; pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM : VkFormat = 1000156002 ; pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM : VkFormat = 1000156003 ; pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM : VkFormat = 1000156004 ; pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM : VkFormat = 1000156005 ; pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM : VkFormat = 1000156006 ; pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16 : VkFormat = 1000156007 ; pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16 : VkFormat = 1000156008 ; pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 : VkFormat = 1000156009 ; pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 : VkFormat = 1000156010 ; pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 : VkFormat = 1000156011 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 : VkFormat = 1000156012 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 : VkFormat = 1000156013 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 : VkFormat = 1000156014 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 : VkFormat = 1000156015 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 : VkFormat = 1000156016 ; pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16 : VkFormat = 1000156017 ; pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16 : VkFormat = 1000156018 ; pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 : VkFormat = 1000156019 ; pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 : VkFormat = 1000156020 ; pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 : VkFormat = 1000156021 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 : VkFormat = 1000156022 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 : VkFormat = 1000156023 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 : VkFormat = 1000156024 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 : VkFormat = 1000156025 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 : VkFormat = 1000156026 ; pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM : VkFormat = 1000156027 ; pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM : VkFormat = 1000156028 ; pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM : VkFormat = 1000156029 ; pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM : VkFormat = 1000156030 ; pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM : VkFormat = 1000156031 ; pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM : VkFormat = 1000156032 ; pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM : VkFormat = 1000156033 ; pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG : VkFormat = 1000054000 ; pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG : VkFormat = 1000054001 ; pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG : VkFormat = 1000054002 ; pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG : VkFormat = 1000054003 ; pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG : VkFormat = 1000054004 ; pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG : VkFormat = 1000054005 ; pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG : VkFormat = 1000054006 ; pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG : VkFormat = 1000054007 ; pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM_KHR : VkFormat = 1000156000 ; pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM_KHR : VkFormat = 1000156001 ; pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR : VkFormat = 1000156002 ; pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR : VkFormat = 1000156003 ; pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR : VkFormat = 1000156004 ; pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR : VkFormat = 1000156005 ; pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR : VkFormat = 1000156006 ; pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16_KHR : VkFormat = 1000156007 ; pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR : VkFormat = 1000156008 ; pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR : VkFormat = 1000156009 ; pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR : VkFormat = 1000156010 ; pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR : VkFormat = 1000156011 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR : VkFormat = 1000156012 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR : VkFormat = 1000156013 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR : VkFormat = 1000156014 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR : VkFormat = 1000156015 ; pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR : VkFormat = 1000156016 ; pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16_KHR : VkFormat = 1000156017 ; pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR : VkFormat = 1000156018 ; pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR : VkFormat = 1000156019 ; pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR : VkFormat = 1000156020 ; pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR : VkFormat = 1000156021 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR : VkFormat = 1000156022 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR : VkFormat = 1000156023 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR : VkFormat = 1000156024 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR : VkFormat = 1000156025 ; pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR : VkFormat = 1000156026 ; pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM_KHR : VkFormat = 1000156027 ; pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM_KHR : VkFormat = 1000156028 ; pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR : VkFormat = 1000156029 ; pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR : VkFormat = 1000156030 ; pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR : VkFormat = 1000156031 ; pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR : VkFormat = 1000156032 ; pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR : VkFormat = 1000156033 ; pub const VkFormat_VK_FORMAT_BEGIN_RANGE : VkFormat = 0 ; pub const VkFormat_VK_FORMAT_END_RANGE : VkFormat = 184 ; pub const VkFormat_VK_FORMAT_RANGE_SIZE : VkFormat = 185 ; pub const VkFormat_VK_FORMAT_MAX_ENUM : VkFormat = 2147483647 ; pub type VkFormat = u32 ; pub const VkImageTiling_VK_IMAGE_TILING_OPTIMAL : VkImageTiling = 0 ; pub const VkImageTiling_VK_IMAGE_TILING_LINEAR : VkImageTiling = 1 ; pub const VkImageTiling_VK_IMAGE_TILING_BEGIN_RANGE : VkImageTiling = 0 ; pub const VkImageTiling_VK_IMAGE_TILING_END_RANGE : VkImageTiling = 1 ; pub const VkImageTiling_VK_IMAGE_TILING_RANGE_SIZE : VkImageTiling = 2 ; pub const VkImageTiling_VK_IMAGE_TILING_MAX_ENUM : VkImageTiling = 2147483647 ; pub type VkImageTiling = u32 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_UNDEFINED : VkImageLayout = 0 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_GENERAL : VkImageLayout = 1 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL : VkImageLayout = 2 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL : VkImageLayout = 3 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL : VkImageLayout = 4 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL : VkImageLayout = 5 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL : VkImageLayout = 6 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : VkImageLayout = 7 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_PREINITIALIZED : VkImageLayout = 8 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL : VkImageLayout = 1000117000 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL : VkImageLayout = 1000117001 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_PRESENT_SRC_KHR : VkImageLayout = 1000001002 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR : VkImageLayout = 1000111000 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR : VkImageLayout = 1000117000 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR : VkImageLayout = 1000117001 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_BEGIN_RANGE : VkImageLayout = 0 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_END_RANGE : VkImageLayout = 8 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_RANGE_SIZE : VkImageLayout = 9 ; pub const VkImageLayout_VK_IMAGE_LAYOUT_MAX_ENUM : VkImageLayout = 2147483647 ; pub type VkImageLayout = u32 ; pub const VkFilter_VK_FILTER_NEAREST : VkFilter = 0 ; pub const VkFilter_VK_FILTER_LINEAR : VkFilter = 1 ; pub const VkFilter_VK_FILTER_CUBIC_IMG : VkFilter = 1000015000 ; pub const VkFilter_VK_FILTER_BEGIN_RANGE : VkFilter = 0 ; pub const VkFilter_VK_FILTER_END_RANGE : VkFilter = 1 ; pub const VkFilter_VK_FILTER_RANGE_SIZE : VkFilter = 2 ; pub const VkFilter_VK_FILTER_MAX_ENUM : VkFilter = 2147483647 ; pub type VkFilter = u32 ; pub type VkFormatFeatureFlags = VkFlags ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY : VkSamplerYcbcrModelConversion = 0 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY : VkSamplerYcbcrModelConversion = 1 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 : VkSamplerYcbcrModelConversion = 2 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 : VkSamplerYcbcrModelConversion = 3 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 : VkSamplerYcbcrModelConversion = 4 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR : VkSamplerYcbcrModelConversion = 0 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR : VkSamplerYcbcrModelConversion = 1 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR : VkSamplerYcbcrModelConversion = 2 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR : VkSamplerYcbcrModelConversion = 3 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR : VkSamplerYcbcrModelConversion = 4 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE : VkSamplerYcbcrModelConversion = 0 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE : VkSamplerYcbcrModelConversion = 4 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE : VkSamplerYcbcrModelConversion = 5 ; pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM : VkSamplerYcbcrModelConversion = 2147483647 ; pub type VkSamplerYcbcrModelConversion = u32 ; pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_ITU_FULL : VkSamplerYcbcrRange = 0 ; pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_ITU_NARROW : VkSamplerYcbcrRange = 1 ; pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR : VkSamplerYcbcrRange = 0 ; pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR : VkSamplerYcbcrRange = 1 ; pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE : VkSamplerYcbcrRange = 0 ; pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_END_RANGE : VkSamplerYcbcrRange = 1 ; pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE : VkSamplerYcbcrRange = 2 ; pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_MAX_ENUM : VkSamplerYcbcrRange = 2147483647 ; pub type VkSamplerYcbcrRange = u32 ; pub const VkChromaLocation_VK_CHROMA_LOCATION_COSITED_EVEN : VkChromaLocation = 0 ; pub const VkChromaLocation_VK_CHROMA_LOCATION_MIDPOINT : VkChromaLocation = 1 ; pub const VkChromaLocation_VK_CHROMA_LOCATION_COSITED_EVEN_KHR : VkChromaLocation = 0 ; pub const VkChromaLocation_VK_CHROMA_LOCATION_MIDPOINT_KHR : VkChromaLocation = 1 ; pub const VkChromaLocation_VK_CHROMA_LOCATION_BEGIN_RANGE : VkChromaLocation = 0 ; pub const VkChromaLocation_VK_CHROMA_LOCATION_END_RANGE : VkChromaLocation = 1 ; pub const VkChromaLocation_VK_CHROMA_LOCATION_RANGE_SIZE : VkChromaLocation = 2 ; pub const VkChromaLocation_VK_CHROMA_LOCATION_MAX_ENUM : VkChromaLocation = 2147483647 ; pub type VkChromaLocation = u32 ; pub type GrVkBackendMemory = isize ; # [ doc = " Types for interacting with Vulkan resources created externally to Skia. GrBackendObjects for" ] # [ doc = " Vulkan textures are really const GrVkImageInfo*" ] # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrVkAlloc { pub fMemory : VkDeviceMemory , pub fOffset : VkDeviceSize , pub fSize : VkDeviceSize , pub fFlags : u32 , pub fBackendMemory : GrVkBackendMemory , pub fUsesSystemHeap : bool , } pub const GrVkAlloc_Flag_kNoncoherent_Flag : GrVkAlloc_Flag = 1 ; pub const GrVkAlloc_Flag_kMappable_Flag : GrVkAlloc_Flag = 2 ; pub type GrVkAlloc_Flag = u32 ; # [ test ] fn bindgen_test_layout_GrVkAlloc ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrVkAlloc > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( GrVkAlloc ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrVkAlloc > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrVkAlloc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkAlloc > ( ) ) ) . fMemory as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrVkAlloc ) , "::" , stringify ! ( fMemory ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkAlloc > ( ) ) ) . fOffset as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrVkAlloc ) , "::" , stringify ! ( fOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkAlloc > ( ) ) ) . fSize as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrVkAlloc ) , "::" , stringify ! ( fSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkAlloc > ( ) ) ) . fFlags as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrVkAlloc ) , "::" , stringify ! ( fFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkAlloc > ( ) ) ) . fBackendMemory as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( GrVkAlloc ) , "::" , stringify ! ( fBackendMemory ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkAlloc > ( ) ) ) . fUsesSystemHeap as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( GrVkAlloc ) , "::" , stringify ! ( fUsesSystemHeap ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN9GrVkAllocC1Ev" ] pub fn GrVkAlloc_GrVkAlloc ( this : * mut GrVkAlloc ) ; } extern "C" { # [ link_name = "\u{1}__ZN9GrVkAllocC1EP16VkDeviceMemory_Tyyj" ] pub fn GrVkAlloc_GrVkAlloc1 ( this : * mut GrVkAlloc , memory : VkDeviceMemory , offset : VkDeviceSize , size : VkDeviceSize , flags : u32 ) ; } impl GrVkAlloc { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrVkAlloc_GrVkAlloc ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( memory : VkDeviceMemory , offset : VkDeviceSize , size : VkDeviceSize , flags : u32 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrVkAlloc_GrVkAlloc1 ( & mut __bindgen_tmp , memory , offset , size , flags ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrVkYcbcrConversionInfo { pub fYcbcrModel : VkSamplerYcbcrModelConversion , pub fYcbcrRange : VkSamplerYcbcrRange , pub fXChromaOffset : VkChromaLocation , pub fYChromaOffset : VkChromaLocation , pub fChromaFilter : VkFilter , pub fForceExplicitReconstruction : VkBool32 , pub fExternalFormat : u64 , pub fExternalFormatFeatures : VkFormatFeatureFlags , } # [ test ] fn bindgen_test_layout_GrVkYcbcrConversionInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrVkYcbcrConversionInfo > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( GrVkYcbcrConversionInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrVkYcbcrConversionInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrVkYcbcrConversionInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkYcbcrConversionInfo > ( ) ) ) . fYcbcrModel as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrVkYcbcrConversionInfo ) , "::" , stringify ! ( fYcbcrModel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkYcbcrConversionInfo > ( ) ) ) . fYcbcrRange as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrVkYcbcrConversionInfo ) , "::" , stringify ! ( fYcbcrRange ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkYcbcrConversionInfo > ( ) ) ) . fXChromaOffset as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrVkYcbcrConversionInfo ) , "::" , stringify ! ( fXChromaOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkYcbcrConversionInfo > ( ) ) ) . fYChromaOffset as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( GrVkYcbcrConversionInfo ) , "::" , stringify ! ( fYChromaOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkYcbcrConversionInfo > ( ) ) ) . fChromaFilter as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrVkYcbcrConversionInfo ) , "::" , stringify ! ( fChromaFilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkYcbcrConversionInfo > ( ) ) ) . fForceExplicitReconstruction as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( GrVkYcbcrConversionInfo ) , "::" , stringify ! ( fForceExplicitReconstruction ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkYcbcrConversionInfo > ( ) ) ) . fExternalFormat as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrVkYcbcrConversionInfo ) , "::" , stringify ! ( fExternalFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkYcbcrConversionInfo > ( ) ) ) . fExternalFormatFeatures as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( GrVkYcbcrConversionInfo ) , "::" , stringify ! ( fExternalFormatFeatures ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK23GrVkYcbcrConversionInfo7isValidEv" ] pub fn GrVkYcbcrConversionInfo_isValid ( this : * const GrVkYcbcrConversionInfo ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN23GrVkYcbcrConversionInfoC1Ev" ] pub fn GrVkYcbcrConversionInfo_GrVkYcbcrConversionInfo ( this : * mut GrVkYcbcrConversionInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN23GrVkYcbcrConversionInfoC1E29VkSamplerYcbcrModelConversion19VkSamplerYcbcrRange16VkChromaLocationS2_8VkFilterjyj" ] pub fn GrVkYcbcrConversionInfo_GrVkYcbcrConversionInfo1 ( this : * mut GrVkYcbcrConversionInfo , ycbcrModel : VkSamplerYcbcrModelConversion , ycbcrRange : VkSamplerYcbcrRange , xChromaOffset : VkChromaLocation , yChromaOffset : VkChromaLocation , chromaFilter : VkFilter , forceExplicitReconstruction : VkBool32 , externalFormat : u64 , externalFormatFeatures : VkFormatFeatureFlags ) ; } impl GrVkYcbcrConversionInfo { # [ inline ] pub unsafe fn isValid ( & self ) -> bool { GrVkYcbcrConversionInfo_isValid ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrVkYcbcrConversionInfo_GrVkYcbcrConversionInfo ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( ycbcrModel : VkSamplerYcbcrModelConversion , ycbcrRange : VkSamplerYcbcrRange , xChromaOffset : VkChromaLocation , yChromaOffset : VkChromaLocation , chromaFilter : VkFilter , forceExplicitReconstruction : VkBool32 , externalFormat : u64 , externalFormatFeatures : VkFormatFeatureFlags ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrVkYcbcrConversionInfo_GrVkYcbcrConversionInfo1 ( & mut __bindgen_tmp , ycbcrModel , ycbcrRange , xChromaOffset , yChromaOffset , chromaFilter , forceExplicitReconstruction , externalFormat , externalFormatFeatures ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrVkImageInfo { pub fImage : VkImage , pub fAlloc : GrVkAlloc , pub fImageTiling : VkImageTiling , pub fImageLayout : VkImageLayout , pub fFormat : VkFormat , pub fLevelCount : u32 , pub fCurrentQueueFamily : u32 , pub fYcbcrConversionInfo : GrVkYcbcrConversionInfo , } # [ test ] fn bindgen_test_layout_GrVkImageInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrVkImageInfo > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( GrVkImageInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrVkImageInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrVkImageInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkImageInfo > ( ) ) ) . fImage as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrVkImageInfo ) , "::" , stringify ! ( fImage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkImageInfo > ( ) ) ) . fAlloc as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrVkImageInfo ) , "::" , stringify ! ( fAlloc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkImageInfo > ( ) ) ) . fImageTiling as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( GrVkImageInfo ) , "::" , stringify ! ( fImageTiling ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkImageInfo > ( ) ) ) . fImageLayout as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( GrVkImageInfo ) , "::" , stringify ! ( fImageLayout ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkImageInfo > ( ) ) ) . fFormat as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( GrVkImageInfo ) , "::" , stringify ! ( fFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkImageInfo > ( ) ) ) . fLevelCount as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( GrVkImageInfo ) , "::" , stringify ! ( fLevelCount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkImageInfo > ( ) ) ) . fCurrentQueueFamily as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( GrVkImageInfo ) , "::" , stringify ! ( fCurrentQueueFamily ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkImageInfo > ( ) ) ) . fYcbcrConversionInfo as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( GrVkImageInfo ) , "::" , stringify ! ( fYcbcrConversionInfo ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrVkImageInfo17updateImageLayoutE13VkImageLayout" ] pub fn GrVkImageInfo_updateImageLayout ( this : * mut GrVkImageInfo , layout : VkImageLayout ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrVkImageInfoC1Ev" ] pub fn GrVkImageInfo_GrVkImageInfo ( this : * mut GrVkImageInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrVkImageInfoC1EP9VkImage_T9GrVkAlloc13VkImageTiling13VkImageLayout8VkFormatjj23GrVkYcbcrConversionInfo" ] pub fn GrVkImageInfo_GrVkImageInfo1 ( this : * mut GrVkImageInfo , image : VkImage , alloc : GrVkAlloc , imageTiling : VkImageTiling , layout : VkImageLayout , format : VkFormat , levelCount : u32 , currentQueueFamily : u32 , ycbcrConversionInfo : GrVkYcbcrConversionInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrVkImageInfoC1ERKS_13VkImageLayout" ] pub fn GrVkImageInfo_GrVkImageInfo2 ( this : * mut GrVkImageInfo , info : * const GrVkImageInfo , layout : VkImageLayout ) ; } impl GrVkImageInfo { # [ inline ] pub unsafe fn updateImageLayout ( & mut self , layout : VkImageLayout ) { GrVkImageInfo_updateImageLayout ( self , layout ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrVkImageInfo_GrVkImageInfo ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( image : VkImage , alloc : GrVkAlloc , imageTiling : VkImageTiling , layout : VkImageLayout , format : VkFormat , levelCount : u32 , currentQueueFamily : u32 , ycbcrConversionInfo : GrVkYcbcrConversionInfo ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrVkImageInfo_GrVkImageInfo1 ( & mut __bindgen_tmp , image , alloc , imageTiling , layout , format , levelCount , currentQueueFamily , ycbcrConversionInfo ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( info : * const GrVkImageInfo , layout : VkImageLayout ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrVkImageInfo_GrVkImageInfo2 ( & mut __bindgen_tmp , info , layout ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrVkImageLayout { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrVkBackendSurfaceInfo { pub fImageInfo : GrVkImageInfo , pub fLayout : * mut GrVkImageLayout , } # [ test ] fn bindgen_test_layout_GrVkBackendSurfaceInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrVkBackendSurfaceInfo > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( GrVkBackendSurfaceInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrVkBackendSurfaceInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrVkBackendSurfaceInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkBackendSurfaceInfo > ( ) ) ) . fImageInfo as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrVkBackendSurfaceInfo ) , "::" , stringify ! ( fImageInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrVkBackendSurfaceInfo > ( ) ) ) . fLayout as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( GrVkBackendSurfaceInfo ) , "::" , stringify ! ( fLayout ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN22GrVkBackendSurfaceInfo7cleanupEv" ] pub fn GrVkBackendSurfaceInfo_cleanup ( this : * mut GrVkBackendSurfaceInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN22GrVkBackendSurfaceInfo6assignERKS_b" ] pub fn GrVkBackendSurfaceInfo_assign ( this : * mut GrVkBackendSurfaceInfo , arg1 : * const GrVkBackendSurfaceInfo , isValid : bool ) ; } extern "C" { # [ link_name = "\u{1}__ZN22GrVkBackendSurfaceInfo14setImageLayoutE13VkImageLayout" ] pub fn GrVkBackendSurfaceInfo_setImageLayout ( this : * mut GrVkBackendSurfaceInfo , layout : VkImageLayout ) ; } extern "C" { # [ link_name = "\u{1}__ZNK22GrVkBackendSurfaceInfo18getGrVkImageLayoutEv" ] pub fn GrVkBackendSurfaceInfo_getGrVkImageLayout ( this : * const GrVkBackendSurfaceInfo ) -> sk_sp < GrVkImageLayout > ; } extern "C" { # [ link_name = "\u{1}__ZNK22GrVkBackendSurfaceInfo13snapImageInfoEv" ] pub fn GrVkBackendSurfaceInfo_snapImageInfo ( this : * const GrVkBackendSurfaceInfo ) -> GrVkImageInfo ; } extern "C" { # [ link_name = "\u{1}__ZN22GrVkBackendSurfaceInfoC1E13GrVkImageInfoP15GrVkImageLayout" ] pub fn GrVkBackendSurfaceInfo_GrVkBackendSurfaceInfo ( this : * mut GrVkBackendSurfaceInfo , info : GrVkImageInfo , layout : * mut GrVkImageLayout ) ; } impl GrVkBackendSurfaceInfo { # [ inline ] pub unsafe fn cleanup ( & mut self ) { GrVkBackendSurfaceInfo_cleanup ( self ) } # [ inline ] pub unsafe fn assign ( & mut self , arg1 : * const GrVkBackendSurfaceInfo , isValid : bool ) { GrVkBackendSurfaceInfo_assign ( self , arg1 , isValid ) } # [ inline ] pub unsafe fn setImageLayout ( & mut self , layout : VkImageLayout ) { GrVkBackendSurfaceInfo_setImageLayout ( self , layout ) } # [ inline ] pub unsafe fn getGrVkImageLayout ( & self ) -> sk_sp < GrVkImageLayout > { GrVkBackendSurfaceInfo_getGrVkImageLayout ( self ) } # [ inline ] pub unsafe fn snapImageInfo ( & self ) -> GrVkImageInfo { GrVkBackendSurfaceInfo_snapImageInfo ( self ) } # [ inline ] pub unsafe fn new ( info : GrVkImageInfo , layout : * mut GrVkImageLayout ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrVkBackendSurfaceInfo_GrVkBackendSurfaceInfo ( & mut __bindgen_tmp , info , layout ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct GrBackendFormat { pub fBackend : GrBackendApi , pub fValid : bool , pub __bindgen_anon_1 : GrBackendFormat__bindgen_ty_1 , pub fTextureType : GrTextureType , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union GrBackendFormat__bindgen_ty_1 { pub fGLFormat : GrGLenum , pub fVk : GrBackendFormat__bindgen_ty_1__bindgen_ty_1 , pub fMockFormat : GrPixelConfig , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrBackendFormat__bindgen_ty_1__bindgen_ty_1 { pub fFormat : VkFormat , pub fYcbcrConversionInfo : GrVkYcbcrConversionInfo , } # [ test ] fn bindgen_test_layout_GrBackendFormat__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( GrBackendFormat__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrBackendFormat__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . fFormat as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendFormat__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( fFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . fYcbcrConversionInfo as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendFormat__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( fYcbcrConversionInfo ) ) ) ; } # [ test ] fn bindgen_test_layout_GrBackendFormat__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrBackendFormat__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( GrBackendFormat__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrBackendFormat__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrBackendFormat__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendFormat__bindgen_ty_1 > ( ) ) ) . fGLFormat as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendFormat__bindgen_ty_1 ) , "::" , stringify ! ( fGLFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendFormat__bindgen_ty_1 > ( ) ) ) . fVk as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendFormat__bindgen_ty_1 ) , "::" , stringify ! ( fVk ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendFormat__bindgen_ty_1 > ( ) ) ) . fMockFormat as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendFormat__bindgen_ty_1 ) , "::" , stringify ! ( fMockFormat ) ) ) ; } # [ test ] fn bindgen_test_layout_GrBackendFormat ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrBackendFormat > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( GrBackendFormat ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrBackendFormat > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrBackendFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendFormat > ( ) ) ) . fBackend as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendFormat ) , "::" , stringify ! ( fBackend ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendFormat > ( ) ) ) . fValid as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendFormat ) , "::" , stringify ! ( fValid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendFormat > ( ) ) ) . fTextureType as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendFormat ) , "::" , stringify ! ( fTextureType ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN15GrBackendFormat6MakeGLEjj" ] pub fn GrBackendFormat_MakeGL ( format : GrGLenum , target : GrGLenum ) -> GrBackendFormat ; } extern "C" { # [ link_name = "\u{1}__ZN15GrBackendFormat6MakeVkE8VkFormat" ] pub fn GrBackendFormat_MakeVk ( format : VkFormat ) -> GrBackendFormat ; } extern "C" { # [ link_name = "\u{1}__ZN15GrBackendFormat6MakeVkERK23GrVkYcbcrConversionInfo" ] pub fn GrBackendFormat_MakeVk1 ( ycbcrInfo : * const GrVkYcbcrConversionInfo ) -> GrBackendFormat ; } extern "C" { # [ link_name = "\u{1}__ZN15GrBackendFormat8MakeMockE13GrPixelConfig" ] pub fn GrBackendFormat_MakeMock ( config : GrPixelConfig ) -> GrBackendFormat ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat7backendEv" ] pub fn GrBackendFormat_backend ( this : * const GrBackendFormat ) -> GrBackendApi ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat11textureTypeEv" ] pub fn GrBackendFormat_textureType ( this : * const GrBackendFormat ) -> GrTextureType ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat11getGLFormatEv" ] pub fn GrBackendFormat_getGLFormat ( this : * const GrBackendFormat ) -> * const GrGLenum ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat11getGLTargetEv" ] pub fn GrBackendFormat_getGLTarget ( this : * const GrBackendFormat ) -> * const GrGLenum ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat11getVkFormatEv" ] pub fn GrBackendFormat_getVkFormat ( this : * const GrBackendFormat ) -> * const VkFormat ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat24getVkYcbcrConversionInfoEv" ] pub fn GrBackendFormat_getVkYcbcrConversionInfo ( this : * const GrBackendFormat ) -> * const GrVkYcbcrConversionInfo ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat13getMockFormatEv" ] pub fn GrBackendFormat_getMockFormat ( this : * const GrBackendFormat ) -> * const GrPixelConfig ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat13makeTexture2DEv" ] pub fn GrBackendFormat_makeTexture2D ( this : * const GrBackendFormat ) -> GrBackendFormat ; } extern "C" { # [ link_name = "\u{1}__ZNK15GrBackendFormat7isValidEv" ] pub fn GrBackendFormat_isValid ( this : * const GrBackendFormat ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN15GrBackendFormatC1Ev" ] pub fn GrBackendFormat_GrBackendFormat ( this : * mut GrBackendFormat ) ; } impl GrBackendFormat { # [ inline ] pub unsafe fn MakeGL ( format : GrGLenum , target : GrGLenum ) -> GrBackendFormat { GrBackendFormat_MakeGL ( format , target ) } # [ inline ] pub unsafe fn MakeVk ( format : VkFormat ) -> GrBackendFormat { GrBackendFormat_MakeVk ( format ) } # [ inline ] pub unsafe fn MakeVk1 ( ycbcrInfo : * const GrVkYcbcrConversionInfo ) -> GrBackendFormat { GrBackendFormat_MakeVk1 ( ycbcrInfo ) } # [ inline ] pub unsafe fn MakeMock ( config : GrPixelConfig ) -> GrBackendFormat { GrBackendFormat_MakeMock ( config ) } # [ inline ] pub unsafe fn backend ( & self ) -> GrBackendApi { GrBackendFormat_backend ( self ) } # [ inline ] pub unsafe fn textureType ( & self ) -> GrTextureType { GrBackendFormat_textureType ( self ) } # [ inline ] pub unsafe fn getGLFormat ( & self ) -> * const GrGLenum { GrBackendFormat_getGLFormat ( self ) } # [ inline ] pub unsafe fn getGLTarget ( & self ) -> * const GrGLenum { GrBackendFormat_getGLTarget ( self ) } # [ inline ] pub unsafe fn getVkFormat ( & self ) -> * const VkFormat { GrBackendFormat_getVkFormat ( self ) } # [ inline ] pub unsafe fn getVkYcbcrConversionInfo ( & self ) -> * const GrVkYcbcrConversionInfo { GrBackendFormat_getVkYcbcrConversionInfo ( self ) } # [ inline ] pub unsafe fn getMockFormat ( & self ) -> * const GrPixelConfig { GrBackendFormat_getMockFormat ( self ) } # [ inline ] pub unsafe fn makeTexture2D ( & self ) -> GrBackendFormat { GrBackendFormat_makeTexture2D ( self ) } # [ inline ] pub unsafe fn isValid ( & self ) -> bool { GrBackendFormat_isValid ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendFormat_GrBackendFormat ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ repr ( C ) ] pub struct GrBackendTexture { pub fIsValid : bool , pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fConfig : GrPixelConfig , pub fMipMapped : GrMipMapped , pub fBackend : GrBackendApi , pub __bindgen_anon_1 : GrBackendTexture__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union GrBackendTexture__bindgen_ty_1 { pub fGLInfo : GrGLTextureInfo , pub fVkInfo : GrVkBackendSurfaceInfo , pub fMockInfo : GrMockTextureInfo , _bindgen_union_align : [ u64 ; 16usize ] , } # [ test ] fn bindgen_test_layout_GrBackendTexture__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrBackendTexture__bindgen_ty_1 > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( GrBackendTexture__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrBackendTexture__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrBackendTexture__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture__bindgen_ty_1 > ( ) ) ) . fGLInfo as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture__bindgen_ty_1 ) , "::" , stringify ! ( fGLInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture__bindgen_ty_1 > ( ) ) ) . fVkInfo as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture__bindgen_ty_1 ) , "::" , stringify ! ( fVkInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture__bindgen_ty_1 > ( ) ) ) . fMockInfo as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture__bindgen_ty_1 ) , "::" , stringify ! ( fMockInfo ) ) ) ; } # [ test ] fn bindgen_test_layout_GrBackendTexture ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrBackendTexture > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( GrBackendTexture ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrBackendTexture > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrBackendTexture ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture > ( ) ) ) . fIsValid as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture ) , "::" , stringify ! ( fIsValid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture > ( ) ) ) . fWidth as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture > ( ) ) ) . fHeight as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture ) , "::" , stringify ! ( fHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture > ( ) ) ) . fConfig as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture ) , "::" , stringify ! ( fConfig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture > ( ) ) ) . fMipMapped as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture ) , "::" , stringify ! ( fMipMapped ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendTexture > ( ) ) ) . fBackend as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendTexture ) , "::" , stringify ! ( fBackend ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture5widthEv" ] pub fn GrBackendTexture_width ( this : * const GrBackendTexture ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture6heightEv" ] pub fn GrBackendTexture_height ( this : * const GrBackendTexture ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture10hasMipMapsEv" ] pub fn GrBackendTexture_hasMipMaps ( this : * const GrBackendTexture ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture7backendEv" ] pub fn GrBackendTexture_backend ( this : * const GrBackendTexture ) -> GrBackendApi ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture16getGLTextureInfoEP15GrGLTextureInfo" ] pub fn GrBackendTexture_getGLTextureInfo ( this : * const GrBackendTexture , arg1 : * mut GrGLTextureInfo ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture14getVkImageInfoEP13GrVkImageInfo" ] pub fn GrBackendTexture_getVkImageInfo ( this : * const GrBackendTexture , arg1 : * mut GrVkImageInfo ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN16GrBackendTexture16setVkImageLayoutE13VkImageLayout" ] pub fn GrBackendTexture_setVkImageLayout ( this : * mut GrBackendTexture , arg1 : VkImageLayout ) ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture16getBackendFormatEv" ] pub fn GrBackendTexture_getBackendFormat ( this : * const GrBackendTexture ) -> GrBackendFormat ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture18getMockTextureInfoEP17GrMockTextureInfo" ] pub fn GrBackendTexture_getMockTextureInfo ( this : * const GrBackendTexture , arg1 : * mut GrMockTextureInfo ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK16GrBackendTexture7isValidEv" ] pub fn GrBackendTexture_isValid ( this : * const GrBackendTexture ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN16GrBackendTextureC1Ev" ] pub fn GrBackendTexture_GrBackendTexture ( this : * mut GrBackendTexture ) ; } extern "C" { # [ link_name = "\u{1}__ZN16GrBackendTextureC1Eii11GrMipMappedRK15GrGLTextureInfo" ] pub fn GrBackendTexture_GrBackendTexture1 ( this : * mut GrBackendTexture , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , glInfo : * const GrGLTextureInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN16GrBackendTextureC1EiiRK13GrVkImageInfo" ] pub fn GrBackendTexture_GrBackendTexture2 ( this : * mut GrBackendTexture , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN16GrBackendTextureC1Eii11GrMipMappedRK17GrMockTextureInfo" ] pub fn GrBackendTexture_GrBackendTexture3 ( this : * mut GrBackendTexture , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , mockInfo : * const GrMockTextureInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN16GrBackendTextureC1ERKS_" ] pub fn GrBackendTexture_GrBackendTexture4 ( this : * mut GrBackendTexture , that : * const GrBackendTexture ) ; } extern "C" { # [ link_name = "\u{1}__ZN16GrBackendTextureD1Ev" ] pub fn GrBackendTexture_GrBackendTexture_destructor ( this : * mut GrBackendTexture ) ; } impl GrBackendTexture { # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { GrBackendTexture_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { GrBackendTexture_height ( self ) } # [ inline ] pub unsafe fn hasMipMaps ( & self ) -> bool { GrBackendTexture_hasMipMaps ( self ) } # [ inline ] pub unsafe fn backend ( & self ) -> GrBackendApi { GrBackendTexture_backend ( self ) } # [ inline ] pub unsafe fn getGLTextureInfo ( & self , arg1 : * mut GrGLTextureInfo ) -> bool { GrBackendTexture_getGLTextureInfo ( self , arg1 ) } # [ inline ] pub unsafe fn getVkImageInfo ( & self , arg1 : * mut GrVkImageInfo ) -> bool { GrBackendTexture_getVkImageInfo ( self , arg1 ) } # [ inline ] pub unsafe fn setVkImageLayout ( & mut self , arg1 : VkImageLayout ) { GrBackendTexture_setVkImageLayout ( self , arg1 ) } # [ inline ] pub unsafe fn getBackendFormat ( & self ) -> GrBackendFormat { GrBackendTexture_getBackendFormat ( self ) } # [ inline ] pub unsafe fn getMockTextureInfo ( & self , arg1 : * mut GrMockTextureInfo ) -> bool { GrBackendTexture_getMockTextureInfo ( self , arg1 ) } # [ inline ] pub unsafe fn isValid ( & self ) -> bool { GrBackendTexture_isValid ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendTexture_GrBackendTexture ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , glInfo : * const GrGLTextureInfo ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendTexture_GrBackendTexture1 ( & mut __bindgen_tmp , width , height , arg1 , glInfo ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendTexture_GrBackendTexture2 ( & mut __bindgen_tmp , width , height , vkInfo ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , mockInfo : * const GrMockTextureInfo ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendTexture_GrBackendTexture3 ( & mut __bindgen_tmp , width , height , arg1 , mockInfo ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new4 ( that : * const GrBackendTexture ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendTexture_GrBackendTexture4 ( & mut __bindgen_tmp , that ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { GrBackendTexture_GrBackendTexture_destructor ( self ) } } # [ repr ( C ) ] pub struct GrBackendRenderTarget { pub fIsValid : bool , pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fSampleCnt : :: std :: os :: raw :: c_int , pub fStencilBits : :: std :: os :: raw :: c_int , pub fConfig : GrPixelConfig , pub fBackend : GrBackendApi , pub __bindgen_anon_1 : GrBackendRenderTarget__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union GrBackendRenderTarget__bindgen_ty_1 { pub fGLInfo : GrGLFramebufferInfo , pub fVkInfo : GrVkBackendSurfaceInfo , pub fMockInfo : GrMockRenderTargetInfo , _bindgen_union_align : [ u64 ; 16usize ] , } # [ test ] fn bindgen_test_layout_GrBackendRenderTarget__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrBackendRenderTarget__bindgen_ty_1 > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( GrBackendRenderTarget__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrBackendRenderTarget__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrBackendRenderTarget__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget__bindgen_ty_1 > ( ) ) ) . fGLInfo as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget__bindgen_ty_1 ) , "::" , stringify ! ( fGLInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget__bindgen_ty_1 > ( ) ) ) . fVkInfo as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget__bindgen_ty_1 ) , "::" , stringify ! ( fVkInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget__bindgen_ty_1 > ( ) ) ) . fMockInfo as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget__bindgen_ty_1 ) , "::" , stringify ! ( fMockInfo ) ) ) ; } # [ test ] fn bindgen_test_layout_GrBackendRenderTarget ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrBackendRenderTarget > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( GrBackendRenderTarget ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrBackendRenderTarget > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrBackendRenderTarget ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget > ( ) ) ) . fIsValid as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget ) , "::" , stringify ! ( fIsValid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget > ( ) ) ) . fWidth as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget > ( ) ) ) . fHeight as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget ) , "::" , stringify ! ( fHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget > ( ) ) ) . fSampleCnt as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget ) , "::" , stringify ! ( fSampleCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget > ( ) ) ) . fStencilBits as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget ) , "::" , stringify ! ( fStencilBits ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget > ( ) ) ) . fConfig as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget ) , "::" , stringify ! ( fConfig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrBackendRenderTarget > ( ) ) ) . fBackend as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrBackendRenderTarget ) , "::" , stringify ! ( fBackend ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget5widthEv" ] pub fn GrBackendRenderTarget_width ( this : * const GrBackendRenderTarget ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget6heightEv" ] pub fn GrBackendRenderTarget_height ( this : * const GrBackendRenderTarget ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget9sampleCntEv" ] pub fn GrBackendRenderTarget_sampleCnt ( this : * const GrBackendRenderTarget ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget11stencilBitsEv" ] pub fn GrBackendRenderTarget_stencilBits ( this : * const GrBackendRenderTarget ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget7backendEv" ] pub fn GrBackendRenderTarget_backend ( this : * const GrBackendRenderTarget ) -> GrBackendApi ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget20getGLFramebufferInfoEP19GrGLFramebufferInfo" ] pub fn GrBackendRenderTarget_getGLFramebufferInfo ( this : * const GrBackendRenderTarget , arg1 : * mut GrGLFramebufferInfo ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget14getVkImageInfoEP13GrVkImageInfo" ] pub fn GrBackendRenderTarget_getVkImageInfo ( this : * const GrBackendRenderTarget , arg1 : * mut GrVkImageInfo ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN21GrBackendRenderTarget16setVkImageLayoutE13VkImageLayout" ] pub fn GrBackendRenderTarget_setVkImageLayout ( this : * mut GrBackendRenderTarget , arg1 : VkImageLayout ) ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget23getMockRenderTargetInfoEP22GrMockRenderTargetInfo" ] pub fn GrBackendRenderTarget_getMockRenderTargetInfo ( this : * const GrBackendRenderTarget , arg1 : * mut GrMockRenderTargetInfo ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK21GrBackendRenderTarget7isValidEv" ] pub fn GrBackendRenderTarget_isValid ( this : * const GrBackendRenderTarget ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN21GrBackendRenderTargetC1Ev" ] pub fn GrBackendRenderTarget_GrBackendRenderTarget ( this : * mut GrBackendRenderTarget ) ; } extern "C" { # [ link_name = "\u{1}__ZN21GrBackendRenderTargetC1EiiiiRK19GrGLFramebufferInfo" ] pub fn GrBackendRenderTarget_GrBackendRenderTarget1 ( this : * mut GrBackendRenderTarget , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , stencilBits : :: std :: os :: raw :: c_int , glInfo : * const GrGLFramebufferInfo ) ; } extern "C" { # [ doc = " Deprecated, use version that does not take stencil bits." ] # [ link_name = "\u{1}__ZN21GrBackendRenderTargetC1EiiiiRK13GrVkImageInfo" ] pub fn GrBackendRenderTarget_GrBackendRenderTarget2 ( this : * mut GrBackendRenderTarget , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , stencilBits : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN21GrBackendRenderTargetC1EiiiRK13GrVkImageInfo" ] pub fn GrBackendRenderTarget_GrBackendRenderTarget3 ( this : * mut GrBackendRenderTarget , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN21GrBackendRenderTargetC1EiiiiRK22GrMockRenderTargetInfo" ] pub fn GrBackendRenderTarget_GrBackendRenderTarget4 ( this : * mut GrBackendRenderTarget , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , stencilBits : :: std :: os :: raw :: c_int , mockInfo : * const GrMockRenderTargetInfo ) ; } extern "C" { # [ link_name = "\u{1}__ZN21GrBackendRenderTargetC1ERKS_" ] pub fn GrBackendRenderTarget_GrBackendRenderTarget5 ( this : * mut GrBackendRenderTarget , that : * const GrBackendRenderTarget ) ; } extern "C" { # [ link_name = "\u{1}__ZN21GrBackendRenderTargetD1Ev" ] pub fn GrBackendRenderTarget_GrBackendRenderTarget_destructor ( this : * mut GrBackendRenderTarget ) ; } impl GrBackendRenderTarget { # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { GrBackendRenderTarget_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { GrBackendRenderTarget_height ( self ) } # [ inline ] pub unsafe fn sampleCnt ( & self ) -> :: std :: os :: raw :: c_int { GrBackendRenderTarget_sampleCnt ( self ) } # [ inline ] pub unsafe fn stencilBits ( & self ) -> :: std :: os :: raw :: c_int { GrBackendRenderTarget_stencilBits ( self ) } # [ inline ] pub unsafe fn backend ( & self ) -> GrBackendApi { GrBackendRenderTarget_backend ( self ) } # [ inline ] pub unsafe fn getGLFramebufferInfo ( & self , arg1 : * mut GrGLFramebufferInfo ) -> bool { GrBackendRenderTarget_getGLFramebufferInfo ( self , arg1 ) } # [ inline ] pub unsafe fn getVkImageInfo ( & self , arg1 : * mut GrVkImageInfo ) -> bool { GrBackendRenderTarget_getVkImageInfo ( self , arg1 ) } # [ inline ] pub unsafe fn setVkImageLayout ( & mut self , arg1 : VkImageLayout ) { GrBackendRenderTarget_setVkImageLayout ( self , arg1 ) } # [ inline ] pub unsafe fn getMockRenderTargetInfo ( & self , arg1 : * mut GrMockRenderTargetInfo ) -> bool { GrBackendRenderTarget_getMockRenderTargetInfo ( self , arg1 ) } # [ inline ] pub unsafe fn isValid ( & self ) -> bool { GrBackendRenderTarget_isValid ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendRenderTarget_GrBackendRenderTarget ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , stencilBits : :: std :: os :: raw :: c_int , glInfo : * const GrGLFramebufferInfo ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendRenderTarget_GrBackendRenderTarget1 ( & mut __bindgen_tmp , width , height , sampleCnt , stencilBits , glInfo ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , stencilBits : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendRenderTarget_GrBackendRenderTarget2 ( & mut __bindgen_tmp , width , height , sampleCnt , stencilBits , vkInfo ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new3 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendRenderTarget_GrBackendRenderTarget3 ( & mut __bindgen_tmp , width , height , sampleCnt , vkInfo ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new4 ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , stencilBits : :: std :: os :: raw :: c_int , mockInfo : * const GrMockRenderTargetInfo ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendRenderTarget_GrBackendRenderTarget4 ( & mut __bindgen_tmp , width , height , sampleCnt , stencilBits , mockInfo ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new5 ( that : * const GrBackendRenderTarget ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrBackendRenderTarget_GrBackendRenderTarget5 ( & mut __bindgen_tmp , that ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { GrBackendRenderTarget_GrBackendRenderTarget_destructor ( self ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrSurfacePriv { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrSurface { pub _base : GrGpuResource , pub fConfig : GrPixelConfig , pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fSurfaceFlags : GrInternalSurfaceFlags , pub fReleaseHelper : sk_sp < GrReleaseProcHelper > , } pub type GrSurface_ReleaseCtx = * mut :: std :: os :: raw :: c_void ; pub type GrSurface_ReleaseProc = :: core :: option :: Option < unsafe extern "C" fn ( arg1 : GrSurface_ReleaseCtx ) > ; pub type GrSurface_INHERITED = GrGpuResource ; # [ test ] fn bindgen_test_layout_GrSurface ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrSurface > ( ) , 184usize , concat ! ( "Size of: " , stringify ! ( GrSurface ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrSurface > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrSurface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurface > ( ) ) ) . fConfig as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( GrSurface ) , "::" , stringify ! ( fConfig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurface > ( ) ) ) . fWidth as * const _ as usize } , 164usize , concat ! ( "Offset of field: " , stringify ! ( GrSurface ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurface > ( ) ) ) . fHeight as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( GrSurface ) , "::" , stringify ! ( fHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurface > ( ) ) ) . fSurfaceFlags as * const _ as usize } , 172usize , concat ! ( "Offset of field: " , stringify ! ( GrSurface ) , "::" , stringify ! ( fSurfaceFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurface > ( ) ) ) . fReleaseHelper as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( GrSurface ) , "::" , stringify ! ( fReleaseHelper ) ) ) ; } extern "C" { # [ doc = " Retrieves the width of the surface." ] # [ link_name = "\u{1}__ZNK9GrSurface5widthEv" ] pub fn GrSurface_width ( this : * const GrSurface ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Retrieves the height of the surface." ] # [ link_name = "\u{1}__ZNK9GrSurface6heightEv" ] pub fn GrSurface_height ( this : * const GrSurface ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Helper that gets the width and height of the surface as a bounding rectangle." ] # [ link_name = "\u{1}__ZNK9GrSurface13getBoundsRectEv" ] pub fn GrSurface_getBoundsRect ( this : * const GrSurface ) -> SkRect ; } extern "C" { # [ doc = " Retrieves the pixel config specified when the surface was created." ] # [ doc = " For render targets this can be kUnknown_GrPixelConfig" ] # [ doc = " if client asked us to render to a target that has a pixel" ] # [ doc = " config that isn\'t equivalent with one of our configs." ] # [ link_name = "\u{1}__ZNK9GrSurface6configEv" ] pub fn GrSurface_config ( this : * const GrSurface ) -> GrPixelConfig ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface10setReleaseE5sk_spI19GrReleaseProcHelperE" ] pub fn GrSurface_setRelease ( this : * mut GrSurface , releaseHelper : sk_sp < GrReleaseProcHelper > ) ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface10setReleaseEPFvPvES0_" ] pub fn GrSurface_setRelease1 ( this : * mut GrSurface , proc_ : GrSurface_ReleaseProc , ctx : GrSurface_ReleaseCtx ) ; } extern "C" { # [ doc = " Access methods that are only to be used within Skia code." ] # [ link_name = "\u{1}__ZN9GrSurface11surfacePrivEv" ] pub fn GrSurface_surfacePriv ( this : * mut GrSurface ) -> GrSurfacePriv ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrSurface11surfacePrivEv" ] pub fn GrSurface_surfacePriv1 ( this : * const GrSurface ) -> GrSurfacePriv ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface13WorstCaseSizeERK13GrSurfaceDescb" ] pub fn GrSurface_WorstCaseSize ( desc : * const GrSurfaceDesc , useNextPow2 : bool ) -> usize ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface11ComputeSizeE13GrPixelConfigiii11GrMipMappedb" ] pub fn GrSurface_ComputeSize ( config : GrPixelConfig , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , colorSamplesPerPixel : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , useNextPow2 : bool ) -> usize ; } extern "C" { # [ doc = " The pixel values of this surface cannot be modified (e.g. doesn\'t support write pixels or" ] # [ doc = " MIP map level regen)." ] # [ link_name = "\u{1}__ZNK9GrSurface8readOnlyEv" ] pub fn GrSurface_readOnly ( this : * const GrSurface ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface18setHasMixedSamplesEv" ] pub fn GrSurface_setHasMixedSamples ( this : * mut GrSurface ) ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrSurface15hasMixedSamplesEv" ] pub fn GrSurface_hasMixedSamples ( this : * const GrSurface ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface15setGLRTFBOIDIs0Ev" ] pub fn GrSurface_setGLRTFBOIDIs0 ( this : * mut GrSurface ) ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrSurface12glRTFBOIDis0Ev" ] pub fn GrSurface_glRTFBOIDis0 ( this : * const GrSurface ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface11setReadOnlyEv" ] pub fn GrSurface_setReadOnly ( this : * mut GrSurface ) ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrSurface14hasPendingReadEv" ] pub fn GrSurface_hasPendingRead ( this : * const GrSurface ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrSurface15hasPendingWriteEv" ] pub fn GrSurface_hasPendingWrite ( this : * const GrSurface ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrSurface12hasPendingIOEv" ] pub fn GrSurface_hasPendingIO ( this : * const GrSurface ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurfaceC2EP5GrGpuRK13GrSurfaceDesc" ] pub fn GrSurface_GrSurface ( this : * mut GrSurface , gpu : * mut GrGpu , desc : * const GrSurfaceDesc ) ; } impl GrSurface { # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { GrSurface_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { GrSurface_height ( self ) } # [ inline ] pub unsafe fn getBoundsRect ( & self ) -> SkRect { GrSurface_getBoundsRect ( self ) } # [ inline ] pub unsafe fn config ( & self ) -> GrPixelConfig { GrSurface_config ( self ) } # [ inline ] pub unsafe fn setRelease ( & mut self , releaseHelper : sk_sp < GrReleaseProcHelper > ) { GrSurface_setRelease ( self , releaseHelper ) } # [ inline ] pub unsafe fn setRelease1 ( & mut self , proc_ : GrSurface_ReleaseProc , ctx : GrSurface_ReleaseCtx ) { GrSurface_setRelease1 ( self , proc_ , ctx ) } # [ inline ] pub unsafe fn surfacePriv ( & mut self ) -> GrSurfacePriv { GrSurface_surfacePriv ( self ) } # [ inline ] pub unsafe fn surfacePriv1 ( & self ) -> GrSurfacePriv { GrSurface_surfacePriv1 ( self ) } # [ inline ] pub unsafe fn WorstCaseSize ( desc : * const GrSurfaceDesc , useNextPow2 : bool ) -> usize { GrSurface_WorstCaseSize ( desc , useNextPow2 ) } # [ inline ] pub unsafe fn ComputeSize ( config : GrPixelConfig , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , colorSamplesPerPixel : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , useNextPow2 : bool ) -> usize { GrSurface_ComputeSize ( config , width , height , colorSamplesPerPixel , arg1 , useNextPow2 ) } # [ inline ] pub unsafe fn readOnly ( & self ) -> bool { GrSurface_readOnly ( self ) } # [ inline ] pub unsafe fn setHasMixedSamples ( & mut self ) { GrSurface_setHasMixedSamples ( self ) } # [ inline ] pub unsafe fn hasMixedSamples ( & self ) -> bool { GrSurface_hasMixedSamples ( self ) } # [ inline ] pub unsafe fn setGLRTFBOIDIs0 ( & mut self ) { GrSurface_setGLRTFBOIDIs0 ( self ) } # [ inline ] pub unsafe fn glRTFBOIDis0 ( & self ) -> bool { GrSurface_glRTFBOIDis0 ( self ) } # [ inline ] pub unsafe fn setReadOnly ( & mut self ) { GrSurface_setReadOnly ( self ) } # [ inline ] pub unsafe fn hasPendingRead ( & self ) -> bool { GrSurface_hasPendingRead ( self ) } # [ inline ] pub unsafe fn hasPendingWrite ( & self ) -> bool { GrSurface_hasPendingWrite ( self ) } # [ inline ] pub unsafe fn hasPendingIO ( & self ) -> bool { GrSurface_hasPendingIO ( self ) } # [ inline ] pub unsafe fn new ( gpu : * mut GrGpu , desc : * const GrSurfaceDesc ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSurface_GrSurface ( & mut __bindgen_tmp , gpu , desc ) ; __bindgen_tmp } } extern "C" { # [ doc = " @return the texture associated with the surface, may be null." ] # [ link_name = "\u{1}__ZN9GrSurface9asTextureEv" ] pub fn GrSurface_asTexture ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrTexture ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrSurface9asTextureEv" ] pub fn GrSurface_asTexture1 ( this : * mut :: std :: os :: raw :: c_void ) -> * const GrTexture ; } extern "C" { # [ doc = " @return the render target underlying this surface, may be null." ] # [ link_name = "\u{1}__ZN9GrSurface14asRenderTargetEv" ] pub fn GrSurface_asRenderTarget ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrRenderTarget ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrSurface14asRenderTargetEv" ] pub fn GrSurface_asRenderTarget1 ( this : * mut :: std :: os :: raw :: c_void ) -> * const GrRenderTarget ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurfaceD1Ev" ] pub fn GrSurface_GrSurface_destructor ( this : * mut GrSurface ) ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface9onReleaseEv" ] pub fn GrSurface_onRelease ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}__ZN9GrSurface9onAbandonEv" ] pub fn GrSurface_onAbandon ( this : * mut :: std :: os :: raw :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrOpList { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrProxyProvider { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrRenderTargetOpList { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrResourceProvider { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrSurfaceContext { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrSurfaceProxyPriv { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrTextureOpList { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrTextureProxy { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] pub struct GrIORefProxy__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrIORefProxy { pub vtable_ : * const GrIORefProxy__bindgen_vtable , pub fTarget : * mut GrSurface , pub fRefCnt : i32 , pub fPendingReads : i32 , pub fPendingWrites : i32 , } # [ test ] fn bindgen_test_layout_GrIORefProxy ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrIORefProxy > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( GrIORefProxy ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrIORefProxy > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrIORefProxy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrIORefProxy > ( ) ) ) . fTarget as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrIORefProxy ) , "::" , stringify ! ( fTarget ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrIORefProxy > ( ) ) ) . fRefCnt as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrIORefProxy ) , "::" , stringify ! ( fRefCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrIORefProxy > ( ) ) ) . fPendingReads as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( GrIORefProxy ) , "::" , stringify ! ( fPendingReads ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrIORefProxy > ( ) ) ) . fPendingWrites as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrIORefProxy ) , "::" , stringify ! ( fPendingWrites ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy3refEv" ] pub fn GrIORefProxy_ref ( this : * const GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy5unrefEv" ] pub fn GrIORefProxy_unref ( this : * const GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy18isUnique_debugOnlyEv" ] pub fn GrIORefProxy_isUnique_debugOnly ( this : * const GrIORefProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN12GrIORefProxy7releaseEv" ] pub fn GrIORefProxy_release ( this : * mut GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy8validateEv" ] pub fn GrIORefProxy_validate ( this : * const GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy25getBackingRefCnt_TestOnlyEv" ] pub fn GrIORefProxy_getBackingRefCnt_TestOnly ( this : * const GrIORefProxy ) -> i32 ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy26getPendingReadCnt_TestOnlyEv" ] pub fn GrIORefProxy_getPendingReadCnt_TestOnly ( this : * const GrIORefProxy ) -> i32 ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy27getPendingWriteCnt_TestOnlyEv" ] pub fn GrIORefProxy_getPendingWriteCnt_TestOnly ( this : * const GrIORefProxy ) -> i32 ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy14addPendingReadEv" ] pub fn GrIORefProxy_addPendingRead ( this : * const GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy13completedReadEv" ] pub fn GrIORefProxy_completedRead ( this : * const GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy15addPendingWriteEv" ] pub fn GrIORefProxy_addPendingWrite ( this : * const GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy14completedWriteEv" ] pub fn GrIORefProxy_completedWrite ( this : * const GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrIORefProxy12transferRefsEv" ] pub fn GrIORefProxy_transferRefs ( this : * mut GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy22internalGetProxyRefCntEv" ] pub fn GrIORefProxy_internalGetProxyRefCnt ( this : * const GrIORefProxy ) -> i32 ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy20internalHasPendingIOEv" ] pub fn GrIORefProxy_internalHasPendingIO ( this : * const GrIORefProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrIORefProxy23internalHasPendingWriteEv" ] pub fn GrIORefProxy_internalHasPendingWrite ( this : * const GrIORefProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN12GrIORefProxyC1Ev" ] pub fn GrIORefProxy_GrIORefProxy ( this : * mut GrIORefProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrIORefProxyC1E5sk_spI9GrSurfaceE" ] pub fn GrIORefProxy_GrIORefProxy1 ( this : * mut GrIORefProxy , surface : sk_sp < GrSurface > ) ; } impl GrIORefProxy { # [ inline ] pub unsafe fn ref_ ( & self ) { GrIORefProxy_ref ( self ) } # [ inline ] pub unsafe fn unref ( & self ) { GrIORefProxy_unref ( self ) } # [ inline ] pub unsafe fn isUnique_debugOnly ( & self ) -> bool { GrIORefProxy_isUnique_debugOnly ( self ) } # [ inline ] pub unsafe fn release ( & mut self ) { GrIORefProxy_release ( self ) } # [ inline ] pub unsafe fn validate ( & self ) { GrIORefProxy_validate ( self ) } # [ inline ] pub unsafe fn getBackingRefCnt_TestOnly ( & self ) -> i32 { GrIORefProxy_getBackingRefCnt_TestOnly ( self ) } # [ inline ] pub unsafe fn getPendingReadCnt_TestOnly ( & self ) -> i32 { GrIORefProxy_getPendingReadCnt_TestOnly ( self ) } # [ inline ] pub unsafe fn getPendingWriteCnt_TestOnly ( & self ) -> i32 { GrIORefProxy_getPendingWriteCnt_TestOnly ( self ) } # [ inline ] pub unsafe fn addPendingRead ( & self ) { GrIORefProxy_addPendingRead ( self ) } # [ inline ] pub unsafe fn completedRead ( & self ) { GrIORefProxy_completedRead ( self ) } # [ inline ] pub unsafe fn addPendingWrite ( & self ) { GrIORefProxy_addPendingWrite ( self ) } # [ inline ] pub unsafe fn completedWrite ( & self ) { GrIORefProxy_completedWrite ( self ) } # [ inline ] pub unsafe fn transferRefs ( & mut self ) { GrIORefProxy_transferRefs ( self ) } # [ inline ] pub unsafe fn internalGetProxyRefCnt ( & self ) -> i32 { GrIORefProxy_internalGetProxyRefCnt ( self ) } # [ inline ] pub unsafe fn internalHasPendingIO ( & self ) -> bool { GrIORefProxy_internalHasPendingIO ( self ) } # [ inline ] pub unsafe fn internalHasPendingWrite ( & self ) -> bool { GrIORefProxy_internalHasPendingWrite ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrIORefProxy_GrIORefProxy ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( surface : sk_sp < GrSurface > ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrIORefProxy_GrIORefProxy1 ( & mut __bindgen_tmp , surface ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN12GrIORefProxyD1Ev" ] pub fn GrIORefProxy_GrIORefProxy_destructor ( this : * mut GrIORefProxy ) ; } # [ repr ( C ) ] # [ repr ( align ( 16 ) ) ] pub struct GrSurfaceProxy { pub _base : GrIORefProxy , pub fSurfaceFlags : GrInternalSurfaceFlags , pub fFormat : GrBackendFormat , pub fConfig : GrPixelConfig , pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fOrigin : GrSurfaceOrigin , pub fFit : SkBackingFit , pub fBudgeted : SkBudgeted , pub fUniqueID : GrSurfaceProxy_UniqueID , pub __bindgen_padding_0 : u64 , pub fLazyInstantiateCallback : GrSurfaceProxy_LazyInstantiateCallback , pub fLazyInstantiationType : GrSurfaceProxy_LazyInstantiationType , pub fNeedsClear : bool , pub fGpuMemorySize : usize , pub fLastOpList : * mut GrOpList , } pub const GrSurfaceProxy_LazyInstantiationType_kSingleUse : GrSurfaceProxy_LazyInstantiationType = 0 ; pub const GrSurfaceProxy_LazyInstantiationType_kMultipleUse : GrSurfaceProxy_LazyInstantiationType = 1 ; pub const GrSurfaceProxy_LazyInstantiationType_kDeinstantiate : GrSurfaceProxy_LazyInstantiationType = 2 ; pub type GrSurfaceProxy_LazyInstantiationType = i32 ; pub const GrSurfaceProxy_LazyState_kNot : GrSurfaceProxy_LazyState = 0 ; pub const GrSurfaceProxy_LazyState_kPartially : GrSurfaceProxy_LazyState = 1 ; pub const GrSurfaceProxy_LazyState_kFully : GrSurfaceProxy_LazyState = 2 ; pub type GrSurfaceProxy_LazyState = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrSurfaceProxy_UniqueID { pub fID : u32 , } # [ test ] fn bindgen_test_layout_GrSurfaceProxy_UniqueID ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrSurfaceProxy_UniqueID > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( GrSurfaceProxy_UniqueID ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrSurfaceProxy_UniqueID > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrSurfaceProxy_UniqueID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy_UniqueID > ( ) ) ) . fID as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy_UniqueID ) , "::" , stringify ! ( fID ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy8UniqueID9InvalidIDEv" ] pub fn GrSurfaceProxy_UniqueID_InvalidID ( ) -> GrSurfaceProxy_UniqueID ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy8UniqueID6asUIntEv" ] pub fn GrSurfaceProxy_UniqueID_asUInt ( this : * const GrSurfaceProxy_UniqueID ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy8UniqueID11makeInvalidEv" ] pub fn GrSurfaceProxy_UniqueID_makeInvalid ( this : * mut GrSurfaceProxy_UniqueID ) ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy8UniqueID9isInvalidEv" ] pub fn GrSurfaceProxy_UniqueID_isInvalid ( this : * const GrSurfaceProxy_UniqueID ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy8UniqueIDC1ERKN13GrGpuResource8UniqueIDE" ] pub fn GrSurfaceProxy_UniqueID_UniqueID ( this : * mut GrSurfaceProxy_UniqueID , id : * const GrGpuResource_UniqueID ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy8UniqueIDC1Ev" ] pub fn GrSurfaceProxy_UniqueID_UniqueID1 ( this : * mut GrSurfaceProxy_UniqueID ) ; } impl GrSurfaceProxy_UniqueID { # [ inline ] pub unsafe fn InvalidID ( ) -> GrSurfaceProxy_UniqueID { GrSurfaceProxy_UniqueID_InvalidID ( ) } # [ inline ] pub unsafe fn asUInt ( & self ) -> u32 { GrSurfaceProxy_UniqueID_asUInt ( self ) } # [ inline ] pub unsafe fn makeInvalid ( & mut self ) { GrSurfaceProxy_UniqueID_makeInvalid ( self ) } # [ inline ] pub unsafe fn isInvalid ( & self ) -> bool { GrSurfaceProxy_UniqueID_isInvalid ( self ) } # [ inline ] pub unsafe fn new ( id : * const GrGpuResource_UniqueID ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSurfaceProxy_UniqueID_UniqueID ( & mut __bindgen_tmp , id ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSurfaceProxy_UniqueID_UniqueID1 ( & mut __bindgen_tmp ) ; __bindgen_tmp } } pub type GrSurfaceProxy_LazyInstantiateCallback = [ u128 ; 3usize ] ; pub type GrSurfaceProxy_INHERITED = GrIORefProxy ; extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy21kInvalidGpuMemorySizeE" ] pub static GrSurfaceProxy_kInvalidGpuMemorySize : usize ; } # [ test ] fn bindgen_test_layout_GrSurfaceProxy ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrSurfaceProxy > ( ) , 208usize , concat ! ( "Size of: " , stringify ! ( GrSurfaceProxy ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrSurfaceProxy > ( ) , 16usize , concat ! ( "Alignment of " , stringify ! ( GrSurfaceProxy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fSurfaceFlags as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fSurfaceFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fFormat as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fConfig as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fConfig ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fWidth as * const _ as usize } , 100usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fWidth ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fHeight as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fHeight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fOrigin as * const _ as usize } , 108usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fOrigin ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fFit as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fFit ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fBudgeted as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fBudgeted ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fUniqueID as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fUniqueID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fLazyInstantiateCallback as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fLazyInstantiateCallback ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fLazyInstantiationType as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fLazyInstantiationType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fNeedsClear as * const _ as usize } , 180usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fNeedsClear ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fGpuMemorySize as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fGpuMemorySize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSurfaceProxy > ( ) ) ) . fLastOpList as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( GrSurfaceProxy ) , "::" , stringify ! ( fLastOpList ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy22lazyInstantiationStateEv" ] pub fn GrSurfaceProxy_lazyInstantiationState ( this : * const GrSurfaceProxy ) -> GrSurfaceProxy_LazyState ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy6configEv" ] pub fn GrSurfaceProxy_config ( this : * const GrSurfaceProxy ) -> GrPixelConfig ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy5widthEv" ] pub fn GrSurfaceProxy_width ( this : * const GrSurfaceProxy ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy6heightEv" ] pub fn GrSurfaceProxy_height ( this : * const GrSurfaceProxy ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy5isizeEv" ] pub fn GrSurfaceProxy_isize ( this : * const GrSurfaceProxy ) -> SkISize ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy14worstCaseWidthEv" ] pub fn GrSurfaceProxy_worstCaseWidth ( this : * const GrSurfaceProxy ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy15worstCaseHeightEv" ] pub fn GrSurfaceProxy_worstCaseHeight ( this : * const GrSurfaceProxy ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Helper that gets the width and height of the surface as a bounding rectangle." ] # [ link_name = "\u{1}__ZNK14GrSurfaceProxy13getBoundsRectEv" ] pub fn GrSurfaceProxy_getBoundsRect ( this : * const GrSurfaceProxy ) -> SkRect ; } extern "C" { # [ doc = " Helper that gets the worst case width and height of the surface as a bounding rectangle." ] # [ link_name = "\u{1}__ZNK14GrSurfaceProxy22getWorstCaseBoundsRectEv" ] pub fn GrSurfaceProxy_getWorstCaseBoundsRect ( this : * const GrSurfaceProxy ) -> SkRect ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy6originEv" ] pub fn GrSurfaceProxy_origin ( this : * const GrSurfaceProxy ) -> GrSurfaceOrigin ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy13backendFormatEv" ] pub fn GrSurfaceProxy_backendFormat ( this : * const GrSurfaceProxy ) -> * const GrBackendFormat ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy8uniqueIDEv" ] pub fn GrSurfaceProxy_uniqueID ( this : * const GrSurfaceProxy ) -> GrSurfaceProxy_UniqueID ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy18underlyingUniqueIDEv" ] pub fn GrSurfaceProxy_underlyingUniqueID ( this : * const GrSurfaceProxy ) -> GrSurfaceProxy_UniqueID ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy13deinstantiateEv" ] pub fn GrSurfaceProxy_deinstantiate ( this : * mut GrSurfaceProxy ) ; } extern "C" { # [ doc = " Proxies that are already instantiated and whose backing surface cannot be recycled to" ] # [ doc = " instantiate other proxies do not need to be considered by GrResourceAllocator." ] # [ link_name = "\u{1}__ZNK14GrSurfaceProxy24canSkipResourceAllocatorEv" ] pub fn GrSurfaceProxy_canSkipResourceAllocator ( this : * const GrSurfaceProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy14isInstantiatedEv" ] pub fn GrSurfaceProxy_isInstantiated ( this : * const GrSurfaceProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy11peekSurfaceEv" ] pub fn GrSurfaceProxy_peekSurface ( this : * const GrSurfaceProxy ) -> * mut GrSurface ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy11peekTextureEv" ] pub fn GrSurfaceProxy_peekTexture ( this : * const GrSurfaceProxy ) -> * mut GrTexture ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy16peekRenderTargetEv" ] pub fn GrSurfaceProxy_peekRenderTarget ( this : * const GrSurfaceProxy ) -> * mut GrRenderTarget ; } extern "C" { # [ doc = " Does the resource count against the resource budget?" ] # [ link_name = "\u{1}__ZNK14GrSurfaceProxy10isBudgetedEv" ] pub fn GrSurfaceProxy_isBudgeted ( this : * const GrSurfaceProxy ) -> SkBudgeted ; } extern "C" { # [ doc = " The pixel values of this proxy\'s surface cannot be modified (e.g. doesn\'t support write" ] # [ doc = " pixels or MIP map level regen). Read-only proxies also bypass interval tracking and" ] # [ doc = " assignment in GrResourceAllocator." ] # [ link_name = "\u{1}__ZNK14GrSurfaceProxy8readOnlyEv" ] pub fn GrSurfaceProxy_readOnly ( this : * const GrSurfaceProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy13setLastOpListEP8GrOpList" ] pub fn GrSurfaceProxy_setLastOpList ( this : * mut GrSurfaceProxy , opList : * mut GrOpList ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy13getLastOpListEv" ] pub fn GrSurfaceProxy_getLastOpList ( this : * mut GrSurfaceProxy ) -> * mut GrOpList ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy25getLastRenderTargetOpListEv" ] pub fn GrSurfaceProxy_getLastRenderTargetOpList ( this : * mut GrSurfaceProxy ) -> * mut GrRenderTargetOpList ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy20getLastTextureOpListEv" ] pub fn GrSurfaceProxy_getLastTextureOpList ( this : * mut GrSurfaceProxy ) -> * mut GrTextureOpList ; } extern "C" { # [ doc = " Retrieves the amount of GPU memory that will be or currently is used by this resource" ] # [ doc = " in bytes. It is approximate since we aren\'t aware of additional padding or copies made" ] # [ doc = " by the driver." ] # [ doc = "" ] # [ doc = " @return the amount of GPU memory used in bytes" ] # [ link_name = "\u{1}__ZNK14GrSurfaceProxy13gpuMemorySizeEv" ] pub fn GrSurfaceProxy_gpuMemorySize ( this : * const GrSurfaceProxy ) -> usize ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy4CopyEP18GrRecordingContextPS_11GrMipMapped7SkIRect12SkBackingFit10SkBudgeted" ] pub fn GrSurfaceProxy_Copy ( arg1 : * mut GrRecordingContext , src : * mut GrSurfaceProxy , arg2 : GrMipMapped , srcRect : SkIRect , arg3 : SkBackingFit , arg4 : SkBudgeted ) -> sk_sp < GrTextureProxy > ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy4CopyEP18GrRecordingContextPS_11GrMipMapped12SkBackingFit10SkBudgeted" ] pub fn GrSurfaceProxy_Copy1 ( arg1 : * mut GrRecordingContext , src : * mut GrSurfaceProxy , arg2 : GrMipMapped , arg3 : SkBackingFit , arg4 : SkBudgeted ) -> sk_sp < GrTextureProxy > ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy8TestCopyEP18GrRecordingContextRK13GrSurfaceDesc15GrSurfaceOriginPS_" ] pub fn GrSurfaceProxy_TestCopy ( context : * mut GrRecordingContext , dstDesc : * const GrSurfaceDesc , arg1 : GrSurfaceOrigin , srcProxy : * mut GrSurfaceProxy ) -> sk_sp < GrSurfaceContext > ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy20isWrapped_ForTestingEv" ] pub fn GrSurfaceProxy_isWrapped_ForTesting ( this : * const GrSurfaceProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy8validateEP14GrContext_Base" ] pub fn GrSurfaceProxy_validate ( this : * const GrSurfaceProxy , arg1 : * mut GrContext_Base ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy4privEv" ] pub fn GrSurfaceProxy_priv ( this : * mut GrSurfaceProxy ) -> GrSurfaceProxyPriv ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy4privEv" ] pub fn GrSurfaceProxy_priv1 ( this : * const GrSurfaceProxy ) -> GrSurfaceProxyPriv ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy20testingOnly_getFlagsEv" ] pub fn GrSurfaceProxy_testingOnly_getFlags ( this : * const GrSurfaceProxy ) -> GrInternalSurfaceFlags ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy14getProxyRefCntEv" ] pub fn GrSurfaceProxy_getProxyRefCnt ( this : * const GrSurfaceProxy ) -> i32 ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy12hasPendingIOEv" ] pub fn GrSurfaceProxy_hasPendingIO ( this : * const GrSurfaceProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy15hasPendingWriteEv" ] pub fn GrSurfaceProxy_hasPendingWrite ( this : * const GrSurfaceProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy17computeScratchKeyEP12GrScratchKey" ] pub fn GrSurfaceProxy_computeScratchKey ( this : * const GrSurfaceProxy , arg1 : * mut GrScratchKey ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy6assignE5sk_spI9GrSurfaceE" ] pub fn GrSurfaceProxy_assign ( this : * mut GrSurfaceProxy , surface : sk_sp < GrSurface > ) ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy17createSurfaceImplEP18GrResourceProviderib14GrSurfaceFlags11GrMipMapped" ] pub fn GrSurfaceProxy_createSurfaceImpl ( this : * const GrSurfaceProxy , arg1 : * mut GrResourceProvider , sampleCnt : :: std :: os :: raw :: c_int , needsStencil : bool , arg2 : GrSurfaceDescFlags , arg3 : GrMipMapped ) -> sk_sp < GrSurface > ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxy15instantiateImplEP18GrResourceProviderib14GrSurfaceFlags11GrMipMappedPK11GrUniqueKey" ] pub fn GrSurfaceProxy_instantiateImpl ( this : * mut GrSurfaceProxy , resourceProvider : * mut GrResourceProvider , sampleCnt : :: std :: os :: raw :: c_int , needsStencil : bool , descFlags : GrSurfaceDescFlags , arg1 : GrMipMapped , arg2 : * const GrUniqueKey ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxyC2ERK15GrBackendFormatRK13GrSurfaceDesc15GrSurfaceOrigin12SkBackingFit10SkBudgeted22GrInternalSurfaceFlags" ] pub fn GrSurfaceProxy_GrSurfaceProxy ( this : * mut GrSurfaceProxy , format : * const GrBackendFormat , desc : * const GrSurfaceDesc , origin : GrSurfaceOrigin , fit : SkBackingFit , budgeted : SkBudgeted , surfaceFlags : GrInternalSurfaceFlags ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxyC2EONSt3__18functionIF5sk_spI9GrSurfaceEP18GrResourceProviderEEENS_21LazyInstantiationTypeERK15GrBackendFormatRK13GrSurfaceDesc15GrSurfaceOrigin12SkBackingFit10SkBudgeted22GrInternalSurfaceFlags" ] pub fn GrSurfaceProxy_GrSurfaceProxy1 ( this : * mut GrSurfaceProxy , arg1 : * mut GrSurfaceProxy_LazyInstantiateCallback , arg2 : GrSurfaceProxy_LazyInstantiationType , format : * const GrBackendFormat , arg3 : * const GrSurfaceDesc , arg4 : GrSurfaceOrigin , arg5 : SkBackingFit , arg6 : SkBudgeted , arg7 : GrInternalSurfaceFlags ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxyC2E5sk_spI9GrSurfaceE15GrSurfaceOrigin12SkBackingFit" ] pub fn GrSurfaceProxy_GrSurfaceProxy2 ( this : * mut GrSurfaceProxy , arg1 : sk_sp < GrSurface > , arg2 : GrSurfaceOrigin , arg3 : SkBackingFit ) ; } impl GrSurfaceProxy { # [ inline ] pub unsafe fn lazyInstantiationState ( & self ) -> GrSurfaceProxy_LazyState { GrSurfaceProxy_lazyInstantiationState ( self ) } # [ inline ] pub unsafe fn config ( & self ) -> GrPixelConfig { GrSurfaceProxy_config ( self ) } # [ inline ] pub unsafe fn width ( & self ) -> :: std :: os :: raw :: c_int { GrSurfaceProxy_width ( self ) } # [ inline ] pub unsafe fn height ( & self ) -> :: std :: os :: raw :: c_int { GrSurfaceProxy_height ( self ) } # [ inline ] pub unsafe fn isize ( & self ) -> SkISize { GrSurfaceProxy_isize ( self ) } # [ inline ] pub unsafe fn worstCaseWidth ( & self ) -> :: std :: os :: raw :: c_int { GrSurfaceProxy_worstCaseWidth ( self ) } # [ inline ] pub unsafe fn worstCaseHeight ( & self ) -> :: std :: os :: raw :: c_int { GrSurfaceProxy_worstCaseHeight ( self ) } # [ inline ] pub unsafe fn getBoundsRect ( & self ) -> SkRect { GrSurfaceProxy_getBoundsRect ( self ) } # [ inline ] pub unsafe fn getWorstCaseBoundsRect ( & self ) -> SkRect { GrSurfaceProxy_getWorstCaseBoundsRect ( self ) } # [ inline ] pub unsafe fn origin ( & self ) -> GrSurfaceOrigin { GrSurfaceProxy_origin ( self ) } # [ inline ] pub unsafe fn backendFormat ( & self ) -> * const GrBackendFormat { GrSurfaceProxy_backendFormat ( self ) } # [ inline ] pub unsafe fn uniqueID ( & self ) -> GrSurfaceProxy_UniqueID { GrSurfaceProxy_uniqueID ( self ) } # [ inline ] pub unsafe fn underlyingUniqueID ( & self ) -> GrSurfaceProxy_UniqueID { GrSurfaceProxy_underlyingUniqueID ( self ) } # [ inline ] pub unsafe fn deinstantiate ( & mut self ) { GrSurfaceProxy_deinstantiate ( self ) } # [ inline ] pub unsafe fn canSkipResourceAllocator ( & self ) -> bool { GrSurfaceProxy_canSkipResourceAllocator ( self ) } # [ inline ] pub unsafe fn isInstantiated ( & self ) -> bool { GrSurfaceProxy_isInstantiated ( self ) } # [ inline ] pub unsafe fn peekSurface ( & self ) -> * mut GrSurface { GrSurfaceProxy_peekSurface ( self ) } # [ inline ] pub unsafe fn peekTexture ( & self ) -> * mut GrTexture { GrSurfaceProxy_peekTexture ( self ) } # [ inline ] pub unsafe fn peekRenderTarget ( & self ) -> * mut GrRenderTarget { GrSurfaceProxy_peekRenderTarget ( self ) } # [ inline ] pub unsafe fn isBudgeted ( & self ) -> SkBudgeted { GrSurfaceProxy_isBudgeted ( self ) } # [ inline ] pub unsafe fn readOnly ( & self ) -> bool { GrSurfaceProxy_readOnly ( self ) } # [ inline ] pub unsafe fn setLastOpList ( & mut self , opList : * mut GrOpList ) { GrSurfaceProxy_setLastOpList ( self , opList ) } # [ inline ] pub unsafe fn getLastOpList ( & mut self ) -> * mut GrOpList { GrSurfaceProxy_getLastOpList ( self ) } # [ inline ] pub unsafe fn getLastRenderTargetOpList ( & mut self ) -> * mut GrRenderTargetOpList { GrSurfaceProxy_getLastRenderTargetOpList ( self ) } # [ inline ] pub unsafe fn getLastTextureOpList ( & mut self ) -> * mut GrTextureOpList { GrSurfaceProxy_getLastTextureOpList ( self ) } # [ inline ] pub unsafe fn gpuMemorySize ( & self ) -> usize { GrSurfaceProxy_gpuMemorySize ( self ) } # [ inline ] pub unsafe fn Copy ( arg1 : * mut GrRecordingContext , src : * mut GrSurfaceProxy , arg2 : GrMipMapped , srcRect : SkIRect , arg3 : SkBackingFit , arg4 : SkBudgeted ) -> sk_sp < GrTextureProxy > { GrSurfaceProxy_Copy ( arg1 , src , arg2 , srcRect , arg3 , arg4 ) } # [ inline ] pub unsafe fn Copy1 ( arg1 : * mut GrRecordingContext , src : * mut GrSurfaceProxy , arg2 : GrMipMapped , arg3 : SkBackingFit , arg4 : SkBudgeted ) -> sk_sp < GrTextureProxy > { GrSurfaceProxy_Copy1 ( arg1 , src , arg2 , arg3 , arg4 ) } # [ inline ] pub unsafe fn TestCopy ( context : * mut GrRecordingContext , dstDesc : * const GrSurfaceDesc , arg1 : GrSurfaceOrigin , srcProxy : * mut GrSurfaceProxy ) -> sk_sp < GrSurfaceContext > { GrSurfaceProxy_TestCopy ( context , dstDesc , arg1 , srcProxy ) } # [ inline ] pub unsafe fn isWrapped_ForTesting ( & self ) -> bool { GrSurfaceProxy_isWrapped_ForTesting ( self ) } # [ inline ] pub unsafe fn validate ( & self , arg1 : * mut GrContext_Base ) { GrSurfaceProxy_validate ( self , arg1 ) } # [ inline ] pub unsafe fn priv_ ( & mut self ) -> GrSurfaceProxyPriv { GrSurfaceProxy_priv ( self ) } # [ inline ] pub unsafe fn priv1 ( & self ) -> GrSurfaceProxyPriv { GrSurfaceProxy_priv1 ( self ) } # [ inline ] pub unsafe fn testingOnly_getFlags ( & self ) -> GrInternalSurfaceFlags { GrSurfaceProxy_testingOnly_getFlags ( self ) } # [ inline ] pub unsafe fn getProxyRefCnt ( & self ) -> i32 { GrSurfaceProxy_getProxyRefCnt ( self ) } # [ inline ] pub unsafe fn hasPendingIO ( & self ) -> bool { GrSurfaceProxy_hasPendingIO ( self ) } # [ inline ] pub unsafe fn hasPendingWrite ( & self ) -> bool { GrSurfaceProxy_hasPendingWrite ( self ) } # [ inline ] pub unsafe fn computeScratchKey ( & self , arg1 : * mut GrScratchKey ) { GrSurfaceProxy_computeScratchKey ( self , arg1 ) } # [ inline ] pub unsafe fn assign ( & mut self , surface : sk_sp < GrSurface > ) { GrSurfaceProxy_assign ( self , surface ) } # [ inline ] pub unsafe fn createSurfaceImpl ( & self , arg1 : * mut GrResourceProvider , sampleCnt : :: std :: os :: raw :: c_int , needsStencil : bool , arg2 : GrSurfaceDescFlags , arg3 : GrMipMapped ) -> sk_sp < GrSurface > { GrSurfaceProxy_createSurfaceImpl ( self , arg1 , sampleCnt , needsStencil , arg2 , arg3 ) } # [ inline ] pub unsafe fn instantiateImpl ( & mut self , resourceProvider : * mut GrResourceProvider , sampleCnt : :: std :: os :: raw :: c_int , needsStencil : bool , descFlags : GrSurfaceDescFlags , arg1 : GrMipMapped , arg2 : * const GrUniqueKey ) -> bool { GrSurfaceProxy_instantiateImpl ( self , resourceProvider , sampleCnt , needsStencil , descFlags , arg1 , arg2 ) } # [ inline ] pub unsafe fn new ( format : * const GrBackendFormat , desc : * const GrSurfaceDesc , origin : GrSurfaceOrigin , fit : SkBackingFit , budgeted : SkBudgeted , surfaceFlags : GrInternalSurfaceFlags ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSurfaceProxy_GrSurfaceProxy ( & mut __bindgen_tmp , format , desc , origin , fit , budgeted , surfaceFlags ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : * mut GrSurfaceProxy_LazyInstantiateCallback , arg2 : GrSurfaceProxy_LazyInstantiationType , format : * const GrBackendFormat , arg3 : * const GrSurfaceDesc , arg4 : GrSurfaceOrigin , arg5 : SkBackingFit , arg6 : SkBudgeted , arg7 : GrInternalSurfaceFlags ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSurfaceProxy_GrSurfaceProxy1 ( & mut __bindgen_tmp , arg1 , arg2 , format , arg3 , arg4 , arg5 , arg6 , arg7 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( arg1 : sk_sp < GrSurface > , arg2 : GrSurfaceOrigin , arg3 : SkBackingFit ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSurfaceProxy_GrSurfaceProxy2 ( & mut __bindgen_tmp , arg1 , arg2 , arg3 ) ; __bindgen_tmp } } extern "C" { # [ doc = " @return the texture proxy associated with the surface proxy, may be NULL." ] # [ link_name = "\u{1}__ZN14GrSurfaceProxy14asTextureProxyEv" ] pub fn GrSurfaceProxy_asTextureProxy ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrTextureProxy ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy14asTextureProxyEv" ] pub fn GrSurfaceProxy_asTextureProxy1 ( this : * mut :: std :: os :: raw :: c_void ) -> * const GrTextureProxy ; } extern "C" { # [ doc = " @return the render target proxy associated with the surface proxy, may be NULL." ] # [ link_name = "\u{1}__ZN14GrSurfaceProxy19asRenderTargetProxyEv" ] pub fn GrSurfaceProxy_asRenderTargetProxy ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrRenderTargetProxy ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrSurfaceProxy19asRenderTargetProxyEv" ] pub fn GrSurfaceProxy_asRenderTargetProxy1 ( this : * mut :: std :: os :: raw :: c_void ) -> * const GrRenderTargetProxy ; } extern "C" { # [ link_name = "\u{1}__ZN14GrSurfaceProxyD1Ev" ] pub fn GrSurfaceProxy_GrSurfaceProxy_destructor ( this : * mut GrSurfaceProxy ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrRenderTargetProxyPriv { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ repr ( align ( 16 ) ) ] pub struct GrRenderTargetProxy { pub __bindgen_padding_0 : [ u32 ; 2usize ] , pub fSampleCnt : :: std :: os :: raw :: c_int , pub fNeedsStencil : bool , pub fWrapsVkSecondaryCB : GrRenderTargetProxy_WrapsVkSecondaryCB , pub __bindgen_padding_1 : [ u16 ; 105usize ] , } pub const GrRenderTargetProxy_WrapsVkSecondaryCB_kNo : GrRenderTargetProxy_WrapsVkSecondaryCB = 0 ; pub const GrRenderTargetProxy_WrapsVkSecondaryCB_kYes : GrRenderTargetProxy_WrapsVkSecondaryCB = 1 ; pub type GrRenderTargetProxy_WrapsVkSecondaryCB = u8 ; pub type GrRenderTargetProxy_INHERITED = GrSurfaceProxy ; # [ test ] fn bindgen_test_layout_GrRenderTargetProxy ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrRenderTargetProxy > ( ) , 224usize , concat ! ( "Size of: " , stringify ! ( GrRenderTargetProxy ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrRenderTargetProxy > ( ) , 16usize , concat ! ( "Alignment of " , stringify ! ( GrRenderTargetProxy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrRenderTargetProxy > ( ) ) ) . fSampleCnt as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrRenderTargetProxy ) , "::" , stringify ! ( fSampleCnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrRenderTargetProxy > ( ) ) ) . fNeedsStencil as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( GrRenderTargetProxy ) , "::" , stringify ! ( fNeedsStencil ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrRenderTargetProxy > ( ) ) ) . fWrapsVkSecondaryCB as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( GrRenderTargetProxy ) , "::" , stringify ! ( fWrapsVkSecondaryCB ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK19GrRenderTargetProxy8fsaaTypeEv" ] pub fn GrRenderTargetProxy_fsaaType ( this : * const GrRenderTargetProxy ) -> GrFSAAType ; } extern "C" { # [ link_name = "\u{1}__ZN19GrRenderTargetProxy15setNeedsStencilEv" ] pub fn GrRenderTargetProxy_setNeedsStencil ( this : * mut GrRenderTargetProxy ) ; } extern "C" { # [ link_name = "\u{1}__ZNK19GrRenderTargetProxy12needsStencilEv" ] pub fn GrRenderTargetProxy_needsStencil ( this : * const GrRenderTargetProxy ) -> bool ; } extern "C" { # [ doc = " Returns the number of samples/pixel in the stencil buffer (One if non-MSAA)." ] # [ link_name = "\u{1}__ZNK19GrRenderTargetProxy17numStencilSamplesEv" ] pub fn GrRenderTargetProxy_numStencilSamples ( this : * const GrRenderTargetProxy ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Returns the number of samples/pixel in the color buffer (One if non-MSAA or mixed sampled)." ] # [ link_name = "\u{1}__ZNK19GrRenderTargetProxy15numColorSamplesEv" ] pub fn GrRenderTargetProxy_numColorSamples ( this : * const GrRenderTargetProxy ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK19GrRenderTargetProxy19maxWindowRectanglesERK6GrCaps" ] pub fn GrRenderTargetProxy_maxWindowRectangles ( this : * const GrRenderTargetProxy , caps : * const GrCaps ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__ZNK19GrRenderTargetProxy18wrapsVkSecondaryCBEv" ] pub fn GrRenderTargetProxy_wrapsVkSecondaryCB ( this : * const GrRenderTargetProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK19GrRenderTargetProxy18refsWrappedObjectsEv" ] pub fn GrRenderTargetProxy_refsWrappedObjects ( this : * const GrRenderTargetProxy ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN19GrRenderTargetProxy6rtPrivEv" ] pub fn GrRenderTargetProxy_rtPriv ( this : * mut GrRenderTargetProxy ) -> GrRenderTargetProxyPriv ; } extern "C" { # [ link_name = "\u{1}__ZNK19GrRenderTargetProxy6rtPrivEv" ] pub fn GrRenderTargetProxy_rtPriv1 ( this : * const GrRenderTargetProxy ) -> GrRenderTargetProxyPriv ; } extern "C" { # [ link_name = "\u{1}__ZN19GrRenderTargetProxyC1ERK6GrCapsRK15GrBackendFormatRK13GrSurfaceDesc15GrSurfaceOrigin12SkBackingFit10SkBudgeted22GrInternalSurfaceFlags" ] pub fn GrRenderTargetProxy_GrRenderTargetProxy ( this : * mut GrRenderTargetProxy , arg1 : * const GrCaps , arg2 : * const GrBackendFormat , arg3 : * const GrSurfaceDesc , arg4 : GrSurfaceOrigin , arg5 : SkBackingFit , arg6 : SkBudgeted , arg7 : GrInternalSurfaceFlags ) ; } extern "C" { # [ link_name = "\u{1}__ZN19GrRenderTargetProxyC1EONSt3__18functionIF5sk_spI9GrSurfaceEP18GrResourceProviderEEEN14GrSurfaceProxy21LazyInstantiationTypeERK15GrBackendFormatRK13GrSurfaceDesc15GrSurfaceOrigin12SkBackingFit10SkBudgeted22GrInternalSurfaceFlags" ] pub fn GrRenderTargetProxy_GrRenderTargetProxy1 ( this : * mut GrRenderTargetProxy , arg1 : * mut GrSurfaceProxy_LazyInstantiateCallback , lazyType : GrSurfaceProxy_LazyInstantiationType , arg2 : * const GrBackendFormat , arg3 : * const GrSurfaceDesc , arg4 : GrSurfaceOrigin , arg5 : SkBackingFit , arg6 : SkBudgeted , arg7 : GrInternalSurfaceFlags ) ; } extern "C" { # [ link_name = "\u{1}__ZN19GrRenderTargetProxyC1E5sk_spI9GrSurfaceE15GrSurfaceOriginNS_18WrapsVkSecondaryCBE" ] pub fn GrRenderTargetProxy_GrRenderTargetProxy2 ( this : * mut GrRenderTargetProxy , arg1 : sk_sp < GrSurface > , arg2 : GrSurfaceOrigin , wrapsVkSecondaryCB : GrRenderTargetProxy_WrapsVkSecondaryCB ) ; } impl GrRenderTargetProxy { # [ inline ] pub unsafe fn fsaaType ( & self ) -> GrFSAAType { GrRenderTargetProxy_fsaaType ( self ) } # [ inline ] pub unsafe fn setNeedsStencil ( & mut self ) { GrRenderTargetProxy_setNeedsStencil ( self ) } # [ inline ] pub unsafe fn needsStencil ( & self ) -> bool { GrRenderTargetProxy_needsStencil ( self ) } # [ inline ] pub unsafe fn numStencilSamples ( & self ) -> :: std :: os :: raw :: c_int { GrRenderTargetProxy_numStencilSamples ( self ) } # [ inline ] pub unsafe fn numColorSamples ( & self ) -> :: std :: os :: raw :: c_int { GrRenderTargetProxy_numColorSamples ( self ) } # [ inline ] pub unsafe fn maxWindowRectangles ( & self , caps : * const GrCaps ) -> :: std :: os :: raw :: c_int { GrRenderTargetProxy_maxWindowRectangles ( self , caps ) } # [ inline ] pub unsafe fn wrapsVkSecondaryCB ( & self ) -> bool { GrRenderTargetProxy_wrapsVkSecondaryCB ( self ) } # [ inline ] pub unsafe fn refsWrappedObjects ( & self ) -> bool { GrRenderTargetProxy_refsWrappedObjects ( self ) } # [ inline ] pub unsafe fn rtPriv ( & mut self ) -> GrRenderTargetProxyPriv { GrRenderTargetProxy_rtPriv ( self ) } # [ inline ] pub unsafe fn rtPriv1 ( & self ) -> GrRenderTargetProxyPriv { GrRenderTargetProxy_rtPriv1 ( self ) } # [ inline ] pub unsafe fn new ( arg1 : * const GrCaps , arg2 : * const GrBackendFormat , arg3 : * const GrSurfaceDesc , arg4 : GrSurfaceOrigin , arg5 : SkBackingFit , arg6 : SkBudgeted , arg7 : GrInternalSurfaceFlags ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrRenderTargetProxy_GrRenderTargetProxy ( & mut __bindgen_tmp , arg1 , arg2 , arg3 , arg4 , arg5 , arg6 , arg7 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( arg1 : * mut GrSurfaceProxy_LazyInstantiateCallback , lazyType : GrSurfaceProxy_LazyInstantiationType , arg2 : * const GrBackendFormat , arg3 : * const GrSurfaceDesc , arg4 : GrSurfaceOrigin , arg5 : SkBackingFit , arg6 : SkBudgeted , arg7 : GrInternalSurfaceFlags ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrRenderTargetProxy_GrRenderTargetProxy1 ( & mut __bindgen_tmp , arg1 , lazyType , arg2 , arg3 , arg4 , arg5 , arg6 , arg7 ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new2 ( arg1 : sk_sp < GrSurface > , arg2 : GrSurfaceOrigin , wrapsVkSecondaryCB : GrRenderTargetProxy_WrapsVkSecondaryCB ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrRenderTargetProxy_GrRenderTargetProxy2 ( & mut __bindgen_tmp , arg1 , arg2 , wrapsVkSecondaryCB ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZTv0_n56_N19GrRenderTargetProxy19asRenderTargetProxyEv" ] pub fn GrRenderTargetProxy_asRenderTargetProxy ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrRenderTargetProxy ; } extern "C" { # [ link_name = "\u{1}__ZTv0_n64_NK19GrRenderTargetProxy19asRenderTargetProxyEv" ] pub fn GrRenderTargetProxy_asRenderTargetProxy1 ( this : * mut :: std :: os :: raw :: c_void ) -> * const GrRenderTargetProxy ; } extern "C" { # [ link_name = "\u{1}__ZTv0_n32_N19GrRenderTargetProxy11instantiateEP18GrResourceProvider" ] pub fn GrRenderTargetProxy_instantiate ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut GrResourceProvider ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZTv0_n72_NK19GrRenderTargetProxy13createSurfaceEP18GrResourceProvider" ] pub fn GrRenderTargetProxy_createSurface ( this : * mut :: std :: os :: raw :: c_void , arg1 : * mut GrResourceProvider ) -> sk_sp < GrSurface > ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkGoodHash { pub _address : u8 , } # [ test ] fn bindgen_test_layout_SkGoodHash ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkGoodHash > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( SkGoodHash ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkGoodHash > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SkGoodHash ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkTHashTable { pub fCount : :: std :: os :: raw :: c_int , pub fCapacity : :: std :: os :: raw :: c_int , pub fSlots : SkAutoTArray , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkTHashTable_Slot < T > { pub val : T , pub hash : u32 , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct SkTHashMap { pub fTable : SkTHashTable , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkTHashMap_Pair < K , V > { pub key : K , pub val : V , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < K > > , pub _phantom_1 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < V > > , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrOp { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkJSONWriter { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrAuditTrail { pub fOpPool : GrAuditTrail_OpPool , pub fIDLookup : SkTHashMap , pub fClientIDLookup : SkTHashMap , pub fOpList : GrAuditTrail_OpList , pub fCurrentStackTrace : [ u64 ; 3usize ] , pub fClientID : :: std :: os :: raw :: c_int , pub fEnabled : bool , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrAuditTrail_AutoEnable { pub fAuditTrail : * mut GrAuditTrail , } # [ test ] fn bindgen_test_layout_GrAuditTrail_AutoEnable ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrAuditTrail_AutoEnable > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrAuditTrail_AutoEnable ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrAuditTrail_AutoEnable > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrAuditTrail_AutoEnable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_AutoEnable > ( ) ) ) . fAuditTrail as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_AutoEnable ) , "::" , stringify ! ( fAuditTrail ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail10AutoEnableC1EPS_" ] pub fn GrAuditTrail_AutoEnable_AutoEnable ( this : * mut GrAuditTrail_AutoEnable , auditTrail : * mut GrAuditTrail ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail10AutoEnableD1Ev" ] pub fn GrAuditTrail_AutoEnable_AutoEnable_destructor ( this : * mut GrAuditTrail_AutoEnable ) ; } impl GrAuditTrail_AutoEnable { # [ inline ] pub unsafe fn new ( auditTrail : * mut GrAuditTrail ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrAuditTrail_AutoEnable_AutoEnable ( & mut __bindgen_tmp , auditTrail ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { GrAuditTrail_AutoEnable_AutoEnable_destructor ( self ) } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrAuditTrail_AutoManageOpList { pub fAutoEnable : GrAuditTrail_AutoEnable , pub fAuditTrail : * mut GrAuditTrail , } # [ test ] fn bindgen_test_layout_GrAuditTrail_AutoManageOpList ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrAuditTrail_AutoManageOpList > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( GrAuditTrail_AutoManageOpList ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrAuditTrail_AutoManageOpList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrAuditTrail_AutoManageOpList ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_AutoManageOpList > ( ) ) ) . fAutoEnable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_AutoManageOpList ) , "::" , stringify ! ( fAutoEnable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_AutoManageOpList > ( ) ) ) . fAuditTrail as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_AutoManageOpList ) , "::" , stringify ! ( fAuditTrail ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail16AutoManageOpListC1EPS_" ] pub fn GrAuditTrail_AutoManageOpList_AutoManageOpList ( this : * mut GrAuditTrail_AutoManageOpList , auditTrail : * mut GrAuditTrail ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail16AutoManageOpListD1Ev" ] pub fn GrAuditTrail_AutoManageOpList_AutoManageOpList_destructor ( this : * mut GrAuditTrail_AutoManageOpList ) ; } impl GrAuditTrail_AutoManageOpList { # [ inline ] pub unsafe fn new ( auditTrail : * mut GrAuditTrail ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrAuditTrail_AutoManageOpList_AutoManageOpList ( & mut __bindgen_tmp , auditTrail ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { GrAuditTrail_AutoManageOpList_AutoManageOpList_destructor ( self ) } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrAuditTrail_AutoCollectOps { pub fAutoEnable : GrAuditTrail_AutoEnable , pub fAuditTrail : * mut GrAuditTrail , } # [ test ] fn bindgen_test_layout_GrAuditTrail_AutoCollectOps ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrAuditTrail_AutoCollectOps > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( GrAuditTrail_AutoCollectOps ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrAuditTrail_AutoCollectOps > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrAuditTrail_AutoCollectOps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_AutoCollectOps > ( ) ) ) . fAutoEnable as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_AutoCollectOps ) , "::" , stringify ! ( fAutoEnable ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_AutoCollectOps > ( ) ) ) . fAuditTrail as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_AutoCollectOps ) , "::" , stringify ! ( fAuditTrail ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail14AutoCollectOpsC1EPS_i" ] pub fn GrAuditTrail_AutoCollectOps_AutoCollectOps ( this : * mut GrAuditTrail_AutoCollectOps , auditTrail : * mut GrAuditTrail , clientID : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail14AutoCollectOpsD1Ev" ] pub fn GrAuditTrail_AutoCollectOps_AutoCollectOps_destructor ( this : * mut GrAuditTrail_AutoCollectOps ) ; } impl GrAuditTrail_AutoCollectOps { # [ inline ] pub unsafe fn new ( auditTrail : * mut GrAuditTrail , clientID : :: std :: os :: raw :: c_int ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrAuditTrail_AutoCollectOps_AutoCollectOps ( & mut __bindgen_tmp , auditTrail , clientID ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { GrAuditTrail_AutoCollectOps_AutoCollectOps_destructor ( self ) } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrAuditTrail_OpInfo { pub fBounds : SkRect , pub fProxyUniqueID : GrSurfaceProxy_UniqueID , pub fOps : [ u64 ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrAuditTrail_OpInfo_Op { pub fClientID : :: std :: os :: raw :: c_int , pub fBounds : SkRect , } # [ test ] fn bindgen_test_layout_GrAuditTrail_OpInfo_Op ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrAuditTrail_OpInfo_Op > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( GrAuditTrail_OpInfo_Op ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrAuditTrail_OpInfo_Op > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( GrAuditTrail_OpInfo_Op ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_OpInfo_Op > ( ) ) ) . fClientID as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_OpInfo_Op ) , "::" , stringify ! ( fClientID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_OpInfo_Op > ( ) ) ) . fBounds as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_OpInfo_Op ) , "::" , stringify ! ( fBounds ) ) ) ; } # [ test ] fn bindgen_test_layout_GrAuditTrail_OpInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrAuditTrail_OpInfo > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( GrAuditTrail_OpInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrAuditTrail_OpInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrAuditTrail_OpInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_OpInfo > ( ) ) ) . fBounds as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_OpInfo ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_OpInfo > ( ) ) ) . fProxyUniqueID as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_OpInfo ) , "::" , stringify ! ( fProxyUniqueID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_OpInfo > ( ) ) ) . fOps as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_OpInfo ) , "::" , stringify ! ( fOps ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrAuditTrail_Op { pub fName : SkString , pub fStackTrace : [ u64 ; 3usize ] , pub fBounds : SkRect , pub fClientID : :: std :: os :: raw :: c_int , pub fOpListID : :: std :: os :: raw :: c_int , pub fChildID : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_GrAuditTrail_Op ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrAuditTrail_Op > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( GrAuditTrail_Op ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrAuditTrail_Op > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrAuditTrail_Op ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_Op > ( ) ) ) . fName as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_Op ) , "::" , stringify ! ( fName ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_Op > ( ) ) ) . fStackTrace as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_Op ) , "::" , stringify ! ( fStackTrace ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_Op > ( ) ) ) . fBounds as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_Op ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_Op > ( ) ) ) . fClientID as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_Op ) , "::" , stringify ! ( fClientID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_Op > ( ) ) ) . fOpListID as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_Op ) , "::" , stringify ! ( fOpListID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_Op > ( ) ) ) . fChildID as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_Op ) , "::" , stringify ! ( fChildID ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrAuditTrail2Op6toJsonER12SkJSONWriter" ] pub fn GrAuditTrail_Op_toJson ( this : * const GrAuditTrail_Op , writer : * mut SkJSONWriter ) ; } impl GrAuditTrail_Op { # [ inline ] pub unsafe fn toJson ( & self , writer : * mut SkJSONWriter ) { GrAuditTrail_Op_toJson ( self , writer ) } } pub type GrAuditTrail_OpPool = [ u64 ; 3usize ] ; pub type GrAuditTrail_Ops = [ u64 ; 3usize ] ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrAuditTrail_OpNode { pub fBounds : SkRect , pub fChildren : GrAuditTrail_Ops , pub fProxyUniqueID : GrSurfaceProxy_UniqueID , } # [ test ] fn bindgen_test_layout_GrAuditTrail_OpNode ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrAuditTrail_OpNode > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( GrAuditTrail_OpNode ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrAuditTrail_OpNode > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrAuditTrail_OpNode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_OpNode > ( ) ) ) . fBounds as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_OpNode ) , "::" , stringify ! ( fBounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_OpNode > ( ) ) ) . fChildren as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_OpNode ) , "::" , stringify ! ( fChildren ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail_OpNode > ( ) ) ) . fProxyUniqueID as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail_OpNode ) , "::" , stringify ! ( fProxyUniqueID ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrAuditTrail6OpNode6toJsonER12SkJSONWriter" ] pub fn GrAuditTrail_OpNode_toJson ( this : * const GrAuditTrail_OpNode , writer : * mut SkJSONWriter ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail6OpNodeC1ERKN14GrSurfaceProxy8UniqueIDE" ] pub fn GrAuditTrail_OpNode_OpNode ( this : * mut GrAuditTrail_OpNode , proxyID : * const GrSurfaceProxy_UniqueID ) ; } impl GrAuditTrail_OpNode { # [ inline ] pub unsafe fn toJson ( & self , writer : * mut SkJSONWriter ) { GrAuditTrail_OpNode_toJson ( self , writer ) } # [ inline ] pub unsafe fn new ( proxyID : * const GrSurfaceProxy_UniqueID ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrAuditTrail_OpNode_OpNode ( & mut __bindgen_tmp , proxyID ) ; __bindgen_tmp } } pub type GrAuditTrail_OpList = [ u64 ; 3usize ] ; extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail22kGrAuditTrailInvalidIDE" ] pub static GrAuditTrail_kGrAuditTrailInvalidID : :: std :: os :: raw :: c_int ; } # [ test ] fn bindgen_test_layout_GrAuditTrail ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrAuditTrail > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( GrAuditTrail ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrAuditTrail > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrAuditTrail ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail > ( ) ) ) . fOpPool as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail ) , "::" , stringify ! ( fOpPool ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail > ( ) ) ) . fIDLookup as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail ) , "::" , stringify ! ( fIDLookup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail > ( ) ) ) . fClientIDLookup as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail ) , "::" , stringify ! ( fClientIDLookup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail > ( ) ) ) . fOpList as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail ) , "::" , stringify ! ( fOpList ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail > ( ) ) ) . fCurrentStackTrace as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail ) , "::" , stringify ! ( fCurrentStackTrace ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail > ( ) ) ) . fClientID as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail ) , "::" , stringify ! ( fClientID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrAuditTrail > ( ) ) ) . fEnabled as * const _ as usize } , 124usize , concat ! ( "Offset of field: " , stringify ! ( GrAuditTrail ) , "::" , stringify ! ( fEnabled ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail9pushFrameEPKc" ] pub fn GrAuditTrail_pushFrame ( this : * mut GrAuditTrail , framename : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail5addOpEPK4GrOpN14GrSurfaceProxy8UniqueIDE" ] pub fn GrAuditTrail_addOp ( this : * mut GrAuditTrail , arg1 : * const GrOp , proxyID : GrSurfaceProxy_UniqueID ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail11opsCombinedEPK4GrOpS2_" ] pub fn GrAuditTrail_opsCombined ( this : * mut GrAuditTrail , consumer : * const GrOp , consumed : * const GrOp ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrAuditTrail6toJsonER12SkJSONWriter" ] pub fn GrAuditTrail_toJson ( this : * const GrAuditTrail , writer : * mut SkJSONWriter ) ; } extern "C" { # [ link_name = "\u{1}__ZNK12GrAuditTrail6toJsonER12SkJSONWriteri" ] pub fn GrAuditTrail_toJson1 ( this : * const GrAuditTrail , writer : * mut SkJSONWriter , clientID : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail9isEnabledEv" ] pub fn GrAuditTrail_isEnabled ( this : * mut GrAuditTrail ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail10setEnabledEb" ] pub fn GrAuditTrail_setEnabled ( this : * mut GrAuditTrail , enabled : bool ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail11setClientIDEi" ] pub fn GrAuditTrail_setClientID ( this : * mut GrAuditTrail , clientID : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail19getBoundsByClientIDEP8SkTArrayINS_6OpInfoELb0EEi" ] pub fn GrAuditTrail_getBoundsByClientID ( this : * mut GrAuditTrail , outInfo : * mut u8 , clientID : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail19getBoundsByOpListIDEPNS_6OpInfoEi" ] pub fn GrAuditTrail_getBoundsByOpListID ( this : * mut GrAuditTrail , outInfo : * mut GrAuditTrail_OpInfo , opListID : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrail9fullResetEv" ] pub fn GrAuditTrail_fullReset ( this : * mut GrAuditTrail ) ; } extern "C" { # [ link_name = "\u{1}__ZN12GrAuditTrailC1Ev" ] pub fn GrAuditTrail_GrAuditTrail ( this : * mut GrAuditTrail ) ; } impl GrAuditTrail { # [ inline ] pub unsafe fn pushFrame ( & mut self , framename : * const :: std :: os :: raw :: c_char ) { GrAuditTrail_pushFrame ( self , framename ) } # [ inline ] pub unsafe fn addOp ( & mut self , arg1 : * const GrOp , proxyID : GrSurfaceProxy_UniqueID ) { GrAuditTrail_addOp ( self , arg1 , proxyID ) } # [ inline ] pub unsafe fn opsCombined ( & mut self , consumer : * const GrOp , consumed : * const GrOp ) { GrAuditTrail_opsCombined ( self , consumer , consumed ) } # [ inline ] pub unsafe fn toJson ( & self , writer : * mut SkJSONWriter ) { GrAuditTrail_toJson ( self , writer ) } # [ inline ] pub unsafe fn toJson1 ( & self , writer : * mut SkJSONWriter , clientID : :: std :: os :: raw :: c_int ) { GrAuditTrail_toJson1 ( self , writer , clientID ) } # [ inline ] pub unsafe fn isEnabled ( & mut self ) -> bool { GrAuditTrail_isEnabled ( self ) } # [ inline ] pub unsafe fn setEnabled ( & mut self , enabled : bool ) { GrAuditTrail_setEnabled ( self , enabled ) } # [ inline ] pub unsafe fn setClientID ( & mut self , clientID : :: std :: os :: raw :: c_int ) { GrAuditTrail_setClientID ( self , clientID ) } # [ inline ] pub unsafe fn getBoundsByClientID ( & mut self , outInfo : * mut u8 , clientID : :: std :: os :: raw :: c_int ) { GrAuditTrail_getBoundsByClientID ( self , outInfo , clientID ) } # [ inline ] pub unsafe fn getBoundsByOpListID ( & mut self , outInfo : * mut GrAuditTrail_OpInfo , opListID : :: std :: os :: raw :: c_int ) { GrAuditTrail_getBoundsByOpListID ( self , outInfo , opListID ) } # [ inline ] pub unsafe fn fullReset ( & mut self ) { GrAuditTrail_fullReset ( self ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrAuditTrail_GrAuditTrail ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrDriverBugWorkarounds { pub add_and_true_to_loop_condition : bool , pub disable_blend_equation_advanced : bool , pub disable_discard_framebuffer : bool , pub disable_texture_storage : bool , pub disallow_large_instanced_draw : bool , pub emulate_abs_int_function : bool , pub flush_on_framebuffer_change : bool , pub gl_clear_broken : bool , pub max_fragment_uniform_vectors_32 : bool , pub max_msaa_sample_count_4 : bool , pub max_texture_size_limit_4096 : bool , pub pack_parameters_workaround_with_pack_buffer : bool , pub remove_pow_with_constant_exponent : bool , pub restore_scissor_on_fbo_change : bool , pub rewrite_do_while_loops : bool , pub unbind_attachments_on_bound_render_fbo_delete : bool , pub unfold_short_circuit_as_ternary_operation : bool , } # [ test ] fn bindgen_test_layout_GrDriverBugWorkarounds ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrDriverBugWorkarounds > ( ) , 17usize , concat ! ( "Size of: " , stringify ! ( GrDriverBugWorkarounds ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrDriverBugWorkarounds > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( GrDriverBugWorkarounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . add_and_true_to_loop_condition as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( add_and_true_to_loop_condition ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . disable_blend_equation_advanced as * const _ as usize } , 1usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( disable_blend_equation_advanced ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . disable_discard_framebuffer as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( disable_discard_framebuffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . disable_texture_storage as * const _ as usize } , 3usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( disable_texture_storage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . disallow_large_instanced_draw as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( disallow_large_instanced_draw ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . emulate_abs_int_function as * const _ as usize } , 5usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( emulate_abs_int_function ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . flush_on_framebuffer_change as * const _ as usize } , 6usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( flush_on_framebuffer_change ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . gl_clear_broken as * const _ as usize } , 7usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( gl_clear_broken ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . max_fragment_uniform_vectors_32 as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( max_fragment_uniform_vectors_32 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . max_msaa_sample_count_4 as * const _ as usize } , 9usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( max_msaa_sample_count_4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . max_texture_size_limit_4096 as * const _ as usize } , 10usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( max_texture_size_limit_4096 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . pack_parameters_workaround_with_pack_buffer as * const _ as usize } , 11usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( pack_parameters_workaround_with_pack_buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . remove_pow_with_constant_exponent as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( remove_pow_with_constant_exponent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . restore_scissor_on_fbo_change as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( restore_scissor_on_fbo_change ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . rewrite_do_while_loops as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( rewrite_do_while_loops ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . unbind_attachments_on_bound_render_fbo_delete as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( unbind_attachments_on_bound_render_fbo_delete ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrDriverBugWorkarounds > ( ) ) ) . unfold_short_circuit_as_ternary_operation as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrDriverBugWorkarounds ) , "::" , stringify ! ( unfold_short_circuit_as_ternary_operation ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN22GrDriverBugWorkarounds14applyOverridesERKS_" ] pub fn GrDriverBugWorkarounds_applyOverrides ( this : * mut GrDriverBugWorkarounds , workarounds : * const GrDriverBugWorkarounds ) ; } extern "C" { # [ link_name = "\u{1}__ZN22GrDriverBugWorkaroundsC1Ev" ] pub fn GrDriverBugWorkarounds_GrDriverBugWorkarounds ( this : * mut GrDriverBugWorkarounds ) ; } extern "C" { # [ link_name = "\u{1}__ZN22GrDriverBugWorkaroundsC1ERKNSt3__16vectorIiNS0_9allocatorIiEEEE" ] pub fn GrDriverBugWorkarounds_GrDriverBugWorkarounds1 ( this : * mut GrDriverBugWorkarounds , workarounds : * const std_vector ) ; } extern "C" { # [ link_name = "\u{1}__ZN22GrDriverBugWorkaroundsD1Ev" ] pub fn GrDriverBugWorkarounds_GrDriverBugWorkarounds_destructor ( this : * mut GrDriverBugWorkarounds ) ; } impl GrDriverBugWorkarounds { # [ inline ] pub unsafe fn applyOverrides ( & mut self , workarounds : * const GrDriverBugWorkarounds ) { GrDriverBugWorkarounds_applyOverrides ( self , workarounds ) } # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrDriverBugWorkarounds_GrDriverBugWorkarounds ( & mut __bindgen_tmp ) ; __bindgen_tmp } # [ inline ] pub unsafe fn new1 ( workarounds : * const std_vector ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrDriverBugWorkarounds_GrDriverBugWorkarounds1 ( & mut __bindgen_tmp , workarounds ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { GrDriverBugWorkarounds_GrDriverBugWorkarounds_destructor ( self ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkExecutor { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrContextOptions { pub fSuppressPrints : bool , # [ doc = " Overrides: These options override feature detection using backend API queries. These" ] # [ doc = "overrides can only reduce the feature set or limits, never increase them beyond the" ] # [ doc = "detected values." ] pub fMaxTextureSizeOverride : :: std :: os :: raw :: c_int , # [ doc = " the threshold in bytes above which we will use a buffer mapping API to map vertex and index" ] # [ doc = "buffers to CPU memory in order to update them.  A value of -1 means the GrContext should" ] # [ doc = "deduce the optimal value for this platform." ] pub fBufferMapThreshold : :: std :: os :: raw :: c_int , # [ doc = " Executor to handle threaded work within Ganesh. If this is nullptr, then all work will be" ] # [ doc = " done serially on the main thread. To have worker threads assist with various tasks, set this" ] # [ doc = " to a valid SkExecutor instance. Currently, used for software path rendering, but may be used" ] # [ doc = " for other tasks." ] pub fExecutor : * mut SkExecutor , # [ doc = " Construct mipmaps manually, via repeated downsampling draw-calls. This is used when" ] # [ doc = "the driver\'s implementation (glGenerateMipmap) contains bugs. This requires mipmap" ] # [ doc = "level and LOD control (ie desktop or ES3)." ] pub fDoManualMipmapping : bool , # [ doc = " Disables the coverage counting path renderer. Coverage counting can sometimes cause new" ] # [ doc = " rendering artifacts along shared edges if care isn\'t taken to ensure both contours wind in" ] # [ doc = " the same direction." ] pub fDisableCoverageCountingPaths : bool , # [ doc = " Disables distance field rendering for paths. Distance field computation can be expensive," ] # [ doc = " and yields no benefit if a path is not rendered multiple times with different transforms." ] pub fDisableDistanceFieldPaths : bool , # [ doc = " If true this allows path mask textures to be cached. This is only really useful if paths" ] # [ doc = " are commonly rendered at the same scale and fractional translation." ] pub fAllowPathMaskCaching : bool , # [ doc = " If true, the GPU will not be used to perform YUV -> RGB conversion when generating" ] # [ doc = " textures from codec-backed images." ] pub fDisableGpuYUVConversion : bool , # [ doc = " The maximum size of cache textures used for Skia\'s Glyph cache." ] pub fGlyphCacheTextureMaximumBytes : usize , # [ doc = " Below this threshold size in device space distance field fonts won\'t be used. Distance field" ] # [ doc = " fonts don\'t support hinting which is more important at smaller sizes. A negative value means" ] # [ doc = " use the default threshold." ] pub fMinDistanceFieldFontSize : f32 , # [ doc = " Above this threshold size in device space glyphs are drawn as individual paths. A negative" ] # [ doc = " value means use the default threshold." ] pub fGlyphsAsPathsFontSize : f32 , # [ doc = " Can the glyph atlas use multiple textures. If allowed, the each texture\'s size is bound by" ] # [ doc = " fGlypheCacheTextureMaximumBytes." ] pub fAllowMultipleGlyphCacheTextures : GrContextOptions_Enable , # [ doc = " Bugs on certain drivers cause stencil buffers to leak. This flag causes Skia to avoid" ] # [ doc = " allocating stencil buffers and use alternate rasterization paths, avoiding the leak." ] pub fAvoidStencilBuffers : bool , # [ doc = " If true, texture fetches from mip-mapped textures will be biased to read larger MIP levels." ] # [ doc = " This has the effect of sharpening those textures, at the cost of some aliasing, and possible" ] # [ doc = " performance impact." ] pub fSharpenMipmappedTextures : bool , # [ doc = " Enables driver workaround to use draws instead of HW clears, e.g. glClear on the GL backend." ] pub fUseDrawInsteadOfClear : GrContextOptions_Enable , # [ doc = " Allow Ganesh to explicitly allocate resources at flush time rather than incrementally while" ] # [ doc = " drawing. This will eventually just be the way it is but, for now, it is optional." ] pub fExplicitlyAllocateGPUResources : GrContextOptions_Enable , # [ doc = " Allow Ganesh to sort the opLists prior to allocating resources. This is an optional" ] # [ doc = " behavior that is only relevant when \'fExplicitlyAllocateGPUResources\' is enabled." ] # [ doc = " Eventually this will just be what is done and will not be optional." ] pub fSortRenderTargets : GrContextOptions_Enable , # [ doc = " Allow Ganesh to more aggressively reorder operations. This is an optional" ] # [ doc = " behavior that is only relevant when \'fSortRenderTargets\' is enabled." ] # [ doc = " Eventually this will just be what is done and will not be optional." ] pub fReduceOpListSplitting : GrContextOptions_Enable , # [ doc = " Some ES3 contexts report the ES2 external image extension, but not the ES3 version." ] # [ doc = " If support for external images is critical, enabling this option will cause Ganesh to limit" ] # [ doc = " shaders to the ES2 shading language in that situation." ] pub fPreferExternalImagesOverES3 : bool , # [ doc = " Disables correctness workarounds that are enabled for particular GPUs, OSes, or drivers." ] # [ doc = " This does not affect code path choices that are made for perfomance reasons nor does it" ] # [ doc = " override other GrContextOption settings." ] pub fDisableDriverCorrectnessWorkarounds : bool , # [ doc = " Cache in which to store compiled shader binaries between runs." ] pub fPersistentCache : * mut GrContextOptions_PersistentCache , # [ doc = " This affects the usage of the PersistentCache. If this is set to true GLSL shader strings" ] # [ doc = " rather than GL program binaries will be cached. It is intended to be used when the driver\'s" ] # [ doc = " binary loading/storing is believed to have bugs. Caching GLSL strings still saves a" ] # [ doc = " significant amount of CPU work when a GL program is created." ] pub fDisallowGLSLBinaryCaching : bool , pub fDriverBugWorkarounds : GrDriverBugWorkarounds , } # [ doc = " Forces an option to be disabled." ] pub const GrContextOptions_Enable_kNo : GrContextOptions_Enable = 0 ; # [ doc = " Forces an option to be enabled." ] pub const GrContextOptions_Enable_kYes : GrContextOptions_Enable = 1 ; # [ doc = " Uses Skia\'s default behavior, which may use runtime properties (e.g. driver version)." ] pub const GrContextOptions_Enable_kDefault : GrContextOptions_Enable = 2 ; pub type GrContextOptions_Enable = i32 ; # [ repr ( C ) ] pub struct GrContextOptions_PersistentCache__bindgen_vtable ( :: std :: os :: raw :: c_void ) ; # [ doc = " Abstract class which stores Skia data in a cache that persists between sessions. Currently," ] # [ doc = " Skia stores compiled shader binaries (only when glProgramBinary / glGetProgramBinary are" ] # [ doc = " supported) when provided a persistent cache, but this may extend to other data in the future." ] # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrContextOptions_PersistentCache { pub vtable_ : * const GrContextOptions_PersistentCache__bindgen_vtable , } # [ test ] fn bindgen_test_layout_GrContextOptions_PersistentCache ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrContextOptions_PersistentCache > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrContextOptions_PersistentCache ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrContextOptions_PersistentCache > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrContextOptions_PersistentCache ) ) ) ; } # [ test ] fn bindgen_test_layout_GrContextOptions ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrContextOptions > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( GrContextOptions ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrContextOptions > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrContextOptions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fSuppressPrints as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fSuppressPrints ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fMaxTextureSizeOverride as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fMaxTextureSizeOverride ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fBufferMapThreshold as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fBufferMapThreshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fExecutor as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fExecutor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fDoManualMipmapping as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fDoManualMipmapping ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fDisableCoverageCountingPaths as * const _ as usize } , 25usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fDisableCoverageCountingPaths ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fDisableDistanceFieldPaths as * const _ as usize } , 26usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fDisableDistanceFieldPaths ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fAllowPathMaskCaching as * const _ as usize } , 27usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fAllowPathMaskCaching ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fDisableGpuYUVConversion as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fDisableGpuYUVConversion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fGlyphCacheTextureMaximumBytes as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fGlyphCacheTextureMaximumBytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fMinDistanceFieldFontSize as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fMinDistanceFieldFontSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fGlyphsAsPathsFontSize as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fGlyphsAsPathsFontSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fAllowMultipleGlyphCacheTextures as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fAllowMultipleGlyphCacheTextures ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fAvoidStencilBuffers as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fAvoidStencilBuffers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fSharpenMipmappedTextures as * const _ as usize } , 53usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fSharpenMipmappedTextures ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fUseDrawInsteadOfClear as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fUseDrawInsteadOfClear ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fExplicitlyAllocateGPUResources as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fExplicitlyAllocateGPUResources ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fSortRenderTargets as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fSortRenderTargets ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fReduceOpListSplitting as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fReduceOpListSplitting ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fPreferExternalImagesOverES3 as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fPreferExternalImagesOverES3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fDisableDriverCorrectnessWorkarounds as * const _ as usize } , 73usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fDisableDriverCorrectnessWorkarounds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fPersistentCache as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fPersistentCache ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fDisallowGLSLBinaryCaching as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fDisallowGLSLBinaryCaching ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContextOptions > ( ) ) ) . fDriverBugWorkarounds as * const _ as usize } , 89usize , concat ! ( "Offset of field: " , stringify ! ( GrContextOptions ) , "::" , stringify ! ( fDriverBugWorkarounds ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN16GrContextOptionsC1Ev" ] pub fn GrContextOptions_GrContextOptions ( this : * mut GrContextOptions ) ; } impl GrContextOptions { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrContextOptions_GrContextOptions ( & mut __bindgen_tmp ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN16GrContextOptions15PersistentCacheD1Ev" ] pub fn GrContextOptions_PersistentCache_PersistentCache_destructor ( this : * mut GrContextOptions_PersistentCache ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrBaseContextPriv { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrSkSLFPFactoryCache { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrContext_Base { pub _base : SkRefCnt , pub fBackend : GrBackendApi , pub fOptions : GrContextOptions , pub fContextID : u32 , pub fCaps : sk_sp < GrCaps > , pub fFPFactoryCache : sk_sp < GrSkSLFPFactoryCache > , } pub type GrContext_Base_INHERITED = SkRefCnt ; # [ test ] fn bindgen_test_layout_GrContext_Base ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrContext_Base > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( GrContext_Base ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrContext_Base > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrContext_Base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext_Base > ( ) ) ) . fBackend as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( GrContext_Base ) , "::" , stringify ! ( fBackend ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext_Base > ( ) ) ) . fOptions as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( GrContext_Base ) , "::" , stringify ! ( fOptions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext_Base > ( ) ) ) . fContextID as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( GrContext_Base ) , "::" , stringify ! ( fContextID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext_Base > ( ) ) ) . fCaps as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( GrContext_Base ) , "::" , stringify ! ( fCaps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext_Base > ( ) ) ) . fFPFactoryCache as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( GrContext_Base ) , "::" , stringify ! ( fFPFactoryCache ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrContext_Base7backendEv" ] pub fn GrContext_Base_backend ( this : * const GrContext_Base ) -> GrBackendApi ; } extern "C" { # [ link_name = "\u{1}__ZN14GrContext_Base4privEv" ] pub fn GrContext_Base_priv ( this : * mut GrContext_Base ) -> GrBaseContextPriv ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrContext_Base4privEv" ] pub fn GrContext_Base_priv1 ( this : * const GrContext_Base ) -> GrBaseContextPriv ; } extern "C" { # [ doc = " An identifier for this context. The id is used by all compatible contexts. For example," ] # [ doc = " if SkImages are created on one thread using an image creation context, then fed into a" ] # [ doc = " DDL Recorder on second thread (which has a recording context) and finally replayed on" ] # [ doc = " a third thread with a direct context, then all three contexts will report the same id." ] # [ doc = " It is an error for an image to be used with contexts that report different ids." ] # [ link_name = "\u{1}__ZNK14GrContext_Base9contextIDEv" ] pub fn GrContext_Base_contextID ( this : * const GrContext_Base ) -> u32 ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrContext_Base7matchesEPS_" ] pub fn GrContext_Base_matches ( this : * const GrContext_Base , candidate : * mut GrContext_Base ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrContext_Base7optionsEv" ] pub fn GrContext_Base_options ( this : * const GrContext_Base ) -> * const GrContextOptions ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrContext_Base30explicitlyAllocateGPUResourcesEv" ] pub fn GrContext_Base_explicitlyAllocateGPUResources ( this : * const GrContext_Base ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrContext_Base4capsEv" ] pub fn GrContext_Base_caps ( this : * const GrContext_Base ) -> * const GrCaps ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrContext_Base7refCapsEv" ] pub fn GrContext_Base_refCaps ( this : * const GrContext_Base ) -> sk_sp < GrCaps > ; } extern "C" { # [ link_name = "\u{1}__ZN14GrContext_Base14fpFactoryCacheEv" ] pub fn GrContext_Base_fpFactoryCache ( this : * mut GrContext_Base ) -> sk_sp < GrSkSLFPFactoryCache > ; } extern "C" { # [ link_name = "\u{1}__ZN14GrContext_BaseC1E12GrBackendApiRK16GrContextOptionsj" ] pub fn GrContext_Base_GrContext_Base ( this : * mut GrContext_Base , backend : GrBackendApi , options : * const GrContextOptions , contextID : u32 ) ; } impl GrContext_Base { # [ inline ] pub unsafe fn backend ( & self ) -> GrBackendApi { GrContext_Base_backend ( self ) } # [ inline ] pub unsafe fn priv_ ( & mut self ) -> GrBaseContextPriv { GrContext_Base_priv ( self ) } # [ inline ] pub unsafe fn priv1 ( & self ) -> GrBaseContextPriv { GrContext_Base_priv1 ( self ) } # [ inline ] pub unsafe fn contextID ( & self ) -> u32 { GrContext_Base_contextID ( self ) } # [ inline ] pub unsafe fn matches ( & self , candidate : * mut GrContext_Base ) -> bool { GrContext_Base_matches ( self , candidate ) } # [ inline ] pub unsafe fn options ( & self ) -> * const GrContextOptions { GrContext_Base_options ( self ) } # [ inline ] pub unsafe fn explicitlyAllocateGPUResources ( & self ) -> bool { GrContext_Base_explicitlyAllocateGPUResources ( self ) } # [ inline ] pub unsafe fn caps ( & self ) -> * const GrCaps { GrContext_Base_caps ( self ) } # [ inline ] pub unsafe fn refCaps ( & self ) -> sk_sp < GrCaps > { GrContext_Base_refCaps ( self ) } # [ inline ] pub unsafe fn fpFactoryCache ( & mut self ) -> sk_sp < GrSkSLFPFactoryCache > { GrContext_Base_fpFactoryCache ( self ) } # [ inline ] pub unsafe fn new ( backend : GrBackendApi , options : * const GrContextOptions , contextID : u32 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrContext_Base_GrContext_Base ( & mut __bindgen_tmp , backend , options , contextID ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN14GrContext_BaseD1Ev" ] pub fn GrContext_Base_GrContext_Base_destructor ( this : * mut GrContext_Base ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrContext_Base4initE5sk_spIK6GrCapsES0_I20GrSkSLFPFactoryCacheE" ] pub fn GrContext_Base_init ( this : * mut :: std :: os :: raw :: c_void , arg1 : sk_sp < GrCaps > , arg2 : sk_sp < GrSkSLFPFactoryCache > ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN14GrContext_Base14asImageContextEv" ] pub fn GrContext_Base_asImageContext ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrImageContext ; } extern "C" { # [ link_name = "\u{1}__ZN14GrContext_Base18asRecordingContextEv" ] pub fn GrContext_Base_asRecordingContext ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrRecordingContext ; } extern "C" { # [ link_name = "\u{1}__ZN14GrContext_Base15asDirectContextEv" ] pub fn GrContext_Base_asDirectContext ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrContext ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrSingleOwner { pub fMutex : SkMutex , pub fOwner : SkThreadID , pub fReentranceCount : :: std :: os :: raw :: c_int , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrSingleOwner_AutoEnforce { pub fSO : * mut GrSingleOwner , } # [ test ] fn bindgen_test_layout_GrSingleOwner_AutoEnforce ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrSingleOwner_AutoEnforce > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( GrSingleOwner_AutoEnforce ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrSingleOwner_AutoEnforce > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrSingleOwner_AutoEnforce ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSingleOwner_AutoEnforce > ( ) ) ) . fSO as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrSingleOwner_AutoEnforce ) , "::" , stringify ! ( fSO ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrSingleOwner11AutoEnforceC1EPS_" ] pub fn GrSingleOwner_AutoEnforce_AutoEnforce ( this : * mut GrSingleOwner_AutoEnforce , so : * mut GrSingleOwner ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrSingleOwner11AutoEnforceD1Ev" ] pub fn GrSingleOwner_AutoEnforce_AutoEnforce_destructor ( this : * mut GrSingleOwner_AutoEnforce ) ; } impl GrSingleOwner_AutoEnforce { # [ inline ] pub unsafe fn new ( so : * mut GrSingleOwner ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSingleOwner_AutoEnforce_AutoEnforce ( & mut __bindgen_tmp , so ) ; __bindgen_tmp } # [ inline ] pub unsafe fn destruct ( & mut self ) { GrSingleOwner_AutoEnforce_AutoEnforce_destructor ( self ) } } # [ test ] fn bindgen_test_layout_GrSingleOwner ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrSingleOwner > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( GrSingleOwner ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrSingleOwner > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrSingleOwner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSingleOwner > ( ) ) ) . fMutex as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( GrSingleOwner ) , "::" , stringify ! ( fMutex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSingleOwner > ( ) ) ) . fOwner as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( GrSingleOwner ) , "::" , stringify ! ( fOwner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrSingleOwner > ( ) ) ) . fReentranceCount as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( GrSingleOwner ) , "::" , stringify ! ( fReentranceCount ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN13GrSingleOwnerC1Ev" ] pub fn GrSingleOwner_GrSingleOwner ( this : * mut GrSingleOwner ) ; } impl GrSingleOwner { # [ inline ] pub unsafe fn new ( ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrSingleOwner_GrSingleOwner ( & mut __bindgen_tmp ) ; __bindgen_tmp } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrImageContextPriv { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrImageContext { pub _base : GrContext_Base , pub fProxyProvider : std_unique_ptr , pub fAbandoned : bool , pub fSingleOwner : GrSingleOwner , } pub type GrImageContext_INHERITED = GrContext_Base ; # [ test ] fn bindgen_test_layout_GrImageContext ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrImageContext > ( ) , 208usize , concat ! ( "Size of: " , stringify ! ( GrImageContext ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrImageContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrImageContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrImageContext > ( ) ) ) . fProxyProvider as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( GrImageContext ) , "::" , stringify ! ( fProxyProvider ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrImageContext > ( ) ) ) . fAbandoned as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( GrImageContext ) , "::" , stringify ! ( fAbandoned ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrImageContext > ( ) ) ) . fSingleOwner as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( GrImageContext ) , "::" , stringify ! ( fSingleOwner ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrImageContext4privEv" ] pub fn GrImageContext_priv ( this : * mut GrImageContext ) -> GrImageContextPriv ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrImageContext4privEv" ] pub fn GrImageContext_priv1 ( this : * const GrImageContext ) -> GrImageContextPriv ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrImageContext9abandonedEv" ] pub fn GrImageContext_abandoned ( this : * const GrImageContext ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN14GrImageContext13proxyProviderEv" ] pub fn GrImageContext_proxyProvider ( this : * mut GrImageContext ) -> * mut GrProxyProvider ; } extern "C" { # [ link_name = "\u{1}__ZNK14GrImageContext13proxyProviderEv" ] pub fn GrImageContext_proxyProvider1 ( this : * const GrImageContext ) -> * const GrProxyProvider ; } extern "C" { # [ doc = " This is only useful for debug purposes" ] # [ link_name = "\u{1}__ZNK14GrImageContext11singleOwnerEv" ] pub fn GrImageContext_singleOwner ( this : * const GrImageContext ) -> * mut GrSingleOwner ; } extern "C" { # [ link_name = "\u{1}__ZN14GrImageContextC1E12GrBackendApiRK16GrContextOptionsj" ] pub fn GrImageContext_GrImageContext ( this : * mut GrImageContext , arg1 : GrBackendApi , arg2 : * const GrContextOptions , contextID : u32 ) ; } impl GrImageContext { # [ inline ] pub unsafe fn priv_ ( & mut self ) -> GrImageContextPriv { GrImageContext_priv ( self ) } # [ inline ] pub unsafe fn priv1 ( & self ) -> GrImageContextPriv { GrImageContext_priv1 ( self ) } # [ inline ] pub unsafe fn abandoned ( & self ) -> bool { GrImageContext_abandoned ( self ) } # [ inline ] pub unsafe fn proxyProvider ( & mut self ) -> * mut GrProxyProvider { GrImageContext_proxyProvider ( self ) } # [ inline ] pub unsafe fn proxyProvider1 ( & self ) -> * const GrProxyProvider { GrImageContext_proxyProvider1 ( self ) } # [ inline ] pub unsafe fn singleOwner ( & self ) -> * mut GrSingleOwner { GrImageContext_singleOwner ( self ) } # [ inline ] pub unsafe fn new ( arg1 : GrBackendApi , arg2 : * const GrContextOptions , contextID : u32 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrImageContext_GrImageContext ( & mut __bindgen_tmp , arg1 , arg2 , contextID ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN14GrImageContextD1Ev" ] pub fn GrImageContext_GrImageContext_destructor ( this : * mut GrImageContext ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrImageContext14abandonContextEv" ] pub fn GrImageContext_abandonContext ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}__ZN14GrImageContext14asImageContextEv" ] pub fn GrImageContext_asImageContext ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrImageContext ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrDrawingManager { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrOnFlushCallbackObject { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrOpMemoryPool { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrRecordingContextPriv { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrStrikeCache { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrTextBlobCache { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrRecordingContext { pub _base : GrImageContext , pub fDrawingManager : std_unique_ptr , pub fOpMemoryPool : sk_sp < GrOpMemoryPool > , pub fGlyphCache : std_unique_ptr , pub fTextBlobCache : std_unique_ptr , pub fAuditTrail : GrAuditTrail , } pub type GrRecordingContext_INHERITED = GrImageContext ; # [ test ] fn bindgen_test_layout_GrRecordingContext ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrRecordingContext > ( ) , 368usize , concat ! ( "Size of: " , stringify ! ( GrRecordingContext ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrRecordingContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrRecordingContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrRecordingContext > ( ) ) ) . fDrawingManager as * const _ as usize } , 208usize , concat ! ( "Offset of field: " , stringify ! ( GrRecordingContext ) , "::" , stringify ! ( fDrawingManager ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrRecordingContext > ( ) ) ) . fOpMemoryPool as * const _ as usize } , 216usize , concat ! ( "Offset of field: " , stringify ! ( GrRecordingContext ) , "::" , stringify ! ( fOpMemoryPool ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrRecordingContext > ( ) ) ) . fGlyphCache as * const _ as usize } , 224usize , concat ! ( "Offset of field: " , stringify ! ( GrRecordingContext ) , "::" , stringify ! ( fGlyphCache ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrRecordingContext > ( ) ) ) . fTextBlobCache as * const _ as usize } , 232usize , concat ! ( "Offset of field: " , stringify ! ( GrRecordingContext ) , "::" , stringify ! ( fTextBlobCache ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrRecordingContext > ( ) ) ) . fAuditTrail as * const _ as usize } , 240usize , concat ! ( "Offset of field: " , stringify ! ( GrRecordingContext ) , "::" , stringify ! ( fAuditTrail ) ) ) ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext4privEv" ] pub fn GrRecordingContext_priv ( this : * mut GrRecordingContext ) -> GrRecordingContextPriv ; } extern "C" { # [ link_name = "\u{1}__ZNK18GrRecordingContext4privEv" ] pub fn GrRecordingContext_priv1 ( this : * const GrRecordingContext ) -> GrRecordingContextPriv ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext14drawingManagerEv" ] pub fn GrRecordingContext_drawingManager ( this : * mut GrRecordingContext ) -> * mut GrDrawingManager ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext15refOpMemoryPoolEv" ] pub fn GrRecordingContext_refOpMemoryPool ( this : * mut GrRecordingContext ) -> sk_sp < GrOpMemoryPool > ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext12opMemoryPoolEv" ] pub fn GrRecordingContext_opMemoryPool ( this : * mut GrRecordingContext ) -> * mut GrOpMemoryPool ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext13getGlyphCacheEv" ] pub fn GrRecordingContext_getGlyphCache ( this : * mut GrRecordingContext ) -> * mut GrStrikeCache ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext16getTextBlobCacheEv" ] pub fn GrRecordingContext_getTextBlobCache ( this : * mut GrRecordingContext ) -> * mut GrTextBlobCache ; } extern "C" { # [ link_name = "\u{1}__ZNK18GrRecordingContext16getTextBlobCacheEv" ] pub fn GrRecordingContext_getTextBlobCache1 ( this : * const GrRecordingContext ) -> * const GrTextBlobCache ; } extern "C" { # [ doc = " Registers an object for flush-related callbacks. (See GrOnFlushCallbackObject.)" ] # [ doc = "" ] # [ doc = " NOTE: the drawing manager tracks this object as a raw pointer; it is up to the caller to" ] # [ doc = " ensure its lifetime is tied to that of the context." ] # [ link_name = "\u{1}__ZN18GrRecordingContext24addOnFlushCallbackObjectEP23GrOnFlushCallbackObject" ] pub fn GrRecordingContext_addOnFlushCallbackObject ( this : * mut GrRecordingContext , arg1 : * mut GrOnFlushCallbackObject ) ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext25makeWrappedSurfaceContextE5sk_spI14GrSurfaceProxyES0_I12SkColorSpaceEPK14SkSurfaceProps" ] pub fn GrRecordingContext_makeWrappedSurfaceContext ( this : * mut GrRecordingContext , arg1 : sk_sp < GrSurfaceProxy > , arg2 : sk_sp < SkColorSpace > , arg3 : * const SkSurfaceProps ) -> sk_sp < GrSurfaceContext > ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext26makeDeferredSurfaceContextERK15GrBackendFormatRK13GrSurfaceDesc15GrSurfaceOrigin11GrMipMapped12SkBackingFit10SkBudgeted5sk_spI12SkColorSpaceEPK14SkSurfaceProps" ] pub fn GrRecordingContext_makeDeferredSurfaceContext ( this : * mut GrRecordingContext , arg1 : * const GrBackendFormat , arg2 : * const GrSurfaceDesc , arg3 : GrSurfaceOrigin , arg4 : GrMipMapped , arg5 : SkBackingFit , arg6 : SkBudgeted , colorSpace : sk_sp < SkColorSpace > , arg7 : * const SkSurfaceProps ) -> sk_sp < GrSurfaceContext > ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext31makeDeferredRenderTargetContextERK15GrBackendFormat12SkBackingFitii13GrPixelConfig5sk_spI12SkColorSpaceEi11GrMipMapped15GrSurfaceOriginPK14SkSurfaceProps10SkBudgeted" ] pub fn GrRecordingContext_makeDeferredRenderTargetContext ( this : * mut GrRecordingContext , format : * const GrBackendFormat , fit : SkBackingFit , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , config : GrPixelConfig , colorSpace : sk_sp < SkColorSpace > , sampleCnt : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , origin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , arg2 : SkBudgeted ) -> sk_sp < GrRenderTargetContext > ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext43makeDeferredRenderTargetContextWithFallbackERK15GrBackendFormat12SkBackingFitii13GrPixelConfig5sk_spI12SkColorSpaceEi11GrMipMapped15GrSurfaceOriginPK14SkSurfaceProps10SkBudgeted" ] pub fn GrRecordingContext_makeDeferredRenderTargetContextWithFallback ( this : * mut GrRecordingContext , format : * const GrBackendFormat , fit : SkBackingFit , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , config : GrPixelConfig , colorSpace : sk_sp < SkColorSpace > , sampleCnt : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , origin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , budgeted : SkBudgeted ) -> sk_sp < GrRenderTargetContext > ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext10auditTrailEv" ] pub fn GrRecordingContext_auditTrail ( this : * mut GrRecordingContext ) -> * mut GrAuditTrail ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContextC1E12GrBackendApiRK16GrContextOptionsj" ] pub fn GrRecordingContext_GrRecordingContext ( this : * mut GrRecordingContext , arg1 : GrBackendApi , arg2 : * const GrContextOptions , contextID : u32 ) ; } impl GrRecordingContext { # [ inline ] pub unsafe fn priv_ ( & mut self ) -> GrRecordingContextPriv { GrRecordingContext_priv ( self ) } # [ inline ] pub unsafe fn priv1 ( & self ) -> GrRecordingContextPriv { GrRecordingContext_priv1 ( self ) } # [ inline ] pub unsafe fn drawingManager ( & mut self ) -> * mut GrDrawingManager { GrRecordingContext_drawingManager ( self ) } # [ inline ] pub unsafe fn refOpMemoryPool ( & mut self ) -> sk_sp < GrOpMemoryPool > { GrRecordingContext_refOpMemoryPool ( self ) } # [ inline ] pub unsafe fn opMemoryPool ( & mut self ) -> * mut GrOpMemoryPool { GrRecordingContext_opMemoryPool ( self ) } # [ inline ] pub unsafe fn getGlyphCache ( & mut self ) -> * mut GrStrikeCache { GrRecordingContext_getGlyphCache ( self ) } # [ inline ] pub unsafe fn getTextBlobCache ( & mut self ) -> * mut GrTextBlobCache { GrRecordingContext_getTextBlobCache ( self ) } # [ inline ] pub unsafe fn getTextBlobCache1 ( & self ) -> * const GrTextBlobCache { GrRecordingContext_getTextBlobCache1 ( self ) } # [ inline ] pub unsafe fn addOnFlushCallbackObject ( & mut self , arg1 : * mut GrOnFlushCallbackObject ) { GrRecordingContext_addOnFlushCallbackObject ( self , arg1 ) } # [ inline ] pub unsafe fn makeWrappedSurfaceContext ( & mut self , arg1 : sk_sp < GrSurfaceProxy > , arg2 : sk_sp < SkColorSpace > , arg3 : * const SkSurfaceProps ) -> sk_sp < GrSurfaceContext > { GrRecordingContext_makeWrappedSurfaceContext ( self , arg1 , arg2 , arg3 ) } # [ inline ] pub unsafe fn makeDeferredSurfaceContext ( & mut self , arg1 : * const GrBackendFormat , arg2 : * const GrSurfaceDesc , arg3 : GrSurfaceOrigin , arg4 : GrMipMapped , arg5 : SkBackingFit , arg6 : SkBudgeted , colorSpace : sk_sp < SkColorSpace > , arg7 : * const SkSurfaceProps ) -> sk_sp < GrSurfaceContext > { GrRecordingContext_makeDeferredSurfaceContext ( self , arg1 , arg2 , arg3 , arg4 , arg5 , arg6 , colorSpace , arg7 ) } # [ inline ] pub unsafe fn makeDeferredRenderTargetContext ( & mut self , format : * const GrBackendFormat , fit : SkBackingFit , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , config : GrPixelConfig , colorSpace : sk_sp < SkColorSpace > , sampleCnt : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , origin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , arg2 : SkBudgeted ) -> sk_sp < GrRenderTargetContext > { GrRecordingContext_makeDeferredRenderTargetContext ( self , format , fit , width , height , config , colorSpace , sampleCnt , arg1 , origin , surfaceProps , arg2 ) } # [ inline ] pub unsafe fn makeDeferredRenderTargetContextWithFallback ( & mut self , format : * const GrBackendFormat , fit : SkBackingFit , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , config : GrPixelConfig , colorSpace : sk_sp < SkColorSpace > , sampleCnt : :: std :: os :: raw :: c_int , arg1 : GrMipMapped , origin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , budgeted : SkBudgeted ) -> sk_sp < GrRenderTargetContext > { GrRecordingContext_makeDeferredRenderTargetContextWithFallback ( self , format , fit , width , height , config , colorSpace , sampleCnt , arg1 , origin , surfaceProps , budgeted ) } # [ inline ] pub unsafe fn auditTrail ( & mut self ) -> * mut GrAuditTrail { GrRecordingContext_auditTrail ( self ) } # [ inline ] pub unsafe fn new ( arg1 : GrBackendApi , arg2 : * const GrContextOptions , contextID : u32 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrRecordingContext_GrRecordingContext ( & mut __bindgen_tmp , arg1 , arg2 , contextID ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContextD1Ev" ] pub fn GrRecordingContext_GrRecordingContext_destructor ( this : * mut GrRecordingContext ) ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext4initE5sk_spIK6GrCapsES0_I20GrSkSLFPFactoryCacheE" ] pub fn GrRecordingContext_init ( this : * mut :: std :: os :: raw :: c_void , arg1 : sk_sp < GrCaps > , arg2 : sk_sp < GrSkSLFPFactoryCache > ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext14abandonContextEv" ] pub fn GrRecordingContext_abandonContext ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}__ZN18GrRecordingContext18asRecordingContextEv" ] pub fn GrRecordingContext_asRecordingContext ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrRecordingContext ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrAtlasManager { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrContextPriv { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrGLInterface { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct GrVkBackendContext { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkTaskGroup { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct GrContext { pub _base : GrRecordingContext , pub fThreadSafeProxy : sk_sp < GrContextThreadSafeProxy > , pub fTaskGroup : std_unique_ptr , pub fGpu : sk_sp < GrGpu > , pub fResourceCache : * mut GrResourceCache , pub fResourceProvider : * mut GrResourceProvider , pub fDidTestPMConversions : bool , pub fPMUPMConversionsRoundTrip : bool , pub fPersistentCache : * mut GrContextOptions_PersistentCache , } pub type GrContext_INHERITED = GrRecordingContext ; # [ test ] fn bindgen_test_layout_GrContext ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrContext > ( ) , 424usize , concat ! ( "Size of: " , stringify ! ( GrContext ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( GrContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext > ( ) ) ) . fThreadSafeProxy as * const _ as usize } , 368usize , concat ! ( "Offset of field: " , stringify ! ( GrContext ) , "::" , stringify ! ( fThreadSafeProxy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext > ( ) ) ) . fTaskGroup as * const _ as usize } , 376usize , concat ! ( "Offset of field: " , stringify ! ( GrContext ) , "::" , stringify ! ( fTaskGroup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext > ( ) ) ) . fGpu as * const _ as usize } , 384usize , concat ! ( "Offset of field: " , stringify ! ( GrContext ) , "::" , stringify ! ( fGpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext > ( ) ) ) . fResourceCache as * const _ as usize } , 392usize , concat ! ( "Offset of field: " , stringify ! ( GrContext ) , "::" , stringify ! ( fResourceCache ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext > ( ) ) ) . fResourceProvider as * const _ as usize } , 400usize , concat ! ( "Offset of field: " , stringify ! ( GrContext ) , "::" , stringify ! ( fResourceProvider ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext > ( ) ) ) . fDidTestPMConversions as * const _ as usize } , 408usize , concat ! ( "Offset of field: " , stringify ! ( GrContext ) , "::" , stringify ! ( fDidTestPMConversions ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext > ( ) ) ) . fPMUPMConversionsRoundTrip as * const _ as usize } , 409usize , concat ! ( "Offset of field: " , stringify ! ( GrContext ) , "::" , stringify ! ( fPMUPMConversionsRoundTrip ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < GrContext > ( ) ) ) . fPersistentCache as * const _ as usize } , 416usize , concat ! ( "Offset of field: " , stringify ! ( GrContext ) , "::" , stringify ! ( fPersistentCache ) ) ) ; } extern "C" { # [ doc = " Creates a GrContext for a backend context. If no GrGLInterface is provided then the result of" ] # [ doc = " GrGLMakeNativeInterface() is used if it succeeds." ] # [ link_name = "\u{1}__ZN9GrContext6MakeGLE5sk_spIK13GrGLInterfaceERK16GrContextOptions" ] pub fn GrContext_MakeGL ( arg1 : sk_sp < GrGLInterface > , arg2 : * const GrContextOptions ) -> sk_sp < GrContext > ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext6MakeGLE5sk_spIK13GrGLInterfaceE" ] pub fn GrContext_MakeGL1 ( arg1 : sk_sp < GrGLInterface > ) -> sk_sp < GrContext > ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext6MakeGLERK16GrContextOptions" ] pub fn GrContext_MakeGL2 ( arg1 : * const GrContextOptions ) -> sk_sp < GrContext > ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext6MakeGLEv" ] pub fn GrContext_MakeGL3 ( ) -> sk_sp < GrContext > ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext10MakeVulkanERK18GrVkBackendContextRK16GrContextOptions" ] pub fn GrContext_MakeVulkan ( arg1 : * const GrVkBackendContext , arg2 : * const GrContextOptions ) -> sk_sp < GrContext > ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext10MakeVulkanERK18GrVkBackendContext" ] pub fn GrContext_MakeVulkan1 ( arg1 : * const GrVkBackendContext ) -> sk_sp < GrContext > ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext8MakeMockEPK13GrMockOptionsRK16GrContextOptions" ] pub fn GrContext_MakeMock ( arg1 : * const GrMockOptions , arg2 : * const GrContextOptions ) -> sk_sp < GrContext > ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext8MakeMockEPK13GrMockOptions" ] pub fn GrContext_MakeMock1 ( arg1 : * const GrMockOptions ) -> sk_sp < GrContext > ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext15threadSafeProxyEv" ] pub fn GrContext_threadSafeProxy ( this : * mut GrContext ) -> sk_sp < GrContextThreadSafeProxy > ; } extern "C" { # [ doc = " The GrContext normally assumes that no outsider is setting state" ] # [ doc = " within the underlying 3D API\'s context/device/whatever. This call informs" ] # [ doc = " the context that the state was modified and it should resend. Shouldn\'t" ] # [ doc = " be called frequently for good performance." ] # [ doc = " The flag bits, state, is dpendent on which backend is used by the" ] # [ doc = " context, either GL or D3D (possible in future)." ] # [ link_name = "\u{1}__ZN9GrContext12resetContextEj" ] pub fn GrContext_resetContext ( this : * mut GrContext , state : u32 ) ; } extern "C" { # [ doc = " If the backend is GrBackendApi::kOpenGL, then all texture unit/target combinations for which" ] # [ doc = " the GrContext has modified the bound texture will have texture id 0 bound. This does not" ] # [ doc = " flush the GrContext. Calling resetContext() does not change the set that will be bound" ] # [ doc = " to texture id 0 on the next call to resetGLTextureBindings(). After this is called" ] # [ doc = " all unit/target combinations are considered to have unmodified bindings until the GrContext" ] # [ doc = " subsequently modifies them (meaning if this is called twice in a row with no intervening" ] # [ doc = " GrContext usage then the second call is a no-op.)" ] # [ link_name = "\u{1}__ZN9GrContext22resetGLTextureBindingsEv" ] pub fn GrContext_resetGLTextureBindings ( this : * mut GrContext ) ; } extern "C" { # [ doc = "  Return the current GPU resource cache limits." ] # [ doc = "" ] # [ doc = "  @param maxResources If non-null, returns maximum number of resources that" ] # [ doc = "                      can be held in the cache." ] # [ doc = "  @param maxResourceBytes If non-null, returns maximum number of bytes of" ] # [ doc = "                          video memory that can be held in the cache." ] # [ link_name = "\u{1}__ZNK9GrContext22getResourceCacheLimitsEPiPm" ] pub fn GrContext_getResourceCacheLimits ( this : * const GrContext , maxResources : * mut :: std :: os :: raw :: c_int , maxResourceBytes : * mut usize ) ; } extern "C" { # [ doc = "  Gets the current GPU resource cache usage." ] # [ doc = "" ] # [ doc = "  @param resourceCount If non-null, returns the number of resources that are held in the" ] # [ doc = "                       cache." ] # [ doc = "  @param maxResourceBytes If non-null, returns the total number of bytes of video memory held" ] # [ doc = "                          in the cache." ] # [ link_name = "\u{1}__ZNK9GrContext21getResourceCacheUsageEPiPm" ] pub fn GrContext_getResourceCacheUsage ( this : * const GrContext , resourceCount : * mut :: std :: os :: raw :: c_int , resourceBytes : * mut usize ) ; } extern "C" { # [ doc = "  Gets the number of bytes in the cache consumed by purgeable (e.g. unlocked) resources." ] # [ link_name = "\u{1}__ZNK9GrContext30getResourceCachePurgeableBytesEv" ] pub fn GrContext_getResourceCachePurgeableBytes ( this : * const GrContext ) -> usize ; } extern "C" { # [ doc = "  Specify the GPU resource cache limits. If the current cache exceeds either" ] # [ doc = "  of these, it will be purged (LRU) to keep the cache within these limits." ] # [ doc = "" ] # [ doc = "  @param maxResources The maximum number of resources that can be held in" ] # [ doc = "                      the cache." ] # [ doc = "  @param maxResourceBytes The maximum number of bytes of video memory" ] # [ doc = "                          that can be held in the cache." ] # [ link_name = "\u{1}__ZN9GrContext22setResourceCacheLimitsEim" ] pub fn GrContext_setResourceCacheLimits ( this : * mut GrContext , maxResources : :: std :: os :: raw :: c_int , maxResourceBytes : usize ) ; } extern "C" { # [ doc = " Purge GPU resources that haven\'t been used in the past \'msNotUsed\' milliseconds or are" ] # [ doc = " otherwise marked for deletion, regardless of whether the context is under budget." ] # [ link_name = "\u{1}__ZN9GrContext22performDeferredCleanupENSt3__16chrono8durationIxNS0_5ratioILl1ELl1000EEEEE" ] pub fn GrContext_performDeferredCleanup ( this : * mut GrContext , msNotUsed : std_chrono_milliseconds ) ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext25purgeResourcesNotUsedInMsENSt3__16chrono8durationIxNS0_5ratioILl1ELl1000EEEEE" ] pub fn GrContext_purgeResourcesNotUsedInMs ( this : * mut GrContext , msNotUsed : std_chrono_milliseconds ) ; } extern "C" { # [ doc = " Purge unlocked resources from the cache until the the provided byte count has been reached" ] # [ doc = " or we have purged all unlocked resources. The default policy is to purge in LRU order, but" ] # [ doc = " can be overridden to prefer purging scratch resources (in LRU order) prior to purging other" ] # [ doc = " resource types." ] # [ doc = "" ] # [ doc = " @param maxBytesToPurge the desired number of bytes to be purged." ] # [ doc = " @param preferScratchResources If true scratch resources will be purged prior to other" ] # [ doc = "                               resource types." ] # [ link_name = "\u{1}__ZN9GrContext22purgeUnlockedResourcesEmb" ] pub fn GrContext_purgeUnlockedResources ( this : * mut GrContext , bytesToPurge : usize , preferScratchResources : bool ) ; } extern "C" { # [ doc = " This entry point is intended for instances where an app has been backgrounded or" ] # [ doc = " suspended." ] # [ doc = " If \'scratchResourcesOnly\' is true all unlocked scratch resources will be purged but the" ] # [ doc = " unlocked resources with persistent data will remain. If \'scratchResourcesOnly\' is false" ] # [ doc = " then all unlocked resources will be purged." ] # [ doc = " In either case, after the unlocked resources are purged a separate pass will be made to" ] # [ doc = " ensure that resource usage is under budget (i.e., even if \'scratchResourcesOnly\' is true" ] # [ doc = " some resources with persistent data may be purged to be under budget)." ] # [ doc = "" ] # [ doc = " @param scratchResourcesOnly   If true only unlocked scratch resources will be purged prior" ] # [ doc = "                               enforcing the budget requirements." ] # [ link_name = "\u{1}__ZN9GrContext22purgeUnlockedResourcesEb" ] pub fn GrContext_purgeUnlockedResources1 ( this : * mut GrContext , scratchResourcesOnly : bool ) ; } extern "C" { # [ doc = " Gets the maximum supported texture size." ] # [ link_name = "\u{1}__ZNK9GrContext14maxTextureSizeEv" ] pub fn GrContext_maxTextureSize ( this : * const GrContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Gets the maximum supported render target size." ] # [ link_name = "\u{1}__ZNK9GrContext19maxRenderTargetSizeEv" ] pub fn GrContext_maxRenderTargetSize ( this : * const GrContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Can a SkImage be created with the given color type." ] # [ link_name = "\u{1}__ZNK9GrContext25colorTypeSupportedAsImageE11SkColorType" ] pub fn GrContext_colorTypeSupportedAsImage ( this : * const GrContext , arg1 : SkColorType ) -> bool ; } extern "C" { # [ doc = " Can a SkSurface be created with the given color type. To check whether MSAA is supported" ] # [ doc = " use maxSurfaceSampleCountForColorType()." ] # [ link_name = "\u{1}__ZNK9GrContext27colorTypeSupportedAsSurfaceE11SkColorType" ] pub fn GrContext_colorTypeSupportedAsSurface ( this : * const GrContext , colorType : SkColorType ) -> bool ; } extern "C" { # [ doc = " Gets the maximum supported sample count for a color type. 1 is returned if only non-MSAA" ] # [ doc = " rendering is supported for the color type. 0 is returned if rendering to this color type" ] # [ doc = " is not supported at all." ] # [ link_name = "\u{1}__ZNK9GrContext33maxSurfaceSampleCountForColorTypeE11SkColorType" ] pub fn GrContext_maxSurfaceSampleCountForColorType ( this : * const GrContext , arg1 : SkColorType ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ doc = " Call to ensure all drawing to the context has been issued to the underlying 3D API." ] # [ link_name = "\u{1}__ZN9GrContext5flushEv" ] pub fn GrContext_flush ( this : * mut GrContext ) ; } extern "C" { # [ doc = " Call to ensure all drawing to the context has been issued to the underlying 3D API. After" ] # [ doc = " issuing all commands, numSemaphore semaphores will be signaled by the gpu. The client passes" ] # [ doc = " in an array of numSemaphores GrBackendSemaphores. In general these GrBackendSemaphore\'s can" ] # [ doc = " be either initialized or not. If they are initialized, the backend uses the passed in" ] # [ doc = " semaphore. If it is not initialized, a new semaphore is created and the GrBackendSemaphore" ] # [ doc = " object is initialized with that semaphore." ] # [ doc = "" ] # [ doc = " The client will own and be responsible for deleting the underlying semaphores that are stored" ] # [ doc = " and returned in initialized GrBackendSemaphore objects. The GrBackendSemaphore objects" ] # [ doc = " themselves can be deleted as soon as this function returns." ] # [ doc = "" ] # [ doc = " If the backend API is OpenGL only uninitialized GrBackendSemaphores are supported." ] # [ doc = " If the backend API is Vulkan either initialized or unitialized semaphores are supported." ] # [ doc = " If unitialized, the semaphores which are created will be valid for use only with the VkDevice" ] # [ doc = " with which they were created." ] # [ doc = "" ] # [ doc = " If this call returns GrSemaphoresSubmited::kNo, the GPU backend will not have created or" ] # [ doc = " added any semaphores to signal on the GPU. Thus the client should not have the GPU wait on" ] # [ doc = " any of the semaphores. However, any pending commands to the context will still be flushed." ] # [ link_name = "\u{1}__ZN9GrContext24flushAndSignalSemaphoresEiP18GrBackendSemaphore" ] pub fn GrContext_flushAndSignalSemaphores ( this : * mut GrContext , numSemaphores : :: std :: os :: raw :: c_int , signalSemaphores : * mut GrBackendSemaphore ) -> GrSemaphoresSubmitted ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext4privEv" ] pub fn GrContext_priv ( this : * mut GrContext ) -> GrContextPriv ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrContext4privEv" ] pub fn GrContext_priv1 ( this : * const GrContext ) -> GrContextPriv ; } extern "C" { # [ doc = " Enumerates all cached GPU resources and dumps their memory to traceMemoryDump." ] # [ link_name = "\u{1}__ZNK9GrContext20dumpMemoryStatisticsEP17SkTraceMemoryDump" ] pub fn GrContext_dumpMemoryStatistics ( this : * const GrContext , traceMemoryDump : * mut SkTraceMemoryDump ) ; } extern "C" { # [ link_name = "\u{1}__ZNK9GrContext25supportsDistanceFieldTextEv" ] pub fn GrContext_supportsDistanceFieldText ( this : * const GrContext ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext24storeVkPipelineCacheDataEv" ] pub fn GrContext_storeVkPipelineCacheData ( this : * mut GrContext ) ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContextC2E12GrBackendApiRK16GrContextOptionsi" ] pub fn GrContext_GrContext ( this : * mut GrContext , arg1 : GrBackendApi , arg2 : * const GrContextOptions , contextID : i32 ) ; } impl GrContext { # [ inline ] pub unsafe fn MakeGL ( arg1 : sk_sp < GrGLInterface > , arg2 : * const GrContextOptions ) -> sk_sp < GrContext > { GrContext_MakeGL ( arg1 , arg2 ) } # [ inline ] pub unsafe fn MakeGL1 ( arg1 : sk_sp < GrGLInterface > ) -> sk_sp < GrContext > { GrContext_MakeGL1 ( arg1 ) } # [ inline ] pub unsafe fn MakeGL2 ( arg1 : * const GrContextOptions ) -> sk_sp < GrContext > { GrContext_MakeGL2 ( arg1 ) } # [ inline ] pub unsafe fn MakeGL3 ( ) -> sk_sp < GrContext > { GrContext_MakeGL3 ( ) } # [ inline ] pub unsafe fn MakeVulkan ( arg1 : * const GrVkBackendContext , arg2 : * const GrContextOptions ) -> sk_sp < GrContext > { GrContext_MakeVulkan ( arg1 , arg2 ) } # [ inline ] pub unsafe fn MakeVulkan1 ( arg1 : * const GrVkBackendContext ) -> sk_sp < GrContext > { GrContext_MakeVulkan1 ( arg1 ) } # [ inline ] pub unsafe fn MakeMock ( arg1 : * const GrMockOptions , arg2 : * const GrContextOptions ) -> sk_sp < GrContext > { GrContext_MakeMock ( arg1 , arg2 ) } # [ inline ] pub unsafe fn MakeMock1 ( arg1 : * const GrMockOptions ) -> sk_sp < GrContext > { GrContext_MakeMock1 ( arg1 ) } # [ inline ] pub unsafe fn threadSafeProxy ( & mut self ) -> sk_sp < GrContextThreadSafeProxy > { GrContext_threadSafeProxy ( self ) } # [ inline ] pub unsafe fn resetContext ( & mut self , state : u32 ) { GrContext_resetContext ( self , state ) } # [ inline ] pub unsafe fn resetGLTextureBindings ( & mut self ) { GrContext_resetGLTextureBindings ( self ) } # [ inline ] pub unsafe fn getResourceCacheLimits ( & self , maxResources : * mut :: std :: os :: raw :: c_int , maxResourceBytes : * mut usize ) { GrContext_getResourceCacheLimits ( self , maxResources , maxResourceBytes ) } # [ inline ] pub unsafe fn getResourceCacheUsage ( & self , resourceCount : * mut :: std :: os :: raw :: c_int , resourceBytes : * mut usize ) { GrContext_getResourceCacheUsage ( self , resourceCount , resourceBytes ) } # [ inline ] pub unsafe fn getResourceCachePurgeableBytes ( & self ) -> usize { GrContext_getResourceCachePurgeableBytes ( self ) } # [ inline ] pub unsafe fn setResourceCacheLimits ( & mut self , maxResources : :: std :: os :: raw :: c_int , maxResourceBytes : usize ) { GrContext_setResourceCacheLimits ( self , maxResources , maxResourceBytes ) } # [ inline ] pub unsafe fn performDeferredCleanup ( & mut self , msNotUsed : std_chrono_milliseconds ) { GrContext_performDeferredCleanup ( self , msNotUsed ) } # [ inline ] pub unsafe fn purgeResourcesNotUsedInMs ( & mut self , msNotUsed : std_chrono_milliseconds ) { GrContext_purgeResourcesNotUsedInMs ( self , msNotUsed ) } # [ inline ] pub unsafe fn purgeUnlockedResources ( & mut self , bytesToPurge : usize , preferScratchResources : bool ) { GrContext_purgeUnlockedResources ( self , bytesToPurge , preferScratchResources ) } # [ inline ] pub unsafe fn purgeUnlockedResources1 ( & mut self , scratchResourcesOnly : bool ) { GrContext_purgeUnlockedResources1 ( self , scratchResourcesOnly ) } # [ inline ] pub unsafe fn maxTextureSize ( & self ) -> :: std :: os :: raw :: c_int { GrContext_maxTextureSize ( self ) } # [ inline ] pub unsafe fn maxRenderTargetSize ( & self ) -> :: std :: os :: raw :: c_int { GrContext_maxRenderTargetSize ( self ) } # [ inline ] pub unsafe fn colorTypeSupportedAsImage ( & self , arg1 : SkColorType ) -> bool { GrContext_colorTypeSupportedAsImage ( self , arg1 ) } # [ inline ] pub unsafe fn colorTypeSupportedAsSurface ( & self , colorType : SkColorType ) -> bool { GrContext_colorTypeSupportedAsSurface ( self , colorType ) } # [ inline ] pub unsafe fn maxSurfaceSampleCountForColorType ( & self , arg1 : SkColorType ) -> :: std :: os :: raw :: c_int { GrContext_maxSurfaceSampleCountForColorType ( self , arg1 ) } # [ inline ] pub unsafe fn flush ( & mut self ) { GrContext_flush ( self ) } # [ inline ] pub unsafe fn flushAndSignalSemaphores ( & mut self , numSemaphores : :: std :: os :: raw :: c_int , signalSemaphores : * mut GrBackendSemaphore ) -> GrSemaphoresSubmitted { GrContext_flushAndSignalSemaphores ( self , numSemaphores , signalSemaphores ) } # [ inline ] pub unsafe fn priv_ ( & mut self ) -> GrContextPriv { GrContext_priv ( self ) } # [ inline ] pub unsafe fn priv1 ( & self ) -> GrContextPriv { GrContext_priv1 ( self ) } # [ inline ] pub unsafe fn dumpMemoryStatistics ( & self , traceMemoryDump : * mut SkTraceMemoryDump ) { GrContext_dumpMemoryStatistics ( self , traceMemoryDump ) } # [ inline ] pub unsafe fn supportsDistanceFieldText ( & self ) -> bool { GrContext_supportsDistanceFieldText ( self ) } # [ inline ] pub unsafe fn storeVkPipelineCacheData ( & mut self ) { GrContext_storeVkPipelineCacheData ( self ) } # [ inline ] pub unsafe fn new ( arg1 : GrBackendApi , arg2 : * const GrContextOptions , contextID : i32 ) -> Self { let mut __bindgen_tmp = :: core :: mem :: uninitialized ( ) ; GrContext_GrContext ( & mut __bindgen_tmp , arg1 , arg2 , contextID ) ; __bindgen_tmp } } extern "C" { # [ link_name = "\u{1}__ZN9GrContextD1Ev" ] pub fn GrContext_GrContext_destructor ( this : * mut GrContext ) ; } extern "C" { # [ doc = " Abandons all GPU resources and assumes the underlying backend 3D API context is no longer" ] # [ doc = " usable. Call this if you have lost the associated GPU context, and thus internal texture," ] # [ doc = " buffer, etc. references/IDs are now invalid. Calling this ensures that the destructors of the" ] # [ doc = " GrContext and any of its created resource objects will not make backend 3D API calls. Content" ] # [ doc = " rendered but not previously flushed may be lost. After this function is called all subsequent" ] # [ doc = " calls on the GrContext will fail or be no-ops." ] # [ doc = "" ] # [ doc = " The typical use case for this function is that the underlying 3D context was lost and further" ] # [ doc = " API calls may crash." ] # [ link_name = "\u{1}__ZN9GrContext14abandonContextEv" ] pub fn GrContext_abandonContext ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ doc = " This is similar to abandonContext() however the underlying 3D context is not yet lost and" ] # [ doc = " the GrContext will cleanup all allocated resources before returning. After returning it will" ] # [ doc = " assume that the underlying context may no longer be valid." ] # [ doc = "" ] # [ doc = " The typical use case for this function is that the client is going to destroy the 3D context" ] # [ doc = " but can\'t guarantee that GrContext will be destroyed first (perhaps because it may be ref\'ed" ] # [ doc = " elsewhere by either the client or Skia objects)." ] # [ link_name = "\u{1}__ZN9GrContext33releaseResourcesAndAbandonContextEv" ] pub fn GrContext_releaseResourcesAndAbandonContext ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ doc = " Frees GPU created by the context. Can be called to reduce GPU memory" ] # [ doc = " pressure." ] # [ link_name = "\u{1}__ZN9GrContext16freeGpuResourcesEv" ] pub fn GrContext_freeGpuResources ( this : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext4initE5sk_spIK6GrCapsES0_I20GrSkSLFPFactoryCacheE" ] pub fn GrContext_init ( this : * mut :: std :: os :: raw :: c_void , arg1 : sk_sp < GrCaps > , arg2 : sk_sp < GrSkSLFPFactoryCache > ) -> bool ; } extern "C" { # [ link_name = "\u{1}__ZN9GrContext15asDirectContextEv" ] pub fn GrContext_asDirectContext ( this : * mut :: std :: os :: raw :: c_void ) -> * mut GrContext ; } extern "C" { # [ link_name = "\u{1}_C_SkSurface_MakeRasterN32Premul" ] pub fn C_SkSurface_MakeRasterN32Premul ( width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps ) -> * mut SkSurface ; } extern "C" { # [ link_name = "\u{1}_C_SkSurface_MakeRenderTarget" ] pub fn C_SkSurface_MakeRenderTarget ( context : * mut GrContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo ) -> * mut SkSurface ; } extern "C" { # [ link_name = "\u{1}_C_SkSurface_makeImageSnapshot" ] pub fn C_SkSurface_makeImageSnapshot ( self_ : * mut SkSurface ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeRasterData" ] pub fn C_SkImage_MakeRasterData ( info : * const SkImageInfo , pixels : * mut SkData , rowBytes : usize ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromBitmap" ] pub fn C_SkImage_MakeFromBitmap ( bitmap : * const SkBitmap ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromEncoded" ] pub fn C_SkImage_MakeFromEncoded ( encoded : * mut SkData , subset : * const SkIRect ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromTexture" ] pub fn C_SkImage_MakeFromTexture ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeCrossContextFromEncoded" ] pub fn C_SkImage_MakeCrossContextFromEncoded ( context : * mut GrContext , data : * mut SkData , buildMips : bool , dstColorSpace : * mut SkColorSpace , limitToMaxTextureSize : bool ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromAdoptedTexture" ] pub fn C_SkImage_MakeFromAdoptedTexture ( context : * mut GrContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromYUVATexturesCopy" ] pub fn C_SkImage_MakeFromYUVATexturesCopy ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , colorSpace : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromYUVATexturesCopyWithExternalBackend" ] pub fn C_SkImage_MakeFromYUVATexturesCopyWithExternalBackend ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , backendTexture : * const GrBackendTexture , colorSpace : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromYUVATextures" ] pub fn C_SkImage_MakeFromYUVATextures ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , yuvaTextures : * const GrBackendTexture , yuvaIndices : * const SkYUVAIndex , imageSize : SkISize , imageOrigin : GrSurfaceOrigin , colorSpace : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromNV12TexturesCopy" ] pub fn C_SkImage_MakeFromNV12TexturesCopy ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , nv12Textures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , imageColorSpace : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromNV12TexturesCopyWithExternalBackend" ] pub fn C_SkImage_MakeFromNV12TexturesCopyWithExternalBackend ( context : * mut GrContext , yuvColorSpace : SkYUVColorSpace , nv12Textures : * const GrBackendTexture , imageOrigin : GrSurfaceOrigin , backendTexture : * const GrBackendTexture , imageColorSpace : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_MakeFromPicture" ] pub fn C_SkImage_MakeFromPicture ( picture : * mut SkPicture , dimensions : * const SkISize , matrix : * const SkMatrix , paint : * const SkPaint , bitDepth : SkImage_BitDepth , colorSpace : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_getBackendTexture" ] pub fn C_SkImage_getBackendTexture ( self_ : * const SkImage , flushPendingGrContextIO : bool , origin : * mut GrSurfaceOrigin , result : * mut GrBackendTexture ) ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_encodeToData" ] pub fn C_SkImage_encodeToData ( self_ : * const SkImage , imageFormat : SkEncodedImageFormat ) -> * mut SkData ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_refEncodedData" ] pub fn C_SkImage_refEncodedData ( self_ : * const SkImage ) -> * mut SkData ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_makeSubset" ] pub fn C_SkImage_makeSubset ( self_ : * const SkImage , subset : * const SkIRect ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_makeTextureImage" ] pub fn C_SkImage_makeTextureImage ( self_ : * const SkImage , context : * mut GrContext , dstColorSpace : * mut SkColorSpace , mipMapped : GrMipMapped ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_makeNonTextureImage" ] pub fn C_SkImage_makeNonTextureImage ( self_ : * const SkImage ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_makeRasterImage" ] pub fn C_SkImage_makeRasterImage ( self_ : * const SkImage ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkImage_makeColorSpace" ] pub fn C_SkImage_makeColorSpace ( self_ : * const SkImage , target : * mut SkColorSpace ) -> * mut SkImage ; } extern "C" { # [ link_name = "\u{1}_C_SkData_ref" ] pub fn C_SkData_ref ( self_ : * const SkData ) ; } extern "C" { # [ link_name = "\u{1}_C_SkData_unref" ] pub fn C_SkData_unref ( self_ : * const SkData ) ; } extern "C" { # [ link_name = "\u{1}_C_SkPaint_destruct" ] pub fn C_SkPaint_destruct ( self_ : * const SkPaint ) ; } extern "C" { # [ link_name = "\u{1}_C_SkPath_destruct" ] pub fn C_SkPath_destruct ( self_ : * const SkPath ) ; } extern "C" { # [ link_name = "\u{1}_C_SkCanvas_destruct" ] pub fn C_SkCanvas_destruct ( self_ : * const SkCanvas ) ; } extern "C" { # [ link_name = "\u{1}_C_SkImageInfo_Construct" ] pub fn C_SkImageInfo_Construct ( uninitialized : * mut SkImageInfo ) ; } extern "C" { # [ link_name = "\u{1}_C_SkImageInfo_Destruct" ] pub fn C_SkImageInfo_Destruct ( self_ : * mut SkImageInfo ) ; } extern "C" { # [ link_name = "\u{1}_C_SkImageInfo_Copy" ] pub fn C_SkImageInfo_Copy ( from : * const SkImageInfo , to : * mut SkImageInfo ) ; } extern "C" { # [ link_name = "\u{1}_C_SkImageInfo_Make" ] pub fn C_SkImageInfo_Make ( self_ : * mut SkImageInfo , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , ct : SkColorType , at : SkAlphaType , cs : * mut SkColorSpace ) ; } extern "C" { # [ link_name = "\u{1}_C_SkImageInfo_MakeS32" ] pub fn C_SkImageInfo_MakeS32 ( self_ : * mut SkImageInfo , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType ) ; } extern "C" { # [ link_name = "\u{1}_C_SkImageInfo_colorSpace" ] pub fn C_SkImageInfo_colorSpace ( self_ : * const SkImageInfo ) -> * mut SkColorSpace ; } extern "C" { # [ link_name = "\u{1}_C_SkColorSpace_ref" ] pub fn C_SkColorSpace_ref ( self_ : * const SkColorSpace ) ; } extern "C" { # [ link_name = "\u{1}_C_SkColorSpace_unref" ] pub fn C_SkColorSpace_unref ( self_ : * const SkColorSpace ) ; } extern "C" { # [ link_name = "\u{1}_C_SkColorSpace_MakeSRGB" ] pub fn C_SkColorSpace_MakeSRGB ( ) -> * mut SkColorSpace ; } extern "C" { # [ link_name = "\u{1}_C_SkColorSpace_MakeSRGBLinear" ] pub fn C_SkColorSpace_MakeSRGBLinear ( ) -> * mut SkColorSpace ; } extern "C" { # [ link_name = "\u{1}_C_SkColorSpace_serialize" ] pub fn C_SkColorSpace_serialize ( self_ : * const SkColorSpace ) -> * mut SkData ; } extern "C" { # [ link_name = "\u{1}_C_SkColorSpace_Deserialize" ] pub fn C_SkColorSpace_Deserialize ( data : * const :: std :: os :: raw :: c_void , length : usize ) -> * mut SkColorSpace ; } extern "C" { # [ link_name = "\u{1}_C_SkMatrix44_Construct" ] pub fn C_SkMatrix44_Construct ( uninitialized : * mut SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}_C_SkMatrix44_Destruct" ] pub fn C_SkMatrix44_Destruct ( self_ : * mut SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}_C_SkMatrix44_Equals" ] pub fn C_SkMatrix44_Equals ( self_ : * const SkMatrix44 , rhs : * const SkMatrix44 ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkMatrix44_SkMatrix" ] pub fn C_SkMatrix44_SkMatrix ( self_ : * const SkMatrix44 , m : * mut SkMatrix ) ; } extern "C" { # [ link_name = "\u{1}_C_SkMatrix44_Mul" ] pub fn C_SkMatrix44_Mul ( self_ : * const SkMatrix44 , rhs : * const SkMatrix44 , result : * mut SkMatrix44 ) ; } extern "C" { # [ link_name = "\u{1}_C_SkMatrix44_MulV4" ] pub fn C_SkMatrix44_MulV4 ( self_ : * const SkMatrix44 , rhs : * const SkVector4 , result : * mut SkVector4 ) ; } extern "C" { # [ link_name = "\u{1}_C_SkMatrix_Equals" ] pub fn C_SkMatrix_Equals ( self_ : * const SkMatrix , rhs : * const SkMatrix ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkSurfaceProps_Equals" ] pub fn C_SkSurfaceProps_Equals ( self_ : * const SkSurfaceProps , rhs : * const SkSurfaceProps ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_Construct" ] pub fn C_SkBitmap_Construct ( uninitialized : * mut SkBitmap ) ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_Destruct" ] pub fn C_SkBitmap_Destruct ( self_ : * mut SkBitmap ) ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_Copy" ] pub fn C_SkBitmap_Copy ( from : * const SkBitmap , to : * mut SkBitmap ) ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_colorSpace" ] pub fn C_SkBitmap_colorSpace ( self_ : * const SkBitmap ) -> * mut SkColorSpace ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_ComputeIsOpaque" ] pub fn C_SkBitmap_ComputeIsOpaque ( self_ : * const SkBitmap ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_tryAllocN32Pixels" ] pub fn C_SkBitmap_tryAllocN32Pixels ( self_ : * mut SkBitmap , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_tryAllocPixels" ] pub fn C_SkBitmap_tryAllocPixels ( self_ : * mut SkBitmap ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_readyToDraw" ] pub fn C_SkBitmap_readyToDraw ( self_ : * const SkBitmap ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_eraseARGB" ] pub fn C_SkBitmap_eraseARGB ( self_ : * const SkBitmap , a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU ) ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_getAlphaf" ] pub fn C_SkBitmap_getAlphaf ( self_ : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ) -> f32 ; } extern "C" { # [ link_name = "\u{1}_C_SkBitmap_extractAlpha" ] pub fn C_SkBitmap_extractAlpha ( self_ : * const SkBitmap , dst : * mut SkBitmap , paint : * const SkPaint , offset : * mut SkIPoint ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkPicture_MakeFromData" ] pub fn C_SkPicture_MakeFromData ( data : * const SkData ) -> * mut SkPicture ; } extern "C" { # [ link_name = "\u{1}_C_SkPicture_serialize" ] pub fn C_SkPicture_serialize ( self_ : * const SkPicture ) -> * mut SkData ; } extern "C" { # [ link_name = "\u{1}_C_SkPicture_MakePlaceholder" ] pub fn C_SkPicture_MakePlaceholder ( cull : * const SkRect ) -> * mut SkPicture ; } extern "C" { # [ link_name = "\u{1}_C_SkPicture_playback" ] pub fn C_SkPicture_playback ( self_ : * const SkPicture , canvas : * mut SkCanvas ) ; } extern "C" { # [ link_name = "\u{1}_C_SkPicture_cullRect" ] pub fn C_SkPicture_cullRect ( self_ : * const SkPicture ) -> SkRect ; } extern "C" { # [ link_name = "\u{1}_C_SkRRect_equals" ] pub fn C_SkRRect_equals ( lhs : * const SkRRect , rhs : * const SkRRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkRRect_not_equals" ] pub fn C_SkRRect_not_equals ( lhs : * const SkRRect , rhs : * const SkRRect ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_GrBackendTexture_destruct" ] pub fn C_GrBackendTexture_destruct ( self_ : * const GrBackendTexture ) ; } extern "C" { # [ link_name = "\u{1}_C_SkRegion_destruct" ] pub fn C_SkRegion_destruct ( region : * mut SkRegion ) ; } extern "C" { # [ link_name = "\u{1}_C_SkRegion_equals" ] pub fn C_SkRegion_equals ( lhs : * const SkRegion , rhs : * const SkRegion ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkFontStyle_equals" ] pub fn C_SkFontStyle_equals ( lhs : * const SkFontStyle , rhs : * const SkFontStyle ) -> bool ; } extern "C" { # [ link_name = "\u{1}_C_SkTypeface_MakeDefault" ] pub fn C_SkTypeface_MakeDefault ( ) -> * mut SkTypeface ; } extern "C" { # [ link_name = "\u{1}_C_SkTypeface_MakeFromName" ] pub fn C_SkTypeface_MakeFromName ( familyName : * const :: std :: os :: raw :: c_char , fontStyle : SkFontStyle ) -> * mut SkTypeface ; } extern "C" { # [ link_name = "\u{1}_C_SkTypeface_MakeFromFile" ] pub fn C_SkTypeface_MakeFromFile ( path : * const :: std :: os :: raw :: c_char , index : :: std :: os :: raw :: c_int ) -> * mut SkTypeface ; } extern "C" { # [ link_name = "\u{1}_C_SkTypeface_MakeFromData" ] pub fn C_SkTypeface_MakeFromData ( data : * mut SkData , index : :: std :: os :: raw :: c_int ) -> * mut SkTypeface ; } extern "C" { # [ link_name = "\u{1}_C_SkTypeface_serialize" ] pub fn C_SkTypeface_serialize ( self_ : * const SkTypeface , behavior : SkTypeface_SerializeBehavior ) -> * mut SkData ; } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: core :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __va_list_tag > ( ) ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __va_list_tag > ( ) ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __va_list_tag > ( ) ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __va_list_tag > ( ) ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_uint8_t_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_nano_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_chrono_duration < :: std :: os :: raw :: c_longlong > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_chrono_duration < :: std :: os :: raw :: c_longlong > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_chrono_duration < :: std :: os :: raw :: c_longlong > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_chrono_duration < :: std :: os :: raw :: c_longlong > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_milli_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_chrono_duration < :: std :: os :: raw :: c_longlong > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_chrono_duration < :: std :: os :: raw :: c_longlong > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_chrono_duration < :: std :: os :: raw :: c_longlong > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_chrono_duration < :: std :: os :: raw :: c_longlong > ) ) ) ; } pub type rep = :: std :: os :: raw :: c_longlong ; # [ test ] fn __bindgen_test_layout_std_chrono_time_point_open0_std_chrono_steady_clock_std_chrono_steady_clock_duration_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_chrono_time_point < std_chrono_steady_clock_duration > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_chrono_time_point < std_chrono_steady_clock_duration > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_chrono_time_point < std_chrono_steady_clock_duration > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_chrono_time_point < std_chrono_steady_clock_duration > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_int32_t_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_int32_t_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_int32_t_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkString_Rec > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkString_Rec > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkString_Rec > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkString_Rec > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_int32_t_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkString_Rec > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkString_Rec > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkString_Rec > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkString_Rec > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamAsset_std_default_delete_open1_SkStreamAsset_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamAsset_std_default_delete_open1_SkStreamAsset_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_8 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamAsset_std_default_delete_open1_SkStreamAsset_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_unsigned_int_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_SkNVRefCnt_open0_SkColorSpace_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkNVRefCnt > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( SkNVRefCnt ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkNVRefCnt > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( SkNVRefCnt ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_8 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_9 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_10 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_11 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_12 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_13 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkMaskFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkMaskFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkMaskFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkMaskFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkMaskFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkMaskFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkMaskFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkMaskFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImageFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImageFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImageFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImageFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImageFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImageFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImageFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImageFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkDrawLooper_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkDrawLooper > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkDrawLooper > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkDrawLooper > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkDrawLooper > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkDrawLooper_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkDrawLooper > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkDrawLooper > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkDrawLooper > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkDrawLooper > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkDrawLooper_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkDrawLooper > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkDrawLooper > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkDrawLooper > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkDrawLooper > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkMaskFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkMaskFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkMaskFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkMaskFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkDrawLooper_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkDrawLooper > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkDrawLooper > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkDrawLooper > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkDrawLooper > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImageFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImageFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImageFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImageFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkRasterHandleAllocator_std_default_delete_open1_SkRasterHandleAllocator_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkCanvas_std_default_delete_open1_SkCanvas_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_SkNVRefCnt_open0_SkData_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkNVRefCnt > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( SkNVRefCnt ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkNVRefCnt > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( SkNVRefCnt ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_8 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_9 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_10 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_11 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_12 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_13 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_14 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_SkNVRefCnt_open0_SkVertices_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkNVRefCnt > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( SkNVRefCnt ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkNVRefCnt > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( SkNVRefCnt ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_15 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkCanvas_std_default_delete_open1_SkCanvas_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkCanvas_std_default_delete_open1_SkCanvas_close1_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTextBlob > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTextBlob > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTextBlob > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTextBlob > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_8 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_9 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkVertices > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkVertices > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_16 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SkDrawIter { pub _address : u8 , } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkRasterHandleAllocator_std_default_delete_open1_SkRasterHandleAllocator_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkGlyphRunBuilder_std_default_delete_open1_SkGlyphRunBuilder_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkGlyphRunBuilder_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_int_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_SkNVRefCnt_open0_SkPathRef_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkNVRefCnt > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( SkNVRefCnt ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkNVRefCnt > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( SkNVRefCnt ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathRef > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathRef > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathRef > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathRef > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathRef > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathRef > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathRef > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathRef > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathRef > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathRef > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathRef > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathRef > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_bool__close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_SkTDArray_open0_SkScalar_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkTDArray < SkScalar > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( SkTDArray < SkScalar > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkTDArray < SkScalar > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( SkTDArray < SkScalar > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_int_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 4usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_SkTDArray_open0_ptr_GenIDChangeListener_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkTDArray < * mut SkPathRef_GenIDChangeListener > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( SkTDArray < * mut SkPathRef_GenIDChangeListener > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkTDArray < * mut SkPathRef_GenIDChangeListener > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( SkTDArray < * mut SkPathRef_GenIDChangeListener > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_initializer_list_open0_SkPoint_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_initializer_list < SkPoint > > ( ) , 16usize , concat ! ( "Size of template specialization: " , stringify ! ( std_initializer_list < SkPoint > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_initializer_list < SkPoint > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_initializer_list < SkPoint > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_17 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathRef > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathRef > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathRef > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathRef > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_SkPath_Convexity_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_atomic_open0_uint8_t_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_atomic > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_atomic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_atomic > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_atomic ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_14 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_15 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_16 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPixelRef > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPixelRef > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPixelRef > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPixelRef > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPixelRef > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPixelRef > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPixelRef > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPixelRef > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamAsset_std_default_delete_open1_SkStreamAsset_close1_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStream_std_default_delete_open1_SkStream_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStream_std_default_delete_open1_SkStream_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamRewindable_std_default_delete_open1_SkStreamRewindable_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamRewindable_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamSeekable_std_default_delete_open1_SkStreamSeekable_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamSeekable_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamSeekable_std_default_delete_open1_SkStreamSeekable_close1_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamSeekable_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamAsset_std_default_delete_open1_SkStreamAsset_close1_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkStreamAsset_std_default_delete_open1_SkStreamAsset_close1_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkFlattenable > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkFlattenable > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkFlattenable > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkFlattenable > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_18 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkFlattenable > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkFlattenable > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkFlattenable > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkFlattenable > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorFilter > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorFilter > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorFilter > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorFilter > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_17 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_8 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_9 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_10 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_11 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_12 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_13 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_14 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_15 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_16 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_17 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_18 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_19 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_8 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_19 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_9 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_10 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_11 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_12 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_20 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_13 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_21 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_14 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_18 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_15 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_19 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_16 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_22 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_17 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_18 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_20 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_19 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_21 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_20 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_22 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_21 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_23 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_22 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_24 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_23 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_25 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_24 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_26 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_25 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_27 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_26 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_28 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_27 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_29 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_28 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_30 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_20 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_21 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkShader > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkShader > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_23 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_24 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_25 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_29 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_30 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_31 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_32 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_33 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_34 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_35 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_31 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_36 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_32 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_37 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_33 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_34 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_8 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_35 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_9 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_10 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_11 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_12 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_13 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_14 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_15 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_38 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_39 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkImage > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkImage > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_26 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPicture > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPicture > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_9 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_10 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_11 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_12 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_13 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_14 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_15 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkTypeface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkTypeface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_8 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_9 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkPathEffect > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkPathEffect > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_27 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_28 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_GrIORef_open0_GrGpuResource_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrIORef > ( ) , 12usize , concat ! ( "Size of template specialization: " , stringify ! ( GrIORef ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrIORef > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( GrIORef ) ) ) ; } # [ test ] fn __bindgen_test_layout_GrIORef_open0_GrGpuResource_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < GrIORef > ( ) , 12usize , concat ! ( "Size of template specialization: " , stringify ! ( GrIORef ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < GrIORef > ( ) , 4usize , concat ! ( "Alignment of template specialization: " , stringify ! ( GrIORef ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrReleaseProcHelper_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrReleaseProcHelper > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrReleaseProcHelper > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrReleaseProcHelper > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrReleaseProcHelper > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrReleaseProcHelper_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrReleaseProcHelper > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrReleaseProcHelper > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrReleaseProcHelper > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrReleaseProcHelper > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSurface_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSurface_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSurface_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSurface_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSurface_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSurface_close0_instantiation_5 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSurface_close0_instantiation_6 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSurface_close0_instantiation_7 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSurface > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSurface > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_GrAuditTrail_Op_std_default_delete_open1_GrAuditTrail_Op_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_GrAuditTrail_Op_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_GrAuditTrail_OpNode_std_default_delete_open1_GrAuditTrail_OpNode_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_GrAuditTrail_OpNode_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_SkTHashMap_open0_uint32_t_int_SkGoodHash_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkTHashMap > ( ) , 24usize , concat ! ( "Size of template specialization: " , stringify ! ( SkTHashMap ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkTHashMap > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( SkTHashMap ) ) ) ; } # [ test ] fn __bindgen_test_layout_SkTHashMap_open0_int_ptr_Ops_SkGoodHash_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SkTHashMap > ( ) , 24usize , concat ! ( "Size of template specialization: " , stringify ! ( SkTHashMap ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SkTHashMap > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( SkTHashMap ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_29 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkData > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkData > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrCaps_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSkSLFPFactoryCache_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrCaps_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSkSLFPFactoryCache_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrCaps_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSkSLFPFactoryCache_close0_instantiation_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_GrProxyProvider_std_default_delete_open1_GrProxyProvider_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_GrProxyProvider_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrCaps_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSkSLFPFactoryCache_close0_instantiation_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrOpMemoryPool_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrOpMemoryPool > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrOpMemoryPool > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrOpMemoryPool > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrOpMemoryPool > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_36 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_37 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_38 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_39 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < SkColorSpace > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < SkColorSpace > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_GrDrawingManager_std_default_delete_open1_GrDrawingManager_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_GrDrawingManager_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrOpMemoryPool_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrOpMemoryPool > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrOpMemoryPool > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrOpMemoryPool > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrOpMemoryPool > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_GrStrikeCache_std_default_delete_open1_GrStrikeCache_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_GrStrikeCache_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_GrTextBlobCache_std_default_delete_open1_GrTextBlobCache_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_GrTextBlobCache_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrContextThreadSafeProxy > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrContextThreadSafeProxy > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrCaps_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrCaps > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrCaps > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrSkSLFPFactoryCache_close0_instantiation_4 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrSkSLFPFactoryCache > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrSkSLFPFactoryCache > ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrContextThreadSafeProxy > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrContextThreadSafeProxy > ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_unique_ptr_open0_SkTaskGroup_std_default_delete_open1_SkTaskGroup_close1_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_unique_ptr > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_unique_ptr ) ) ) ; } # [ test ] fn __bindgen_test_layout_std_default_delete_open0_SkTaskGroup_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Size of template specialization: " , stringify ! ( std_default_delete ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < std_default_delete > ( ) , 1usize , concat ! ( "Alignment of template specialization: " , stringify ! ( std_default_delete ) ) ) ; } # [ test ] fn __bindgen_test_layout_sk_sp_open0_GrGpu_close0_instantiation ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sk_sp < GrGpu > > ( ) , 8usize , concat ! ( "Size of template specialization: " , stringify ! ( sk_sp < GrGpu > ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sk_sp < GrGpu > > ( ) , 8usize , concat ! ( "Alignment of template specialization: " , stringify ! ( sk_sp < GrGpu > ) ) ) ; }